{"title": "maxhumber_redframes-setup.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "setup.py"], "line_no": 0, "start_line_no": 0, "end_line_no": 25, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "from setuptools import find_packages, setup\n\nexec(open(\"redframes/version.py\").read())\n\nwith open(\"README.md\", \"r\", encoding=\"utf-8\") as f:\n    long_description = f.read()\n\nsetup(\n    name=\"redframes\",\n    version=__version__,  # type: ignore\n    url=\"https://github.com/maxhumber/redframes\",\n    description=\"General Purpose Data Manipulation Library\",\n    long_description=long_description,\n    long_description_content_type=\"text/markdown\",\n    author=\"Max Humber\",\n    author_email=\"max.humber@gmail.com\",\n    license=\"BSD 2\",\n    packages=find_packages(),\n    python_requires=\">=3.9\",\n    install_requires=[\"pandas>=1.5,<2.0\", \"scikit-learn==1.2.2\"],\n    extras_require={\n        \"test\": [\n            \"matplotlib\",\n            \"scikit-learn\",\n            \"protobuf==3.20.3\",", "id": "maxhumber_redframes_maxhumber_redframes-setup.py_0-25"}
{"title": "maxhumber_redframes-setup.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "setup.py"], "line_no": 10, "start_line_no": 0, "end_line_no": 35, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "from setuptools import find_packages, setup\n\nexec(open(\"redframes/version.py\").read())\n\nwith open(\"README.md\", \"r\", encoding=\"utf-8\") as f:\n    long_description = f.read()\n\nsetup(\n    name=\"redframes\",\n    version=__version__,  # type: ignore\n    url=\"https://github.com/maxhumber/redframes\",\n    description=\"General Purpose Data Manipulation Library\",\n    long_description=long_description,\n    long_description_content_type=\"text/markdown\",\n    author=\"Max Humber\",\n    author_email=\"max.humber@gmail.com\",\n    license=\"BSD 2\",\n    packages=find_packages(),\n    python_requires=\">=3.9\",\n    install_requires=[\"pandas>=1.5,<2.0\", \"scikit-learn==1.2.2\"],\n    extras_require={\n        \"test\": [\n            \"matplotlib\",\n            \"scikit-learn\",\n            \"protobuf==3.20.3\",\n        ],\n        \"dev\": [\n            \"black\",\n            \"ipykernel\",\n            \"isort\",\n            \"lxml\",\n            \"matplotlib\",\n            \"mypy\",\n            \"pandas-stubs\",\n            \"pyright\",", "id": "maxhumber_redframes_maxhumber_redframes-setup.py_0-35"}
{"title": "maxhumber_redframes-setup.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "setup.py"], "line_no": 20, "start_line_no": 0, "end_line_no": 45, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "from setuptools import find_packages, setup\n\nexec(open(\"redframes/version.py\").read())\n\nwith open(\"README.md\", \"r\", encoding=\"utf-8\") as f:\n    long_description = f.read()\n\nsetup(\n    name=\"redframes\",\n    version=__version__,  # type: ignore\n    url=\"https://github.com/maxhumber/redframes\",\n    description=\"General Purpose Data Manipulation Library\",\n    long_description=long_description,\n    long_description_content_type=\"text/markdown\",\n    author=\"Max Humber\",\n    author_email=\"max.humber@gmail.com\",\n    license=\"BSD 2\",\n    packages=find_packages(),\n    python_requires=\">=3.9\",\n    install_requires=[\"pandas>=1.5,<2.0\", \"scikit-learn==1.2.2\"],\n    extras_require={\n        \"test\": [\n            \"matplotlib\",\n            \"scikit-learn\",\n            \"protobuf==3.20.3\",\n        ],\n        \"dev\": [\n            \"black\",\n            \"ipykernel\",\n            \"isort\",\n            \"lxml\",\n            \"matplotlib\",\n            \"mypy\",\n            \"pandas-stubs\",\n            \"pyright\",\n            \"scikit-learn\",\n            \"tabulate\",\n        ],\n    },\n    classifiers=[\n        \"Intended Audience :: Developers\",\n        \"Programming Language :: Python :: 3.9\",\n        \"Programming Language :: Python :: 3.10\",\n        \"Programming Language :: Python :: 3.11\",\n    ],", "id": "maxhumber_redframes_maxhumber_redframes-setup.py_0-45"}
{"title": "maxhumber_redframes-setup.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "setup.py"], "line_no": 30, "start_line_no": 5, "end_line_no": 46, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "    long_description = f.read()\n\nsetup(\n    name=\"redframes\",\n    version=__version__,  # type: ignore\n    url=\"https://github.com/maxhumber/redframes\",\n    description=\"General Purpose Data Manipulation Library\",\n    long_description=long_description,\n    long_description_content_type=\"text/markdown\",\n    author=\"Max Humber\",\n    author_email=\"max.humber@gmail.com\",\n    license=\"BSD 2\",\n    packages=find_packages(),\n    python_requires=\">=3.9\",\n    install_requires=[\"pandas>=1.5,<2.0\", \"scikit-learn==1.2.2\"],\n    extras_require={\n        \"test\": [\n            \"matplotlib\",\n            \"scikit-learn\",\n            \"protobuf==3.20.3\",\n        ],\n        \"dev\": [\n            \"black\",\n            \"ipykernel\",\n            \"isort\",\n            \"lxml\",\n            \"matplotlib\",\n            \"mypy\",\n            \"pandas-stubs\",\n            \"pyright\",\n            \"scikit-learn\",\n            \"tabulate\",\n        ],\n    },\n    classifiers=[\n        \"Intended Audience :: Developers\",\n        \"Programming Language :: Python :: 3.9\",\n        \"Programming Language :: Python :: 3.10\",\n        \"Programming Language :: Python :: 3.11\",\n    ],\n)", "id": "maxhumber_redframes_maxhumber_redframes-setup.py_5-46"}
{"title": "maxhumber_redframes-setup.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "setup.py"], "line_no": 40, "start_line_no": 15, "end_line_no": 46, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "    author_email=\"max.humber@gmail.com\",\n    license=\"BSD 2\",\n    packages=find_packages(),\n    python_requires=\">=3.9\",\n    install_requires=[\"pandas>=1.5,<2.0\", \"scikit-learn==1.2.2\"],\n    extras_require={\n        \"test\": [\n            \"matplotlib\",\n            \"scikit-learn\",\n            \"protobuf==3.20.3\",\n        ],\n        \"dev\": [\n            \"black\",\n            \"ipykernel\",\n            \"isort\",\n            \"lxml\",\n            \"matplotlib\",\n            \"mypy\",\n            \"pandas-stubs\",\n            \"pyright\",\n            \"scikit-learn\",\n            \"tabulate\",\n        ],\n    },\n    classifiers=[\n        \"Intended Audience :: Developers\",\n        \"Programming Language :: Python :: 3.9\",\n        \"Programming Language :: Python :: 3.10\",\n        \"Programming Language :: Python :: 3.11\",\n    ],\n)", "id": "maxhumber_redframes_maxhumber_redframes-setup.py_15-46"}
{"title": "maxhumber_redframes-redframes-checks.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "checks.py"], "line_no": 0, "start_line_no": 0, "end_line_no": 25, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "from __future__ import annotations\n\nfrom .types import (\n    Any,\n    Columns,\n    LazyColumns,\n    PandasDataFrame,\n    PandasIndex,\n    PandasRangeIndex,\n)\n\n\ndef _check_type(argument: Any, against: type | set[type | None]) -> None:\n    if isinstance(against, set):\n        if len(against) == 0:\n            against = {against}  # type: ignore\n    if not isinstance(against, set):\n        against = {against}\n    optional = None in against\n    just_types = against.difference({None})\n    checks = [isinstance(argument, t) for t in just_types]  # type: ignore\n    if optional:\n        checks += [argument == None]\n    if not any(checks):\n        str_types = \" | \".join([t.__name__ for t in just_types])  # type: ignore\n\nAST=Module(ImportFrom(alias)ImportFrom(aliasaliasaliasaliasaliasalias)FunctionDef(arguments(arg(Name(Load))arg(BinOp(Name(Load)BitOrSubscript(Name(Load)BinOp(Name(Load)BitOrConstant)Load))))If(Call(Name(Load)Name(Load)Name(Load))If(Compare(Call(Name(Load)Name(Load))EqConstant)Assign(Name(Store)Set(Name(Load)))))If(UnaryOp(NotCall(Name(Load)Name(Load)Name(Load)))Assign(Name(Store)Set(Name(Load))))Assign(Name(Store)Compare(ConstantInName(Load)))Assign(Name(Store)Call(Attribute(Name(Load)Load)Set(Constant)))Assign(Name(Store)ListComp(Call(Name(Load)Name(Load)Name(Load))comprehension(Name(Store)Name(Load))))If(Name(Load)AugAssign(Name(Store)AddList(Compare(Name(Load)EqConstant)Load)))If(UnaryOp(NotCall(Name(Load)Name(Load)))Assign(Name(Store)Call(Attribute(ConstantLoad)ListComp(Attribute(Name(Load)Load)comprehension(Name(Store)Name(Load))))))Constant))", "id": "maxhumber_redframes_maxhumber_redframes-redframes-checks.py_0-25"}
{"title": "maxhumber_redframes-redframes-checks.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "checks.py"], "line_no": 10, "start_line_no": 0, "end_line_no": 35, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "from __future__ import annotations\n\nfrom .types import (\n    Any,\n    Columns,\n    LazyColumns,\n    PandasDataFrame,\n    PandasIndex,\n    PandasRangeIndex,\n)\n\n\ndef _check_type(argument: Any, against: type | set[type | None]) -> None:\n    if isinstance(against, set):\n        if len(against) == 0:\n            against = {against}  # type: ignore\n    if not isinstance(against, set):\n        against = {against}\n    optional = None in against\n    just_types = against.difference({None})\n    checks = [isinstance(argument, t) for t in just_types]  # type: ignore\n    if optional:\n        checks += [argument == None]\n    if not any(checks):\n        str_types = \" | \".join([t.__name__ for t in just_types])  # type: ignore\n        if optional:\n            str_types += \" | None\"\n        raise TypeError(f\"must be {str_types}\")\n\n\ndef _check_values(values: Any, type: type) -> None:\n    if not all(isinstance(value, type) for value in values):\n        raise TypeError(f\"must be {type.__name__}\")\n\n\n\nAST=Module(ImportFrom(alias)ImportFrom(aliasaliasaliasaliasaliasalias)FunctionDef(arguments(arg(Name(Load))arg(BinOp(Name(Load)BitOrSubscript(Name(Load)BinOp(Name(Load)BitOrConstant)Load))))If(Call(Name(Load)Name(Load)Name(Load))If(Compare(Call(Name(Load)Name(Load))EqConstant)Assign(Name(Store)Set(Name(Load)))))If(UnaryOp(NotCall(Name(Load)Name(Load)Name(Load)))Assign(Name(Store)Set(Name(Load))))Assign(Name(Store)Compare(ConstantInName(Load)))Assign(Name(Store)Call(Attribute(Name(Load)Load)Set(Constant)))Assign(Name(Store)ListComp(Call(Name(Load)Name(Load)Name(Load))comprehension(Name(Store)Name(Load))))If(Name(Load)AugAssign(Name(Store)AddList(Compare(Name(Load)EqConstant)Load)))If(UnaryOp(NotCall(Name(Load)Name(Load)))Assign(Name(Store)Call(Attribute(ConstantLoad)ListComp(Attribute(Name(Load)Load)comprehension(Name(Store)Name(Load)))))If(Name(Load)AugAssign(Name(Store)AddConstant))Raise(Call(Name(Load)JoinedStr(ConstantFormattedValue(Name(Load))))))Constant)FunctionDef(arguments(arg(Name(Load))arg(Name(Load)))If(UnaryOp(NotCall(Name(Load)GeneratorExp(Call(Name(Load)Name(Load)Name(Load))comprehension(Name(Store)Name(Load)))))Raise(Call(Name(Load)JoinedStr(ConstantFormattedValue(Attribute(Name(Load)Load))))))Constant))", "id": "maxhumber_redframes_maxhumber_redframes-redframes-checks.py_0-35"}
{"title": "maxhumber_redframes-redframes-checks.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "checks.py"], "line_no": 20, "start_line_no": 0, "end_line_no": 45, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "from __future__ import annotations\n\nfrom .types import (\n    Any,\n    Columns,\n    LazyColumns,\n    PandasDataFrame,\n    PandasIndex,\n    PandasRangeIndex,\n)\n\n\ndef _check_type(argument: Any, against: type | set[type | None]) -> None:\n    if isinstance(against, set):\n        if len(against) == 0:\n            against = {against}  # type: ignore\n    if not isinstance(against, set):\n        against = {against}\n    optional = None in against\n    just_types = against.difference({None})\n    checks = [isinstance(argument, t) for t in just_types]  # type: ignore\n    if optional:\n        checks += [argument == None]\n    if not any(checks):\n        str_types = \" | \".join([t.__name__ for t in just_types])  # type: ignore\n        if optional:\n            str_types += \" | None\"\n        raise TypeError(f\"must be {str_types}\")\n\n\ndef _check_values(values: Any, type: type) -> None:\n    if not all(isinstance(value, type) for value in values):\n        raise TypeError(f\"must be {type.__name__}\")\n\n\ndef _check_keys(columns: LazyColumns | None, against: Columns | PandasIndex) -> None:\n    if isinstance(columns, str):\n        columns = [columns]\n    columns = [] if (columns == None) else columns\n    bad_keys = set(columns).difference(against)  # type: ignore\n    if bad_keys:\n        if len(bad_keys) == 1:\n            raise KeyError(f\"invalid key {bad_keys}\")\n        else:\n            raise KeyError(f\"invalid keys {bad_keys}\")\n\nAST=Module(ImportFrom(alias)ImportFrom(aliasaliasaliasaliasaliasalias)FunctionDef(arguments(arg(Name(Load))arg(BinOp(Name(Load)BitOrSubscript(Name(Load)BinOp(Name(Load)BitOrConstant)Load))))If(Call(Name(Load)Name(Load)Name(Load))If(Compare(Call(Name(Load)Name(Load))EqConstant)Assign(Name(Store)Set(Name(Load)))))If(UnaryOp(NotCall(Name(Load)Name(Load)Name(Load)))Assign(Name(Store)Set(Name(Load))))Assign(Name(Store)Compare(ConstantInName(Load)))Assign(Name(Store)Call(Attribute(Name(Load)Load)Set(Constant)))Assign(Name(Store)ListComp(Call(Name(Load)Name(Load)Name(Load))comprehension(Name(Store)Name(Load))))If(Name(Load)AugAssign(Name(Store)AddList(Compare(Name(Load)EqConstant)Load)))If(UnaryOp(NotCall(Name(Load)Name(Load)))Assign(Name(Store)Call(Attribute(ConstantLoad)ListComp(Attribute(Name(Load)Load)comprehension(Name(Store)Name(Load)))))If(Name(Load)AugAssign(Name(Store)AddConstant))Raise(Call(Name(Load)JoinedStr(ConstantFormattedValue(Name(Load))))))Constant)FunctionDef(arguments(arg(Name(Load))arg(Name(Load)))If(UnaryOp(NotCall(Name(Load)GeneratorExp(Call(Name(Load)Name(Load)Name(Load))comprehension(Name(Store)Name(Load)))))Raise(Call(Name(Load)JoinedStr(ConstantFormattedValue(Attribute(Name(Load)Load))))))Constant)FunctionDef(arguments(arg(BinOp(Name(Load)BitOrConstant))arg(BinOp(Name(Load)BitOrName(Load))))If(Call(Name(Load)Name(Load)Name(Load))Assign(Name(Store)List(Name(Load)Load)))Assign(Name(Store)IfExp(Compare(Name(Load)EqConstant)List(Load)Name(Load)))Assign(Name(Store)Call(Attribute(Call(Name(Load)Name(Load))Load)Name(Load)))If(Name(Load)If(Compare(Call(Name(Load)Name(Load))EqConstant)Raise(Call(Name(Load)JoinedStr(ConstantFormattedValue(Name(Load)))))Raise(Call(Name(Load)JoinedStr(ConstantFormattedValue(Name(Load)))))))Constant))", "id": "maxhumber_redframes_maxhumber_redframes-redframes-checks.py_0-45"}
{"title": "maxhumber_redframes-redframes-checks.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "checks.py"], "line_no": 30, "start_line_no": 5, "end_line_no": 55, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "    LazyColumns,\n    PandasDataFrame,\n    PandasIndex,\n    PandasRangeIndex,\n)\n\n\ndef _check_type(argument: Any, against: type | set[type | None]) -> None:\n    if isinstance(against, set):\n        if len(against) == 0:\n            against = {against}  # type: ignore\n    if not isinstance(against, set):\n        against = {against}\n    optional = None in against\n    just_types = against.difference({None})\n    checks = [isinstance(argument, t) for t in just_types]  # type: ignore\n    if optional:\n        checks += [argument == None]\n    if not any(checks):\n        str_types = \" | \".join([t.__name__ for t in just_types])  # type: ignore\n        if optional:\n            str_types += \" | None\"\n        raise TypeError(f\"must be {str_types}\")\n\n\ndef _check_values(values: Any, type: type) -> None:\n    if not all(isinstance(value, type) for value in values):\n        raise TypeError(f\"must be {type.__name__}\")\n\n\ndef _check_keys(columns: LazyColumns | None, against: Columns | PandasIndex) -> None:\n    if isinstance(columns, str):\n        columns = [columns]\n    columns = [] if (columns == None) else columns\n    bad_keys = set(columns).difference(against)  # type: ignore\n    if bad_keys:\n        if len(bad_keys) == 1:\n            raise KeyError(f\"invalid key {bad_keys}\")\n        else:\n            raise KeyError(f\"invalid keys {bad_keys}\")\n\n\ndef _check_index(df: PandasDataFrame) -> None:\n    if not (df.index.name == None):\n        raise IndexError(\"must be unnamed\")\n    if not isinstance(df.index, PandasRangeIndex):\n        raise IndexError(\"must be range\")\n    if not (df.index.start == 0):\n        raise IndexError(\"must start at 0\")\n    if not (df.index.step == 1):", "id": "maxhumber_redframes_maxhumber_redframes-redframes-checks.py_5-55"}
{"title": "maxhumber_redframes-redframes-checks.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "checks.py"], "line_no": 40, "start_line_no": 15, "end_line_no": 65, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "            against = {against}  # type: ignore\n    if not isinstance(against, set):\n        against = {against}\n    optional = None in against\n    just_types = against.difference({None})\n    checks = [isinstance(argument, t) for t in just_types]  # type: ignore\n    if optional:\n        checks += [argument == None]\n    if not any(checks):\n        str_types = \" | \".join([t.__name__ for t in just_types])  # type: ignore\n        if optional:\n            str_types += \" | None\"\n        raise TypeError(f\"must be {str_types}\")\n\n\ndef _check_values(values: Any, type: type) -> None:\n    if not all(isinstance(value, type) for value in values):\n        raise TypeError(f\"must be {type.__name__}\")\n\n\ndef _check_keys(columns: LazyColumns | None, against: Columns | PandasIndex) -> None:\n    if isinstance(columns, str):\n        columns = [columns]\n    columns = [] if (columns == None) else columns\n    bad_keys = set(columns).difference(against)  # type: ignore\n    if bad_keys:\n        if len(bad_keys) == 1:\n            raise KeyError(f\"invalid key {bad_keys}\")\n        else:\n            raise KeyError(f\"invalid keys {bad_keys}\")\n\n\ndef _check_index(df: PandasDataFrame) -> None:\n    if not (df.index.name == None):\n        raise IndexError(\"must be unnamed\")\n    if not isinstance(df.index, PandasRangeIndex):\n        raise IndexError(\"must be range\")\n    if not (df.index.start == 0):\n        raise IndexError(\"must start at 0\")\n    if not (df.index.step == 1):\n        raise IndexError(\"must step by 1\")\n\n\ndef _check_columns(df: PandasDataFrame) -> None:\n    if type(df.columns) != PandasIndex:\n        raise KeyError(\"must be flat\")\n    if df.columns.has_duplicates:\n        raise KeyError(\"must not contain duplicate keys\")\n\n", "id": "maxhumber_redframes_maxhumber_redframes-redframes-checks.py_15-65"}
{"title": "maxhumber_redframes-redframes-checks.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "checks.py"], "line_no": 50, "start_line_no": 25, "end_line_no": 68, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        if optional:\n            str_types += \" | None\"\n        raise TypeError(f\"must be {str_types}\")\n\n\ndef _check_values(values: Any, type: type) -> None:\n    if not all(isinstance(value, type) for value in values):\n        raise TypeError(f\"must be {type.__name__}\")\n\n\ndef _check_keys(columns: LazyColumns | None, against: Columns | PandasIndex) -> None:\n    if isinstance(columns, str):\n        columns = [columns]\n    columns = [] if (columns == None) else columns\n    bad_keys = set(columns).difference(against)  # type: ignore\n    if bad_keys:\n        if len(bad_keys) == 1:\n            raise KeyError(f\"invalid key {bad_keys}\")\n        else:\n            raise KeyError(f\"invalid keys {bad_keys}\")\n\n\ndef _check_index(df: PandasDataFrame) -> None:\n    if not (df.index.name == None):\n        raise IndexError(\"must be unnamed\")\n    if not isinstance(df.index, PandasRangeIndex):\n        raise IndexError(\"must be range\")\n    if not (df.index.start == 0):\n        raise IndexError(\"must start at 0\")\n    if not (df.index.step == 1):\n        raise IndexError(\"must step by 1\")\n\n\ndef _check_columns(df: PandasDataFrame) -> None:\n    if type(df.columns) != PandasIndex:\n        raise KeyError(\"must be flat\")\n    if df.columns.has_duplicates:\n        raise KeyError(\"must not contain duplicate keys\")\n\n\ndef _check_file(path: str) -> None:\n    if not path.endswith(\".csv\"):\n        raise TypeError(\"must end in .csv\")", "id": "maxhumber_redframes_maxhumber_redframes-redframes-checks.py_25-68"}
{"title": "maxhumber_redframes-redframes-checks.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "checks.py"], "line_no": 60, "start_line_no": 35, "end_line_no": 68, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "def _check_keys(columns: LazyColumns | None, against: Columns | PandasIndex) -> None:\n    if isinstance(columns, str):\n        columns = [columns]\n    columns = [] if (columns == None) else columns\n    bad_keys = set(columns).difference(against)  # type: ignore\n    if bad_keys:\n        if len(bad_keys) == 1:\n            raise KeyError(f\"invalid key {bad_keys}\")\n        else:\n            raise KeyError(f\"invalid keys {bad_keys}\")\n\n\ndef _check_index(df: PandasDataFrame) -> None:\n    if not (df.index.name == None):\n        raise IndexError(\"must be unnamed\")\n    if not isinstance(df.index, PandasRangeIndex):\n        raise IndexError(\"must be range\")\n    if not (df.index.start == 0):\n        raise IndexError(\"must start at 0\")\n    if not (df.index.step == 1):\n        raise IndexError(\"must step by 1\")\n\n\ndef _check_columns(df: PandasDataFrame) -> None:\n    if type(df.columns) != PandasIndex:\n        raise KeyError(\"must be flat\")\n    if df.columns.has_duplicates:\n        raise KeyError(\"must not contain duplicate keys\")\n\n\ndef _check_file(path: str) -> None:\n    if not path.endswith(\".csv\"):\n        raise TypeError(\"must end in .csv\")\n\nAST=Module(FunctionDef(arguments(arg(BinOp(Name(Load)BitOrConstant))arg(BinOp(Name(Load)BitOrName(Load))))If(Call(Name(Load)Name(Load)Name(Load))Assign(Name(Store)List(Name(Load)Load)))Assign(Name(Store)IfExp(Compare(Name(Load)EqConstant)List(Load)Name(Load)))Assign(Name(Store)Call(Attribute(Call(Name(Load)Name(Load))Load)Name(Load)))If(Name(Load)If(Compare(Call(Name(Load)Name(Load))EqConstant)Raise(Call(Name(Load)JoinedStr(ConstantFormattedValue(Name(Load)))))Raise(Call(Name(Load)JoinedStr(ConstantFormattedValue(Name(Load)))))))Constant)FunctionDef(arguments(arg(Name(Load)))If(UnaryOp(NotCompare(Attribute(Attribute(Name(Load)Load)Load)EqConstant))Raise(Call(Name(Load)Constant)))If(UnaryOp(NotCall(Name(Load)Attribute(Name(Load)Load)Name(Load)))Raise(Call(Name(Load)Constant)))If(UnaryOp(NotCompare(Attribute(Attribute(Name(Load)Load)Load)EqConstant))Raise(Call(Name(Load)Constant)))If(UnaryOp(NotCompare(Attribute(Attribute(Name(Load)Load)Load)EqConstant))Raise(Call(Name(Load)Constant)))Constant)FunctionDef(arguments(arg(Name(Load)))If(Compare(Call(Name(Load)Attribute(Name(Load)Load))NotEqName(Load))Raise(Call(Name(Load)Constant)))If(Attribute(Attribute(Name(Load)Load)Load)Raise(Call(Name(Load)Constant)))Constant)FunctionDef(arguments(arg(Name(Load)))If(UnaryOp(NotCall(Attribute(Name(Load)Load)Constant))Raise(Call(Name(Load)Constant)))Constant))", "id": "maxhumber_redframes_maxhumber_redframes-redframes-checks.py_35-68"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 0, "start_line_no": 0, "end_line_no": 25, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "from __future__ import annotations\n\nimport pprint\nimport warnings\n\nfrom .checks import _check_type\nfrom .types import (\n    Any,\n    Column,\n    Columns,\n    DateTime,\n    Direction,\n    Func,\n    Join,\n    LazyColumns,\n    NewColumn,\n    NewValue,\n    NumpyArray,\n    NumpyType,\n    OldColumn,\n    OldValue,\n    PandasDataFrame,\n    PandasGroupedFrame,\n    Value,\n    Values,", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_0-25"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 10, "start_line_no": 0, "end_line_no": 35, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "from __future__ import annotations\n\nimport pprint\nimport warnings\n\nfrom .checks import _check_type\nfrom .types import (\n    Any,\n    Column,\n    Columns,\n    DateTime,\n    Direction,\n    Func,\n    Join,\n    LazyColumns,\n    NewColumn,\n    NewValue,\n    NumpyArray,\n    NumpyType,\n    OldColumn,\n    OldValue,\n    PandasDataFrame,\n    PandasGroupedFrame,\n    Value,\n    Values,\n)\nfrom .verbs import (\n    accumulate,\n    append,\n    combine,\n    cross,\n    dedupe,\n    denix,\n    drop,\n    fill,", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_0-35"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 20, "start_line_no": 0, "end_line_no": 45, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "from __future__ import annotations\n\nimport pprint\nimport warnings\n\nfrom .checks import _check_type\nfrom .types import (\n    Any,\n    Column,\n    Columns,\n    DateTime,\n    Direction,\n    Func,\n    Join,\n    LazyColumns,\n    NewColumn,\n    NewValue,\n    NumpyArray,\n    NumpyType,\n    OldColumn,\n    OldValue,\n    PandasDataFrame,\n    PandasGroupedFrame,\n    Value,\n    Values,\n)\nfrom .verbs import (\n    accumulate,\n    append,\n    combine,\n    cross,\n    dedupe,\n    denix,\n    drop,\n    fill,\n    filter,\n    gather,\n    group,\n    join,\n    mutate,\n    pack,\n    rank,\n    rename,\n    replace,\n    rollup,", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_0-45"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 30, "start_line_no": 5, "end_line_no": 55, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "from .checks import _check_type\nfrom .types import (\n    Any,\n    Column,\n    Columns,\n    DateTime,\n    Direction,\n    Func,\n    Join,\n    LazyColumns,\n    NewColumn,\n    NewValue,\n    NumpyArray,\n    NumpyType,\n    OldColumn,\n    OldValue,\n    PandasDataFrame,\n    PandasGroupedFrame,\n    Value,\n    Values,\n)\nfrom .verbs import (\n    accumulate,\n    append,\n    combine,\n    cross,\n    dedupe,\n    denix,\n    drop,\n    fill,\n    filter,\n    gather,\n    group,\n    join,\n    mutate,\n    pack,\n    rank,\n    rename,\n    replace,\n    rollup,\n    sample,\n    select,\n    shuffle,\n    sort,\n    split,\n    spread,\n    take,\n    unpack,\n)\n\n\nAST=Module(ImportFrom(alias)ImportFrom(aliasaliasaliasaliasaliasaliasaliasaliasaliasaliasaliasaliasaliasaliasaliasaliasaliasalias)ImportFrom(aliasaliasaliasaliasaliasaliasaliasaliasaliasaliasaliasaliasaliasaliasaliasaliasaliasaliasaliasaliasaliasaliasaliasaliasaliasalias))", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_5-55"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 40, "start_line_no": 15, "end_line_no": 65, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "    NewColumn,\n    NewValue,\n    NumpyArray,\n    NumpyType,\n    OldColumn,\n    OldValue,\n    PandasDataFrame,\n    PandasGroupedFrame,\n    Value,\n    Values,\n)\nfrom .verbs import (\n    accumulate,\n    append,\n    combine,\n    cross,\n    dedupe,\n    denix,\n    drop,\n    fill,\n    filter,\n    gather,\n    group,\n    join,\n    mutate,\n    pack,\n    rank,\n    rename,\n    replace,\n    rollup,\n    sample,\n    select,\n    shuffle,\n    sort,\n    split,\n    spread,\n    take,\n    unpack,\n)\n\n\ndef _wrap(data: PandasDataFrame) -> DataFrame:\n    \"\"\"Unsafe version of redframes.io.wrap()\"\"\"\n    df = DataFrame()\n    df._data = data\n    return df\n\n\nclass _TakeMixin:\n    def __init__(self, data: PandasDataFrame | PandasGroupedFrame) -> None:", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_15-65"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 50, "start_line_no": 25, "end_line_no": 75, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": ")\nfrom .verbs import (\n    accumulate,\n    append,\n    combine,\n    cross,\n    dedupe,\n    denix,\n    drop,\n    fill,\n    filter,\n    gather,\n    group,\n    join,\n    mutate,\n    pack,\n    rank,\n    rename,\n    replace,\n    rollup,\n    sample,\n    select,\n    shuffle,\n    sort,\n    split,\n    spread,\n    take,\n    unpack,\n)\n\n\ndef _wrap(data: PandasDataFrame) -> DataFrame:\n    \"\"\"Unsafe version of redframes.io.wrap()\"\"\"\n    df = DataFrame()\n    df._data = data\n    return df\n\n\nclass _TakeMixin:\n    def __init__(self, data: PandasDataFrame | PandasGroupedFrame) -> None:\n        self._data = data\n\n    def take(self, rows: int, **kwargs) -> DataFrame:\n        \"\"\"Take any number of rows (from the top/bottom)\n\n        Examples:\n\n        ```python\n        df = rf.DataFrame({\"foo\": range(10)})\n        ```", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_25-75"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 60, "start_line_no": 35, "end_line_no": 85, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "    filter,\n    gather,\n    group,\n    join,\n    mutate,\n    pack,\n    rank,\n    rename,\n    replace,\n    rollup,\n    sample,\n    select,\n    shuffle,\n    sort,\n    split,\n    spread,\n    take,\n    unpack,\n)\n\n\ndef _wrap(data: PandasDataFrame) -> DataFrame:\n    \"\"\"Unsafe version of redframes.io.wrap()\"\"\"\n    df = DataFrame()\n    df._data = data\n    return df\n\n\nclass _TakeMixin:\n    def __init__(self, data: PandasDataFrame | PandasGroupedFrame) -> None:\n        self._data = data\n\n    def take(self, rows: int, **kwargs) -> DataFrame:\n        \"\"\"Take any number of rows (from the top/bottom)\n\n        Examples:\n\n        ```python\n        df = rf.DataFrame({\"foo\": range(10)})\n        ```\n        |   foo |\n        |------:|\n        |     0 |\n        |     1 |\n        |     2 |\n        |     3 |\n        |     4 |\n        |     5 |\n        |     6 |\n        |     7 |", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_35-85"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 70, "start_line_no": 45, "end_line_no": 95, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "    sample,\n    select,\n    shuffle,\n    sort,\n    split,\n    spread,\n    take,\n    unpack,\n)\n\n\ndef _wrap(data: PandasDataFrame) -> DataFrame:\n    \"\"\"Unsafe version of redframes.io.wrap()\"\"\"\n    df = DataFrame()\n    df._data = data\n    return df\n\n\nclass _TakeMixin:\n    def __init__(self, data: PandasDataFrame | PandasGroupedFrame) -> None:\n        self._data = data\n\n    def take(self, rows: int, **kwargs) -> DataFrame:\n        \"\"\"Take any number of rows (from the top/bottom)\n\n        Examples:\n\n        ```python\n        df = rf.DataFrame({\"foo\": range(10)})\n        ```\n        |   foo |\n        |------:|\n        |     0 |\n        |     1 |\n        |     2 |\n        |     3 |\n        |     4 |\n        |     5 |\n        |     6 |\n        |     7 |\n        |     8 |\n        |     9 |\n\n        From \"head\":\n\n        ```python\n        df.take(1)\n        ```\n        |   foo |\n        |------:|", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_45-95"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 80, "start_line_no": 55, "end_line_no": 105, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "\ndef _wrap(data: PandasDataFrame) -> DataFrame:\n    \"\"\"Unsafe version of redframes.io.wrap()\"\"\"\n    df = DataFrame()\n    df._data = data\n    return df\n\n\nclass _TakeMixin:\n    def __init__(self, data: PandasDataFrame | PandasGroupedFrame) -> None:\n        self._data = data\n\n    def take(self, rows: int, **kwargs) -> DataFrame:\n        \"\"\"Take any number of rows (from the top/bottom)\n\n        Examples:\n\n        ```python\n        df = rf.DataFrame({\"foo\": range(10)})\n        ```\n        |   foo |\n        |------:|\n        |     0 |\n        |     1 |\n        |     2 |\n        |     3 |\n        |     4 |\n        |     5 |\n        |     6 |\n        |     7 |\n        |     8 |\n        |     9 |\n\n        From \"head\":\n\n        ```python\n        df.take(1)\n        ```\n        |   foo |\n        |------:|\n        |     0 |\n\n        From \"tail\":\n\n        ```python\n        df.take(-2)\n        ```\n        |   foo |\n        |------:|\n        |     8 |", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_55-105"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 90, "start_line_no": 65, "end_line_no": 115, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        self._data = data\n\n    def take(self, rows: int, **kwargs) -> DataFrame:\n        \"\"\"Take any number of rows (from the top/bottom)\n\n        Examples:\n\n        ```python\n        df = rf.DataFrame({\"foo\": range(10)})\n        ```\n        |   foo |\n        |------:|\n        |     0 |\n        |     1 |\n        |     2 |\n        |     3 |\n        |     4 |\n        |     5 |\n        |     6 |\n        |     7 |\n        |     8 |\n        |     9 |\n\n        From \"head\":\n\n        ```python\n        df.take(1)\n        ```\n        |   foo |\n        |------:|\n        |     0 |\n\n        From \"tail\":\n\n        ```python\n        df.take(-2)\n        ```\n        |   foo |\n        |------:|\n        |     8 |\n        |     9 |\n        \"\"\"\n        return _wrap(take(self._data, rows, **kwargs))\n\n\nclass _InterchangeMixin(_TakeMixin):\n    def __init__(self, data: PandasDataFrame) -> None:\n        self._data = data\n\n    def __array__(self) -> NumpyArray:", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_65-115"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 100, "start_line_no": 75, "end_line_no": 125, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        |   foo |\n        |------:|\n        |     0 |\n        |     1 |\n        |     2 |\n        |     3 |\n        |     4 |\n        |     5 |\n        |     6 |\n        |     7 |\n        |     8 |\n        |     9 |\n\n        From \"head\":\n\n        ```python\n        df.take(1)\n        ```\n        |   foo |\n        |------:|\n        |     0 |\n\n        From \"tail\":\n\n        ```python\n        df.take(-2)\n        ```\n        |   foo |\n        |------:|\n        |     8 |\n        |     9 |\n        \"\"\"\n        return _wrap(take(self._data, rows, **kwargs))\n\n\nclass _InterchangeMixin(_TakeMixin):\n    def __init__(self, data: PandasDataFrame) -> None:\n        self._data = data\n\n    def __array__(self) -> NumpyArray:\n        return self._data.__array__()\n\n    def __dataframe__(self, nan_as_null=False, allow_copy=True) -> \"PandasDataFrameXchg\":  # type: ignore\n        return self._data.__dataframe__(nan_as_null, allow_copy)\n\n    def __len__(self) -> int:\n        return self._data.__len__()\n\n    @property\n    def iloc(self):", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_75-125"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 110, "start_line_no": 85, "end_line_no": 135, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        |     8 |\n        |     9 |\n\n        From \"head\":\n\n        ```python\n        df.take(1)\n        ```\n        |   foo |\n        |------:|\n        |     0 |\n\n        From \"tail\":\n\n        ```python\n        df.take(-2)\n        ```\n        |   foo |\n        |------:|\n        |     8 |\n        |     9 |\n        \"\"\"\n        return _wrap(take(self._data, rows, **kwargs))\n\n\nclass _InterchangeMixin(_TakeMixin):\n    def __init__(self, data: PandasDataFrame) -> None:\n        self._data = data\n\n    def __array__(self) -> NumpyArray:\n        return self._data.__array__()\n\n    def __dataframe__(self, nan_as_null=False, allow_copy=True) -> \"PandasDataFrameXchg\":  # type: ignore\n        return self._data.__dataframe__(nan_as_null, allow_copy)\n\n    def __len__(self) -> int:\n        return self._data.__len__()\n\n    @property\n    def iloc(self):\n        return self._data.iloc\n\n\nclass _CommonMixin(_TakeMixin):\n    def __init__(self, data: PandasDataFrame | PandasGroupedFrame) -> None:\n        self._data = data\n\n    def accumulate(self, column: Column, into: Column) -> DataFrame:\n        \"\"\"Run a cumulative sum over a column\n", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_85-135"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 120, "start_line_no": 95, "end_line_no": 145, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        |     0 |\n\n        From \"tail\":\n\n        ```python\n        df.take(-2)\n        ```\n        |   foo |\n        |------:|\n        |     8 |\n        |     9 |\n        \"\"\"\n        return _wrap(take(self._data, rows, **kwargs))\n\n\nclass _InterchangeMixin(_TakeMixin):\n    def __init__(self, data: PandasDataFrame) -> None:\n        self._data = data\n\n    def __array__(self) -> NumpyArray:\n        return self._data.__array__()\n\n    def __dataframe__(self, nan_as_null=False, allow_copy=True) -> \"PandasDataFrameXchg\":  # type: ignore\n        return self._data.__dataframe__(nan_as_null, allow_copy)\n\n    def __len__(self) -> int:\n        return self._data.__len__()\n\n    @property\n    def iloc(self):\n        return self._data.iloc\n\n\nclass _CommonMixin(_TakeMixin):\n    def __init__(self, data: PandasDataFrame | PandasGroupedFrame) -> None:\n        self._data = data\n\n    def accumulate(self, column: Column, into: Column) -> DataFrame:\n        \"\"\"Run a cumulative sum over a column\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [1, 2, 3, 4]})\n        ```\n        |   foo |\n        |------:|\n        |     1 |\n        |     2 |\n        |     3 |", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_95-145"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 130, "start_line_no": 105, "end_line_no": 155, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        |     9 |\n        \"\"\"\n        return _wrap(take(self._data, rows, **kwargs))\n\n\nclass _InterchangeMixin(_TakeMixin):\n    def __init__(self, data: PandasDataFrame) -> None:\n        self._data = data\n\n    def __array__(self) -> NumpyArray:\n        return self._data.__array__()\n\n    def __dataframe__(self, nan_as_null=False, allow_copy=True) -> \"PandasDataFrameXchg\":  # type: ignore\n        return self._data.__dataframe__(nan_as_null, allow_copy)\n\n    def __len__(self) -> int:\n        return self._data.__len__()\n\n    @property\n    def iloc(self):\n        return self._data.iloc\n\n\nclass _CommonMixin(_TakeMixin):\n    def __init__(self, data: PandasDataFrame | PandasGroupedFrame) -> None:\n        self._data = data\n\n    def accumulate(self, column: Column, into: Column) -> DataFrame:\n        \"\"\"Run a cumulative sum over a column\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [1, 2, 3, 4]})\n        ```\n        |   foo |\n        |------:|\n        |     1 |\n        |     2 |\n        |     3 |\n        |     4 |\n\n        ```python\n        df.accumulate(\"foo\", into=\"cumsum\")\n        ```\n        |   foo |   cumsum |\n        |------:|---------:|\n        |     1 |        1 |\n        |     2 |        3 |\n        |     3 |        6 |", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_105-155"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 140, "start_line_no": 115, "end_line_no": 165, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        return self._data.__array__()\n\n    def __dataframe__(self, nan_as_null=False, allow_copy=True) -> \"PandasDataFrameXchg\":  # type: ignore\n        return self._data.__dataframe__(nan_as_null, allow_copy)\n\n    def __len__(self) -> int:\n        return self._data.__len__()\n\n    @property\n    def iloc(self):\n        return self._data.iloc\n\n\nclass _CommonMixin(_TakeMixin):\n    def __init__(self, data: PandasDataFrame | PandasGroupedFrame) -> None:\n        self._data = data\n\n    def accumulate(self, column: Column, into: Column) -> DataFrame:\n        \"\"\"Run a cumulative sum over a column\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [1, 2, 3, 4]})\n        ```\n        |   foo |\n        |------:|\n        |     1 |\n        |     2 |\n        |     3 |\n        |     4 |\n\n        ```python\n        df.accumulate(\"foo\", into=\"cumsum\")\n        ```\n        |   foo |   cumsum |\n        |------:|---------:|\n        |     1 |        1 |\n        |     2 |        3 |\n        |     3 |        6 |\n        |     4 |       10 |\n        \"\"\"\n        return _wrap(accumulate(self._data, column, into))\n\n    def gather(\n        self,\n        columns: Columns | None = None,\n        beside: LazyColumns | None = None,\n        into: tuple[Column, Column] = (\"variable\", \"value\"),\n    ):", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_115-165"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 150, "start_line_no": 125, "end_line_no": 175, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        return self._data.iloc\n\n\nclass _CommonMixin(_TakeMixin):\n    def __init__(self, data: PandasDataFrame | PandasGroupedFrame) -> None:\n        self._data = data\n\n    def accumulate(self, column: Column, into: Column) -> DataFrame:\n        \"\"\"Run a cumulative sum over a column\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [1, 2, 3, 4]})\n        ```\n        |   foo |\n        |------:|\n        |     1 |\n        |     2 |\n        |     3 |\n        |     4 |\n\n        ```python\n        df.accumulate(\"foo\", into=\"cumsum\")\n        ```\n        |   foo |   cumsum |\n        |------:|---------:|\n        |     1 |        1 |\n        |     2 |        3 |\n        |     3 |        6 |\n        |     4 |       10 |\n        \"\"\"\n        return _wrap(accumulate(self._data, column, into))\n\n    def gather(\n        self,\n        columns: Columns | None = None,\n        beside: LazyColumns | None = None,\n        into: tuple[Column, Column] = (\"variable\", \"value\"),\n    ):\n        \"\"\"Gather columns into rows (opposite of spread)\n\n        Examples:\n\n        ```python\n        df = rf.DataFrame({\n            \"foo\": [1, 2, 1, 2],\n            \"bar\": [\"A\", \"B\", \"C\", \"D\"],\n            \"baz\": [\"!\", \"@\", \"#\", \"$\"],\n            \"jaz\": range(4)", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_125-175"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 160, "start_line_no": 135, "end_line_no": 185, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [1, 2, 3, 4]})\n        ```\n        |   foo |\n        |------:|\n        |     1 |\n        |     2 |\n        |     3 |\n        |     4 |\n\n        ```python\n        df.accumulate(\"foo\", into=\"cumsum\")\n        ```\n        |   foo |   cumsum |\n        |------:|---------:|\n        |     1 |        1 |\n        |     2 |        3 |\n        |     3 |        6 |\n        |     4 |       10 |\n        \"\"\"\n        return _wrap(accumulate(self._data, column, into))\n\n    def gather(\n        self,\n        columns: Columns | None = None,\n        beside: LazyColumns | None = None,\n        into: tuple[Column, Column] = (\"variable\", \"value\"),\n    ):\n        \"\"\"Gather columns into rows (opposite of spread)\n\n        Examples:\n\n        ```python\n        df = rf.DataFrame({\n            \"foo\": [1, 2, 1, 2],\n            \"bar\": [\"A\", \"B\", \"C\", \"D\"],\n            \"baz\": [\"!\", \"@\", \"#\", \"$\"],\n            \"jaz\": range(4)\n        })\n        ```\n        |   foo | bar   | baz   |   jaz |\n        |------:|:------|:------|------:|\n        |     1 | A     | !     |     0 |\n        |     2 | B     | @     |     1 |\n        |     1 | C     | #     |     2 |\n        |     2 | D     | $     |     3 |\n\n        All columns:", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_135-185"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 170, "start_line_no": 145, "end_line_no": 195, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        |     4 |\n\n        ```python\n        df.accumulate(\"foo\", into=\"cumsum\")\n        ```\n        |   foo |   cumsum |\n        |------:|---------:|\n        |     1 |        1 |\n        |     2 |        3 |\n        |     3 |        6 |\n        |     4 |       10 |\n        \"\"\"\n        return _wrap(accumulate(self._data, column, into))\n\n    def gather(\n        self,\n        columns: Columns | None = None,\n        beside: LazyColumns | None = None,\n        into: tuple[Column, Column] = (\"variable\", \"value\"),\n    ):\n        \"\"\"Gather columns into rows (opposite of spread)\n\n        Examples:\n\n        ```python\n        df = rf.DataFrame({\n            \"foo\": [1, 2, 1, 2],\n            \"bar\": [\"A\", \"B\", \"C\", \"D\"],\n            \"baz\": [\"!\", \"@\", \"#\", \"$\"],\n            \"jaz\": range(4)\n        })\n        ```\n        |   foo | bar   | baz   |   jaz |\n        |------:|:------|:------|------:|\n        |     1 | A     | !     |     0 |\n        |     2 | B     | @     |     1 |\n        |     1 | C     | #     |     2 |\n        |     2 | D     | $     |     3 |\n\n        All columns:\n\n        ```python\n        df.gather()\n        ```\n        | variable   | value   |\n        |:-----------|:--------|\n        | foo        | 1       |\n        | foo        | 2       |\n        | foo        | 1       |\n        | foo        | 2       |", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_145-195"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 180, "start_line_no": 155, "end_line_no": 205, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        |     4 |       10 |\n        \"\"\"\n        return _wrap(accumulate(self._data, column, into))\n\n    def gather(\n        self,\n        columns: Columns | None = None,\n        beside: LazyColumns | None = None,\n        into: tuple[Column, Column] = (\"variable\", \"value\"),\n    ):\n        \"\"\"Gather columns into rows (opposite of spread)\n\n        Examples:\n\n        ```python\n        df = rf.DataFrame({\n            \"foo\": [1, 2, 1, 2],\n            \"bar\": [\"A\", \"B\", \"C\", \"D\"],\n            \"baz\": [\"!\", \"@\", \"#\", \"$\"],\n            \"jaz\": range(4)\n        })\n        ```\n        |   foo | bar   | baz   |   jaz |\n        |------:|:------|:------|------:|\n        |     1 | A     | !     |     0 |\n        |     2 | B     | @     |     1 |\n        |     1 | C     | #     |     2 |\n        |     2 | D     | $     |     3 |\n\n        All columns:\n\n        ```python\n        df.gather()\n        ```\n        | variable   | value   |\n        |:-----------|:--------|\n        | foo        | 1       |\n        | foo        | 2       |\n        | foo        | 1       |\n        | foo        | 2       |\n        | bar        | A       |\n        | bar        | B       |\n        | bar        | C       |\n        | bar        | D       |\n        | baz        | !       |\n        | baz        | @       |\n        | baz        | #       |\n        | baz        | $       |\n        | jaz        | 0       |\n        | jaz        | 1       |", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_155-205"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 190, "start_line_no": 165, "end_line_no": 215, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        \"\"\"Gather columns into rows (opposite of spread)\n\n        Examples:\n\n        ```python\n        df = rf.DataFrame({\n            \"foo\": [1, 2, 1, 2],\n            \"bar\": [\"A\", \"B\", \"C\", \"D\"],\n            \"baz\": [\"!\", \"@\", \"#\", \"$\"],\n            \"jaz\": range(4)\n        })\n        ```\n        |   foo | bar   | baz   |   jaz |\n        |------:|:------|:------|------:|\n        |     1 | A     | !     |     0 |\n        |     2 | B     | @     |     1 |\n        |     1 | C     | #     |     2 |\n        |     2 | D     | $     |     3 |\n\n        All columns:\n\n        ```python\n        df.gather()\n        ```\n        | variable   | value   |\n        |:-----------|:--------|\n        | foo        | 1       |\n        | foo        | 2       |\n        | foo        | 1       |\n        | foo        | 2       |\n        | bar        | A       |\n        | bar        | B       |\n        | bar        | C       |\n        | bar        | D       |\n        | baz        | !       |\n        | baz        | @       |\n        | baz        | #       |\n        | baz        | $       |\n        | jaz        | 0       |\n        | jaz        | 1       |\n        | jaz        | 2       |\n        | jaz        | 3       |\n\n        Multiple columns:\n\n        ```python\n        df.gather([\"foo\", \"bar\"], into=(\"var\", \"val\"))\n        ```\n        | baz   |   jaz | var   | val   |\n        |:------|------:|:------|:------|", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_165-215"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 200, "start_line_no": 175, "end_line_no": 225, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        })\n        ```\n        |   foo | bar   | baz   |   jaz |\n        |------:|:------|:------|------:|\n        |     1 | A     | !     |     0 |\n        |     2 | B     | @     |     1 |\n        |     1 | C     | #     |     2 |\n        |     2 | D     | $     |     3 |\n\n        All columns:\n\n        ```python\n        df.gather()\n        ```\n        | variable   | value   |\n        |:-----------|:--------|\n        | foo        | 1       |\n        | foo        | 2       |\n        | foo        | 1       |\n        | foo        | 2       |\n        | bar        | A       |\n        | bar        | B       |\n        | bar        | C       |\n        | bar        | D       |\n        | baz        | !       |\n        | baz        | @       |\n        | baz        | #       |\n        | baz        | $       |\n        | jaz        | 0       |\n        | jaz        | 1       |\n        | jaz        | 2       |\n        | jaz        | 3       |\n\n        Multiple columns:\n\n        ```python\n        df.gather([\"foo\", \"bar\"], into=(\"var\", \"val\"))\n        ```\n        | baz   |   jaz | var   | val   |\n        |:------|------:|:------|:------|\n        | !     |     0 | foo   | 1     |\n        | @     |     1 | foo   | 2     |\n        | #     |     2 | foo   | 1     |\n        | $     |     3 | foo   | 2     |\n        | !     |     0 | bar   | A     |\n        | @     |     1 | bar   | B     |\n        | #     |     2 | bar   | C     |\n        | $     |     3 | bar   | D     |\n\n        All columns beside:", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_175-225"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 210, "start_line_no": 185, "end_line_no": 235, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "\n        ```python\n        df.gather()\n        ```\n        | variable   | value   |\n        |:-----------|:--------|\n        | foo        | 1       |\n        | foo        | 2       |\n        | foo        | 1       |\n        | foo        | 2       |\n        | bar        | A       |\n        | bar        | B       |\n        | bar        | C       |\n        | bar        | D       |\n        | baz        | !       |\n        | baz        | @       |\n        | baz        | #       |\n        | baz        | $       |\n        | jaz        | 0       |\n        | jaz        | 1       |\n        | jaz        | 2       |\n        | jaz        | 3       |\n\n        Multiple columns:\n\n        ```python\n        df.gather([\"foo\", \"bar\"], into=(\"var\", \"val\"))\n        ```\n        | baz   |   jaz | var   | val   |\n        |:------|------:|:------|:------|\n        | !     |     0 | foo   | 1     |\n        | @     |     1 | foo   | 2     |\n        | #     |     2 | foo   | 1     |\n        | $     |     3 | foo   | 2     |\n        | !     |     0 | bar   | A     |\n        | @     |     1 | bar   | B     |\n        | #     |     2 | bar   | C     |\n        | $     |     3 | bar   | D     |\n\n        All columns beside:\n\n        ```python\n        df.group([\"foo\", \"bar\"]).gather(into=(\"variable\", \"value\"))\n        ```\n        |   foo | bar   | variable   | value   |\n        |------:|:------|:-----------|:--------|\n        |     1 | A     | baz        | !       |\n        |     2 | B     | baz        | @       |\n        |     1 | C     | baz        | #       |\n        |     2 | D     | baz        | $       |", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_185-235"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 220, "start_line_no": 195, "end_line_no": 245, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        | bar        | A       |\n        | bar        | B       |\n        | bar        | C       |\n        | bar        | D       |\n        | baz        | !       |\n        | baz        | @       |\n        | baz        | #       |\n        | baz        | $       |\n        | jaz        | 0       |\n        | jaz        | 1       |\n        | jaz        | 2       |\n        | jaz        | 3       |\n\n        Multiple columns:\n\n        ```python\n        df.gather([\"foo\", \"bar\"], into=(\"var\", \"val\"))\n        ```\n        | baz   |   jaz | var   | val   |\n        |:------|------:|:------|:------|\n        | !     |     0 | foo   | 1     |\n        | @     |     1 | foo   | 2     |\n        | #     |     2 | foo   | 1     |\n        | $     |     3 | foo   | 2     |\n        | !     |     0 | bar   | A     |\n        | @     |     1 | bar   | B     |\n        | #     |     2 | bar   | C     |\n        | $     |     3 | bar   | D     |\n\n        All columns beside:\n\n        ```python\n        df.group([\"foo\", \"bar\"]).gather(into=(\"variable\", \"value\"))\n        ```\n        |   foo | bar   | variable   | value   |\n        |------:|:------|:-----------|:--------|\n        |     1 | A     | baz        | !       |\n        |     2 | B     | baz        | @       |\n        |     1 | C     | baz        | #       |\n        |     2 | D     | baz        | $       |\n        |     1 | A     | jaz        | 0       |\n        |     2 | B     | jaz        | 1       |\n        |     1 | C     | jaz        | 2       |\n        |     2 | D     | jaz        | 3       |\n        \"\"\"\n        return _wrap(gather(self._data, columns, beside, into))\n\n    def pack(self, column: Column, sep: str) -> DataFrame:\n        \"\"\"Collate and concatenate row values for a target column (opposite of unpack)\n", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_195-245"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 230, "start_line_no": 205, "end_line_no": 255, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        | jaz        | 2       |\n        | jaz        | 3       |\n\n        Multiple columns:\n\n        ```python\n        df.gather([\"foo\", \"bar\"], into=(\"var\", \"val\"))\n        ```\n        | baz   |   jaz | var   | val   |\n        |:------|------:|:------|:------|\n        | !     |     0 | foo   | 1     |\n        | @     |     1 | foo   | 2     |\n        | #     |     2 | foo   | 1     |\n        | $     |     3 | foo   | 2     |\n        | !     |     0 | bar   | A     |\n        | @     |     1 | bar   | B     |\n        | #     |     2 | bar   | C     |\n        | $     |     3 | bar   | D     |\n\n        All columns beside:\n\n        ```python\n        df.group([\"foo\", \"bar\"]).gather(into=(\"variable\", \"value\"))\n        ```\n        |   foo | bar   | variable   | value   |\n        |------:|:------|:-----------|:--------|\n        |     1 | A     | baz        | !       |\n        |     2 | B     | baz        | @       |\n        |     1 | C     | baz        | #       |\n        |     2 | D     | baz        | $       |\n        |     1 | A     | jaz        | 0       |\n        |     2 | B     | jaz        | 1       |\n        |     1 | C     | jaz        | 2       |\n        |     2 | D     | jaz        | 3       |\n        \"\"\"\n        return _wrap(gather(self._data, columns, beside, into))\n\n    def pack(self, column: Column, sep: str) -> DataFrame:\n        \"\"\"Collate and concatenate row values for a target column (opposite of unpack)\n\n        Examples:\n\n        ```python\n        df = rf.DataFrame({\n            \"foo\": [\"A\", \"A\", \"B\", \"A\", \"B\", \"C\"],\n            \"bar\": [1, 2, 3, 4, 5, 6]\n        })\n        ```\n        | foo   |   bar |\n        |:------|------:|", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_205-255"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 240, "start_line_no": 215, "end_line_no": 265, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        | !     |     0 | foo   | 1     |\n        | @     |     1 | foo   | 2     |\n        | #     |     2 | foo   | 1     |\n        | $     |     3 | foo   | 2     |\n        | !     |     0 | bar   | A     |\n        | @     |     1 | bar   | B     |\n        | #     |     2 | bar   | C     |\n        | $     |     3 | bar   | D     |\n\n        All columns beside:\n\n        ```python\n        df.group([\"foo\", \"bar\"]).gather(into=(\"variable\", \"value\"))\n        ```\n        |   foo | bar   | variable   | value   |\n        |------:|:------|:-----------|:--------|\n        |     1 | A     | baz        | !       |\n        |     2 | B     | baz        | @       |\n        |     1 | C     | baz        | #       |\n        |     2 | D     | baz        | $       |\n        |     1 | A     | jaz        | 0       |\n        |     2 | B     | jaz        | 1       |\n        |     1 | C     | jaz        | 2       |\n        |     2 | D     | jaz        | 3       |\n        \"\"\"\n        return _wrap(gather(self._data, columns, beside, into))\n\n    def pack(self, column: Column, sep: str) -> DataFrame:\n        \"\"\"Collate and concatenate row values for a target column (opposite of unpack)\n\n        Examples:\n\n        ```python\n        df = rf.DataFrame({\n            \"foo\": [\"A\", \"A\", \"B\", \"A\", \"B\", \"C\"],\n            \"bar\": [1, 2, 3, 4, 5, 6]\n        })\n        ```\n        | foo   |   bar |\n        |:------|------:|\n        | A     |     1 |\n        | A     |     2 |\n        | B     |     3 |\n        | A     |     4 |\n        | B     |     5 |\n        | C     |     6 |\n\n        Pack all rows:\n\n        ```python", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_215-265"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 250, "start_line_no": 225, "end_line_no": 275, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "\n        ```python\n        df.group([\"foo\", \"bar\"]).gather(into=(\"variable\", \"value\"))\n        ```\n        |   foo | bar   | variable   | value   |\n        |------:|:------|:-----------|:--------|\n        |     1 | A     | baz        | !       |\n        |     2 | B     | baz        | @       |\n        |     1 | C     | baz        | #       |\n        |     2 | D     | baz        | $       |\n        |     1 | A     | jaz        | 0       |\n        |     2 | B     | jaz        | 1       |\n        |     1 | C     | jaz        | 2       |\n        |     2 | D     | jaz        | 3       |\n        \"\"\"\n        return _wrap(gather(self._data, columns, beside, into))\n\n    def pack(self, column: Column, sep: str) -> DataFrame:\n        \"\"\"Collate and concatenate row values for a target column (opposite of unpack)\n\n        Examples:\n\n        ```python\n        df = rf.DataFrame({\n            \"foo\": [\"A\", \"A\", \"B\", \"A\", \"B\", \"C\"],\n            \"bar\": [1, 2, 3, 4, 5, 6]\n        })\n        ```\n        | foo   |   bar |\n        |:------|------:|\n        | A     |     1 |\n        | A     |     2 |\n        | B     |     3 |\n        | A     |     4 |\n        | B     |     5 |\n        | C     |     6 |\n\n        Pack all rows:\n\n        ```python\n        df.pack(\"foo\", sep=\"+\")\n        ```\n        | foo         |\n        |:------------|\n        | A+A+B+A+B+C |\n\n        Pack rows by Group:\n\n        ```python\n        df.group(\"foo\").pack(\"bar\", sep=\"|\")", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_225-275"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 260, "start_line_no": 235, "end_line_no": 285, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        |     1 | A     | jaz        | 0       |\n        |     2 | B     | jaz        | 1       |\n        |     1 | C     | jaz        | 2       |\n        |     2 | D     | jaz        | 3       |\n        \"\"\"\n        return _wrap(gather(self._data, columns, beside, into))\n\n    def pack(self, column: Column, sep: str) -> DataFrame:\n        \"\"\"Collate and concatenate row values for a target column (opposite of unpack)\n\n        Examples:\n\n        ```python\n        df = rf.DataFrame({\n            \"foo\": [\"A\", \"A\", \"B\", \"A\", \"B\", \"C\"],\n            \"bar\": [1, 2, 3, 4, 5, 6]\n        })\n        ```\n        | foo   |   bar |\n        |:------|------:|\n        | A     |     1 |\n        | A     |     2 |\n        | B     |     3 |\n        | A     |     4 |\n        | B     |     5 |\n        | C     |     6 |\n\n        Pack all rows:\n\n        ```python\n        df.pack(\"foo\", sep=\"+\")\n        ```\n        | foo         |\n        |:------------|\n        | A+A+B+A+B+C |\n\n        Pack rows by Group:\n\n        ```python\n        df.group(\"foo\").pack(\"bar\", sep=\"|\")\n        ```\n        | foo   | bar   |\n        |:------|:------|\n        | A     | 1|2|4 |\n        | B     | 3|5   |\n        | C     | 6     |\n        \"\"\"\n        return _wrap(pack(self._data, column, sep))\n\n    def rank(", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_235-285"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 270, "start_line_no": 245, "end_line_no": 295, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        Examples:\n\n        ```python\n        df = rf.DataFrame({\n            \"foo\": [\"A\", \"A\", \"B\", \"A\", \"B\", \"C\"],\n            \"bar\": [1, 2, 3, 4, 5, 6]\n        })\n        ```\n        | foo   |   bar |\n        |:------|------:|\n        | A     |     1 |\n        | A     |     2 |\n        | B     |     3 |\n        | A     |     4 |\n        | B     |     5 |\n        | C     |     6 |\n\n        Pack all rows:\n\n        ```python\n        df.pack(\"foo\", sep=\"+\")\n        ```\n        | foo         |\n        |:------------|\n        | A+A+B+A+B+C |\n\n        Pack rows by Group:\n\n        ```python\n        df.group(\"foo\").pack(\"bar\", sep=\"|\")\n        ```\n        | foo   | bar   |\n        |:------|:------|\n        | A     | 1|2|4 |\n        | B     | 3|5   |\n        | C     | 6     |\n        \"\"\"\n        return _wrap(pack(self._data, column, sep))\n\n    def rank(\n        self,\n        column: Column,\n        into: Column,\n        descending: bool = False,\n    ) -> DataFrame:\n        \"\"\"Rank order values in a column\n\n        Example:\n\n        ```python", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_245-295"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 280, "start_line_no": 255, "end_line_no": 305, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        | A     |     1 |\n        | A     |     2 |\n        | B     |     3 |\n        | A     |     4 |\n        | B     |     5 |\n        | C     |     6 |\n\n        Pack all rows:\n\n        ```python\n        df.pack(\"foo\", sep=\"+\")\n        ```\n        | foo         |\n        |:------------|\n        | A+A+B+A+B+C |\n\n        Pack rows by Group:\n\n        ```python\n        df.group(\"foo\").pack(\"bar\", sep=\"|\")\n        ```\n        | foo   | bar   |\n        |:------|:------|\n        | A     | 1|2|4 |\n        | B     | 3|5   |\n        | C     | 6     |\n        \"\"\"\n        return _wrap(pack(self._data, column, sep))\n\n    def rank(\n        self,\n        column: Column,\n        into: Column,\n        descending: bool = False,\n    ) -> DataFrame:\n        \"\"\"Rank order values in a column\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [2, 3, 3, 99, 1000, 1, -6, 4]})\n        ```\n        |   foo |\n        |------:|\n        |     2 |\n        |     3 |\n        |     3 |\n        |    99 |\n        |  1000 |\n        |     1 |", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_255-305"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 290, "start_line_no": 265, "end_line_no": 315, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        df.pack(\"foo\", sep=\"+\")\n        ```\n        | foo         |\n        |:------------|\n        | A+A+B+A+B+C |\n\n        Pack rows by Group:\n\n        ```python\n        df.group(\"foo\").pack(\"bar\", sep=\"|\")\n        ```\n        | foo   | bar   |\n        |:------|:------|\n        | A     | 1|2|4 |\n        | B     | 3|5   |\n        | C     | 6     |\n        \"\"\"\n        return _wrap(pack(self._data, column, sep))\n\n    def rank(\n        self,\n        column: Column,\n        into: Column,\n        descending: bool = False,\n    ) -> DataFrame:\n        \"\"\"Rank order values in a column\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [2, 3, 3, 99, 1000, 1, -6, 4]})\n        ```\n        |   foo |\n        |------:|\n        |     2 |\n        |     3 |\n        |     3 |\n        |    99 |\n        |  1000 |\n        |     1 |\n        |    -6 |\n        |     4 |\n\n        ```python\n        df.rank(\"foo\", into=\"rank\", descending=True)\n        ```\n        |   foo |   rank |\n        |------:|-------:|\n        |     2 |      5 |\n        |     3 |      4 |", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_265-315"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 300, "start_line_no": 275, "end_line_no": 325, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        ```\n        | foo   | bar   |\n        |:------|:------|\n        | A     | 1|2|4 |\n        | B     | 3|5   |\n        | C     | 6     |\n        \"\"\"\n        return _wrap(pack(self._data, column, sep))\n\n    def rank(\n        self,\n        column: Column,\n        into: Column,\n        descending: bool = False,\n    ) -> DataFrame:\n        \"\"\"Rank order values in a column\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [2, 3, 3, 99, 1000, 1, -6, 4]})\n        ```\n        |   foo |\n        |------:|\n        |     2 |\n        |     3 |\n        |     3 |\n        |    99 |\n        |  1000 |\n        |     1 |\n        |    -6 |\n        |     4 |\n\n        ```python\n        df.rank(\"foo\", into=\"rank\", descending=True)\n        ```\n        |   foo |   rank |\n        |------:|-------:|\n        |     2 |      5 |\n        |     3 |      4 |\n        |     3 |      4 |\n        |    99 |      2 |\n        |  1000 |      1 |\n        |     1 |      6 |\n        |    -6 |      7 |\n        |     4 |      3 |\n        \"\"\"\n        return _wrap(rank(self._data, column, into, descending))\n\n    def rollup(self, over: dict[Column, tuple[Column, Func]]) -> DataFrame:", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_275-325"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 310, "start_line_no": 285, "end_line_no": 335, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        self,\n        column: Column,\n        into: Column,\n        descending: bool = False,\n    ) -> DataFrame:\n        \"\"\"Rank order values in a column\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [2, 3, 3, 99, 1000, 1, -6, 4]})\n        ```\n        |   foo |\n        |------:|\n        |     2 |\n        |     3 |\n        |     3 |\n        |    99 |\n        |  1000 |\n        |     1 |\n        |    -6 |\n        |     4 |\n\n        ```python\n        df.rank(\"foo\", into=\"rank\", descending=True)\n        ```\n        |   foo |   rank |\n        |------:|-------:|\n        |     2 |      5 |\n        |     3 |      4 |\n        |     3 |      4 |\n        |    99 |      2 |\n        |  1000 |      1 |\n        |     1 |      6 |\n        |    -6 |      7 |\n        |     4 |      3 |\n        \"\"\"\n        return _wrap(rank(self._data, column, into, descending))\n\n    def rollup(self, over: dict[Column, tuple[Column, Func]]) -> DataFrame:\n        \"\"\"Apply summary functions and/or statistics to target columns\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [1, 2, 3, 4, 5], \"bar\": [99, 100, 1, -5, 2]})\n        ```\n        |   foo |   bar |\n        |------:|------:|\n        |     1 |    99 |", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_285-335"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 320, "start_line_no": 295, "end_line_no": 345, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        df = rf.DataFrame({\"foo\": [2, 3, 3, 99, 1000, 1, -6, 4]})\n        ```\n        |   foo |\n        |------:|\n        |     2 |\n        |     3 |\n        |     3 |\n        |    99 |\n        |  1000 |\n        |     1 |\n        |    -6 |\n        |     4 |\n\n        ```python\n        df.rank(\"foo\", into=\"rank\", descending=True)\n        ```\n        |   foo |   rank |\n        |------:|-------:|\n        |     2 |      5 |\n        |     3 |      4 |\n        |     3 |      4 |\n        |    99 |      2 |\n        |  1000 |      1 |\n        |     1 |      6 |\n        |    -6 |      7 |\n        |     4 |      3 |\n        \"\"\"\n        return _wrap(rank(self._data, column, into, descending))\n\n    def rollup(self, over: dict[Column, tuple[Column, Func]]) -> DataFrame:\n        \"\"\"Apply summary functions and/or statistics to target columns\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [1, 2, 3, 4, 5], \"bar\": [99, 100, 1, -5, 2]})\n        ```\n        |   foo |   bar |\n        |------:|------:|\n        |     1 |    99 |\n        |     2 |   100 |\n        |     3 |     1 |\n        |     4 |    -5 |\n        |     5 |     2 |\n\n        ```python\n        df.rollup({\n            \"fcount\": (\"foo\", rf.stat.count),\n            \"fmean\": (\"foo\", rf.stat.mean),\n            \"fsum\": (\"foo\", rf.stat.sum),", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_295-345"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 330, "start_line_no": 305, "end_line_no": 355, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        |    -6 |\n        |     4 |\n\n        ```python\n        df.rank(\"foo\", into=\"rank\", descending=True)\n        ```\n        |   foo |   rank |\n        |------:|-------:|\n        |     2 |      5 |\n        |     3 |      4 |\n        |     3 |      4 |\n        |    99 |      2 |\n        |  1000 |      1 |\n        |     1 |      6 |\n        |    -6 |      7 |\n        |     4 |      3 |\n        \"\"\"\n        return _wrap(rank(self._data, column, into, descending))\n\n    def rollup(self, over: dict[Column, tuple[Column, Func]]) -> DataFrame:\n        \"\"\"Apply summary functions and/or statistics to target columns\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [1, 2, 3, 4, 5], \"bar\": [99, 100, 1, -5, 2]})\n        ```\n        |   foo |   bar |\n        |------:|------:|\n        |     1 |    99 |\n        |     2 |   100 |\n        |     3 |     1 |\n        |     4 |    -5 |\n        |     5 |     2 |\n\n        ```python\n        df.rollup({\n            \"fcount\": (\"foo\", rf.stat.count),\n            \"fmean\": (\"foo\", rf.stat.mean),\n            \"fsum\": (\"foo\", rf.stat.sum),\n            \"fmax\": (\"foo\", rf.stat.max),\n            \"bmedian\": (\"bar\", rf.stat.median),\n            \"bmin\": (\"bar\", rf.stat.min),\n            \"bstd\": (\"bar\", rf.stat.std)\n        })\n        ```\n        |   fcount |   fmean |   fsum |   fmax |   bmedian |   bmin |   bstd |\n        |---------:|--------:|-------:|-------:|----------:|-------:|-------:|\n        |        5 |       3 |     15 |      5 |         2 |     -5 |  54.93 |\n        \"\"\"", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_305-355"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 340, "start_line_no": 315, "end_line_no": 365, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        |     3 |      4 |\n        |    99 |      2 |\n        |  1000 |      1 |\n        |     1 |      6 |\n        |    -6 |      7 |\n        |     4 |      3 |\n        \"\"\"\n        return _wrap(rank(self._data, column, into, descending))\n\n    def rollup(self, over: dict[Column, tuple[Column, Func]]) -> DataFrame:\n        \"\"\"Apply summary functions and/or statistics to target columns\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [1, 2, 3, 4, 5], \"bar\": [99, 100, 1, -5, 2]})\n        ```\n        |   foo |   bar |\n        |------:|------:|\n        |     1 |    99 |\n        |     2 |   100 |\n        |     3 |     1 |\n        |     4 |    -5 |\n        |     5 |     2 |\n\n        ```python\n        df.rollup({\n            \"fcount\": (\"foo\", rf.stat.count),\n            \"fmean\": (\"foo\", rf.stat.mean),\n            \"fsum\": (\"foo\", rf.stat.sum),\n            \"fmax\": (\"foo\", rf.stat.max),\n            \"bmedian\": (\"bar\", rf.stat.median),\n            \"bmin\": (\"bar\", rf.stat.min),\n            \"bstd\": (\"bar\", rf.stat.std)\n        })\n        ```\n        |   fcount |   fmean |   fsum |   fmax |   bmedian |   bmin |   bstd |\n        |---------:|--------:|-------:|-------:|----------:|-------:|-------:|\n        |        5 |       3 |     15 |      5 |         2 |     -5 |  54.93 |\n        \"\"\"\n        return _wrap(rollup(self._data, over))\n\n    def summarize(self, over: dict[Column, tuple[Column, Func]]) -> DataFrame:\n        message = \"Marked for removal, please use `rollup` instead\"\n        warnings.warn(message, FutureWarning)\n        return self.rollup(over)\n\n\nclass GroupedFrame(_CommonMixin):\n    \"\"\"GroupedFrame compatible with: `accumulate`, `gather`, `pack`, `rank`, `rollup`, `take`\"\"\"", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_315-365"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 350, "start_line_no": 325, "end_line_no": 375, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        \"\"\"Apply summary functions and/or statistics to target columns\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [1, 2, 3, 4, 5], \"bar\": [99, 100, 1, -5, 2]})\n        ```\n        |   foo |   bar |\n        |------:|------:|\n        |     1 |    99 |\n        |     2 |   100 |\n        |     3 |     1 |\n        |     4 |    -5 |\n        |     5 |     2 |\n\n        ```python\n        df.rollup({\n            \"fcount\": (\"foo\", rf.stat.count),\n            \"fmean\": (\"foo\", rf.stat.mean),\n            \"fsum\": (\"foo\", rf.stat.sum),\n            \"fmax\": (\"foo\", rf.stat.max),\n            \"bmedian\": (\"bar\", rf.stat.median),\n            \"bmin\": (\"bar\", rf.stat.min),\n            \"bstd\": (\"bar\", rf.stat.std)\n        })\n        ```\n        |   fcount |   fmean |   fsum |   fmax |   bmedian |   bmin |   bstd |\n        |---------:|--------:|-------:|-------:|----------:|-------:|-------:|\n        |        5 |       3 |     15 |      5 |         2 |     -5 |  54.93 |\n        \"\"\"\n        return _wrap(rollup(self._data, over))\n\n    def summarize(self, over: dict[Column, tuple[Column, Func]]) -> DataFrame:\n        message = \"Marked for removal, please use `rollup` instead\"\n        warnings.warn(message, FutureWarning)\n        return self.rollup(over)\n\n\nclass GroupedFrame(_CommonMixin):\n    \"\"\"GroupedFrame compatible with: `accumulate`, `gather`, `pack`, `rank`, `rollup`, `take`\"\"\"\n\n    def __repr__(self) -> str:\n        return self._data.obj.__repr__()  # type: ignore\n\n    def _repr_html_(self) -> str:\n        return self._data.obj.to_html(index=True)  # type: ignore\n\n\nclass DataFrame(_CommonMixin, _InterchangeMixin):\n    def __init__(self, data: dict[Column, Values] | None = None) -> None:", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_325-375"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 360, "start_line_no": 335, "end_line_no": 385, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        |     2 |   100 |\n        |     3 |     1 |\n        |     4 |    -5 |\n        |     5 |     2 |\n\n        ```python\n        df.rollup({\n            \"fcount\": (\"foo\", rf.stat.count),\n            \"fmean\": (\"foo\", rf.stat.mean),\n            \"fsum\": (\"foo\", rf.stat.sum),\n            \"fmax\": (\"foo\", rf.stat.max),\n            \"bmedian\": (\"bar\", rf.stat.median),\n            \"bmin\": (\"bar\", rf.stat.min),\n            \"bstd\": (\"bar\", rf.stat.std)\n        })\n        ```\n        |   fcount |   fmean |   fsum |   fmax |   bmedian |   bmin |   bstd |\n        |---------:|--------:|-------:|-------:|----------:|-------:|-------:|\n        |        5 |       3 |     15 |      5 |         2 |     -5 |  54.93 |\n        \"\"\"\n        return _wrap(rollup(self._data, over))\n\n    def summarize(self, over: dict[Column, tuple[Column, Func]]) -> DataFrame:\n        message = \"Marked for removal, please use `rollup` instead\"\n        warnings.warn(message, FutureWarning)\n        return self.rollup(over)\n\n\nclass GroupedFrame(_CommonMixin):\n    \"\"\"GroupedFrame compatible with: `accumulate`, `gather`, `pack`, `rank`, `rollup`, `take`\"\"\"\n\n    def __repr__(self) -> str:\n        return self._data.obj.__repr__()  # type: ignore\n\n    def _repr_html_(self) -> str:\n        return self._data.obj.to_html(index=True)  # type: ignore\n\n\nclass DataFrame(_CommonMixin, _InterchangeMixin):\n    def __init__(self, data: dict[Column, Values] | None = None) -> None:\n        \"\"\"Initialize a DataFrame with a standard dictionary\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [1, 2], \"bar\": [\"A\", \"B\"]})\n        ```\n        |   foo | bar   |\n        |------:|:------|\n        |     1 | A     |", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_335-385"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 370, "start_line_no": 345, "end_line_no": 395, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "            \"fmax\": (\"foo\", rf.stat.max),\n            \"bmedian\": (\"bar\", rf.stat.median),\n            \"bmin\": (\"bar\", rf.stat.min),\n            \"bstd\": (\"bar\", rf.stat.std)\n        })\n        ```\n        |   fcount |   fmean |   fsum |   fmax |   bmedian |   bmin |   bstd |\n        |---------:|--------:|-------:|-------:|----------:|-------:|-------:|\n        |        5 |       3 |     15 |      5 |         2 |     -5 |  54.93 |\n        \"\"\"\n        return _wrap(rollup(self._data, over))\n\n    def summarize(self, over: dict[Column, tuple[Column, Func]]) -> DataFrame:\n        message = \"Marked for removal, please use `rollup` instead\"\n        warnings.warn(message, FutureWarning)\n        return self.rollup(over)\n\n\nclass GroupedFrame(_CommonMixin):\n    \"\"\"GroupedFrame compatible with: `accumulate`, `gather`, `pack`, `rank`, `rollup`, `take`\"\"\"\n\n    def __repr__(self) -> str:\n        return self._data.obj.__repr__()  # type: ignore\n\n    def _repr_html_(self) -> str:\n        return self._data.obj.to_html(index=True)  # type: ignore\n\n\nclass DataFrame(_CommonMixin, _InterchangeMixin):\n    def __init__(self, data: dict[Column, Values] | None = None) -> None:\n        \"\"\"Initialize a DataFrame with a standard dictionary\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [1, 2], \"bar\": [\"A\", \"B\"]})\n        ```\n        |   foo | bar   |\n        |------:|:------|\n        |     1 | A     |\n        |     2 | B     |\n        \"\"\"\n        _check_type(data, {dict, None})\n        if not data:\n            self._data = PandasDataFrame()\n        if isinstance(data, dict):\n            self._data = PandasDataFrame(data)\n\n    def __eq__(self, rhs: Any) -> bool:\n        \"\"\"Check if two DataFrames are equal to each other", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_345-395"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 380, "start_line_no": 355, "end_line_no": 405, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        return _wrap(rollup(self._data, over))\n\n    def summarize(self, over: dict[Column, tuple[Column, Func]]) -> DataFrame:\n        message = \"Marked for removal, please use `rollup` instead\"\n        warnings.warn(message, FutureWarning)\n        return self.rollup(over)\n\n\nclass GroupedFrame(_CommonMixin):\n    \"\"\"GroupedFrame compatible with: `accumulate`, `gather`, `pack`, `rank`, `rollup`, `take`\"\"\"\n\n    def __repr__(self) -> str:\n        return self._data.obj.__repr__()  # type: ignore\n\n    def _repr_html_(self) -> str:\n        return self._data.obj.to_html(index=True)  # type: ignore\n\n\nclass DataFrame(_CommonMixin, _InterchangeMixin):\n    def __init__(self, data: dict[Column, Values] | None = None) -> None:\n        \"\"\"Initialize a DataFrame with a standard dictionary\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [1, 2], \"bar\": [\"A\", \"B\"]})\n        ```\n        |   foo | bar   |\n        |------:|:------|\n        |     1 | A     |\n        |     2 | B     |\n        \"\"\"\n        _check_type(data, {dict, None})\n        if not data:\n            self._data = PandasDataFrame()\n        if isinstance(data, dict):\n            self._data = PandasDataFrame(data)\n\n    def __eq__(self, rhs: Any) -> bool:\n        \"\"\"Check if two DataFrames are equal to each other\n\n        Example:\n\n        ```python\n        adf = rf.DataFrame({\"foo\": [1]})\n        bdf = rf.DataFrame({\"bar\": [1]})\n        cdf = rf.DataFrame({\"foo\": [1]})\n        print(adf == bdf)\n        print(adf == cdf)\n        # False", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_355-405"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 390, "start_line_no": 365, "end_line_no": 415, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "\n    def __repr__(self) -> str:\n        return self._data.obj.__repr__()  # type: ignore\n\n    def _repr_html_(self) -> str:\n        return self._data.obj.to_html(index=True)  # type: ignore\n\n\nclass DataFrame(_CommonMixin, _InterchangeMixin):\n    def __init__(self, data: dict[Column, Values] | None = None) -> None:\n        \"\"\"Initialize a DataFrame with a standard dictionary\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [1, 2], \"bar\": [\"A\", \"B\"]})\n        ```\n        |   foo | bar   |\n        |------:|:------|\n        |     1 | A     |\n        |     2 | B     |\n        \"\"\"\n        _check_type(data, {dict, None})\n        if not data:\n            self._data = PandasDataFrame()\n        if isinstance(data, dict):\n            self._data = PandasDataFrame(data)\n\n    def __eq__(self, rhs: Any) -> bool:\n        \"\"\"Check if two DataFrames are equal to each other\n\n        Example:\n\n        ```python\n        adf = rf.DataFrame({\"foo\": [1]})\n        bdf = rf.DataFrame({\"bar\": [1]})\n        cdf = rf.DataFrame({\"foo\": [1]})\n        print(adf == bdf)\n        print(adf == cdf)\n        # False\n        # True\n        ```\n        \"\"\"\n        if not isinstance(rhs, DataFrame):\n            return False\n        return self._data.equals(rhs._data)\n\n    def __getitem__(self, key: Column) -> Values:\n        \"\"\"Retrive values (as a python list) from a specified column\n", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_365-415"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 400, "start_line_no": 375, "end_line_no": 425, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        \"\"\"Initialize a DataFrame with a standard dictionary\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [1, 2], \"bar\": [\"A\", \"B\"]})\n        ```\n        |   foo | bar   |\n        |------:|:------|\n        |     1 | A     |\n        |     2 | B     |\n        \"\"\"\n        _check_type(data, {dict, None})\n        if not data:\n            self._data = PandasDataFrame()\n        if isinstance(data, dict):\n            self._data = PandasDataFrame(data)\n\n    def __eq__(self, rhs: Any) -> bool:\n        \"\"\"Check if two DataFrames are equal to each other\n\n        Example:\n\n        ```python\n        adf = rf.DataFrame({\"foo\": [1]})\n        bdf = rf.DataFrame({\"bar\": [1]})\n        cdf = rf.DataFrame({\"foo\": [1]})\n        print(adf == bdf)\n        print(adf == cdf)\n        # False\n        # True\n        ```\n        \"\"\"\n        if not isinstance(rhs, DataFrame):\n            return False\n        return self._data.equals(rhs._data)\n\n    def __getitem__(self, key: Column) -> Values:\n        \"\"\"Retrive values (as a python list) from a specified column\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [1, 2], \"bar\": [\"A\", \"B\"]})\n        df[\"foo\"]\n        # [1, 2]\n        ```\n        \"\"\"\n        return list(self._data[key])\n", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_375-425"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 410, "start_line_no": 385, "end_line_no": 435, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        |     2 | B     |\n        \"\"\"\n        _check_type(data, {dict, None})\n        if not data:\n            self._data = PandasDataFrame()\n        if isinstance(data, dict):\n            self._data = PandasDataFrame(data)\n\n    def __eq__(self, rhs: Any) -> bool:\n        \"\"\"Check if two DataFrames are equal to each other\n\n        Example:\n\n        ```python\n        adf = rf.DataFrame({\"foo\": [1]})\n        bdf = rf.DataFrame({\"bar\": [1]})\n        cdf = rf.DataFrame({\"foo\": [1]})\n        print(adf == bdf)\n        print(adf == cdf)\n        # False\n        # True\n        ```\n        \"\"\"\n        if not isinstance(rhs, DataFrame):\n            return False\n        return self._data.equals(rhs._data)\n\n    def __getitem__(self, key: Column) -> Values:\n        \"\"\"Retrive values (as a python list) from a specified column\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [1, 2], \"bar\": [\"A\", \"B\"]})\n        df[\"foo\"]\n        # [1, 2]\n        ```\n        \"\"\"\n        return list(self._data[key])\n\n    def __repr__(self) -> str:\n        return self._data.__repr__()\n\n    def _repr_html_(self) -> str:\n        return self._data.to_html(index=True)\n\n    def __str__(self) -> str:\n        \"\"\"Return string constructor (for copy-and-pasting)\n\n        Example:", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_385-435"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 420, "start_line_no": 395, "end_line_no": 445, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "\n        Example:\n\n        ```python\n        adf = rf.DataFrame({\"foo\": [1]})\n        bdf = rf.DataFrame({\"bar\": [1]})\n        cdf = rf.DataFrame({\"foo\": [1]})\n        print(adf == bdf)\n        print(adf == cdf)\n        # False\n        # True\n        ```\n        \"\"\"\n        if not isinstance(rhs, DataFrame):\n            return False\n        return self._data.equals(rhs._data)\n\n    def __getitem__(self, key: Column) -> Values:\n        \"\"\"Retrive values (as a python list) from a specified column\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [1, 2], \"bar\": [\"A\", \"B\"]})\n        df[\"foo\"]\n        # [1, 2]\n        ```\n        \"\"\"\n        return list(self._data[key])\n\n    def __repr__(self) -> str:\n        return self._data.__repr__()\n\n    def _repr_html_(self) -> str:\n        return self._data.to_html(index=True)\n\n    def __str__(self) -> str:\n        \"\"\"Return string constructor (for copy-and-pasting)\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [1, 2], \"bar\": [\"A\", \"B\"]})\n        str(df)\n        # \"rf.DataFrame({'foo': [1, 2], 'bar': ['A', 'B']})\"\n        ```\n        \"\"\"\n        data = self._data.to_dict(orient=\"list\")\n        string = pprint.pformat(data, indent=4, sort_dicts=False, compact=True)\n        if \"\\n\" in string:", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_395-445"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 430, "start_line_no": 405, "end_line_no": 455, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        # True\n        ```\n        \"\"\"\n        if not isinstance(rhs, DataFrame):\n            return False\n        return self._data.equals(rhs._data)\n\n    def __getitem__(self, key: Column) -> Values:\n        \"\"\"Retrive values (as a python list) from a specified column\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [1, 2], \"bar\": [\"A\", \"B\"]})\n        df[\"foo\"]\n        # [1, 2]\n        ```\n        \"\"\"\n        return list(self._data[key])\n\n    def __repr__(self) -> str:\n        return self._data.__repr__()\n\n    def _repr_html_(self) -> str:\n        return self._data.to_html(index=True)\n\n    def __str__(self) -> str:\n        \"\"\"Return string constructor (for copy-and-pasting)\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [1, 2], \"bar\": [\"A\", \"B\"]})\n        str(df)\n        # \"rf.DataFrame({'foo': [1, 2], 'bar': ['A', 'B']})\"\n        ```\n        \"\"\"\n        data = self._data.to_dict(orient=\"list\")\n        string = pprint.pformat(data, indent=4, sort_dicts=False, compact=True)\n        if \"\\n\" in string:\n            string = \" \" + string[1:-1]\n            string = f\"rf.DataFrame({{\\n{string}\\n}})\"\n        else:\n            string = f\"rf.DataFrame({string})\"\n        return string\n\n    @property\n    def columns(self) -> Columns:\n        \"\"\"Inspect column keys (names)\n", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_405-455"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 440, "start_line_no": 415, "end_line_no": 465, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [1, 2], \"bar\": [\"A\", \"B\"]})\n        df[\"foo\"]\n        # [1, 2]\n        ```\n        \"\"\"\n        return list(self._data[key])\n\n    def __repr__(self) -> str:\n        return self._data.__repr__()\n\n    def _repr_html_(self) -> str:\n        return self._data.to_html(index=True)\n\n    def __str__(self) -> str:\n        \"\"\"Return string constructor (for copy-and-pasting)\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [1, 2], \"bar\": [\"A\", \"B\"]})\n        str(df)\n        # \"rf.DataFrame({'foo': [1, 2], 'bar': ['A', 'B']})\"\n        ```\n        \"\"\"\n        data = self._data.to_dict(orient=\"list\")\n        string = pprint.pformat(data, indent=4, sort_dicts=False, compact=True)\n        if \"\\n\" in string:\n            string = \" \" + string[1:-1]\n            string = f\"rf.DataFrame({{\\n{string}\\n}})\"\n        else:\n            string = f\"rf.DataFrame({string})\"\n        return string\n\n    @property\n    def columns(self) -> Columns:\n        \"\"\"Inspect column keys (names)\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [1, 2], \"bar\": [\"A\", \"B\"], \"baz\": [True, False]})\n        df.columns\n        # ['foo', 'bar', 'baz']\n        ```\n        \"\"\"\n        return list(self._data.columns)\n", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_415-465"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 450, "start_line_no": 425, "end_line_no": 475, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "    def __repr__(self) -> str:\n        return self._data.__repr__()\n\n    def _repr_html_(self) -> str:\n        return self._data.to_html(index=True)\n\n    def __str__(self) -> str:\n        \"\"\"Return string constructor (for copy-and-pasting)\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [1, 2], \"bar\": [\"A\", \"B\"]})\n        str(df)\n        # \"rf.DataFrame({'foo': [1, 2], 'bar': ['A', 'B']})\"\n        ```\n        \"\"\"\n        data = self._data.to_dict(orient=\"list\")\n        string = pprint.pformat(data, indent=4, sort_dicts=False, compact=True)\n        if \"\\n\" in string:\n            string = \" \" + string[1:-1]\n            string = f\"rf.DataFrame({{\\n{string}\\n}})\"\n        else:\n            string = f\"rf.DataFrame({string})\"\n        return string\n\n    @property\n    def columns(self) -> Columns:\n        \"\"\"Inspect column keys (names)\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [1, 2], \"bar\": [\"A\", \"B\"], \"baz\": [True, False]})\n        df.columns\n        # ['foo', 'bar', 'baz']\n        ```\n        \"\"\"\n        return list(self._data.columns)\n\n    @property\n    def dimensions(self) -> dict[str, int]:\n        \"\"\"Inspect DataFrame shape\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": range(10), \"bar\": range(10, 20)})\n        df.dimensions\n        # {'rows': 10, 'columns': 2}", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_425-475"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 460, "start_line_no": 435, "end_line_no": 485, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "\n        ```python\n        df = rf.DataFrame({\"foo\": [1, 2], \"bar\": [\"A\", \"B\"]})\n        str(df)\n        # \"rf.DataFrame({'foo': [1, 2], 'bar': ['A', 'B']})\"\n        ```\n        \"\"\"\n        data = self._data.to_dict(orient=\"list\")\n        string = pprint.pformat(data, indent=4, sort_dicts=False, compact=True)\n        if \"\\n\" in string:\n            string = \" \" + string[1:-1]\n            string = f\"rf.DataFrame({{\\n{string}\\n}})\"\n        else:\n            string = f\"rf.DataFrame({string})\"\n        return string\n\n    @property\n    def columns(self) -> Columns:\n        \"\"\"Inspect column keys (names)\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [1, 2], \"bar\": [\"A\", \"B\"], \"baz\": [True, False]})\n        df.columns\n        # ['foo', 'bar', 'baz']\n        ```\n        \"\"\"\n        return list(self._data.columns)\n\n    @property\n    def dimensions(self) -> dict[str, int]:\n        \"\"\"Inspect DataFrame shape\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": range(10), \"bar\": range(10, 20)})\n        df.dimensions\n        # {'rows': 10, 'columns': 2}\n        ```\n        \"\"\"\n        return dict(zip([\"rows\", \"columns\"], self._data.shape))\n\n    @property\n    def empty(self) -> bool:\n        \"\"\"Inspect if DataFrame is \"empty\"\n\n        Example:\n", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_435-485"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 470, "start_line_no": 445, "end_line_no": 495, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "            string = \" \" + string[1:-1]\n            string = f\"rf.DataFrame({{\\n{string}\\n}})\"\n        else:\n            string = f\"rf.DataFrame({string})\"\n        return string\n\n    @property\n    def columns(self) -> Columns:\n        \"\"\"Inspect column keys (names)\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [1, 2], \"bar\": [\"A\", \"B\"], \"baz\": [True, False]})\n        df.columns\n        # ['foo', 'bar', 'baz']\n        ```\n        \"\"\"\n        return list(self._data.columns)\n\n    @property\n    def dimensions(self) -> dict[str, int]:\n        \"\"\"Inspect DataFrame shape\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": range(10), \"bar\": range(10, 20)})\n        df.dimensions\n        # {'rows': 10, 'columns': 2}\n        ```\n        \"\"\"\n        return dict(zip([\"rows\", \"columns\"], self._data.shape))\n\n    @property\n    def empty(self) -> bool:\n        \"\"\"Inspect if DataFrame is \"empty\"\n\n        Example:\n\n        ```python\n        df = rf.DataFrame()\n        df.empty\n        # True\n        ```\n        \"\"\"\n        return self._data.empty\n\n    @property\n    def memory(self) -> str:", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_445-495"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 480, "start_line_no": 455, "end_line_no": 505, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [1, 2], \"bar\": [\"A\", \"B\"], \"baz\": [True, False]})\n        df.columns\n        # ['foo', 'bar', 'baz']\n        ```\n        \"\"\"\n        return list(self._data.columns)\n\n    @property\n    def dimensions(self) -> dict[str, int]:\n        \"\"\"Inspect DataFrame shape\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": range(10), \"bar\": range(10, 20)})\n        df.dimensions\n        # {'rows': 10, 'columns': 2}\n        ```\n        \"\"\"\n        return dict(zip([\"rows\", \"columns\"], self._data.shape))\n\n    @property\n    def empty(self) -> bool:\n        \"\"\"Inspect if DataFrame is \"empty\"\n\n        Example:\n\n        ```python\n        df = rf.DataFrame()\n        df.empty\n        # True\n        ```\n        \"\"\"\n        return self._data.empty\n\n    @property\n    def memory(self) -> str:\n        \"\"\"Interrogate DataFrame (deep) memory usage\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [1, 2, 3], \"bar\": [\"A\", \"B\", \"C\"]})\n        df.memory\n        # '326B'\n        ```\n        \"\"\"", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_455-505"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 490, "start_line_no": 465, "end_line_no": 515, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "    @property\n    def dimensions(self) -> dict[str, int]:\n        \"\"\"Inspect DataFrame shape\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": range(10), \"bar\": range(10, 20)})\n        df.dimensions\n        # {'rows': 10, 'columns': 2}\n        ```\n        \"\"\"\n        return dict(zip([\"rows\", \"columns\"], self._data.shape))\n\n    @property\n    def empty(self) -> bool:\n        \"\"\"Inspect if DataFrame is \"empty\"\n\n        Example:\n\n        ```python\n        df = rf.DataFrame()\n        df.empty\n        # True\n        ```\n        \"\"\"\n        return self._data.empty\n\n    @property\n    def memory(self) -> str:\n        \"\"\"Interrogate DataFrame (deep) memory usage\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [1, 2, 3], \"bar\": [\"A\", \"B\", \"C\"]})\n        df.memory\n        # '326B'\n        ```\n        \"\"\"\n        size = self._data.memory_usage(deep=True).sum()\n        power_labels = {40: \"TB\", 30: \"GB\", 20: \"MB\", 10: \"KB\"}\n        for power, label in power_labels.items():\n            if size >= (2**power):\n                approx_size = size // 2**power\n                return f\"{approx_size} {label}\"\n        return f\"{size} B\"\n\n    @property\n    def types(self) -> dict[Column, type]:", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_465-515"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 500, "start_line_no": 475, "end_line_no": 525, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        ```\n        \"\"\"\n        return dict(zip([\"rows\", \"columns\"], self._data.shape))\n\n    @property\n    def empty(self) -> bool:\n        \"\"\"Inspect if DataFrame is \"empty\"\n\n        Example:\n\n        ```python\n        df = rf.DataFrame()\n        df.empty\n        # True\n        ```\n        \"\"\"\n        return self._data.empty\n\n    @property\n    def memory(self) -> str:\n        \"\"\"Interrogate DataFrame (deep) memory usage\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [1, 2, 3], \"bar\": [\"A\", \"B\", \"C\"]})\n        df.memory\n        # '326B'\n        ```\n        \"\"\"\n        size = self._data.memory_usage(deep=True).sum()\n        power_labels = {40: \"TB\", 30: \"GB\", 20: \"MB\", 10: \"KB\"}\n        for power, label in power_labels.items():\n            if size >= (2**power):\n                approx_size = size // 2**power\n                return f\"{approx_size} {label}\"\n        return f\"{size} B\"\n\n    @property\n    def types(self) -> dict[Column, type]:\n        \"\"\"Inspect column types\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [1, 2], \"bar\": [\"A\", \"B\"], \"baz\": [True, False]})\n        df.types\n        # {'foo': int, 'bar': object, 'baz': bool}\n        ```\n        \"\"\"", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_475-525"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 510, "start_line_no": 485, "end_line_no": 535, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        ```python\n        df = rf.DataFrame()\n        df.empty\n        # True\n        ```\n        \"\"\"\n        return self._data.empty\n\n    @property\n    def memory(self) -> str:\n        \"\"\"Interrogate DataFrame (deep) memory usage\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [1, 2, 3], \"bar\": [\"A\", \"B\", \"C\"]})\n        df.memory\n        # '326B'\n        ```\n        \"\"\"\n        size = self._data.memory_usage(deep=True).sum()\n        power_labels = {40: \"TB\", 30: \"GB\", 20: \"MB\", 10: \"KB\"}\n        for power, label in power_labels.items():\n            if size >= (2**power):\n                approx_size = size // 2**power\n                return f\"{approx_size} {label}\"\n        return f\"{size} B\"\n\n    @property\n    def types(self) -> dict[Column, type]:\n        \"\"\"Inspect column types\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [1, 2], \"bar\": [\"A\", \"B\"], \"baz\": [True, False]})\n        df.types\n        # {'foo': int, 'bar': object, 'baz': bool}\n        ```\n        \"\"\"\n        numpy_types = {\n            NumpyType(\"O\"): object,\n            NumpyType(\"int64\"): int,\n            NumpyType(\"float64\"): float,\n            NumpyType(\"bool\"): bool,\n            NumpyType(\"datetime64\"): DateTime,\n        }\n        raw_types = dict(self._data.dtypes)\n        clean_types = {}\n        for column in self.columns:", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_485-535"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 520, "start_line_no": 495, "end_line_no": 545, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        \"\"\"Interrogate DataFrame (deep) memory usage\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [1, 2, 3], \"bar\": [\"A\", \"B\", \"C\"]})\n        df.memory\n        # '326B'\n        ```\n        \"\"\"\n        size = self._data.memory_usage(deep=True).sum()\n        power_labels = {40: \"TB\", 30: \"GB\", 20: \"MB\", 10: \"KB\"}\n        for power, label in power_labels.items():\n            if size >= (2**power):\n                approx_size = size // 2**power\n                return f\"{approx_size} {label}\"\n        return f\"{size} B\"\n\n    @property\n    def types(self) -> dict[Column, type]:\n        \"\"\"Inspect column types\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [1, 2], \"bar\": [\"A\", \"B\"], \"baz\": [True, False]})\n        df.types\n        # {'foo': int, 'bar': object, 'baz': bool}\n        ```\n        \"\"\"\n        numpy_types = {\n            NumpyType(\"O\"): object,\n            NumpyType(\"int64\"): int,\n            NumpyType(\"float64\"): float,\n            NumpyType(\"bool\"): bool,\n            NumpyType(\"datetime64\"): DateTime,\n        }\n        raw_types = dict(self._data.dtypes)\n        clean_types = {}\n        for column in self.columns:\n            current = raw_types[column]\n            clean = numpy_types.get(current, current)  # type: ignore\n            clean_types[column] = clean\n        return clean_types\n\n    def append(self, other: DataFrame) -> DataFrame:\n        \"\"\"Append rows from another DataFrame\n\n        Example:\n", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_495-545"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 530, "start_line_no": 505, "end_line_no": 555, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        size = self._data.memory_usage(deep=True).sum()\n        power_labels = {40: \"TB\", 30: \"GB\", 20: \"MB\", 10: \"KB\"}\n        for power, label in power_labels.items():\n            if size >= (2**power):\n                approx_size = size // 2**power\n                return f\"{approx_size} {label}\"\n        return f\"{size} B\"\n\n    @property\n    def types(self) -> dict[Column, type]:\n        \"\"\"Inspect column types\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [1, 2], \"bar\": [\"A\", \"B\"], \"baz\": [True, False]})\n        df.types\n        # {'foo': int, 'bar': object, 'baz': bool}\n        ```\n        \"\"\"\n        numpy_types = {\n            NumpyType(\"O\"): object,\n            NumpyType(\"int64\"): int,\n            NumpyType(\"float64\"): float,\n            NumpyType(\"bool\"): bool,\n            NumpyType(\"datetime64\"): DateTime,\n        }\n        raw_types = dict(self._data.dtypes)\n        clean_types = {}\n        for column in self.columns:\n            current = raw_types[column]\n            clean = numpy_types.get(current, current)  # type: ignore\n            clean_types[column] = clean\n        return clean_types\n\n    def append(self, other: DataFrame) -> DataFrame:\n        \"\"\"Append rows from another DataFrame\n\n        Example:\n\n        ```python\n        df1 = rf.DataFrame({\"foo\": [1, 2], \"bar\": [\"A\", \"B\"]})\n        ```\n        |   foo | bar   |\n        |------:|:------|\n        |     1 | A     |\n        |     2 | B     |\n\n        ```python\n        df2 = rf.DataFrame({\"bar\": [\"C\", \"D\"], \"foo\": [3, 4], \"baz\": [\"$\", \"@\"]})", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_505-555"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 540, "start_line_no": 515, "end_line_no": 565, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        \"\"\"Inspect column types\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [1, 2], \"bar\": [\"A\", \"B\"], \"baz\": [True, False]})\n        df.types\n        # {'foo': int, 'bar': object, 'baz': bool}\n        ```\n        \"\"\"\n        numpy_types = {\n            NumpyType(\"O\"): object,\n            NumpyType(\"int64\"): int,\n            NumpyType(\"float64\"): float,\n            NumpyType(\"bool\"): bool,\n            NumpyType(\"datetime64\"): DateTime,\n        }\n        raw_types = dict(self._data.dtypes)\n        clean_types = {}\n        for column in self.columns:\n            current = raw_types[column]\n            clean = numpy_types.get(current, current)  # type: ignore\n            clean_types[column] = clean\n        return clean_types\n\n    def append(self, other: DataFrame) -> DataFrame:\n        \"\"\"Append rows from another DataFrame\n\n        Example:\n\n        ```python\n        df1 = rf.DataFrame({\"foo\": [1, 2], \"bar\": [\"A\", \"B\"]})\n        ```\n        |   foo | bar   |\n        |------:|:------|\n        |     1 | A     |\n        |     2 | B     |\n\n        ```python\n        df2 = rf.DataFrame({\"bar\": [\"C\", \"D\"], \"foo\": [3, 4], \"baz\": [\"$\", \"@\"]})\n        ```\n        | bar   |   foo | baz   |\n        |:------|------:|:------|\n        | C     |     3 | $     |\n        | D     |     4 | @     |\n\n        ```python\n        df1.append(df2)\n        ```\n        |   foo | bar   | baz   |", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_515-565"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 550, "start_line_no": 525, "end_line_no": 575, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        numpy_types = {\n            NumpyType(\"O\"): object,\n            NumpyType(\"int64\"): int,\n            NumpyType(\"float64\"): float,\n            NumpyType(\"bool\"): bool,\n            NumpyType(\"datetime64\"): DateTime,\n        }\n        raw_types = dict(self._data.dtypes)\n        clean_types = {}\n        for column in self.columns:\n            current = raw_types[column]\n            clean = numpy_types.get(current, current)  # type: ignore\n            clean_types[column] = clean\n        return clean_types\n\n    def append(self, other: DataFrame) -> DataFrame:\n        \"\"\"Append rows from another DataFrame\n\n        Example:\n\n        ```python\n        df1 = rf.DataFrame({\"foo\": [1, 2], \"bar\": [\"A\", \"B\"]})\n        ```\n        |   foo | bar   |\n        |------:|:------|\n        |     1 | A     |\n        |     2 | B     |\n\n        ```python\n        df2 = rf.DataFrame({\"bar\": [\"C\", \"D\"], \"foo\": [3, 4], \"baz\": [\"$\", \"@\"]})\n        ```\n        | bar   |   foo | baz   |\n        |:------|------:|:------|\n        | C     |     3 | $     |\n        | D     |     4 | @     |\n\n        ```python\n        df1.append(df2)\n        ```\n        |   foo | bar   | baz   |\n        |------:|:------|:------|\n        |     1 | A     | nan   |\n        |     2 | B     | nan   |\n        |     3 | C     | $     |\n        |     4 | D     | @     |\n        \"\"\"\n        _check_type(other, DataFrame)\n        return _wrap(append(self._data, other._data))\n\n    def combine(", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_525-575"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 560, "start_line_no": 535, "end_line_no": 585, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "            current = raw_types[column]\n            clean = numpy_types.get(current, current)  # type: ignore\n            clean_types[column] = clean\n        return clean_types\n\n    def append(self, other: DataFrame) -> DataFrame:\n        \"\"\"Append rows from another DataFrame\n\n        Example:\n\n        ```python\n        df1 = rf.DataFrame({\"foo\": [1, 2], \"bar\": [\"A\", \"B\"]})\n        ```\n        |   foo | bar   |\n        |------:|:------|\n        |     1 | A     |\n        |     2 | B     |\n\n        ```python\n        df2 = rf.DataFrame({\"bar\": [\"C\", \"D\"], \"foo\": [3, 4], \"baz\": [\"$\", \"@\"]})\n        ```\n        | bar   |   foo | baz   |\n        |:------|------:|:------|\n        | C     |     3 | $     |\n        | D     |     4 | @     |\n\n        ```python\n        df1.append(df2)\n        ```\n        |   foo | bar   | baz   |\n        |------:|:------|:------|\n        |     1 | A     | nan   |\n        |     2 | B     | nan   |\n        |     3 | C     | $     |\n        |     4 | D     | @     |\n        \"\"\"\n        _check_type(other, DataFrame)\n        return _wrap(append(self._data, other._data))\n\n    def combine(\n        self, columns: Columns, into: Column, sep: str, drop: bool = True\n    ) -> DataFrame:\n        \"\"\"Combine multiple columns into a single column (opposite of `split`)\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [1, 2], \"bar\": [\"A\", \"B\"]})\n        ```\n        |   foo | bar   |", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_535-585"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 570, "start_line_no": 545, "end_line_no": 595, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        ```python\n        df1 = rf.DataFrame({\"foo\": [1, 2], \"bar\": [\"A\", \"B\"]})\n        ```\n        |   foo | bar   |\n        |------:|:------|\n        |     1 | A     |\n        |     2 | B     |\n\n        ```python\n        df2 = rf.DataFrame({\"bar\": [\"C\", \"D\"], \"foo\": [3, 4], \"baz\": [\"$\", \"@\"]})\n        ```\n        | bar   |   foo | baz   |\n        |:------|------:|:------|\n        | C     |     3 | $     |\n        | D     |     4 | @     |\n\n        ```python\n        df1.append(df2)\n        ```\n        |   foo | bar   | baz   |\n        |------:|:------|:------|\n        |     1 | A     | nan   |\n        |     2 | B     | nan   |\n        |     3 | C     | $     |\n        |     4 | D     | @     |\n        \"\"\"\n        _check_type(other, DataFrame)\n        return _wrap(append(self._data, other._data))\n\n    def combine(\n        self, columns: Columns, into: Column, sep: str, drop: bool = True\n    ) -> DataFrame:\n        \"\"\"Combine multiple columns into a single column (opposite of `split`)\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [1, 2], \"bar\": [\"A\", \"B\"]})\n        ```\n        |   foo | bar   |\n        |------:|:------|\n        |     1 | A     |\n        |     2 | B     |\n\n        ```python\n        df.combine([\"bar\", \"foo\"], into=\"baz\", sep=\"::\", drop=True)\n        ```\n        | baz   |\n        |:------|\n        | A::1  |", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_545-595"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 580, "start_line_no": 555, "end_line_no": 605, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        ```\n        | bar   |   foo | baz   |\n        |:------|------:|:------|\n        | C     |     3 | $     |\n        | D     |     4 | @     |\n\n        ```python\n        df1.append(df2)\n        ```\n        |   foo | bar   | baz   |\n        |------:|:------|:------|\n        |     1 | A     | nan   |\n        |     2 | B     | nan   |\n        |     3 | C     | $     |\n        |     4 | D     | @     |\n        \"\"\"\n        _check_type(other, DataFrame)\n        return _wrap(append(self._data, other._data))\n\n    def combine(\n        self, columns: Columns, into: Column, sep: str, drop: bool = True\n    ) -> DataFrame:\n        \"\"\"Combine multiple columns into a single column (opposite of `split`)\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [1, 2], \"bar\": [\"A\", \"B\"]})\n        ```\n        |   foo | bar   |\n        |------:|:------|\n        |     1 | A     |\n        |     2 | B     |\n\n        ```python\n        df.combine([\"bar\", \"foo\"], into=\"baz\", sep=\"::\", drop=True)\n        ```\n        | baz   |\n        |:------|\n        | A::1  |\n        | B::2  |\n        \"\"\"\n        return _wrap(combine(self._data, columns, into, sep, drop))\n\n    def cross(\n        self, rhs: DataFrame | None = None, postfix: tuple[str, str] = (\"_lhs\", \"_rhs\")\n    ) -> DataFrame:\n        \"\"\"Cross join columns from another DataFrame\n\n        Examples:", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_555-605"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 590, "start_line_no": 565, "end_line_no": 615, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        |------:|:------|:------|\n        |     1 | A     | nan   |\n        |     2 | B     | nan   |\n        |     3 | C     | $     |\n        |     4 | D     | @     |\n        \"\"\"\n        _check_type(other, DataFrame)\n        return _wrap(append(self._data, other._data))\n\n    def combine(\n        self, columns: Columns, into: Column, sep: str, drop: bool = True\n    ) -> DataFrame:\n        \"\"\"Combine multiple columns into a single column (opposite of `split`)\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [1, 2], \"bar\": [\"A\", \"B\"]})\n        ```\n        |   foo | bar   |\n        |------:|:------|\n        |     1 | A     |\n        |     2 | B     |\n\n        ```python\n        df.combine([\"bar\", \"foo\"], into=\"baz\", sep=\"::\", drop=True)\n        ```\n        | baz   |\n        |:------|\n        | A::1  |\n        | B::2  |\n        \"\"\"\n        return _wrap(combine(self._data, columns, into, sep, drop))\n\n    def cross(\n        self, rhs: DataFrame | None = None, postfix: tuple[str, str] = (\"_lhs\", \"_rhs\")\n    ) -> DataFrame:\n        \"\"\"Cross join columns from another DataFrame\n\n        Examples:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [\"a\", \"b\", \"c\"], \"bar\": [1, 2, 3]})\n        ```\n        | foo   |   bar |\n        |:------|------:|\n        | a     |     1 |\n        | b     |     2 |\n        | c     |     3 |\n", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_565-615"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 600, "start_line_no": 575, "end_line_no": 625, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        self, columns: Columns, into: Column, sep: str, drop: bool = True\n    ) -> DataFrame:\n        \"\"\"Combine multiple columns into a single column (opposite of `split`)\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [1, 2], \"bar\": [\"A\", \"B\"]})\n        ```\n        |   foo | bar   |\n        |------:|:------|\n        |     1 | A     |\n        |     2 | B     |\n\n        ```python\n        df.combine([\"bar\", \"foo\"], into=\"baz\", sep=\"::\", drop=True)\n        ```\n        | baz   |\n        |:------|\n        | A::1  |\n        | B::2  |\n        \"\"\"\n        return _wrap(combine(self._data, columns, into, sep, drop))\n\n    def cross(\n        self, rhs: DataFrame | None = None, postfix: tuple[str, str] = (\"_lhs\", \"_rhs\")\n    ) -> DataFrame:\n        \"\"\"Cross join columns from another DataFrame\n\n        Examples:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [\"a\", \"b\", \"c\"], \"bar\": [1, 2, 3]})\n        ```\n        | foo   |   bar |\n        |:------|------:|\n        | a     |     1 |\n        | b     |     2 |\n        | c     |     3 |\n\n        Self:\n\n        ```python\n        df.cross()\n        ```\n\n        | foo_lhs   |   bar_lhs | foo_rhs   |   bar_rhs |\n        |:----------|----------:|:----------|----------:|\n        | a         |         1 | a         |         1 |\n        | a         |         1 | b         |         2 |", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_575-625"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 610, "start_line_no": 585, "end_line_no": 635, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        |------:|:------|\n        |     1 | A     |\n        |     2 | B     |\n\n        ```python\n        df.combine([\"bar\", \"foo\"], into=\"baz\", sep=\"::\", drop=True)\n        ```\n        | baz   |\n        |:------|\n        | A::1  |\n        | B::2  |\n        \"\"\"\n        return _wrap(combine(self._data, columns, into, sep, drop))\n\n    def cross(\n        self, rhs: DataFrame | None = None, postfix: tuple[str, str] = (\"_lhs\", \"_rhs\")\n    ) -> DataFrame:\n        \"\"\"Cross join columns from another DataFrame\n\n        Examples:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [\"a\", \"b\", \"c\"], \"bar\": [1, 2, 3]})\n        ```\n        | foo   |   bar |\n        |:------|------:|\n        | a     |     1 |\n        | b     |     2 |\n        | c     |     3 |\n\n        Self:\n\n        ```python\n        df.cross()\n        ```\n\n        | foo_lhs   |   bar_lhs | foo_rhs   |   bar_rhs |\n        |:----------|----------:|:----------|----------:|\n        | a         |         1 | a         |         1 |\n        | a         |         1 | b         |         2 |\n        | a         |         1 | c         |         3 |\n        | b         |         2 | a         |         1 |\n        | b         |         2 | b         |         2 |\n        | b         |         2 | c         |         3 |\n        | c         |         3 | a         |         1 |\n        | c         |         3 | b         |         2 |\n        | c         |         3 | c         |         3 |\n\n        Two DataFrames:\n", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_585-635"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 620, "start_line_no": 595, "end_line_no": 645, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        | B::2  |\n        \"\"\"\n        return _wrap(combine(self._data, columns, into, sep, drop))\n\n    def cross(\n        self, rhs: DataFrame | None = None, postfix: tuple[str, str] = (\"_lhs\", \"_rhs\")\n    ) -> DataFrame:\n        \"\"\"Cross join columns from another DataFrame\n\n        Examples:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [\"a\", \"b\", \"c\"], \"bar\": [1, 2, 3]})\n        ```\n        | foo   |   bar |\n        |:------|------:|\n        | a     |     1 |\n        | b     |     2 |\n        | c     |     3 |\n\n        Self:\n\n        ```python\n        df.cross()\n        ```\n\n        | foo_lhs   |   bar_lhs | foo_rhs   |   bar_rhs |\n        |:----------|----------:|:----------|----------:|\n        | a         |         1 | a         |         1 |\n        | a         |         1 | b         |         2 |\n        | a         |         1 | c         |         3 |\n        | b         |         2 | a         |         1 |\n        | b         |         2 | b         |         2 |\n        | b         |         2 | c         |         3 |\n        | c         |         3 | a         |         1 |\n        | c         |         3 | b         |         2 |\n        | c         |         3 | c         |         3 |\n\n        Two DataFrames:\n\n        ```python\n        dfa = rf.DataFrame({\"foo\": [1, 2, 3]})\n        dfb = rf.DataFrame({\"bar\": [1, 2, 3]})\n        dfa.cross(dfb, postfix=(\"_a\", \"_b\"))\n        ```\n\n        |   foo |   bar |\n        |------:|------:|\n        |     1 |     1 |\n        |     1 |     2 |", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_595-645"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 630, "start_line_no": 605, "end_line_no": 655, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "\n        ```python\n        df = rf.DataFrame({\"foo\": [\"a\", \"b\", \"c\"], \"bar\": [1, 2, 3]})\n        ```\n        | foo   |   bar |\n        |:------|------:|\n        | a     |     1 |\n        | b     |     2 |\n        | c     |     3 |\n\n        Self:\n\n        ```python\n        df.cross()\n        ```\n\n        | foo_lhs   |   bar_lhs | foo_rhs   |   bar_rhs |\n        |:----------|----------:|:----------|----------:|\n        | a         |         1 | a         |         1 |\n        | a         |         1 | b         |         2 |\n        | a         |         1 | c         |         3 |\n        | b         |         2 | a         |         1 |\n        | b         |         2 | b         |         2 |\n        | b         |         2 | c         |         3 |\n        | c         |         3 | a         |         1 |\n        | c         |         3 | b         |         2 |\n        | c         |         3 | c         |         3 |\n\n        Two DataFrames:\n\n        ```python\n        dfa = rf.DataFrame({\"foo\": [1, 2, 3]})\n        dfb = rf.DataFrame({\"bar\": [1, 2, 3]})\n        dfa.cross(dfb, postfix=(\"_a\", \"_b\"))\n        ```\n\n        |   foo |   bar |\n        |------:|------:|\n        |     1 |     1 |\n        |     1 |     2 |\n        |     1 |     3 |\n        |     2 |     1 |\n        |     2 |     2 |\n        |     2 |     3 |\n        |     3 |     1 |\n        |     3 |     2 |\n        |     3 |     3 |\n        \"\"\"\n        rhs = self if (rhs == None) else rhs\n        _check_type(rhs, DataFrame)", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_605-655"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 640, "start_line_no": 615, "end_line_no": 665, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        Self:\n\n        ```python\n        df.cross()\n        ```\n\n        | foo_lhs   |   bar_lhs | foo_rhs   |   bar_rhs |\n        |:----------|----------:|:----------|----------:|\n        | a         |         1 | a         |         1 |\n        | a         |         1 | b         |         2 |\n        | a         |         1 | c         |         3 |\n        | b         |         2 | a         |         1 |\n        | b         |         2 | b         |         2 |\n        | b         |         2 | c         |         3 |\n        | c         |         3 | a         |         1 |\n        | c         |         3 | b         |         2 |\n        | c         |         3 | c         |         3 |\n\n        Two DataFrames:\n\n        ```python\n        dfa = rf.DataFrame({\"foo\": [1, 2, 3]})\n        dfb = rf.DataFrame({\"bar\": [1, 2, 3]})\n        dfa.cross(dfb, postfix=(\"_a\", \"_b\"))\n        ```\n\n        |   foo |   bar |\n        |------:|------:|\n        |     1 |     1 |\n        |     1 |     2 |\n        |     1 |     3 |\n        |     2 |     1 |\n        |     2 |     2 |\n        |     2 |     3 |\n        |     3 |     1 |\n        |     3 |     2 |\n        |     3 |     3 |\n        \"\"\"\n        rhs = self if (rhs == None) else rhs\n        _check_type(rhs, DataFrame)\n        return _wrap(cross(self._data, rhs._data, postfix))  # type: ignore\n\n    def dedupe(self, columns: LazyColumns | None = None) -> DataFrame:\n        \"\"\"Remove duplicate rows\n\n        Examples:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [1, 1, 2, 2], \"bar\": [\"A\", \"A\", \"B\", \"A\"]})\n        ```", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_615-665"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 650, "start_line_no": 625, "end_line_no": 675, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        | a         |         1 | c         |         3 |\n        | b         |         2 | a         |         1 |\n        | b         |         2 | b         |         2 |\n        | b         |         2 | c         |         3 |\n        | c         |         3 | a         |         1 |\n        | c         |         3 | b         |         2 |\n        | c         |         3 | c         |         3 |\n\n        Two DataFrames:\n\n        ```python\n        dfa = rf.DataFrame({\"foo\": [1, 2, 3]})\n        dfb = rf.DataFrame({\"bar\": [1, 2, 3]})\n        dfa.cross(dfb, postfix=(\"_a\", \"_b\"))\n        ```\n\n        |   foo |   bar |\n        |------:|------:|\n        |     1 |     1 |\n        |     1 |     2 |\n        |     1 |     3 |\n        |     2 |     1 |\n        |     2 |     2 |\n        |     2 |     3 |\n        |     3 |     1 |\n        |     3 |     2 |\n        |     3 |     3 |\n        \"\"\"\n        rhs = self if (rhs == None) else rhs\n        _check_type(rhs, DataFrame)\n        return _wrap(cross(self._data, rhs._data, postfix))  # type: ignore\n\n    def dedupe(self, columns: LazyColumns | None = None) -> DataFrame:\n        \"\"\"Remove duplicate rows\n\n        Examples:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [1, 1, 2, 2], \"bar\": [\"A\", \"A\", \"B\", \"A\"]})\n        ```\n        |   foo | bar   |\n        |------:|:------|\n        |     1 | A     |\n        |     1 | A     |\n        |     2 | B     |\n        |     2 | A     |\n\n        All columns:\n\n        ```python", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_625-675"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 660, "start_line_no": 635, "end_line_no": 685, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        ```python\n        dfa = rf.DataFrame({\"foo\": [1, 2, 3]})\n        dfb = rf.DataFrame({\"bar\": [1, 2, 3]})\n        dfa.cross(dfb, postfix=(\"_a\", \"_b\"))\n        ```\n\n        |   foo |   bar |\n        |------:|------:|\n        |     1 |     1 |\n        |     1 |     2 |\n        |     1 |     3 |\n        |     2 |     1 |\n        |     2 |     2 |\n        |     2 |     3 |\n        |     3 |     1 |\n        |     3 |     2 |\n        |     3 |     3 |\n        \"\"\"\n        rhs = self if (rhs == None) else rhs\n        _check_type(rhs, DataFrame)\n        return _wrap(cross(self._data, rhs._data, postfix))  # type: ignore\n\n    def dedupe(self, columns: LazyColumns | None = None) -> DataFrame:\n        \"\"\"Remove duplicate rows\n\n        Examples:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [1, 1, 2, 2], \"bar\": [\"A\", \"A\", \"B\", \"A\"]})\n        ```\n        |   foo | bar   |\n        |------:|:------|\n        |     1 | A     |\n        |     1 | A     |\n        |     2 | B     |\n        |     2 | A     |\n\n        All columns:\n\n        ```python\n        df.dedupe()\n        ```\n        |   foo | bar   |\n        |------:|:------|\n        |     1 | A     |\n        |     2 | B     |\n        |     2 | A     |\n\n        Single column:\n", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_635-685"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 670, "start_line_no": 645, "end_line_no": 695, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        |     1 |     3 |\n        |     2 |     1 |\n        |     2 |     2 |\n        |     2 |     3 |\n        |     3 |     1 |\n        |     3 |     2 |\n        |     3 |     3 |\n        \"\"\"\n        rhs = self if (rhs == None) else rhs\n        _check_type(rhs, DataFrame)\n        return _wrap(cross(self._data, rhs._data, postfix))  # type: ignore\n\n    def dedupe(self, columns: LazyColumns | None = None) -> DataFrame:\n        \"\"\"Remove duplicate rows\n\n        Examples:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [1, 1, 2, 2], \"bar\": [\"A\", \"A\", \"B\", \"A\"]})\n        ```\n        |   foo | bar   |\n        |------:|:------|\n        |     1 | A     |\n        |     1 | A     |\n        |     2 | B     |\n        |     2 | A     |\n\n        All columns:\n\n        ```python\n        df.dedupe()\n        ```\n        |   foo | bar   |\n        |------:|:------|\n        |     1 | A     |\n        |     2 | B     |\n        |     2 | A     |\n\n        Single column:\n\n        ```python\n        df.dedupe(\"foo\")\n        ```\n        |   foo | bar   |\n        |------:|:------|\n        |     1 | A     |\n        |     2 | B     |\n\n        Multiple columns:\n", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_645-695"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 680, "start_line_no": 655, "end_line_no": 705, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        return _wrap(cross(self._data, rhs._data, postfix))  # type: ignore\n\n    def dedupe(self, columns: LazyColumns | None = None) -> DataFrame:\n        \"\"\"Remove duplicate rows\n\n        Examples:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [1, 1, 2, 2], \"bar\": [\"A\", \"A\", \"B\", \"A\"]})\n        ```\n        |   foo | bar   |\n        |------:|:------|\n        |     1 | A     |\n        |     1 | A     |\n        |     2 | B     |\n        |     2 | A     |\n\n        All columns:\n\n        ```python\n        df.dedupe()\n        ```\n        |   foo | bar   |\n        |------:|:------|\n        |     1 | A     |\n        |     2 | B     |\n        |     2 | A     |\n\n        Single column:\n\n        ```python\n        df.dedupe(\"foo\")\n        ```\n        |   foo | bar   |\n        |------:|:------|\n        |     1 | A     |\n        |     2 | B     |\n\n        Multiple columns:\n\n        ```python\n        df.dedupe([\"foo\", \"bar\"])\n        ```\n        |   foo | bar   |\n        |------:|:------|\n        |     1 | A     |\n        |     2 | B     |\n        |     2 | A     |\n        \"\"\"\n        return _wrap(dedupe(self._data, columns))", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_655-705"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 690, "start_line_no": 665, "end_line_no": 715, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        |   foo | bar   |\n        |------:|:------|\n        |     1 | A     |\n        |     1 | A     |\n        |     2 | B     |\n        |     2 | A     |\n\n        All columns:\n\n        ```python\n        df.dedupe()\n        ```\n        |   foo | bar   |\n        |------:|:------|\n        |     1 | A     |\n        |     2 | B     |\n        |     2 | A     |\n\n        Single column:\n\n        ```python\n        df.dedupe(\"foo\")\n        ```\n        |   foo | bar   |\n        |------:|:------|\n        |     1 | A     |\n        |     2 | B     |\n\n        Multiple columns:\n\n        ```python\n        df.dedupe([\"foo\", \"bar\"])\n        ```\n        |   foo | bar   |\n        |------:|:------|\n        |     1 | A     |\n        |     2 | B     |\n        |     2 | A     |\n        \"\"\"\n        return _wrap(dedupe(self._data, columns))\n\n    def denix(self, columns: LazyColumns | None = None) -> DataFrame:\n        \"\"\"Remove rows with *NaN/None* values\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [1, None, 3, None, 5, 6], \"bar\": [1, None, 3, 4, None, None]})\n        ```\n        |   foo |   bar |", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_665-715"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 700, "start_line_no": 675, "end_line_no": 725, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        df.dedupe()\n        ```\n        |   foo | bar   |\n        |------:|:------|\n        |     1 | A     |\n        |     2 | B     |\n        |     2 | A     |\n\n        Single column:\n\n        ```python\n        df.dedupe(\"foo\")\n        ```\n        |   foo | bar   |\n        |------:|:------|\n        |     1 | A     |\n        |     2 | B     |\n\n        Multiple columns:\n\n        ```python\n        df.dedupe([\"foo\", \"bar\"])\n        ```\n        |   foo | bar   |\n        |------:|:------|\n        |     1 | A     |\n        |     2 | B     |\n        |     2 | A     |\n        \"\"\"\n        return _wrap(dedupe(self._data, columns))\n\n    def denix(self, columns: LazyColumns | None = None) -> DataFrame:\n        \"\"\"Remove rows with *NaN/None* values\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [1, None, 3, None, 5, 6], \"bar\": [1, None, 3, 4, None, None]})\n        ```\n        |   foo |   bar |\n        |------:|------:|\n        |     1 |     1 |\n        |   nan |   nan |\n        |     3 |     3 |\n        |   nan |     4 |\n        |     5 |   nan |\n        |     6 |   nan |\n\n        All columns:\n", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_675-725"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 710, "start_line_no": 685, "end_line_no": 735, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        ```python\n        df.dedupe(\"foo\")\n        ```\n        |   foo | bar   |\n        |------:|:------|\n        |     1 | A     |\n        |     2 | B     |\n\n        Multiple columns:\n\n        ```python\n        df.dedupe([\"foo\", \"bar\"])\n        ```\n        |   foo | bar   |\n        |------:|:------|\n        |     1 | A     |\n        |     2 | B     |\n        |     2 | A     |\n        \"\"\"\n        return _wrap(dedupe(self._data, columns))\n\n    def denix(self, columns: LazyColumns | None = None) -> DataFrame:\n        \"\"\"Remove rows with *NaN/None* values\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [1, None, 3, None, 5, 6], \"bar\": [1, None, 3, 4, None, None]})\n        ```\n        |   foo |   bar |\n        |------:|------:|\n        |     1 |     1 |\n        |   nan |   nan |\n        |     3 |     3 |\n        |   nan |     4 |\n        |     5 |   nan |\n        |     6 |   nan |\n\n        All columns:\n\n        ```python\n        df.denix()\n        ```\n        |   foo |   bar |\n        |------:|------:|\n        |     1 |     1 |\n        |     3 |     3 |\n\n        Single column:\n", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_685-735"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 720, "start_line_no": 695, "end_line_no": 745, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        ```python\n        df.dedupe([\"foo\", \"bar\"])\n        ```\n        |   foo | bar   |\n        |------:|:------|\n        |     1 | A     |\n        |     2 | B     |\n        |     2 | A     |\n        \"\"\"\n        return _wrap(dedupe(self._data, columns))\n\n    def denix(self, columns: LazyColumns | None = None) -> DataFrame:\n        \"\"\"Remove rows with *NaN/None* values\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [1, None, 3, None, 5, 6], \"bar\": [1, None, 3, 4, None, None]})\n        ```\n        |   foo |   bar |\n        |------:|------:|\n        |     1 |     1 |\n        |   nan |   nan |\n        |     3 |     3 |\n        |   nan |     4 |\n        |     5 |   nan |\n        |     6 |   nan |\n\n        All columns:\n\n        ```python\n        df.denix()\n        ```\n        |   foo |   bar |\n        |------:|------:|\n        |     1 |     1 |\n        |     3 |     3 |\n\n        Single column:\n\n        ```python\n        df.denix(\"bar\")\n        ```\n        |   foo |   bar |\n        |------:|------:|\n        |     1 |     1 |\n        |     3 |     3 |\n        |   nan |     4 |\n\n        Multiple columns:", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_695-745"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 730, "start_line_no": 705, "end_line_no": 755, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "\n    def denix(self, columns: LazyColumns | None = None) -> DataFrame:\n        \"\"\"Remove rows with *NaN/None* values\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [1, None, 3, None, 5, 6], \"bar\": [1, None, 3, 4, None, None]})\n        ```\n        |   foo |   bar |\n        |------:|------:|\n        |     1 |     1 |\n        |   nan |   nan |\n        |     3 |     3 |\n        |   nan |     4 |\n        |     5 |   nan |\n        |     6 |   nan |\n\n        All columns:\n\n        ```python\n        df.denix()\n        ```\n        |   foo |   bar |\n        |------:|------:|\n        |     1 |     1 |\n        |     3 |     3 |\n\n        Single column:\n\n        ```python\n        df.denix(\"bar\")\n        ```\n        |   foo |   bar |\n        |------:|------:|\n        |     1 |     1 |\n        |     3 |     3 |\n        |   nan |     4 |\n\n        Multiple columns:\n\n        ```python\n        df.denix([\"foo\", \"bar\"])\n        ```\n        |   foo |   bar |\n        |------:|------:|\n        |     1 |     1 |\n        |     3 |     3 |\n        \"\"\"\n        return _wrap(denix(self._data, columns))", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_705-755"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 740, "start_line_no": 715, "end_line_no": 765, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        |------:|------:|\n        |     1 |     1 |\n        |   nan |   nan |\n        |     3 |     3 |\n        |   nan |     4 |\n        |     5 |   nan |\n        |     6 |   nan |\n\n        All columns:\n\n        ```python\n        df.denix()\n        ```\n        |   foo |   bar |\n        |------:|------:|\n        |     1 |     1 |\n        |     3 |     3 |\n\n        Single column:\n\n        ```python\n        df.denix(\"bar\")\n        ```\n        |   foo |   bar |\n        |------:|------:|\n        |     1 |     1 |\n        |     3 |     3 |\n        |   nan |     4 |\n\n        Multiple columns:\n\n        ```python\n        df.denix([\"foo\", \"bar\"])\n        ```\n        |   foo |   bar |\n        |------:|------:|\n        |     1 |     1 |\n        |     3 |     3 |\n        \"\"\"\n        return _wrap(denix(self._data, columns))\n\n    def drop(self, columns: LazyColumns) -> DataFrame:\n        \"\"\"Drop entire columns\n\n        Examples:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [1, 2], \"bar\": [3, 4], \"baz\": [5, 6]})\n        ```\n        |   foo |   bar |   baz |", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_715-765"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 750, "start_line_no": 725, "end_line_no": 775, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        ```python\n        df.denix()\n        ```\n        |   foo |   bar |\n        |------:|------:|\n        |     1 |     1 |\n        |     3 |     3 |\n\n        Single column:\n\n        ```python\n        df.denix(\"bar\")\n        ```\n        |   foo |   bar |\n        |------:|------:|\n        |     1 |     1 |\n        |     3 |     3 |\n        |   nan |     4 |\n\n        Multiple columns:\n\n        ```python\n        df.denix([\"foo\", \"bar\"])\n        ```\n        |   foo |   bar |\n        |------:|------:|\n        |     1 |     1 |\n        |     3 |     3 |\n        \"\"\"\n        return _wrap(denix(self._data, columns))\n\n    def drop(self, columns: LazyColumns) -> DataFrame:\n        \"\"\"Drop entire columns\n\n        Examples:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [1, 2], \"bar\": [3, 4], \"baz\": [5, 6]})\n        ```\n        |   foo |   bar |   baz |\n        |------:|------:|------:|\n        |     1 |     3 |     5 |\n        |     2 |     4 |     6 |\n\n        ```python\n        df.drop(\"baz\")\n        ```\n        |   foo |   bar |\n        |------:|------:|\n        |     1 |     3 |", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_725-775"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 760, "start_line_no": 735, "end_line_no": 785, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        ```python\n        df.denix(\"bar\")\n        ```\n        |   foo |   bar |\n        |------:|------:|\n        |     1 |     1 |\n        |     3 |     3 |\n        |   nan |     4 |\n\n        Multiple columns:\n\n        ```python\n        df.denix([\"foo\", \"bar\"])\n        ```\n        |   foo |   bar |\n        |------:|------:|\n        |     1 |     1 |\n        |     3 |     3 |\n        \"\"\"\n        return _wrap(denix(self._data, columns))\n\n    def drop(self, columns: LazyColumns) -> DataFrame:\n        \"\"\"Drop entire columns\n\n        Examples:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [1, 2], \"bar\": [3, 4], \"baz\": [5, 6]})\n        ```\n        |   foo |   bar |   baz |\n        |------:|------:|------:|\n        |     1 |     3 |     5 |\n        |     2 |     4 |     6 |\n\n        ```python\n        df.drop(\"baz\")\n        ```\n        |   foo |   bar |\n        |------:|------:|\n        |     1 |     3 |\n        |     2 |     4 |\n\n        ```python\n        df.drop([\"foo\", \"baz\"])\n        ```\n        |   bar |\n        |------:|\n        |     3 |\n        |     4 |\n        \"\"\"", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_735-785"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 770, "start_line_no": 745, "end_line_no": 795, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "\n        ```python\n        df.denix([\"foo\", \"bar\"])\n        ```\n        |   foo |   bar |\n        |------:|------:|\n        |     1 |     1 |\n        |     3 |     3 |\n        \"\"\"\n        return _wrap(denix(self._data, columns))\n\n    def drop(self, columns: LazyColumns) -> DataFrame:\n        \"\"\"Drop entire columns\n\n        Examples:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [1, 2], \"bar\": [3, 4], \"baz\": [5, 6]})\n        ```\n        |   foo |   bar |   baz |\n        |------:|------:|------:|\n        |     1 |     3 |     5 |\n        |     2 |     4 |     6 |\n\n        ```python\n        df.drop(\"baz\")\n        ```\n        |   foo |   bar |\n        |------:|------:|\n        |     1 |     3 |\n        |     2 |     4 |\n\n        ```python\n        df.drop([\"foo\", \"baz\"])\n        ```\n        |   bar |\n        |------:|\n        |     3 |\n        |     4 |\n        \"\"\"\n        return _wrap(drop(self._data, columns))\n\n    def fill(\n        self,\n        columns: LazyColumns | None = None,\n        direction: Direction | None = None,\n        constant: Value | None = None,\n    ) -> DataFrame:\n        \"\"\"Fill missing values \"down\", \"up\", or with a constant\n", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_745-795"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 780, "start_line_no": 755, "end_line_no": 805, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "\n    def drop(self, columns: LazyColumns) -> DataFrame:\n        \"\"\"Drop entire columns\n\n        Examples:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [1, 2], \"bar\": [3, 4], \"baz\": [5, 6]})\n        ```\n        |   foo |   bar |   baz |\n        |------:|------:|------:|\n        |     1 |     3 |     5 |\n        |     2 |     4 |     6 |\n\n        ```python\n        df.drop(\"baz\")\n        ```\n        |   foo |   bar |\n        |------:|------:|\n        |     1 |     3 |\n        |     2 |     4 |\n\n        ```python\n        df.drop([\"foo\", \"baz\"])\n        ```\n        |   bar |\n        |------:|\n        |     3 |\n        |     4 |\n        \"\"\"\n        return _wrap(drop(self._data, columns))\n\n    def fill(\n        self,\n        columns: LazyColumns | None = None,\n        direction: Direction | None = None,\n        constant: Value | None = None,\n    ) -> DataFrame:\n        \"\"\"Fill missing values \"down\", \"up\", or with a constant\n\n        Examples:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [1, None, None, 2, None], \"bar\": [None, \"A\", None, \"B\", None]})\n        ```\n        |   foo | bar   |\n        |------:|:------|\n        |     1 |       |\n        |   nan | A     |\n        |   nan |       |", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_755-805"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 790, "start_line_no": 765, "end_line_no": 815, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        |------:|------:|------:|\n        |     1 |     3 |     5 |\n        |     2 |     4 |     6 |\n\n        ```python\n        df.drop(\"baz\")\n        ```\n        |   foo |   bar |\n        |------:|------:|\n        |     1 |     3 |\n        |     2 |     4 |\n\n        ```python\n        df.drop([\"foo\", \"baz\"])\n        ```\n        |   bar |\n        |------:|\n        |     3 |\n        |     4 |\n        \"\"\"\n        return _wrap(drop(self._data, columns))\n\n    def fill(\n        self,\n        columns: LazyColumns | None = None,\n        direction: Direction | None = None,\n        constant: Value | None = None,\n    ) -> DataFrame:\n        \"\"\"Fill missing values \"down\", \"up\", or with a constant\n\n        Examples:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [1, None, None, 2, None], \"bar\": [None, \"A\", None, \"B\", None]})\n        ```\n        |   foo | bar   |\n        |------:|:------|\n        |     1 |       |\n        |   nan | A     |\n        |   nan |       |\n        |     2 | B     |\n        |   nan |       |\n\n        Constant (all columns):\n\n        ```python\n        df.fill(constant=0)\n        ```\n        |   foo | bar   |\n        |------:|:------|", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_765-815"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 800, "start_line_no": 775, "end_line_no": 825, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        |     2 |     4 |\n\n        ```python\n        df.drop([\"foo\", \"baz\"])\n        ```\n        |   bar |\n        |------:|\n        |     3 |\n        |     4 |\n        \"\"\"\n        return _wrap(drop(self._data, columns))\n\n    def fill(\n        self,\n        columns: LazyColumns | None = None,\n        direction: Direction | None = None,\n        constant: Value | None = None,\n    ) -> DataFrame:\n        \"\"\"Fill missing values \"down\", \"up\", or with a constant\n\n        Examples:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [1, None, None, 2, None], \"bar\": [None, \"A\", None, \"B\", None]})\n        ```\n        |   foo | bar   |\n        |------:|:------|\n        |     1 |       |\n        |   nan | A     |\n        |   nan |       |\n        |     2 | B     |\n        |   nan |       |\n\n        Constant (all columns):\n\n        ```python\n        df.fill(constant=0)\n        ```\n        |   foo | bar   |\n        |------:|:------|\n        |     1 | 0     |\n        |     0 | A     |\n        |     0 | 0     |\n        |     2 | B     |\n        |     0 | 0     |\n\n        Down (all columns):\n\n        ```python\n        df.fill(direction=\"down\")", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_775-825"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 810, "start_line_no": 785, "end_line_no": 835, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        return _wrap(drop(self._data, columns))\n\n    def fill(\n        self,\n        columns: LazyColumns | None = None,\n        direction: Direction | None = None,\n        constant: Value | None = None,\n    ) -> DataFrame:\n        \"\"\"Fill missing values \"down\", \"up\", or with a constant\n\n        Examples:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [1, None, None, 2, None], \"bar\": [None, \"A\", None, \"B\", None]})\n        ```\n        |   foo | bar   |\n        |------:|:------|\n        |     1 |       |\n        |   nan | A     |\n        |   nan |       |\n        |     2 | B     |\n        |   nan |       |\n\n        Constant (all columns):\n\n        ```python\n        df.fill(constant=0)\n        ```\n        |   foo | bar   |\n        |------:|:------|\n        |     1 | 0     |\n        |     0 | A     |\n        |     0 | 0     |\n        |     2 | B     |\n        |     0 | 0     |\n\n        Down (all columns):\n\n        ```python\n        df.fill(direction=\"down\")\n        ```\n        |   foo | bar   |\n        |------:|:------|\n        |     1 |       |\n        |     1 | A     |\n        |     1 | A     |\n        |     2 | B     |\n        |     2 | B     |\n\n        Down (single column):", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_785-835"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 820, "start_line_no": 795, "end_line_no": 845, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        Examples:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [1, None, None, 2, None], \"bar\": [None, \"A\", None, \"B\", None]})\n        ```\n        |   foo | bar   |\n        |------:|:------|\n        |     1 |       |\n        |   nan | A     |\n        |   nan |       |\n        |     2 | B     |\n        |   nan |       |\n\n        Constant (all columns):\n\n        ```python\n        df.fill(constant=0)\n        ```\n        |   foo | bar   |\n        |------:|:------|\n        |     1 | 0     |\n        |     0 | A     |\n        |     0 | 0     |\n        |     2 | B     |\n        |     0 | 0     |\n\n        Down (all columns):\n\n        ```python\n        df.fill(direction=\"down\")\n        ```\n        |   foo | bar   |\n        |------:|:------|\n        |     1 |       |\n        |     1 | A     |\n        |     1 | A     |\n        |     2 | B     |\n        |     2 | B     |\n\n        Down (single column):\n\n        ```python\n        df.fill(\"foo\", direction=\"down\")\n        ```\n        |   foo | bar   |\n        |------:|:------|\n        |     1 |       |\n        |     1 | A     |\n        |     1 |       |\n        |     2 | B     |", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_795-845"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 830, "start_line_no": 805, "end_line_no": 855, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        |     2 | B     |\n        |   nan |       |\n\n        Constant (all columns):\n\n        ```python\n        df.fill(constant=0)\n        ```\n        |   foo | bar   |\n        |------:|:------|\n        |     1 | 0     |\n        |     0 | A     |\n        |     0 | 0     |\n        |     2 | B     |\n        |     0 | 0     |\n\n        Down (all columns):\n\n        ```python\n        df.fill(direction=\"down\")\n        ```\n        |   foo | bar   |\n        |------:|:------|\n        |     1 |       |\n        |     1 | A     |\n        |     1 | A     |\n        |     2 | B     |\n        |     2 | B     |\n\n        Down (single column):\n\n        ```python\n        df.fill(\"foo\", direction=\"down\")\n        ```\n        |   foo | bar   |\n        |------:|:------|\n        |     1 |       |\n        |     1 | A     |\n        |     1 |       |\n        |     2 | B     |\n        |     2 |       |\n\n        Up (single/mutiple columns):\n\n        ```python\n        df.fill([\"foo\"], direction=\"up\")\n        ```\n        |   foo | bar   |\n        |------:|:------|\n        |     1 |       |", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_805-855"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 840, "start_line_no": 815, "end_line_no": 865, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        |     1 | 0     |\n        |     0 | A     |\n        |     0 | 0     |\n        |     2 | B     |\n        |     0 | 0     |\n\n        Down (all columns):\n\n        ```python\n        df.fill(direction=\"down\")\n        ```\n        |   foo | bar   |\n        |------:|:------|\n        |     1 |       |\n        |     1 | A     |\n        |     1 | A     |\n        |     2 | B     |\n        |     2 | B     |\n\n        Down (single column):\n\n        ```python\n        df.fill(\"foo\", direction=\"down\")\n        ```\n        |   foo | bar   |\n        |------:|:------|\n        |     1 |       |\n        |     1 | A     |\n        |     1 |       |\n        |     2 | B     |\n        |     2 |       |\n\n        Up (single/mutiple columns):\n\n        ```python\n        df.fill([\"foo\"], direction=\"up\")\n        ```\n        |   foo | bar   |\n        |------:|:------|\n        |     1 |       |\n        |     2 | A     |\n        |     2 |       |\n        |     2 | B     |\n        |   nan |       |\n        \"\"\"\n        return _wrap(fill(self._data, columns, direction, constant))\n\n    def filter(self, func: Func) -> DataFrame:\n        \"\"\"Keep rows matching specific conditions\n", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_815-865"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 850, "start_line_no": 825, "end_line_no": 875, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        ```\n        |   foo | bar   |\n        |------:|:------|\n        |     1 |       |\n        |     1 | A     |\n        |     1 | A     |\n        |     2 | B     |\n        |     2 | B     |\n\n        Down (single column):\n\n        ```python\n        df.fill(\"foo\", direction=\"down\")\n        ```\n        |   foo | bar   |\n        |------:|:------|\n        |     1 |       |\n        |     1 | A     |\n        |     1 |       |\n        |     2 | B     |\n        |     2 |       |\n\n        Up (single/mutiple columns):\n\n        ```python\n        df.fill([\"foo\"], direction=\"up\")\n        ```\n        |   foo | bar   |\n        |------:|:------|\n        |     1 |       |\n        |     2 | A     |\n        |     2 |       |\n        |     2 | B     |\n        |   nan |       |\n        \"\"\"\n        return _wrap(fill(self._data, columns, direction, constant))\n\n    def filter(self, func: Func) -> DataFrame:\n        \"\"\"Keep rows matching specific conditions\n\n        Compatible operators: `|`, `&`, `< <= == != >= >`, `isin`\n\n        Examples:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [\"A\", \"A\", \"A\", \"B\"], \"bar\": [1, 2, 3, 4]})\n        ```\n        | foo   |   bar |\n        |:------|------:|\n        | A     |     1 |", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_825-875"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 860, "start_line_no": 835, "end_line_no": 885, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "\n        ```python\n        df.fill(\"foo\", direction=\"down\")\n        ```\n        |   foo | bar   |\n        |------:|:------|\n        |     1 |       |\n        |     1 | A     |\n        |     1 |       |\n        |     2 | B     |\n        |     2 |       |\n\n        Up (single/mutiple columns):\n\n        ```python\n        df.fill([\"foo\"], direction=\"up\")\n        ```\n        |   foo | bar   |\n        |------:|:------|\n        |     1 |       |\n        |     2 | A     |\n        |     2 |       |\n        |     2 | B     |\n        |   nan |       |\n        \"\"\"\n        return _wrap(fill(self._data, columns, direction, constant))\n\n    def filter(self, func: Func) -> DataFrame:\n        \"\"\"Keep rows matching specific conditions\n\n        Compatible operators: `|`, `&`, `< <= == != >= >`, `isin`\n\n        Examples:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [\"A\", \"A\", \"A\", \"B\"], \"bar\": [1, 2, 3, 4]})\n        ```\n        | foo   |   bar |\n        |:------|------:|\n        | A     |     1 |\n        | A     |     2 |\n        | A     |     3 |\n        | B     |     4 |\n\n        Single condition:\n\n        ```python\n        df.filter(lambda row: row[\"foo\"].isin([\"A\"]))\n        ```\n        | foo   |   bar |", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_835-885"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 870, "start_line_no": 845, "end_line_no": 895, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        |     2 |       |\n\n        Up (single/mutiple columns):\n\n        ```python\n        df.fill([\"foo\"], direction=\"up\")\n        ```\n        |   foo | bar   |\n        |------:|:------|\n        |     1 |       |\n        |     2 | A     |\n        |     2 |       |\n        |     2 | B     |\n        |   nan |       |\n        \"\"\"\n        return _wrap(fill(self._data, columns, direction, constant))\n\n    def filter(self, func: Func) -> DataFrame:\n        \"\"\"Keep rows matching specific conditions\n\n        Compatible operators: `|`, `&`, `< <= == != >= >`, `isin`\n\n        Examples:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [\"A\", \"A\", \"A\", \"B\"], \"bar\": [1, 2, 3, 4]})\n        ```\n        | foo   |   bar |\n        |:------|------:|\n        | A     |     1 |\n        | A     |     2 |\n        | A     |     3 |\n        | B     |     4 |\n\n        Single condition:\n\n        ```python\n        df.filter(lambda row: row[\"foo\"].isin([\"A\"]))\n        ```\n        | foo   |   bar |\n        |:------|------:|\n        | A     |     1 |\n        | A     |     2 |\n        | A     |     3 |\n\n        And (multiple conditions):\n\n        ```python\n        df.filter(lambda row: (row[\"foo\"] == \"A\") & (row[\"bar\"] <= 2))\n        ```", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_845-895"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 880, "start_line_no": 855, "end_line_no": 905, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        |     2 | A     |\n        |     2 |       |\n        |     2 | B     |\n        |   nan |       |\n        \"\"\"\n        return _wrap(fill(self._data, columns, direction, constant))\n\n    def filter(self, func: Func) -> DataFrame:\n        \"\"\"Keep rows matching specific conditions\n\n        Compatible operators: `|`, `&`, `< <= == != >= >`, `isin`\n\n        Examples:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [\"A\", \"A\", \"A\", \"B\"], \"bar\": [1, 2, 3, 4]})\n        ```\n        | foo   |   bar |\n        |:------|------:|\n        | A     |     1 |\n        | A     |     2 |\n        | A     |     3 |\n        | B     |     4 |\n\n        Single condition:\n\n        ```python\n        df.filter(lambda row: row[\"foo\"].isin([\"A\"]))\n        ```\n        | foo   |   bar |\n        |:------|------:|\n        | A     |     1 |\n        | A     |     2 |\n        | A     |     3 |\n\n        And (multiple conditions):\n\n        ```python\n        df.filter(lambda row: (row[\"foo\"] == \"A\") & (row[\"bar\"] <= 2))\n        ```\n        | foo   |   bar |\n        |:------|------:|\n        | A     |     1 |\n        | A     |     2 |\n\n        Or (multiple conditions):\n\n        ```python\n        df.filter(lambda row: (row[\"foo\"] == \"B\") | (row[\"bar\"] == 1))\n        ```", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_855-905"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 890, "start_line_no": 865, "end_line_no": 915, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        Compatible operators: `|`, `&`, `< <= == != >= >`, `isin`\n\n        Examples:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [\"A\", \"A\", \"A\", \"B\"], \"bar\": [1, 2, 3, 4]})\n        ```\n        | foo   |   bar |\n        |:------|------:|\n        | A     |     1 |\n        | A     |     2 |\n        | A     |     3 |\n        | B     |     4 |\n\n        Single condition:\n\n        ```python\n        df.filter(lambda row: row[\"foo\"].isin([\"A\"]))\n        ```\n        | foo   |   bar |\n        |:------|------:|\n        | A     |     1 |\n        | A     |     2 |\n        | A     |     3 |\n\n        And (multiple conditions):\n\n        ```python\n        df.filter(lambda row: (row[\"foo\"] == \"A\") & (row[\"bar\"] <= 2))\n        ```\n        | foo   |   bar |\n        |:------|------:|\n        | A     |     1 |\n        | A     |     2 |\n\n        Or (multiple conditions):\n\n        ```python\n        df.filter(lambda row: (row[\"foo\"] == \"B\") | (row[\"bar\"] == 1))\n        ```\n        | foo   |   bar |\n        |:------|------:|\n        | A     |     1 |\n        | B     |     4 |\n        \"\"\"\n        return _wrap(filter(self._data, func))\n\n    def group(self, by: LazyColumns) -> GroupedFrame:\n        \"\"\"Prepare groups for compatible verbs\n", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_865-915"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 900, "start_line_no": 875, "end_line_no": 925, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        | A     |     2 |\n        | A     |     3 |\n        | B     |     4 |\n\n        Single condition:\n\n        ```python\n        df.filter(lambda row: row[\"foo\"].isin([\"A\"]))\n        ```\n        | foo   |   bar |\n        |:------|------:|\n        | A     |     1 |\n        | A     |     2 |\n        | A     |     3 |\n\n        And (multiple conditions):\n\n        ```python\n        df.filter(lambda row: (row[\"foo\"] == \"A\") & (row[\"bar\"] <= 2))\n        ```\n        | foo   |   bar |\n        |:------|------:|\n        | A     |     1 |\n        | A     |     2 |\n\n        Or (multiple conditions):\n\n        ```python\n        df.filter(lambda row: (row[\"foo\"] == \"B\") | (row[\"bar\"] == 1))\n        ```\n        | foo   |   bar |\n        |:------|------:|\n        | A     |     1 |\n        | B     |     4 |\n        \"\"\"\n        return _wrap(filter(self._data, func))\n\n    def group(self, by: LazyColumns) -> GroupedFrame:\n        \"\"\"Prepare groups for compatible verbs\n\n        Compatible verbs: `accumulate`, `gather`, `pack`, `rank`, `rollup`, `take`\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [\"A\", \"A\", \"A\", \"B\", \"B\"], \"bar\": [1, 2, 3, 4, 5], \"baz\": [9, 7, 7, 5, 6]})\n        ```\n        | foo   |   bar |   baz |\n        |:------|------:|------:|\n        | A     |     1 |     9 |", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_875-925"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 910, "start_line_no": 885, "end_line_no": 935, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        |:------|------:|\n        | A     |     1 |\n        | A     |     2 |\n        | A     |     3 |\n\n        And (multiple conditions):\n\n        ```python\n        df.filter(lambda row: (row[\"foo\"] == \"A\") & (row[\"bar\"] <= 2))\n        ```\n        | foo   |   bar |\n        |:------|------:|\n        | A     |     1 |\n        | A     |     2 |\n\n        Or (multiple conditions):\n\n        ```python\n        df.filter(lambda row: (row[\"foo\"] == \"B\") | (row[\"bar\"] == 1))\n        ```\n        | foo   |   bar |\n        |:------|------:|\n        | A     |     1 |\n        | B     |     4 |\n        \"\"\"\n        return _wrap(filter(self._data, func))\n\n    def group(self, by: LazyColumns) -> GroupedFrame:\n        \"\"\"Prepare groups for compatible verbs\n\n        Compatible verbs: `accumulate`, `gather`, `pack`, `rank`, `rollup`, `take`\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [\"A\", \"A\", \"A\", \"B\", \"B\"], \"bar\": [1, 2, 3, 4, 5], \"baz\": [9, 7, 7, 5, 6]})\n        ```\n        | foo   |   bar |   baz |\n        |:------|------:|------:|\n        | A     |     1 |     9 |\n        | A     |     2 |     7 |\n        | A     |     3 |     7 |\n        | B     |     4 |     5 |\n        | B     |     5 |     6 |\n\n        + `accumulate`:\n\n        ```python\n        df.group(\"foo\").accumulate(\"bar\", into=\"bar_cumsum\")\n        ```", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_885-935"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 920, "start_line_no": 895, "end_line_no": 945, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        | foo   |   bar |\n        |:------|------:|\n        | A     |     1 |\n        | A     |     2 |\n\n        Or (multiple conditions):\n\n        ```python\n        df.filter(lambda row: (row[\"foo\"] == \"B\") | (row[\"bar\"] == 1))\n        ```\n        | foo   |   bar |\n        |:------|------:|\n        | A     |     1 |\n        | B     |     4 |\n        \"\"\"\n        return _wrap(filter(self._data, func))\n\n    def group(self, by: LazyColumns) -> GroupedFrame:\n        \"\"\"Prepare groups for compatible verbs\n\n        Compatible verbs: `accumulate`, `gather`, `pack`, `rank`, `rollup`, `take`\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [\"A\", \"A\", \"A\", \"B\", \"B\"], \"bar\": [1, 2, 3, 4, 5], \"baz\": [9, 7, 7, 5, 6]})\n        ```\n        | foo   |   bar |   baz |\n        |:------|------:|------:|\n        | A     |     1 |     9 |\n        | A     |     2 |     7 |\n        | A     |     3 |     7 |\n        | B     |     4 |     5 |\n        | B     |     5 |     6 |\n\n        + `accumulate`:\n\n        ```python\n        df.group(\"foo\").accumulate(\"bar\", into=\"bar_cumsum\")\n        ```\n        | foo   |   bar |   baz |   bar_cumsum |\n        |:------|------:|------:|-------------:|\n        | A     |     1 |     9 |            1 |\n        | A     |     2 |     7 |            3 |\n        | A     |     3 |     7 |            6 |\n        | B     |     4 |     5 |            4 |\n        | B     |     5 |     6 |            9 |\n\n        + `gather`:\n", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_895-945"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 930, "start_line_no": 905, "end_line_no": 955, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        | foo   |   bar |\n        |:------|------:|\n        | A     |     1 |\n        | B     |     4 |\n        \"\"\"\n        return _wrap(filter(self._data, func))\n\n    def group(self, by: LazyColumns) -> GroupedFrame:\n        \"\"\"Prepare groups for compatible verbs\n\n        Compatible verbs: `accumulate`, `gather`, `pack`, `rank`, `rollup`, `take`\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [\"A\", \"A\", \"A\", \"B\", \"B\"], \"bar\": [1, 2, 3, 4, 5], \"baz\": [9, 7, 7, 5, 6]})\n        ```\n        | foo   |   bar |   baz |\n        |:------|------:|------:|\n        | A     |     1 |     9 |\n        | A     |     2 |     7 |\n        | A     |     3 |     7 |\n        | B     |     4 |     5 |\n        | B     |     5 |     6 |\n\n        + `accumulate`:\n\n        ```python\n        df.group(\"foo\").accumulate(\"bar\", into=\"bar_cumsum\")\n        ```\n        | foo   |   bar |   baz |   bar_cumsum |\n        |:------|------:|------:|-------------:|\n        | A     |     1 |     9 |            1 |\n        | A     |     2 |     7 |            3 |\n        | A     |     3 |     7 |            6 |\n        | B     |     4 |     5 |            4 |\n        | B     |     5 |     6 |            9 |\n\n        + `gather`:\n\n        ```python\n        df.group(\"foo\").gather()\n        ```\n        | foo   | variable   |   value |\n        |:------|:-----------|--------:|\n        | A     | bar        |       1 |\n        | A     | bar        |       2 |\n        | A     | bar        |       3 |\n        | B     | bar        |       4 |\n        | B     | bar        |       5 |", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_905-955"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 940, "start_line_no": 915, "end_line_no": 965, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        Compatible verbs: `accumulate`, `gather`, `pack`, `rank`, `rollup`, `take`\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [\"A\", \"A\", \"A\", \"B\", \"B\"], \"bar\": [1, 2, 3, 4, 5], \"baz\": [9, 7, 7, 5, 6]})\n        ```\n        | foo   |   bar |   baz |\n        |:------|------:|------:|\n        | A     |     1 |     9 |\n        | A     |     2 |     7 |\n        | A     |     3 |     7 |\n        | B     |     4 |     5 |\n        | B     |     5 |     6 |\n\n        + `accumulate`:\n\n        ```python\n        df.group(\"foo\").accumulate(\"bar\", into=\"bar_cumsum\")\n        ```\n        | foo   |   bar |   baz |   bar_cumsum |\n        |:------|------:|------:|-------------:|\n        | A     |     1 |     9 |            1 |\n        | A     |     2 |     7 |            3 |\n        | A     |     3 |     7 |            6 |\n        | B     |     4 |     5 |            4 |\n        | B     |     5 |     6 |            9 |\n\n        + `gather`:\n\n        ```python\n        df.group(\"foo\").gather()\n        ```\n        | foo   | variable   |   value |\n        |:------|:-----------|--------:|\n        | A     | bar        |       1 |\n        | A     | bar        |       2 |\n        | A     | bar        |       3 |\n        | B     | bar        |       4 |\n        | B     | bar        |       5 |\n        | A     | baz        |       9 |\n        | A     | baz        |       7 |\n        | A     | baz        |       7 |\n        | B     | baz        |       5 |\n        | B     | baz        |       6 |\n\n        + `pack`:\n\n        ```python\n        df.group(\"foo\").pack(\"bar\", sep=\":\")", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_915-965"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 950, "start_line_no": 925, "end_line_no": 975, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        | A     |     2 |     7 |\n        | A     |     3 |     7 |\n        | B     |     4 |     5 |\n        | B     |     5 |     6 |\n\n        + `accumulate`:\n\n        ```python\n        df.group(\"foo\").accumulate(\"bar\", into=\"bar_cumsum\")\n        ```\n        | foo   |   bar |   baz |   bar_cumsum |\n        |:------|------:|------:|-------------:|\n        | A     |     1 |     9 |            1 |\n        | A     |     2 |     7 |            3 |\n        | A     |     3 |     7 |            6 |\n        | B     |     4 |     5 |            4 |\n        | B     |     5 |     6 |            9 |\n\n        + `gather`:\n\n        ```python\n        df.group(\"foo\").gather()\n        ```\n        | foo   | variable   |   value |\n        |:------|:-----------|--------:|\n        | A     | bar        |       1 |\n        | A     | bar        |       2 |\n        | A     | bar        |       3 |\n        | B     | bar        |       4 |\n        | B     | bar        |       5 |\n        | A     | baz        |       9 |\n        | A     | baz        |       7 |\n        | A     | baz        |       7 |\n        | B     | baz        |       5 |\n        | B     | baz        |       6 |\n\n        + `pack`:\n\n        ```python\n        df.group(\"foo\").pack(\"bar\", sep=\":\")\n        ```\n        | foo   | bar   |\n        |:------|:------|\n        | A     | 1:2:3 |\n        | B     | 4:5   |\n\n\n        + `rank`:\n\n        ```python", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_925-975"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 960, "start_line_no": 935, "end_line_no": 985, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        | foo   |   bar |   baz |   bar_cumsum |\n        |:------|------:|------:|-------------:|\n        | A     |     1 |     9 |            1 |\n        | A     |     2 |     7 |            3 |\n        | A     |     3 |     7 |            6 |\n        | B     |     4 |     5 |            4 |\n        | B     |     5 |     6 |            9 |\n\n        + `gather`:\n\n        ```python\n        df.group(\"foo\").gather()\n        ```\n        | foo   | variable   |   value |\n        |:------|:-----------|--------:|\n        | A     | bar        |       1 |\n        | A     | bar        |       2 |\n        | A     | bar        |       3 |\n        | B     | bar        |       4 |\n        | B     | bar        |       5 |\n        | A     | baz        |       9 |\n        | A     | baz        |       7 |\n        | A     | baz        |       7 |\n        | B     | baz        |       5 |\n        | B     | baz        |       6 |\n\n        + `pack`:\n\n        ```python\n        df.group(\"foo\").pack(\"bar\", sep=\":\")\n        ```\n        | foo   | bar   |\n        |:------|:------|\n        | A     | 1:2:3 |\n        | B     | 4:5   |\n\n\n        + `rank`:\n\n        ```python\n        df.group(\"foo\").rank(\"baz\", into=\"baz_rank\", descending=True)\n        ```\n        | foo   |   bar |   baz |   baz_rank |\n        |:------|------:|------:|-----------:|\n        | A     |     1 |     9 |          1 |\n        | A     |     2 |     7 |          2 |\n        | A     |     3 |     7 |          2 |\n        | B     |     4 |     5 |          2 |\n        | B     |     5 |     6 |          1 |\n", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_935-985"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 970, "start_line_no": 945, "end_line_no": 995, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        ```python\n        df.group(\"foo\").gather()\n        ```\n        | foo   | variable   |   value |\n        |:------|:-----------|--------:|\n        | A     | bar        |       1 |\n        | A     | bar        |       2 |\n        | A     | bar        |       3 |\n        | B     | bar        |       4 |\n        | B     | bar        |       5 |\n        | A     | baz        |       9 |\n        | A     | baz        |       7 |\n        | A     | baz        |       7 |\n        | B     | baz        |       5 |\n        | B     | baz        |       6 |\n\n        + `pack`:\n\n        ```python\n        df.group(\"foo\").pack(\"bar\", sep=\":\")\n        ```\n        | foo   | bar   |\n        |:------|:------|\n        | A     | 1:2:3 |\n        | B     | 4:5   |\n\n\n        + `rank`:\n\n        ```python\n        df.group(\"foo\").rank(\"baz\", into=\"baz_rank\", descending=True)\n        ```\n        | foo   |   bar |   baz |   baz_rank |\n        |:------|------:|------:|-----------:|\n        | A     |     1 |     9 |          1 |\n        | A     |     2 |     7 |          2 |\n        | A     |     3 |     7 |          2 |\n        | B     |     4 |     5 |          2 |\n        | B     |     5 |     6 |          1 |\n\n        + `rollup`:\n\n        ```python\n        df.group(\"foo\").rollup({\n            \"bar_mean\": (\"bar\", rf.stat.mean),\n            \"baz_min\": (\"baz\", rf.stat.min)\n        })\n        ```\n        | foo   |   bar_mean |   baz_min |\n        |:------|-----------:|----------:|", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_945-995"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 980, "start_line_no": 955, "end_line_no": 1005, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        | A     | baz        |       9 |\n        | A     | baz        |       7 |\n        | A     | baz        |       7 |\n        | B     | baz        |       5 |\n        | B     | baz        |       6 |\n\n        + `pack`:\n\n        ```python\n        df.group(\"foo\").pack(\"bar\", sep=\":\")\n        ```\n        | foo   | bar   |\n        |:------|:------|\n        | A     | 1:2:3 |\n        | B     | 4:5   |\n\n\n        + `rank`:\n\n        ```python\n        df.group(\"foo\").rank(\"baz\", into=\"baz_rank\", descending=True)\n        ```\n        | foo   |   bar |   baz |   baz_rank |\n        |:------|------:|------:|-----------:|\n        | A     |     1 |     9 |          1 |\n        | A     |     2 |     7 |          2 |\n        | A     |     3 |     7 |          2 |\n        | B     |     4 |     5 |          2 |\n        | B     |     5 |     6 |          1 |\n\n        + `rollup`:\n\n        ```python\n        df.group(\"foo\").rollup({\n            \"bar_mean\": (\"bar\", rf.stat.mean),\n            \"baz_min\": (\"baz\", rf.stat.min)\n        })\n        ```\n        | foo   |   bar_mean |   baz_min |\n        |:------|-----------:|----------:|\n        | A     |        2   |         7 |\n        | B     |        4.5 |         5 |\n\n        + `take`:\n\n        ```python\n        df.group(\"foo\").take(1)\n        ```\n        | foo   |   bar |   baz |\n        |:------|------:|------:|", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_955-1005"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 990, "start_line_no": 965, "end_line_no": 1015, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        ```\n        | foo   | bar   |\n        |:------|:------|\n        | A     | 1:2:3 |\n        | B     | 4:5   |\n\n\n        + `rank`:\n\n        ```python\n        df.group(\"foo\").rank(\"baz\", into=\"baz_rank\", descending=True)\n        ```\n        | foo   |   bar |   baz |   baz_rank |\n        |:------|------:|------:|-----------:|\n        | A     |     1 |     9 |          1 |\n        | A     |     2 |     7 |          2 |\n        | A     |     3 |     7 |          2 |\n        | B     |     4 |     5 |          2 |\n        | B     |     5 |     6 |          1 |\n\n        + `rollup`:\n\n        ```python\n        df.group(\"foo\").rollup({\n            \"bar_mean\": (\"bar\", rf.stat.mean),\n            \"baz_min\": (\"baz\", rf.stat.min)\n        })\n        ```\n        | foo   |   bar_mean |   baz_min |\n        |:------|-----------:|----------:|\n        | A     |        2   |         7 |\n        | B     |        4.5 |         5 |\n\n        + `take`:\n\n        ```python\n        df.group(\"foo\").take(1)\n        ```\n        | foo   |   bar |   baz |\n        |:------|------:|------:|\n        | A     |     1 |     9 |\n        | B     |     4 |     5 |\n\n        \"\"\"\n        return GroupedFrame(group(self._data, by))\n\n    def join(\n        self,\n        rhs: DataFrame,\n        on: LazyColumns,", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_965-1015"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 1000, "start_line_no": 975, "end_line_no": 1025, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        df.group(\"foo\").rank(\"baz\", into=\"baz_rank\", descending=True)\n        ```\n        | foo   |   bar |   baz |   baz_rank |\n        |:------|------:|------:|-----------:|\n        | A     |     1 |     9 |          1 |\n        | A     |     2 |     7 |          2 |\n        | A     |     3 |     7 |          2 |\n        | B     |     4 |     5 |          2 |\n        | B     |     5 |     6 |          1 |\n\n        + `rollup`:\n\n        ```python\n        df.group(\"foo\").rollup({\n            \"bar_mean\": (\"bar\", rf.stat.mean),\n            \"baz_min\": (\"baz\", rf.stat.min)\n        })\n        ```\n        | foo   |   bar_mean |   baz_min |\n        |:------|-----------:|----------:|\n        | A     |        2   |         7 |\n        | B     |        4.5 |         5 |\n\n        + `take`:\n\n        ```python\n        df.group(\"foo\").take(1)\n        ```\n        | foo   |   bar |   baz |\n        |:------|------:|------:|\n        | A     |     1 |     9 |\n        | B     |     4 |     5 |\n\n        \"\"\"\n        return GroupedFrame(group(self._data, by))\n\n    def join(\n        self,\n        rhs: DataFrame,\n        on: LazyColumns,\n        how: Join = \"left\",\n        postfix: tuple[str, str] = (\"_lhs\", \"_rhs\"),\n    ) -> DataFrame:\n        \"\"\"Join columns from another DataFrame\n\n        Examples:\n\n        ```python\n        adf = rf.DataFrame({\"foo\": [\"A\", \"B\", \"C\"], \"bar\": [1, 2, 3]})\n        ```", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_975-1025"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 1010, "start_line_no": 985, "end_line_no": 1035, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        + `rollup`:\n\n        ```python\n        df.group(\"foo\").rollup({\n            \"bar_mean\": (\"bar\", rf.stat.mean),\n            \"baz_min\": (\"baz\", rf.stat.min)\n        })\n        ```\n        | foo   |   bar_mean |   baz_min |\n        |:------|-----------:|----------:|\n        | A     |        2   |         7 |\n        | B     |        4.5 |         5 |\n\n        + `take`:\n\n        ```python\n        df.group(\"foo\").take(1)\n        ```\n        | foo   |   bar |   baz |\n        |:------|------:|------:|\n        | A     |     1 |     9 |\n        | B     |     4 |     5 |\n\n        \"\"\"\n        return GroupedFrame(group(self._data, by))\n\n    def join(\n        self,\n        rhs: DataFrame,\n        on: LazyColumns,\n        how: Join = \"left\",\n        postfix: tuple[str, str] = (\"_lhs\", \"_rhs\"),\n    ) -> DataFrame:\n        \"\"\"Join columns from another DataFrame\n\n        Examples:\n\n        ```python\n        adf = rf.DataFrame({\"foo\": [\"A\", \"B\", \"C\"], \"bar\": [1, 2, 3]})\n        ```\n        | foo   |   bar |\n        |:------|------:|\n        | A     |     1 |\n        | B     |     2 |\n        | C     |     3 |\n\n        ```python\n        bdf = rf.DataFrame({\"foo\": [\"A\", \"B\", \"D\"], \"baz\": [\"!\", \"@\", \"#\"]})\n        ```\n        | foo   | baz   |", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_985-1035"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 1020, "start_line_no": 995, "end_line_no": 1045, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        | A     |        2   |         7 |\n        | B     |        4.5 |         5 |\n\n        + `take`:\n\n        ```python\n        df.group(\"foo\").take(1)\n        ```\n        | foo   |   bar |   baz |\n        |:------|------:|------:|\n        | A     |     1 |     9 |\n        | B     |     4 |     5 |\n\n        \"\"\"\n        return GroupedFrame(group(self._data, by))\n\n    def join(\n        self,\n        rhs: DataFrame,\n        on: LazyColumns,\n        how: Join = \"left\",\n        postfix: tuple[str, str] = (\"_lhs\", \"_rhs\"),\n    ) -> DataFrame:\n        \"\"\"Join columns from another DataFrame\n\n        Examples:\n\n        ```python\n        adf = rf.DataFrame({\"foo\": [\"A\", \"B\", \"C\"], \"bar\": [1, 2, 3]})\n        ```\n        | foo   |   bar |\n        |:------|------:|\n        | A     |     1 |\n        | B     |     2 |\n        | C     |     3 |\n\n        ```python\n        bdf = rf.DataFrame({\"foo\": [\"A\", \"B\", \"D\"], \"baz\": [\"!\", \"@\", \"#\"]})\n        ```\n        | foo   | baz   |\n        |:------|:------|\n        | A     | !     |\n        | B     | @     |\n        | D     | #     |\n\n        Left join:\n\n        ```python\n        adf.join(bdf, on=\"foo\", how=\"left\")\n        ```", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_995-1045"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 1030, "start_line_no": 1005, "end_line_no": 1055, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        | A     |     1 |     9 |\n        | B     |     4 |     5 |\n\n        \"\"\"\n        return GroupedFrame(group(self._data, by))\n\n    def join(\n        self,\n        rhs: DataFrame,\n        on: LazyColumns,\n        how: Join = \"left\",\n        postfix: tuple[str, str] = (\"_lhs\", \"_rhs\"),\n    ) -> DataFrame:\n        \"\"\"Join columns from another DataFrame\n\n        Examples:\n\n        ```python\n        adf = rf.DataFrame({\"foo\": [\"A\", \"B\", \"C\"], \"bar\": [1, 2, 3]})\n        ```\n        | foo   |   bar |\n        |:------|------:|\n        | A     |     1 |\n        | B     |     2 |\n        | C     |     3 |\n\n        ```python\n        bdf = rf.DataFrame({\"foo\": [\"A\", \"B\", \"D\"], \"baz\": [\"!\", \"@\", \"#\"]})\n        ```\n        | foo   | baz   |\n        |:------|:------|\n        | A     | !     |\n        | B     | @     |\n        | D     | #     |\n\n        Left join:\n\n        ```python\n        adf.join(bdf, on=\"foo\", how=\"left\")\n        ```\n        | foo   |   bar | baz   |\n        |:------|------:|:------|\n        | A     |     1 | !     |\n        | B     |     2 | @     |\n        | C     |     3 | nan   |\n\n        Right join:\n\n        ```python\n        adf.join(bdf, on=\"foo\", how=\"right\")", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_1005-1055"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 1040, "start_line_no": 1015, "end_line_no": 1065, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        how: Join = \"left\",\n        postfix: tuple[str, str] = (\"_lhs\", \"_rhs\"),\n    ) -> DataFrame:\n        \"\"\"Join columns from another DataFrame\n\n        Examples:\n\n        ```python\n        adf = rf.DataFrame({\"foo\": [\"A\", \"B\", \"C\"], \"bar\": [1, 2, 3]})\n        ```\n        | foo   |   bar |\n        |:------|------:|\n        | A     |     1 |\n        | B     |     2 |\n        | C     |     3 |\n\n        ```python\n        bdf = rf.DataFrame({\"foo\": [\"A\", \"B\", \"D\"], \"baz\": [\"!\", \"@\", \"#\"]})\n        ```\n        | foo   | baz   |\n        |:------|:------|\n        | A     | !     |\n        | B     | @     |\n        | D     | #     |\n\n        Left join:\n\n        ```python\n        adf.join(bdf, on=\"foo\", how=\"left\")\n        ```\n        | foo   |   bar | baz   |\n        |:------|------:|:------|\n        | A     |     1 | !     |\n        | B     |     2 | @     |\n        | C     |     3 | nan   |\n\n        Right join:\n\n        ```python\n        adf.join(bdf, on=\"foo\", how=\"right\")\n        ```\n        | foo   |   bar | baz   |\n        |:------|------:|:------|\n        | A     |     1 | !     |\n        | B     |     2 | @     |\n        | D     |   nan | #     |\n\n        Inner join:\n\n        ```python", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_1015-1065"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 1050, "start_line_no": 1025, "end_line_no": 1075, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        | foo   |   bar |\n        |:------|------:|\n        | A     |     1 |\n        | B     |     2 |\n        | C     |     3 |\n\n        ```python\n        bdf = rf.DataFrame({\"foo\": [\"A\", \"B\", \"D\"], \"baz\": [\"!\", \"@\", \"#\"]})\n        ```\n        | foo   | baz   |\n        |:------|:------|\n        | A     | !     |\n        | B     | @     |\n        | D     | #     |\n\n        Left join:\n\n        ```python\n        adf.join(bdf, on=\"foo\", how=\"left\")\n        ```\n        | foo   |   bar | baz   |\n        |:------|------:|:------|\n        | A     |     1 | !     |\n        | B     |     2 | @     |\n        | C     |     3 | nan   |\n\n        Right join:\n\n        ```python\n        adf.join(bdf, on=\"foo\", how=\"right\")\n        ```\n        | foo   |   bar | baz   |\n        |:------|------:|:------|\n        | A     |     1 | !     |\n        | B     |     2 | @     |\n        | D     |   nan | #     |\n\n        Inner join:\n\n        ```python\n        adf.join(bdf, on=\"foo\", how=\"inner\")\n        ```\n        | foo   |   bar | baz   |\n        |:------|------:|:------|\n        | A     |     1 | !     |\n        | B     |     2 | @     |\n\n        Full join:\n\n        ```python", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_1025-1075"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 1060, "start_line_no": 1035, "end_line_no": 1085, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        |:------|:------|\n        | A     | !     |\n        | B     | @     |\n        | D     | #     |\n\n        Left join:\n\n        ```python\n        adf.join(bdf, on=\"foo\", how=\"left\")\n        ```\n        | foo   |   bar | baz   |\n        |:------|------:|:------|\n        | A     |     1 | !     |\n        | B     |     2 | @     |\n        | C     |     3 | nan   |\n\n        Right join:\n\n        ```python\n        adf.join(bdf, on=\"foo\", how=\"right\")\n        ```\n        | foo   |   bar | baz   |\n        |:------|------:|:------|\n        | A     |     1 | !     |\n        | B     |     2 | @     |\n        | D     |   nan | #     |\n\n        Inner join:\n\n        ```python\n        adf.join(bdf, on=\"foo\", how=\"inner\")\n        ```\n        | foo   |   bar | baz   |\n        |:------|------:|:------|\n        | A     |     1 | !     |\n        | B     |     2 | @     |\n\n        Full join:\n\n        ```python\n        adf.join(bdf, on=\"foo\", how=\"full\")\n        ```\n        | foo   |   bar | baz   |\n        |:------|------:|:------|\n        | A     |     1 | !     |\n        | B     |     2 | @     |\n        | C     |     3 | nan   |\n        | D     |   nan | #     |\n        \"\"\"\n        _check_type(rhs, DataFrame)", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_1035-1085"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 1070, "start_line_no": 1045, "end_line_no": 1095, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        | foo   |   bar | baz   |\n        |:------|------:|:------|\n        | A     |     1 | !     |\n        | B     |     2 | @     |\n        | C     |     3 | nan   |\n\n        Right join:\n\n        ```python\n        adf.join(bdf, on=\"foo\", how=\"right\")\n        ```\n        | foo   |   bar | baz   |\n        |:------|------:|:------|\n        | A     |     1 | !     |\n        | B     |     2 | @     |\n        | D     |   nan | #     |\n\n        Inner join:\n\n        ```python\n        adf.join(bdf, on=\"foo\", how=\"inner\")\n        ```\n        | foo   |   bar | baz   |\n        |:------|------:|:------|\n        | A     |     1 | !     |\n        | B     |     2 | @     |\n\n        Full join:\n\n        ```python\n        adf.join(bdf, on=\"foo\", how=\"full\")\n        ```\n        | foo   |   bar | baz   |\n        |:------|------:|:------|\n        | A     |     1 | !     |\n        | B     |     2 | @     |\n        | C     |     3 | nan   |\n        | D     |   nan | #     |\n        \"\"\"\n        _check_type(rhs, DataFrame)\n        return _wrap(join(self._data, rhs._data, on, how, postfix))\n\n    def mutate(self, over: dict[Column, Func]) -> DataFrame:\n        \"\"\"Create a new, or overwrite an existing column\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [1, 2, 3]})\n        ```", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_1045-1095"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 1080, "start_line_no": 1055, "end_line_no": 1105, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        ```\n        | foo   |   bar | baz   |\n        |:------|------:|:------|\n        | A     |     1 | !     |\n        | B     |     2 | @     |\n        | D     |   nan | #     |\n\n        Inner join:\n\n        ```python\n        adf.join(bdf, on=\"foo\", how=\"inner\")\n        ```\n        | foo   |   bar | baz   |\n        |:------|------:|:------|\n        | A     |     1 | !     |\n        | B     |     2 | @     |\n\n        Full join:\n\n        ```python\n        adf.join(bdf, on=\"foo\", how=\"full\")\n        ```\n        | foo   |   bar | baz   |\n        |:------|------:|:------|\n        | A     |     1 | !     |\n        | B     |     2 | @     |\n        | C     |     3 | nan   |\n        | D     |   nan | #     |\n        \"\"\"\n        _check_type(rhs, DataFrame)\n        return _wrap(join(self._data, rhs._data, on, how, postfix))\n\n    def mutate(self, over: dict[Column, Func]) -> DataFrame:\n        \"\"\"Create a new, or overwrite an existing column\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [1, 2, 3]})\n        ```\n        |   foo |\n        |------:|\n        |     1 |\n        |     2 |\n        |     3 |\n\n        ```python\n        df.mutate({\n            \"bar\": lambda row: float(row[\"foo\"]),\n            \"baz\": lambda row: \"X\" + str(row[\"bar\"] * 2),", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_1055-1105"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 1090, "start_line_no": 1065, "end_line_no": 1115, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        adf.join(bdf, on=\"foo\", how=\"inner\")\n        ```\n        | foo   |   bar | baz   |\n        |:------|------:|:------|\n        | A     |     1 | !     |\n        | B     |     2 | @     |\n\n        Full join:\n\n        ```python\n        adf.join(bdf, on=\"foo\", how=\"full\")\n        ```\n        | foo   |   bar | baz   |\n        |:------|------:|:------|\n        | A     |     1 | !     |\n        | B     |     2 | @     |\n        | C     |     3 | nan   |\n        | D     |   nan | #     |\n        \"\"\"\n        _check_type(rhs, DataFrame)\n        return _wrap(join(self._data, rhs._data, on, how, postfix))\n\n    def mutate(self, over: dict[Column, Func]) -> DataFrame:\n        \"\"\"Create a new, or overwrite an existing column\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [1, 2, 3]})\n        ```\n        |   foo |\n        |------:|\n        |     1 |\n        |     2 |\n        |     3 |\n\n        ```python\n        df.mutate({\n            \"bar\": lambda row: float(row[\"foo\"]),\n            \"baz\": lambda row: \"X\" + str(row[\"bar\"] * 2),\n            \"jaz\": lambda _: \"Jazz\"\n        })\n        ```\n        |   foo |   bar | baz   | jaz   |\n        |------:|------:|:------|:------|\n        |     1 |     1 | X2.0  | Jazz  |\n        |     2 |     2 | X4.0  | Jazz  |\n        |     3 |     3 | X6.0  | Jazz  |\n        \"\"\"\n        return _wrap(mutate(self._data, over))", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_1065-1115"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 1100, "start_line_no": 1075, "end_line_no": 1125, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        adf.join(bdf, on=\"foo\", how=\"full\")\n        ```\n        | foo   |   bar | baz   |\n        |:------|------:|:------|\n        | A     |     1 | !     |\n        | B     |     2 | @     |\n        | C     |     3 | nan   |\n        | D     |   nan | #     |\n        \"\"\"\n        _check_type(rhs, DataFrame)\n        return _wrap(join(self._data, rhs._data, on, how, postfix))\n\n    def mutate(self, over: dict[Column, Func]) -> DataFrame:\n        \"\"\"Create a new, or overwrite an existing column\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [1, 2, 3]})\n        ```\n        |   foo |\n        |------:|\n        |     1 |\n        |     2 |\n        |     3 |\n\n        ```python\n        df.mutate({\n            \"bar\": lambda row: float(row[\"foo\"]),\n            \"baz\": lambda row: \"X\" + str(row[\"bar\"] * 2),\n            \"jaz\": lambda _: \"Jazz\"\n        })\n        ```\n        |   foo |   bar | baz   | jaz   |\n        |------:|------:|:------|:------|\n        |     1 |     1 | X2.0  | Jazz  |\n        |     2 |     2 | X4.0  | Jazz  |\n        |     3 |     3 | X6.0  | Jazz  |\n        \"\"\"\n        return _wrap(mutate(self._data, over))\n\n    def rename(self, columns: dict[OldColumn, NewColumn]) -> DataFrame:\n        \"\"\"Rename column keys (from \"old\" to \"new\")\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [1, 2], \"bar\": [3, 4]})\n        ```\n        |   foo |   bar |", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_1075-1125"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 1110, "start_line_no": 1085, "end_line_no": 1135, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        return _wrap(join(self._data, rhs._data, on, how, postfix))\n\n    def mutate(self, over: dict[Column, Func]) -> DataFrame:\n        \"\"\"Create a new, or overwrite an existing column\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [1, 2, 3]})\n        ```\n        |   foo |\n        |------:|\n        |     1 |\n        |     2 |\n        |     3 |\n\n        ```python\n        df.mutate({\n            \"bar\": lambda row: float(row[\"foo\"]),\n            \"baz\": lambda row: \"X\" + str(row[\"bar\"] * 2),\n            \"jaz\": lambda _: \"Jazz\"\n        })\n        ```\n        |   foo |   bar | baz   | jaz   |\n        |------:|------:|:------|:------|\n        |     1 |     1 | X2.0  | Jazz  |\n        |     2 |     2 | X4.0  | Jazz  |\n        |     3 |     3 | X6.0  | Jazz  |\n        \"\"\"\n        return _wrap(mutate(self._data, over))\n\n    def rename(self, columns: dict[OldColumn, NewColumn]) -> DataFrame:\n        \"\"\"Rename column keys (from \"old\" to \"new\")\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [1, 2], \"bar\": [3, 4]})\n        ```\n        |   foo |   bar |\n        |------:|------:|\n        |     1 |     3 |\n        |     2 |     4 |\n\n        ```python\n        df.rename({\"foo\": \"oof\", \"bar\": \"rab\"})\n        ```\n        |   oof |   rab |\n        |------:|------:|\n        |     1 |     3 |", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_1085-1135"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 1120, "start_line_no": 1095, "end_line_no": 1145, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        |   foo |\n        |------:|\n        |     1 |\n        |     2 |\n        |     3 |\n\n        ```python\n        df.mutate({\n            \"bar\": lambda row: float(row[\"foo\"]),\n            \"baz\": lambda row: \"X\" + str(row[\"bar\"] * 2),\n            \"jaz\": lambda _: \"Jazz\"\n        })\n        ```\n        |   foo |   bar | baz   | jaz   |\n        |------:|------:|:------|:------|\n        |     1 |     1 | X2.0  | Jazz  |\n        |     2 |     2 | X4.0  | Jazz  |\n        |     3 |     3 | X6.0  | Jazz  |\n        \"\"\"\n        return _wrap(mutate(self._data, over))\n\n    def rename(self, columns: dict[OldColumn, NewColumn]) -> DataFrame:\n        \"\"\"Rename column keys (from \"old\" to \"new\")\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [1, 2], \"bar\": [3, 4]})\n        ```\n        |   foo |   bar |\n        |------:|------:|\n        |     1 |     3 |\n        |     2 |     4 |\n\n        ```python\n        df.rename({\"foo\": \"oof\", \"bar\": \"rab\"})\n        ```\n        |   oof |   rab |\n        |------:|------:|\n        |     1 |     3 |\n        |     2 |     4 |\n\n        \"\"\"\n        return _wrap(rename(self._data, columns))\n\n    def replace(self, over: dict[Column, dict[OldValue, NewValue]]) -> DataFrame:\n        \"\"\"Replace matching values within columns (from \"old\" to \"new\")\n\n        Example:\n", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_1095-1145"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 1130, "start_line_no": 1105, "end_line_no": 1155, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "            \"jaz\": lambda _: \"Jazz\"\n        })\n        ```\n        |   foo |   bar | baz   | jaz   |\n        |------:|------:|:------|:------|\n        |     1 |     1 | X2.0  | Jazz  |\n        |     2 |     2 | X4.0  | Jazz  |\n        |     3 |     3 | X6.0  | Jazz  |\n        \"\"\"\n        return _wrap(mutate(self._data, over))\n\n    def rename(self, columns: dict[OldColumn, NewColumn]) -> DataFrame:\n        \"\"\"Rename column keys (from \"old\" to \"new\")\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [1, 2], \"bar\": [3, 4]})\n        ```\n        |   foo |   bar |\n        |------:|------:|\n        |     1 |     3 |\n        |     2 |     4 |\n\n        ```python\n        df.rename({\"foo\": \"oof\", \"bar\": \"rab\"})\n        ```\n        |   oof |   rab |\n        |------:|------:|\n        |     1 |     3 |\n        |     2 |     4 |\n\n        \"\"\"\n        return _wrap(rename(self._data, columns))\n\n    def replace(self, over: dict[Column, dict[OldValue, NewValue]]) -> DataFrame:\n        \"\"\"Replace matching values within columns (from \"old\" to \"new\")\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [1, 2, 2, 2, 1], \"bar\": [1, \"A\", \"B\", True, False]})\n        ```\n        |   foo | bar   |\n        |------:|:------|\n        |     1 | 1     |\n        |     2 | A     |\n        |     2 | B     |\n        |     2 | True  |\n        |     1 | False |", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_1105-1155"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 1140, "start_line_no": 1115, "end_line_no": 1165, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "\n    def rename(self, columns: dict[OldColumn, NewColumn]) -> DataFrame:\n        \"\"\"Rename column keys (from \"old\" to \"new\")\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [1, 2], \"bar\": [3, 4]})\n        ```\n        |   foo |   bar |\n        |------:|------:|\n        |     1 |     3 |\n        |     2 |     4 |\n\n        ```python\n        df.rename({\"foo\": \"oof\", \"bar\": \"rab\"})\n        ```\n        |   oof |   rab |\n        |------:|------:|\n        |     1 |     3 |\n        |     2 |     4 |\n\n        \"\"\"\n        return _wrap(rename(self._data, columns))\n\n    def replace(self, over: dict[Column, dict[OldValue, NewValue]]) -> DataFrame:\n        \"\"\"Replace matching values within columns (from \"old\" to \"new\")\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [1, 2, 2, 2, 1], \"bar\": [1, \"A\", \"B\", True, False]})\n        ```\n        |   foo | bar   |\n        |------:|:------|\n        |     1 | 1     |\n        |     2 | A     |\n        |     2 | B     |\n        |     2 | True  |\n        |     1 | False |\n\n        ```python\n        df.replace({\n            \"foo\": {2: 222},\n            \"bar\": {False: 0, True: 1, \"A\": 2, \"B\": 3}\n        })\n        ```\n        |   foo |   bar |\n        |------:|------:|\n        |     1 |     1 |", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_1115-1165"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 1150, "start_line_no": 1125, "end_line_no": 1175, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        |------:|------:|\n        |     1 |     3 |\n        |     2 |     4 |\n\n        ```python\n        df.rename({\"foo\": \"oof\", \"bar\": \"rab\"})\n        ```\n        |   oof |   rab |\n        |------:|------:|\n        |     1 |     3 |\n        |     2 |     4 |\n\n        \"\"\"\n        return _wrap(rename(self._data, columns))\n\n    def replace(self, over: dict[Column, dict[OldValue, NewValue]]) -> DataFrame:\n        \"\"\"Replace matching values within columns (from \"old\" to \"new\")\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [1, 2, 2, 2, 1], \"bar\": [1, \"A\", \"B\", True, False]})\n        ```\n        |   foo | bar   |\n        |------:|:------|\n        |     1 | 1     |\n        |     2 | A     |\n        |     2 | B     |\n        |     2 | True  |\n        |     1 | False |\n\n        ```python\n        df.replace({\n            \"foo\": {2: 222},\n            \"bar\": {False: 0, True: 1, \"A\": 2, \"B\": 3}\n        })\n        ```\n        |   foo |   bar |\n        |------:|------:|\n        |     1 |     1 |\n        |   222 |     2 |\n        |   222 |     3 |\n        |   222 |     1 |\n        |     1 |     0 |\n        \"\"\"\n        return _wrap(replace(self._data, over))\n\n    def sample(self, rows: int | float, seed: int | None = None) -> DataFrame:\n        \"\"\"Randomly sample any number of rows\n", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_1125-1175"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 1160, "start_line_no": 1135, "end_line_no": 1185, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        |     2 |     4 |\n\n        \"\"\"\n        return _wrap(rename(self._data, columns))\n\n    def replace(self, over: dict[Column, dict[OldValue, NewValue]]) -> DataFrame:\n        \"\"\"Replace matching values within columns (from \"old\" to \"new\")\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [1, 2, 2, 2, 1], \"bar\": [1, \"A\", \"B\", True, False]})\n        ```\n        |   foo | bar   |\n        |------:|:------|\n        |     1 | 1     |\n        |     2 | A     |\n        |     2 | B     |\n        |     2 | True  |\n        |     1 | False |\n\n        ```python\n        df.replace({\n            \"foo\": {2: 222},\n            \"bar\": {False: 0, True: 1, \"A\": 2, \"B\": 3}\n        })\n        ```\n        |   foo |   bar |\n        |------:|------:|\n        |     1 |     1 |\n        |   222 |     2 |\n        |   222 |     3 |\n        |   222 |     1 |\n        |     1 |     0 |\n        \"\"\"\n        return _wrap(replace(self._data, over))\n\n    def sample(self, rows: int | float, seed: int | None = None) -> DataFrame:\n        \"\"\"Randomly sample any number of rows\n\n        Examples:\n\n        ```python\n        df = rf.DataFrame({\"foo\": range(10), \"bar\": range(10, 20)})\n        ```\n        |   foo |   bar |\n        |------:|------:|\n        |     0 |    10 |\n        |     1 |    11 |\n        |     2 |    12 |", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_1135-1185"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 1170, "start_line_no": 1145, "end_line_no": 1195, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        ```python\n        df = rf.DataFrame({\"foo\": [1, 2, 2, 2, 1], \"bar\": [1, \"A\", \"B\", True, False]})\n        ```\n        |   foo | bar   |\n        |------:|:------|\n        |     1 | 1     |\n        |     2 | A     |\n        |     2 | B     |\n        |     2 | True  |\n        |     1 | False |\n\n        ```python\n        df.replace({\n            \"foo\": {2: 222},\n            \"bar\": {False: 0, True: 1, \"A\": 2, \"B\": 3}\n        })\n        ```\n        |   foo |   bar |\n        |------:|------:|\n        |     1 |     1 |\n        |   222 |     2 |\n        |   222 |     3 |\n        |   222 |     1 |\n        |     1 |     0 |\n        \"\"\"\n        return _wrap(replace(self._data, over))\n\n    def sample(self, rows: int | float, seed: int | None = None) -> DataFrame:\n        \"\"\"Randomly sample any number of rows\n\n        Examples:\n\n        ```python\n        df = rf.DataFrame({\"foo\": range(10), \"bar\": range(10, 20)})\n        ```\n        |   foo |   bar |\n        |------:|------:|\n        |     0 |    10 |\n        |     1 |    11 |\n        |     2 |    12 |\n        |     3 |    13 |\n        |     4 |    14 |\n        |     5 |    15 |\n        |     6 |    16 |\n        |     7 |    17 |\n        |     8 |    18 |\n        |     9 |    19 |\n\n        Single row:\n", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_1145-1195"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 1180, "start_line_no": 1155, "end_line_no": 1205, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "\n        ```python\n        df.replace({\n            \"foo\": {2: 222},\n            \"bar\": {False: 0, True: 1, \"A\": 2, \"B\": 3}\n        })\n        ```\n        |   foo |   bar |\n        |------:|------:|\n        |     1 |     1 |\n        |   222 |     2 |\n        |   222 |     3 |\n        |   222 |     1 |\n        |     1 |     0 |\n        \"\"\"\n        return _wrap(replace(self._data, over))\n\n    def sample(self, rows: int | float, seed: int | None = None) -> DataFrame:\n        \"\"\"Randomly sample any number of rows\n\n        Examples:\n\n        ```python\n        df = rf.DataFrame({\"foo\": range(10), \"bar\": range(10, 20)})\n        ```\n        |   foo |   bar |\n        |------:|------:|\n        |     0 |    10 |\n        |     1 |    11 |\n        |     2 |    12 |\n        |     3 |    13 |\n        |     4 |    14 |\n        |     5 |    15 |\n        |     6 |    16 |\n        |     7 |    17 |\n        |     8 |    18 |\n        |     9 |    19 |\n\n        Single row:\n\n        ```python\n        df.sample(1)\n        ```\n        |   foo |   bar |\n        |------:|------:|\n        |     7 |    17 |\n\n        Multiple rows:\n\n        ```python", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_1155-1205"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 1190, "start_line_no": 1165, "end_line_no": 1215, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        |   222 |     2 |\n        |   222 |     3 |\n        |   222 |     1 |\n        |     1 |     0 |\n        \"\"\"\n        return _wrap(replace(self._data, over))\n\n    def sample(self, rows: int | float, seed: int | None = None) -> DataFrame:\n        \"\"\"Randomly sample any number of rows\n\n        Examples:\n\n        ```python\n        df = rf.DataFrame({\"foo\": range(10), \"bar\": range(10, 20)})\n        ```\n        |   foo |   bar |\n        |------:|------:|\n        |     0 |    10 |\n        |     1 |    11 |\n        |     2 |    12 |\n        |     3 |    13 |\n        |     4 |    14 |\n        |     5 |    15 |\n        |     6 |    16 |\n        |     7 |    17 |\n        |     8 |    18 |\n        |     9 |    19 |\n\n        Single row:\n\n        ```python\n        df.sample(1)\n        ```\n        |   foo |   bar |\n        |------:|------:|\n        |     7 |    17 |\n\n        Multiple rows:\n\n        ```python\n        df.sample(3)\n        ```\n        |   foo |   bar |\n        |------:|------:|\n        |     4 |    14 |\n        |     1 |    11 |\n        |     6 |    16 |\n\n        Percentage of total rows (30%):\n", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_1165-1215"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 1200, "start_line_no": 1175, "end_line_no": 1225, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        Examples:\n\n        ```python\n        df = rf.DataFrame({\"foo\": range(10), \"bar\": range(10, 20)})\n        ```\n        |   foo |   bar |\n        |------:|------:|\n        |     0 |    10 |\n        |     1 |    11 |\n        |     2 |    12 |\n        |     3 |    13 |\n        |     4 |    14 |\n        |     5 |    15 |\n        |     6 |    16 |\n        |     7 |    17 |\n        |     8 |    18 |\n        |     9 |    19 |\n\n        Single row:\n\n        ```python\n        df.sample(1)\n        ```\n        |   foo |   bar |\n        |------:|------:|\n        |     7 |    17 |\n\n        Multiple rows:\n\n        ```python\n        df.sample(3)\n        ```\n        |   foo |   bar |\n        |------:|------:|\n        |     4 |    14 |\n        |     1 |    11 |\n        |     6 |    16 |\n\n        Percentage of total rows (30%):\n\n        ```python\n        df.sample(0.3)\n        ```\n        |   foo |   bar |\n        |------:|------:|\n        |     4 |    14 |\n        |     3 |    13 |\n        |     1 |    11 |\n        \"\"\"\n        return _wrap(sample(self._data, rows, seed))", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_1175-1225"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 1210, "start_line_no": 1185, "end_line_no": 1235, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        |     3 |    13 |\n        |     4 |    14 |\n        |     5 |    15 |\n        |     6 |    16 |\n        |     7 |    17 |\n        |     8 |    18 |\n        |     9 |    19 |\n\n        Single row:\n\n        ```python\n        df.sample(1)\n        ```\n        |   foo |   bar |\n        |------:|------:|\n        |     7 |    17 |\n\n        Multiple rows:\n\n        ```python\n        df.sample(3)\n        ```\n        |   foo |   bar |\n        |------:|------:|\n        |     4 |    14 |\n        |     1 |    11 |\n        |     6 |    16 |\n\n        Percentage of total rows (30%):\n\n        ```python\n        df.sample(0.3)\n        ```\n        |   foo |   bar |\n        |------:|------:|\n        |     4 |    14 |\n        |     3 |    13 |\n        |     1 |    11 |\n        \"\"\"\n        return _wrap(sample(self._data, rows, seed))\n\n    def select(self, columns: LazyColumns) -> DataFrame:\n        \"\"\"Select specific columns\n\n        Examples:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [1, 2], \"bar\": [3, 4], \"baz\": [5, 6]})\n        ```\n        |   foo |   bar |   baz |", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_1185-1235"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 1220, "start_line_no": 1195, "end_line_no": 1245, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        ```python\n        df.sample(1)\n        ```\n        |   foo |   bar |\n        |------:|------:|\n        |     7 |    17 |\n\n        Multiple rows:\n\n        ```python\n        df.sample(3)\n        ```\n        |   foo |   bar |\n        |------:|------:|\n        |     4 |    14 |\n        |     1 |    11 |\n        |     6 |    16 |\n\n        Percentage of total rows (30%):\n\n        ```python\n        df.sample(0.3)\n        ```\n        |   foo |   bar |\n        |------:|------:|\n        |     4 |    14 |\n        |     3 |    13 |\n        |     1 |    11 |\n        \"\"\"\n        return _wrap(sample(self._data, rows, seed))\n\n    def select(self, columns: LazyColumns) -> DataFrame:\n        \"\"\"Select specific columns\n\n        Examples:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [1, 2], \"bar\": [3, 4], \"baz\": [5, 6]})\n        ```\n        |   foo |   bar |   baz |\n        |------:|------:|------:|\n        |     1 |     3 |     5 |\n        |     2 |     4 |     6 |\n\n        Single column:\n\n        ```python\n        df.select(\"foo\")\n        ```\n        |   foo |", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_1195-1245"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 1230, "start_line_no": 1205, "end_line_no": 1255, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        df.sample(3)\n        ```\n        |   foo |   bar |\n        |------:|------:|\n        |     4 |    14 |\n        |     1 |    11 |\n        |     6 |    16 |\n\n        Percentage of total rows (30%):\n\n        ```python\n        df.sample(0.3)\n        ```\n        |   foo |   bar |\n        |------:|------:|\n        |     4 |    14 |\n        |     3 |    13 |\n        |     1 |    11 |\n        \"\"\"\n        return _wrap(sample(self._data, rows, seed))\n\n    def select(self, columns: LazyColumns) -> DataFrame:\n        \"\"\"Select specific columns\n\n        Examples:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [1, 2], \"bar\": [3, 4], \"baz\": [5, 6]})\n        ```\n        |   foo |   bar |   baz |\n        |------:|------:|------:|\n        |     1 |     3 |     5 |\n        |     2 |     4 |     6 |\n\n        Single column:\n\n        ```python\n        df.select(\"foo\")\n        ```\n        |   foo |\n        |------:|\n        |     1 |\n        |     2 |\n\n        Multiple columns:\n\n        ```python\n        df.select([\"foo\", \"baz\"])\n        ```\n        |   foo |   baz |", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_1205-1255"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 1240, "start_line_no": 1215, "end_line_no": 1265, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        ```python\n        df.sample(0.3)\n        ```\n        |   foo |   bar |\n        |------:|------:|\n        |     4 |    14 |\n        |     3 |    13 |\n        |     1 |    11 |\n        \"\"\"\n        return _wrap(sample(self._data, rows, seed))\n\n    def select(self, columns: LazyColumns) -> DataFrame:\n        \"\"\"Select specific columns\n\n        Examples:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [1, 2], \"bar\": [3, 4], \"baz\": [5, 6]})\n        ```\n        |   foo |   bar |   baz |\n        |------:|------:|------:|\n        |     1 |     3 |     5 |\n        |     2 |     4 |     6 |\n\n        Single column:\n\n        ```python\n        df.select(\"foo\")\n        ```\n        |   foo |\n        |------:|\n        |     1 |\n        |     2 |\n\n        Multiple columns:\n\n        ```python\n        df.select([\"foo\", \"baz\"])\n        ```\n        |   foo |   baz |\n        |------:|------:|\n        |     1 |     5 |\n        |     2 |     6 |\n        \"\"\"\n        return _wrap(select(self._data, columns))\n\n    def shuffle(self, seed: int | None = None) -> DataFrame:\n        \"\"\"Shuffle the order of all rows\n\n        Example:", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_1215-1265"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 1250, "start_line_no": 1225, "end_line_no": 1275, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "\n    def select(self, columns: LazyColumns) -> DataFrame:\n        \"\"\"Select specific columns\n\n        Examples:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [1, 2], \"bar\": [3, 4], \"baz\": [5, 6]})\n        ```\n        |   foo |   bar |   baz |\n        |------:|------:|------:|\n        |     1 |     3 |     5 |\n        |     2 |     4 |     6 |\n\n        Single column:\n\n        ```python\n        df.select(\"foo\")\n        ```\n        |   foo |\n        |------:|\n        |     1 |\n        |     2 |\n\n        Multiple columns:\n\n        ```python\n        df.select([\"foo\", \"baz\"])\n        ```\n        |   foo |   baz |\n        |------:|------:|\n        |     1 |     5 |\n        |     2 |     6 |\n        \"\"\"\n        return _wrap(select(self._data, columns))\n\n    def shuffle(self, seed: int | None = None) -> DataFrame:\n        \"\"\"Shuffle the order of all rows\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": range(5), \"bar\": range(5, 10)})\n        ```\n        |   foo |   bar |\n        |------:|------:|\n        |     0 |     5 |\n        |     1 |     6 |\n        |     2 |     7 |\n        |     3 |     8 |", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_1225-1275"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 1260, "start_line_no": 1235, "end_line_no": 1285, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        |------:|------:|------:|\n        |     1 |     3 |     5 |\n        |     2 |     4 |     6 |\n\n        Single column:\n\n        ```python\n        df.select(\"foo\")\n        ```\n        |   foo |\n        |------:|\n        |     1 |\n        |     2 |\n\n        Multiple columns:\n\n        ```python\n        df.select([\"foo\", \"baz\"])\n        ```\n        |   foo |   baz |\n        |------:|------:|\n        |     1 |     5 |\n        |     2 |     6 |\n        \"\"\"\n        return _wrap(select(self._data, columns))\n\n    def shuffle(self, seed: int | None = None) -> DataFrame:\n        \"\"\"Shuffle the order of all rows\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": range(5), \"bar\": range(5, 10)})\n        ```\n        |   foo |   bar |\n        |------:|------:|\n        |     0 |     5 |\n        |     1 |     6 |\n        |     2 |     7 |\n        |     3 |     8 |\n        |     4 |     9 |\n\n        ```python\n        df.shuffle()\n        ```\n        |   foo |   bar |\n        |------:|------:|\n        |     4 |     9 |\n        |     2 |     7 |\n        |     3 |     8 |", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_1235-1285"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 1270, "start_line_no": 1245, "end_line_no": 1295, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        |------:|\n        |     1 |\n        |     2 |\n\n        Multiple columns:\n\n        ```python\n        df.select([\"foo\", \"baz\"])\n        ```\n        |   foo |   baz |\n        |------:|------:|\n        |     1 |     5 |\n        |     2 |     6 |\n        \"\"\"\n        return _wrap(select(self._data, columns))\n\n    def shuffle(self, seed: int | None = None) -> DataFrame:\n        \"\"\"Shuffle the order of all rows\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": range(5), \"bar\": range(5, 10)})\n        ```\n        |   foo |   bar |\n        |------:|------:|\n        |     0 |     5 |\n        |     1 |     6 |\n        |     2 |     7 |\n        |     3 |     8 |\n        |     4 |     9 |\n\n        ```python\n        df.shuffle()\n        ```\n        |   foo |   bar |\n        |------:|------:|\n        |     4 |     9 |\n        |     2 |     7 |\n        |     3 |     8 |\n        |     0 |     5 |\n        |     1 |     6 |\n        \"\"\"\n        return _wrap(shuffle(self._data, seed))\n\n    def sort(self, columns: LazyColumns, descending: bool = False) -> DataFrame:\n        \"\"\"Sort rows by specific columns\n\n        Examples:\n", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_1245-1295"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 1280, "start_line_no": 1255, "end_line_no": 1305, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        |------:|------:|\n        |     1 |     5 |\n        |     2 |     6 |\n        \"\"\"\n        return _wrap(select(self._data, columns))\n\n    def shuffle(self, seed: int | None = None) -> DataFrame:\n        \"\"\"Shuffle the order of all rows\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": range(5), \"bar\": range(5, 10)})\n        ```\n        |   foo |   bar |\n        |------:|------:|\n        |     0 |     5 |\n        |     1 |     6 |\n        |     2 |     7 |\n        |     3 |     8 |\n        |     4 |     9 |\n\n        ```python\n        df.shuffle()\n        ```\n        |   foo |   bar |\n        |------:|------:|\n        |     4 |     9 |\n        |     2 |     7 |\n        |     3 |     8 |\n        |     0 |     5 |\n        |     1 |     6 |\n        \"\"\"\n        return _wrap(shuffle(self._data, seed))\n\n    def sort(self, columns: LazyColumns, descending: bool = False) -> DataFrame:\n        \"\"\"Sort rows by specific columns\n\n        Examples:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [\"Z\", \"X\", \"A\", \"A\"], \"bar\": [2, -2, 4, -4]})\n        ```\n        | foo   |   bar |\n        |:------|------:|\n        | Z     |     2 |\n        | X     |    -2 |\n        | A     |     4 |\n        | A     |    -4 |\n", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_1255-1305"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 1290, "start_line_no": 1265, "end_line_no": 1315, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "\n        ```python\n        df = rf.DataFrame({\"foo\": range(5), \"bar\": range(5, 10)})\n        ```\n        |   foo |   bar |\n        |------:|------:|\n        |     0 |     5 |\n        |     1 |     6 |\n        |     2 |     7 |\n        |     3 |     8 |\n        |     4 |     9 |\n\n        ```python\n        df.shuffle()\n        ```\n        |   foo |   bar |\n        |------:|------:|\n        |     4 |     9 |\n        |     2 |     7 |\n        |     3 |     8 |\n        |     0 |     5 |\n        |     1 |     6 |\n        \"\"\"\n        return _wrap(shuffle(self._data, seed))\n\n    def sort(self, columns: LazyColumns, descending: bool = False) -> DataFrame:\n        \"\"\"Sort rows by specific columns\n\n        Examples:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [\"Z\", \"X\", \"A\", \"A\"], \"bar\": [2, -2, 4, -4]})\n        ```\n        | foo   |   bar |\n        |:------|------:|\n        | Z     |     2 |\n        | X     |    -2 |\n        | A     |     4 |\n        | A     |    -4 |\n\n        Single column:\n\n        ```python\n        df.sort(\"bar\")\n        ```\n        | foo   |   bar |\n        |:------|------:|\n        | A     |    -4 |\n        | X     |    -2 |\n        | Z     |     2 |", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_1265-1315"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 1300, "start_line_no": 1275, "end_line_no": 1325, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        |     4 |     9 |\n\n        ```python\n        df.shuffle()\n        ```\n        |   foo |   bar |\n        |------:|------:|\n        |     4 |     9 |\n        |     2 |     7 |\n        |     3 |     8 |\n        |     0 |     5 |\n        |     1 |     6 |\n        \"\"\"\n        return _wrap(shuffle(self._data, seed))\n\n    def sort(self, columns: LazyColumns, descending: bool = False) -> DataFrame:\n        \"\"\"Sort rows by specific columns\n\n        Examples:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [\"Z\", \"X\", \"A\", \"A\"], \"bar\": [2, -2, 4, -4]})\n        ```\n        | foo   |   bar |\n        |:------|------:|\n        | Z     |     2 |\n        | X     |    -2 |\n        | A     |     4 |\n        | A     |    -4 |\n\n        Single column:\n\n        ```python\n        df.sort(\"bar\")\n        ```\n        | foo   |   bar |\n        |:------|------:|\n        | A     |    -4 |\n        | X     |    -2 |\n        | Z     |     2 |\n        | A     |     4 |\n\n        Descending order:\n\n        ```python\n        df.sort(\"bar\", descending=True)\n        ```\n        | foo   |   bar |\n        |:------|------:|\n        | A     |     4 |", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_1275-1325"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 1310, "start_line_no": 1285, "end_line_no": 1335, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        |     0 |     5 |\n        |     1 |     6 |\n        \"\"\"\n        return _wrap(shuffle(self._data, seed))\n\n    def sort(self, columns: LazyColumns, descending: bool = False) -> DataFrame:\n        \"\"\"Sort rows by specific columns\n\n        Examples:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [\"Z\", \"X\", \"A\", \"A\"], \"bar\": [2, -2, 4, -4]})\n        ```\n        | foo   |   bar |\n        |:------|------:|\n        | Z     |     2 |\n        | X     |    -2 |\n        | A     |     4 |\n        | A     |    -4 |\n\n        Single column:\n\n        ```python\n        df.sort(\"bar\")\n        ```\n        | foo   |   bar |\n        |:------|------:|\n        | A     |    -4 |\n        | X     |    -2 |\n        | Z     |     2 |\n        | A     |     4 |\n\n        Descending order:\n\n        ```python\n        df.sort(\"bar\", descending=True)\n        ```\n        | foo   |   bar |\n        |:------|------:|\n        | A     |     4 |\n        | Z     |     2 |\n        | X     |    -2 |\n        | A     |    -4 |\n\n        Multiple columns:\n\n        ```python\n        df.sort([\"foo\", \"bar\"], descending=False)\n        ```\n        | foo   |   bar |", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_1285-1335"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 1320, "start_line_no": 1295, "end_line_no": 1345, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        ```python\n        df = rf.DataFrame({\"foo\": [\"Z\", \"X\", \"A\", \"A\"], \"bar\": [2, -2, 4, -4]})\n        ```\n        | foo   |   bar |\n        |:------|------:|\n        | Z     |     2 |\n        | X     |    -2 |\n        | A     |     4 |\n        | A     |    -4 |\n\n        Single column:\n\n        ```python\n        df.sort(\"bar\")\n        ```\n        | foo   |   bar |\n        |:------|------:|\n        | A     |    -4 |\n        | X     |    -2 |\n        | Z     |     2 |\n        | A     |     4 |\n\n        Descending order:\n\n        ```python\n        df.sort(\"bar\", descending=True)\n        ```\n        | foo   |   bar |\n        |:------|------:|\n        | A     |     4 |\n        | Z     |     2 |\n        | X     |    -2 |\n        | A     |    -4 |\n\n        Multiple columns:\n\n        ```python\n        df.sort([\"foo\", \"bar\"], descending=False)\n        ```\n        | foo   |   bar |\n        |:------|------:|\n        | A     |    -4 |\n        | A     |     4 |\n        | X     |    -2 |\n        | Z     |     2 |\n        \"\"\"\n        return _wrap(sort(self._data, columns, descending))\n\n    def split(\n        self, column: Column, into: Columns, sep: str, drop: bool = True", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_1295-1345"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 1330, "start_line_no": 1305, "end_line_no": 1355, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        Single column:\n\n        ```python\n        df.sort(\"bar\")\n        ```\n        | foo   |   bar |\n        |:------|------:|\n        | A     |    -4 |\n        | X     |    -2 |\n        | Z     |     2 |\n        | A     |     4 |\n\n        Descending order:\n\n        ```python\n        df.sort(\"bar\", descending=True)\n        ```\n        | foo   |   bar |\n        |:------|------:|\n        | A     |     4 |\n        | Z     |     2 |\n        | X     |    -2 |\n        | A     |    -4 |\n\n        Multiple columns:\n\n        ```python\n        df.sort([\"foo\", \"bar\"], descending=False)\n        ```\n        | foo   |   bar |\n        |:------|------:|\n        | A     |    -4 |\n        | A     |     4 |\n        | X     |    -2 |\n        | Z     |     2 |\n        \"\"\"\n        return _wrap(sort(self._data, columns, descending))\n\n    def split(\n        self, column: Column, into: Columns, sep: str, drop: bool = True\n    ) -> DataFrame:\n        \"\"\"Split a single column into multiple columns (opposite of `combine`)\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [\"A::1\", \"B::2\", \"C:3\"]})\n        ```\n        | foo   |\n        |:------|", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_1305-1355"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 1340, "start_line_no": 1315, "end_line_no": 1365, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        | A     |     4 |\n\n        Descending order:\n\n        ```python\n        df.sort(\"bar\", descending=True)\n        ```\n        | foo   |   bar |\n        |:------|------:|\n        | A     |     4 |\n        | Z     |     2 |\n        | X     |    -2 |\n        | A     |    -4 |\n\n        Multiple columns:\n\n        ```python\n        df.sort([\"foo\", \"bar\"], descending=False)\n        ```\n        | foo   |   bar |\n        |:------|------:|\n        | A     |    -4 |\n        | A     |     4 |\n        | X     |    -2 |\n        | Z     |     2 |\n        \"\"\"\n        return _wrap(sort(self._data, columns, descending))\n\n    def split(\n        self, column: Column, into: Columns, sep: str, drop: bool = True\n    ) -> DataFrame:\n        \"\"\"Split a single column into multiple columns (opposite of `combine`)\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [\"A::1\", \"B::2\", \"C:3\"]})\n        ```\n        | foo   |\n        |:------|\n        | A::1  |\n        | B::2  |\n        | C:3   |\n\n        ```python\n        df.split(\"foo\", into=[\"foo\", \"bar\"], sep=\"::\", drop=True)\n        ```\n        | foo   |   bar |\n        |:------|------:|\n        | A     |     1 |", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_1315-1365"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 1350, "start_line_no": 1325, "end_line_no": 1375, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        | Z     |     2 |\n        | X     |    -2 |\n        | A     |    -4 |\n\n        Multiple columns:\n\n        ```python\n        df.sort([\"foo\", \"bar\"], descending=False)\n        ```\n        | foo   |   bar |\n        |:------|------:|\n        | A     |    -4 |\n        | A     |     4 |\n        | X     |    -2 |\n        | Z     |     2 |\n        \"\"\"\n        return _wrap(sort(self._data, columns, descending))\n\n    def split(\n        self, column: Column, into: Columns, sep: str, drop: bool = True\n    ) -> DataFrame:\n        \"\"\"Split a single column into multiple columns (opposite of `combine`)\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [\"A::1\", \"B::2\", \"C:3\"]})\n        ```\n        | foo   |\n        |:------|\n        | A::1  |\n        | B::2  |\n        | C:3   |\n\n        ```python\n        df.split(\"foo\", into=[\"foo\", \"bar\"], sep=\"::\", drop=True)\n        ```\n        | foo   |   bar |\n        |:------|------:|\n        | A     |     1 |\n        | B     |     2 |\n        | C:3   |       |\n        \"\"\"\n        return _wrap(split(self._data, column, into, sep, drop))\n\n    def spread(self, column: Column, using: Column) -> DataFrame:\n        \"\"\"Spread rows into columns (opposite of `gather`)\n\n        Example:\n", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_1325-1375"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 1360, "start_line_no": 1335, "end_line_no": 1385, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        |:------|------:|\n        | A     |    -4 |\n        | A     |     4 |\n        | X     |    -2 |\n        | Z     |     2 |\n        \"\"\"\n        return _wrap(sort(self._data, columns, descending))\n\n    def split(\n        self, column: Column, into: Columns, sep: str, drop: bool = True\n    ) -> DataFrame:\n        \"\"\"Split a single column into multiple columns (opposite of `combine`)\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [\"A::1\", \"B::2\", \"C:3\"]})\n        ```\n        | foo   |\n        |:------|\n        | A::1  |\n        | B::2  |\n        | C:3   |\n\n        ```python\n        df.split(\"foo\", into=[\"foo\", \"bar\"], sep=\"::\", drop=True)\n        ```\n        | foo   |   bar |\n        |:------|------:|\n        | A     |     1 |\n        | B     |     2 |\n        | C:3   |       |\n        \"\"\"\n        return _wrap(split(self._data, column, into, sep, drop))\n\n    def spread(self, column: Column, using: Column) -> DataFrame:\n        \"\"\"Spread rows into columns (opposite of `gather`)\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [\"A\", \"A\", \"A\", \"B\", \"B\", \"B\", \"B\"], \"bar\": [1, 2, 3, 4, 5, 6, 7]})\n        ```\n        | foo   |   bar |\n        |:------|------:|\n        | A     |     1 |\n        | A     |     2 |\n        | A     |     3 |\n        | B     |     4 |\n        | B     |     5 |", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_1335-1385"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 1370, "start_line_no": 1345, "end_line_no": 1395, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "    ) -> DataFrame:\n        \"\"\"Split a single column into multiple columns (opposite of `combine`)\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [\"A::1\", \"B::2\", \"C:3\"]})\n        ```\n        | foo   |\n        |:------|\n        | A::1  |\n        | B::2  |\n        | C:3   |\n\n        ```python\n        df.split(\"foo\", into=[\"foo\", \"bar\"], sep=\"::\", drop=True)\n        ```\n        | foo   |   bar |\n        |:------|------:|\n        | A     |     1 |\n        | B     |     2 |\n        | C:3   |       |\n        \"\"\"\n        return _wrap(split(self._data, column, into, sep, drop))\n\n    def spread(self, column: Column, using: Column) -> DataFrame:\n        \"\"\"Spread rows into columns (opposite of `gather`)\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [\"A\", \"A\", \"A\", \"B\", \"B\", \"B\", \"B\"], \"bar\": [1, 2, 3, 4, 5, 6, 7]})\n        ```\n        | foo   |   bar |\n        |:------|------:|\n        | A     |     1 |\n        | A     |     2 |\n        | A     |     3 |\n        | B     |     4 |\n        | B     |     5 |\n        | B     |     6 |\n        | B     |     7 |\n\n        ```python\n        df.spread(\"foo\", using=\"bar\")\n        ```\n        |   A |   B |\n        |----:|----:|\n        |   1 |   4 |\n        |   2 |   5 |", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_1345-1395"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 1380, "start_line_no": 1355, "end_line_no": 1405, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        | A::1  |\n        | B::2  |\n        | C:3   |\n\n        ```python\n        df.split(\"foo\", into=[\"foo\", \"bar\"], sep=\"::\", drop=True)\n        ```\n        | foo   |   bar |\n        |:------|------:|\n        | A     |     1 |\n        | B     |     2 |\n        | C:3   |       |\n        \"\"\"\n        return _wrap(split(self._data, column, into, sep, drop))\n\n    def spread(self, column: Column, using: Column) -> DataFrame:\n        \"\"\"Spread rows into columns (opposite of `gather`)\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [\"A\", \"A\", \"A\", \"B\", \"B\", \"B\", \"B\"], \"bar\": [1, 2, 3, 4, 5, 6, 7]})\n        ```\n        | foo   |   bar |\n        |:------|------:|\n        | A     |     1 |\n        | A     |     2 |\n        | A     |     3 |\n        | B     |     4 |\n        | B     |     5 |\n        | B     |     6 |\n        | B     |     7 |\n\n        ```python\n        df.spread(\"foo\", using=\"bar\")\n        ```\n        |   A |   B |\n        |----:|----:|\n        |   1 |   4 |\n        |   2 |   5 |\n        |   3 |   6 |\n        | nan |   7 |\n        \"\"\"\n        return _wrap(spread(self._data, column, using))\n\n    def unpack(self, column: Column, sep: str) -> DataFrame:\n        \"\"\"'Explode' concatenated row values into multiple rows (opposite of `pack`)\n\n        Example:\n", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_1355-1405"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 1390, "start_line_no": 1365, "end_line_no": 1415, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        | B     |     2 |\n        | C:3   |       |\n        \"\"\"\n        return _wrap(split(self._data, column, into, sep, drop))\n\n    def spread(self, column: Column, using: Column) -> DataFrame:\n        \"\"\"Spread rows into columns (opposite of `gather`)\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [\"A\", \"A\", \"A\", \"B\", \"B\", \"B\", \"B\"], \"bar\": [1, 2, 3, 4, 5, 6, 7]})\n        ```\n        | foo   |   bar |\n        |:------|------:|\n        | A     |     1 |\n        | A     |     2 |\n        | A     |     3 |\n        | B     |     4 |\n        | B     |     5 |\n        | B     |     6 |\n        | B     |     7 |\n\n        ```python\n        df.spread(\"foo\", using=\"bar\")\n        ```\n        |   A |   B |\n        |----:|----:|\n        |   1 |   4 |\n        |   2 |   5 |\n        |   3 |   6 |\n        | nan |   7 |\n        \"\"\"\n        return _wrap(spread(self._data, column, using))\n\n    def unpack(self, column: Column, sep: str) -> DataFrame:\n        \"\"\"'Explode' concatenated row values into multiple rows (opposite of `pack`)\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\n            \"foo\": [1, 2, 3, 4],\n            \"bar\": [\"A:B\", \"B:C:D\", \"D:E\", \"F\"]\n        })\n        ```\n        |   foo | bar   |\n        |------:|:------|\n        |     1 | A:B   |\n        |     2 | B:C:D |", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_1365-1415"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 1400, "start_line_no": 1375, "end_line_no": 1425, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        ```python\n        df = rf.DataFrame({\"foo\": [\"A\", \"A\", \"A\", \"B\", \"B\", \"B\", \"B\"], \"bar\": [1, 2, 3, 4, 5, 6, 7]})\n        ```\n        | foo   |   bar |\n        |:------|------:|\n        | A     |     1 |\n        | A     |     2 |\n        | A     |     3 |\n        | B     |     4 |\n        | B     |     5 |\n        | B     |     6 |\n        | B     |     7 |\n\n        ```python\n        df.spread(\"foo\", using=\"bar\")\n        ```\n        |   A |   B |\n        |----:|----:|\n        |   1 |   4 |\n        |   2 |   5 |\n        |   3 |   6 |\n        | nan |   7 |\n        \"\"\"\n        return _wrap(spread(self._data, column, using))\n\n    def unpack(self, column: Column, sep: str) -> DataFrame:\n        \"\"\"'Explode' concatenated row values into multiple rows (opposite of `pack`)\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\n            \"foo\": [1, 2, 3, 4],\n            \"bar\": [\"A:B\", \"B:C:D\", \"D:E\", \"F\"]\n        })\n        ```\n        |   foo | bar   |\n        |------:|:------|\n        |     1 | A:B   |\n        |     2 | B:C:D |\n        |     3 | D:E   |\n        |     4 | F     |\n\n        ```python\n        df.unpack(\"bar\", sep=\":\")\n        ```\n        |   foo | bar   |\n        |------:|:------|\n        |     1 | A     |\n        |     1 | B     |", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_1375-1425"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 1410, "start_line_no": 1385, "end_line_no": 1433, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        | B     |     6 |\n        | B     |     7 |\n\n        ```python\n        df.spread(\"foo\", using=\"bar\")\n        ```\n        |   A |   B |\n        |----:|----:|\n        |   1 |   4 |\n        |   2 |   5 |\n        |   3 |   6 |\n        | nan |   7 |\n        \"\"\"\n        return _wrap(spread(self._data, column, using))\n\n    def unpack(self, column: Column, sep: str) -> DataFrame:\n        \"\"\"'Explode' concatenated row values into multiple rows (opposite of `pack`)\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\n            \"foo\": [1, 2, 3, 4],\n            \"bar\": [\"A:B\", \"B:C:D\", \"D:E\", \"F\"]\n        })\n        ```\n        |   foo | bar   |\n        |------:|:------|\n        |     1 | A:B   |\n        |     2 | B:C:D |\n        |     3 | D:E   |\n        |     4 | F     |\n\n        ```python\n        df.unpack(\"bar\", sep=\":\")\n        ```\n        |   foo | bar   |\n        |------:|:------|\n        |     1 | A     |\n        |     1 | B     |\n        |     2 | B     |\n        |     2 | C     |\n        |     2 | D     |\n        |     3 | D     |\n        |     3 | E     |\n        |     4 | F     |\n        \"\"\"\n        return _wrap(unpack(self._data, column, sep))", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_1385-1433"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 1420, "start_line_no": 1395, "end_line_no": 1433, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        |   3 |   6 |\n        | nan |   7 |\n        \"\"\"\n        return _wrap(spread(self._data, column, using))\n\n    def unpack(self, column: Column, sep: str) -> DataFrame:\n        \"\"\"'Explode' concatenated row values into multiple rows (opposite of `pack`)\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\n            \"foo\": [1, 2, 3, 4],\n            \"bar\": [\"A:B\", \"B:C:D\", \"D:E\", \"F\"]\n        })\n        ```\n        |   foo | bar   |\n        |------:|:------|\n        |     1 | A:B   |\n        |     2 | B:C:D |\n        |     3 | D:E   |\n        |     4 | F     |\n\n        ```python\n        df.unpack(\"bar\", sep=\":\")\n        ```\n        |   foo | bar   |\n        |------:|:------|\n        |     1 | A     |\n        |     1 | B     |\n        |     2 | B     |\n        |     2 | C     |\n        |     2 | D     |\n        |     3 | D     |\n        |     3 | E     |\n        |     4 | F     |\n        \"\"\"\n        return _wrap(unpack(self._data, column, sep))", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_1395-1433"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 1430, "start_line_no": 1405, "end_line_no": 1433, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        ```python\n        df = rf.DataFrame({\n            \"foo\": [1, 2, 3, 4],\n            \"bar\": [\"A:B\", \"B:C:D\", \"D:E\", \"F\"]\n        })\n        ```\n        |   foo | bar   |\n        |------:|:------|\n        |     1 | A:B   |\n        |     2 | B:C:D |\n        |     3 | D:E   |\n        |     4 | F     |\n\n        ```python\n        df.unpack(\"bar\", sep=\":\")\n        ```\n        |   foo | bar   |\n        |------:|:------|\n        |     1 | A     |\n        |     1 | B     |\n        |     2 | B     |\n        |     2 | C     |\n        |     2 | D     |\n        |     3 | D     |\n        |     3 | E     |\n        |     4 | F     |\n        \"\"\"\n        return _wrap(unpack(self._data, column, sep))", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_1405-1433"}
{"title": "maxhumber_redframes-redframes-stat.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "stat.py"], "line_no": 0, "start_line_no": 0, "end_line_no": 11, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}, {"fpath_tuple": ["maxhumber_redframes", "redframes", "stat.py"], "line_no": 10, "start_line_no": 0, "end_line_no": 11, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "\"\"\"Common summary functions/statistics\"\"\"\n\nimport numpy as np  # pyright: ignore[reportMissingImports]\n\ncount = len\nmean = np.mean\nsum = np.sum\nmax = np.max\nmedian = np.median\nmin = np.min\nstd = np.std\n\nAST=Module(Expr(Constant)Import(alias)Assign(Name(Store)Name(Load))Assign(Name(Store)Attribute(Name(Load)Load))Assign(Name(Store)Attribute(Name(Load)Load))Assign(Name(Store)Attribute(Name(Load)Load))Assign(Name(Store)Attribute(Name(Load)Load))Assign(Name(Store)Attribute(Name(Load)Load))Assign(Name(Store)Attribute(Name(Load)Load)))", "id": "maxhumber_redframes_maxhumber_redframes-redframes-stat.py_0-11"}
{"title": "maxhumber_redframes-redframes-types.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "types.py"], "line_no": 0, "start_line_no": 0, "end_line_no": 25, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "from __future__ import annotations\n\nimport datetime\nfrom typing import Any, Callable, Literal, Union\n\nimport numpy as np  # pyright: ignore[reportMissingImports]\nimport pandas as pd  # pyright: ignore[reportMissingImports]\nimport pandas.core.groupby.generic as pg  # pyright: ignore[reportMissingImports]\n\nValue = Any\nValues = list[Value]\nOldValue = Value\nNewValue = Value\nColumn = str\nColumns = list[Column]\nLazyColumns = Union[Column, Columns]\nOldColumn = Column\nNewColumn = Column\nDirection = Literal[\"up\", \"down\"]\nFunc = Callable[..., Any]\nJoin = Literal[\"left\", \"right\", \"inner\", \"full\"]\nNumpyArray = np.ndarray\nNumpyType = np.dtype\nPandasDataFrame = pd.DataFrame\nPandasGroupedFrame = pg.DataFrameGroupBy\n\nAST=Module(ImportFrom(alias)Import(alias)ImportFrom(aliasaliasaliasalias)Import(alias)Import(alias)Import(alias)Assign(Name(Store)Name(Load))Assign(Name(Store)Subscript(Name(Load)Name(Load)Load))Assign(Name(Store)Name(Load))Assign(Name(Store)Name(Load))Assign(Name(Store)Name(Load))Assign(Name(Store)Subscript(Name(Load)Name(Load)Load))Assign(Name(Store)Subscript(Name(Load)Tuple(Name(Load)Name(Load)Load)Load))Assign(Name(Store)Name(Load))Assign(Name(Store)Name(Load))Assign(Name(Store)Subscript(Name(Load)Tuple(ConstantConstantLoad)Load))Assign(Name(Store)Subscript(Name(Load)Tuple(ConstantName(Load)Load)Load))Assign(Name(Store)Subscript(Name(Load)Tuple(ConstantConstantConstantConstantLoad)Load))Assign(Name(Store)Attribute(Name(Load)Load))Assign(Name(Store)Attribute(Name(Load)Load))Assign(Name(Store)Attribute(Name(Load)Load))Assign(Name(Store)Attribute(Name(Load)Load)))", "id": "maxhumber_redframes_maxhumber_redframes-redframes-types.py_0-25"}
{"title": "maxhumber_redframes-redframes-types.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "types.py"], "line_no": 10, "start_line_no": 0, "end_line_no": 28, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}, {"fpath_tuple": ["maxhumber_redframes", "redframes", "types.py"], "line_no": 20, "start_line_no": 0, "end_line_no": 28, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "from __future__ import annotations\n\nimport datetime\nfrom typing import Any, Callable, Literal, Union\n\nimport numpy as np  # pyright: ignore[reportMissingImports]\nimport pandas as pd  # pyright: ignore[reportMissingImports]\nimport pandas.core.groupby.generic as pg  # pyright: ignore[reportMissingImports]\n\nValue = Any\nValues = list[Value]\nOldValue = Value\nNewValue = Value\nColumn = str\nColumns = list[Column]\nLazyColumns = Union[Column, Columns]\nOldColumn = Column\nNewColumn = Column\nDirection = Literal[\"up\", \"down\"]\nFunc = Callable[..., Any]\nJoin = Literal[\"left\", \"right\", \"inner\", \"full\"]\nNumpyArray = np.ndarray\nNumpyType = np.dtype\nPandasDataFrame = pd.DataFrame\nPandasGroupedFrame = pg.DataFrameGroupBy\nPandasIndex = pd.Index\nPandasRangeIndex = pd.RangeIndex\nDateTime = datetime.datetime\n\nAST=Module(ImportFrom(alias)Import(alias)ImportFrom(aliasaliasaliasalias)Import(alias)Import(alias)Import(alias)Assign(Name(Store)Name(Load))Assign(Name(Store)Subscript(Name(Load)Name(Load)Load))Assign(Name(Store)Name(Load))Assign(Name(Store)Name(Load))Assign(Name(Store)Name(Load))Assign(Name(Store)Subscript(Name(Load)Name(Load)Load))Assign(Name(Store)Subscript(Name(Load)Tuple(Name(Load)Name(Load)Load)Load))Assign(Name(Store)Name(Load))Assign(Name(Store)Name(Load))Assign(Name(Store)Subscript(Name(Load)Tuple(ConstantConstantLoad)Load))Assign(Name(Store)Subscript(Name(Load)Tuple(ConstantName(Load)Load)Load))Assign(Name(Store)Subscript(Name(Load)Tuple(ConstantConstantConstantConstantLoad)Load))Assign(Name(Store)Attribute(Name(Load)Load))Assign(Name(Store)Attribute(Name(Load)Load))Assign(Name(Store)Attribute(Name(Load)Load))Assign(Name(Store)Attribute(Name(Load)Load))Assign(Name(Store)Attribute(Name(Load)Load))Assign(Name(Store)Attribute(Name(Load)Load))Assign(Name(Store)Attribute(Name(Load)Load)))", "id": "maxhumber_redframes_maxhumber_redframes-redframes-types.py_0-28"}
{"title": "maxhumber_redframes-redframes-version.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "version.py"], "line_no": 0, "start_line_no": 0, "end_line_no": 1, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "__version__ = \"1.4\"\n\nAST=Module(Assign(Name(Store)Constant))", "id": "maxhumber_redframes_maxhumber_redframes-redframes-version.py_0-1"}
{"title": "maxhumber_redframes-redframes-__init__.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "__init__.py"], "line_no": 0, "start_line_no": 0, "end_line_no": 4, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "from . import stat\nfrom .core import DataFrame\nfrom .io import load, save, unwrap, wrap\nfrom .version import __version__\n\nAST=Module(ImportFrom(alias)ImportFrom(alias)ImportFrom(aliasaliasaliasalias)ImportFrom(alias))", "id": "maxhumber_redframes_maxhumber_redframes-redframes-__init__.py_0-4"}
{"title": "maxhumber_redframes-redframes-io-convert.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "io", "convert.py"], "line_no": 0, "start_line_no": 0, "end_line_no": 25, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "from __future__ import annotations\n\nfrom ..checks import _check_columns, _check_index, _check_type\nfrom ..core import DataFrame\nfrom ..types import PandasDataFrame\n\n\ndef unwrap(rdf: DataFrame) -> PandasDataFrame:\n    \"\"\"Convert a rf.DataFrame into a pd.DataFrame (opposite of `wrap`)\n\n    Example:\n\n    ```python\n    rdf = rf.DataFrame({\"foo\": range(10)})\n    pdf = rf.unwrap(rdf)\n    ```\n    \"\"\"\n    _check_type(rdf, DataFrame)\n    return rdf._data.copy()\n\n\ndef wrap(pdf: PandasDataFrame) -> DataFrame:\n    \"\"\"Convert a pd.DataFrame into a rf.DataFrame (opposite of `unwrap`)\n\n    Example:", "id": "maxhumber_redframes_maxhumber_redframes-redframes-io-convert.py_0-25"}
{"title": "maxhumber_redframes-redframes-io-convert.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "io", "convert.py"], "line_no": 10, "start_line_no": 0, "end_line_no": 35, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "from __future__ import annotations\n\nfrom ..checks import _check_columns, _check_index, _check_type\nfrom ..core import DataFrame\nfrom ..types import PandasDataFrame\n\n\ndef unwrap(rdf: DataFrame) -> PandasDataFrame:\n    \"\"\"Convert a rf.DataFrame into a pd.DataFrame (opposite of `wrap`)\n\n    Example:\n\n    ```python\n    rdf = rf.DataFrame({\"foo\": range(10)})\n    pdf = rf.unwrap(rdf)\n    ```\n    \"\"\"\n    _check_type(rdf, DataFrame)\n    return rdf._data.copy()\n\n\ndef wrap(pdf: PandasDataFrame) -> DataFrame:\n    \"\"\"Convert a pd.DataFrame into a rf.DataFrame (opposite of `unwrap`)\n\n    Example:\n\n    ```python\n    pdf = pd.DataFrame({\"foo\": range(10)})\n    rdf = rf.wrap(pdf)\n    ```\n    \"\"\"\n    _check_type(pdf, PandasDataFrame)\n    _check_index(pdf)\n    _check_columns(pdf)\n    rdf = DataFrame()\n\nAST=Module(ImportFrom(alias)ImportFrom(aliasaliasalias)ImportFrom(alias)ImportFrom(alias)FunctionDef(arguments(arg(Name(Load)))Expr(Constant)Expr(Call(Name(Load)Name(Load)Name(Load)))Return(Call(Attribute(Attribute(Name(Load)Load)Load)))Name(Load))FunctionDef(arguments(arg(Name(Load)))Expr(Constant)Expr(Call(Name(Load)Name(Load)Name(Load)))Expr(Call(Name(Load)Name(Load)))Expr(Call(Name(Load)Name(Load)))Assign(Name(Store)Call(Name(Load)))Name(Load)))", "id": "maxhumber_redframes_maxhumber_redframes-redframes-io-convert.py_0-35"}
{"title": "maxhumber_redframes-redframes-io-convert.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "io", "convert.py"], "line_no": 20, "start_line_no": 0, "end_line_no": 45, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "from __future__ import annotations\n\nfrom ..checks import _check_columns, _check_index, _check_type\nfrom ..core import DataFrame\nfrom ..types import PandasDataFrame\n\n\ndef unwrap(rdf: DataFrame) -> PandasDataFrame:\n    \"\"\"Convert a rf.DataFrame into a pd.DataFrame (opposite of `wrap`)\n\n    Example:\n\n    ```python\n    rdf = rf.DataFrame({\"foo\": range(10)})\n    pdf = rf.unwrap(rdf)\n    ```\n    \"\"\"\n    _check_type(rdf, DataFrame)\n    return rdf._data.copy()\n\n\ndef wrap(pdf: PandasDataFrame) -> DataFrame:\n    \"\"\"Convert a pd.DataFrame into a rf.DataFrame (opposite of `unwrap`)\n\n    Example:\n\n    ```python\n    pdf = pd.DataFrame({\"foo\": range(10)})\n    rdf = rf.wrap(pdf)\n    ```\n    \"\"\"\n    _check_type(pdf, PandasDataFrame)\n    _check_index(pdf)\n    _check_columns(pdf)\n    rdf = DataFrame()\n    rdf._data = pdf.copy()\n    return rdf\n\n\ndef convert(df: DataFrame | PandasDataFrame) -> PandasDataFrame | DataFrame:\n    \"\"\"Convert a rf.DataFrame into a pd.DataFrame (and/or vice versa)\n\n    Example:\n\n    ```python", "id": "maxhumber_redframes_maxhumber_redframes-redframes-io-convert.py_0-45"}
{"title": "maxhumber_redframes-redframes-io-convert.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "io", "convert.py"], "line_no": 30, "start_line_no": 5, "end_line_no": 55, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "\n\ndef unwrap(rdf: DataFrame) -> PandasDataFrame:\n    \"\"\"Convert a rf.DataFrame into a pd.DataFrame (opposite of `wrap`)\n\n    Example:\n\n    ```python\n    rdf = rf.DataFrame({\"foo\": range(10)})\n    pdf = rf.unwrap(rdf)\n    ```\n    \"\"\"\n    _check_type(rdf, DataFrame)\n    return rdf._data.copy()\n\n\ndef wrap(pdf: PandasDataFrame) -> DataFrame:\n    \"\"\"Convert a pd.DataFrame into a rf.DataFrame (opposite of `unwrap`)\n\n    Example:\n\n    ```python\n    pdf = pd.DataFrame({\"foo\": range(10)})\n    rdf = rf.wrap(pdf)\n    ```\n    \"\"\"\n    _check_type(pdf, PandasDataFrame)\n    _check_index(pdf)\n    _check_columns(pdf)\n    rdf = DataFrame()\n    rdf._data = pdf.copy()\n    return rdf\n\n\ndef convert(df: DataFrame | PandasDataFrame) -> PandasDataFrame | DataFrame:\n    \"\"\"Convert a rf.DataFrame into a pd.DataFrame (and/or vice versa)\n\n    Example:\n\n    ```python\n    redf = rf.DataFrame({\"foo\": range(10)})\n    padf = rf.convert(redf) # now a pd.DataFrame\n    redf = rf.convert(padf) # now a rf.DataFrame\n    ```\n    \"\"\"\n    if isinstance(df, DataFrame):\n        return unwrap(df)\n    if isinstance(df, PandasDataFrame):\n        return wrap(df)\n    raise TypeError(\"must be rf.DataFrame | pd.DataFrame\")\n\nAST=Module(FunctionDef(arguments(arg(Name(Load)))Expr(Constant)Expr(Call(Name(Load)Name(Load)Name(Load)))Return(Call(Attribute(Attribute(Name(Load)Load)Load)))Name(Load))FunctionDef(arguments(arg(Name(Load)))Expr(Constant)Expr(Call(Name(Load)Name(Load)Name(Load)))Expr(Call(Name(Load)Name(Load)))Expr(Call(Name(Load)Name(Load)))Assign(Name(Store)Call(Name(Load)))Assign(Attribute(Name(Load)Store)Call(Attribute(Name(Load)Load)))Return(Name(Load))Name(Load))FunctionDef(arguments(arg(BinOp(Name(Load)BitOrName(Load))))Expr(Constant)If(Call(Name(Load)Name(Load)Name(Load))Return(Call(Name(Load)Name(Load))))If(Call(Name(Load)Name(Load)Name(Load))Return(Call(Name(Load)Name(Load))))Raise(Call(Name(Load)Constant))BinOp(Name(Load)BitOrName(Load))))", "id": "maxhumber_redframes_maxhumber_redframes-redframes-io-convert.py_5-55"}
{"title": "maxhumber_redframes-redframes-io-convert.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "io", "convert.py"], "line_no": 40, "start_line_no": 15, "end_line_no": 55, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "    ```\n    \"\"\"\n    _check_type(rdf, DataFrame)\n    return rdf._data.copy()\n\n\ndef wrap(pdf: PandasDataFrame) -> DataFrame:\n    \"\"\"Convert a pd.DataFrame into a rf.DataFrame (opposite of `unwrap`)\n\n    Example:\n\n    ```python\n    pdf = pd.DataFrame({\"foo\": range(10)})\n    rdf = rf.wrap(pdf)\n    ```\n    \"\"\"\n    _check_type(pdf, PandasDataFrame)\n    _check_index(pdf)\n    _check_columns(pdf)\n    rdf = DataFrame()\n    rdf._data = pdf.copy()\n    return rdf\n\n\ndef convert(df: DataFrame | PandasDataFrame) -> PandasDataFrame | DataFrame:\n    \"\"\"Convert a rf.DataFrame into a pd.DataFrame (and/or vice versa)\n\n    Example:\n\n    ```python\n    redf = rf.DataFrame({\"foo\": range(10)})\n    padf = rf.convert(redf) # now a pd.DataFrame\n    redf = rf.convert(padf) # now a rf.DataFrame\n    ```\n    \"\"\"\n    if isinstance(df, DataFrame):\n        return unwrap(df)\n    if isinstance(df, PandasDataFrame):\n        return wrap(df)\n    raise TypeError(\"must be rf.DataFrame | pd.DataFrame\")", "id": "maxhumber_redframes_maxhumber_redframes-redframes-io-convert.py_15-55"}
{"title": "maxhumber_redframes-redframes-io-convert.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "io", "convert.py"], "line_no": 50, "start_line_no": 25, "end_line_no": 55, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "\n    ```python\n    pdf = pd.DataFrame({\"foo\": range(10)})\n    rdf = rf.wrap(pdf)\n    ```\n    \"\"\"\n    _check_type(pdf, PandasDataFrame)\n    _check_index(pdf)\n    _check_columns(pdf)\n    rdf = DataFrame()\n    rdf._data = pdf.copy()\n    return rdf\n\n\ndef convert(df: DataFrame | PandasDataFrame) -> PandasDataFrame | DataFrame:\n    \"\"\"Convert a rf.DataFrame into a pd.DataFrame (and/or vice versa)\n\n    Example:\n\n    ```python\n    redf = rf.DataFrame({\"foo\": range(10)})\n    padf = rf.convert(redf) # now a pd.DataFrame\n    redf = rf.convert(padf) # now a rf.DataFrame\n    ```\n    \"\"\"\n    if isinstance(df, DataFrame):\n        return unwrap(df)\n    if isinstance(df, PandasDataFrame):\n        return wrap(df)\n    raise TypeError(\"must be rf.DataFrame | pd.DataFrame\")", "id": "maxhumber_redframes_maxhumber_redframes-redframes-io-convert.py_25-55"}
{"title": "maxhumber_redframes-redframes-io-load.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "io", "load.py"], "line_no": 0, "start_line_no": 0, "end_line_no": 23, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}, {"fpath_tuple": ["maxhumber_redframes", "redframes", "io", "load.py"], "line_no": 10, "start_line_no": 0, "end_line_no": 23, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}, {"fpath_tuple": ["maxhumber_redframes", "redframes", "io", "load.py"], "line_no": 20, "start_line_no": 0, "end_line_no": 23, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "import pandas as pd  # pyright: ignore[reportMissingImports]\n\nfrom redframes.types import PandasDataFrame\n\nfrom ..checks import _check_columns, _check_file, _check_index, _check_type\nfrom ..core import DataFrame, _wrap\n\n\ndef load(path: str, **kwargs) -> DataFrame:\n    \"\"\"Load a csv file into a rf.DataFrame (opposite of `save`)\n\n    Example:\n\n    ```python\n    df = rf.load(\"example.csv\")\n    ```\n    \"\"\"\n    _check_type(path, str)\n    _check_file(path)\n    data: PandasDataFrame = pd.read_csv(path, **kwargs)  # type: ignore\n    _check_index(data)\n    _check_columns(data)\n    return _wrap(data)\n\nAST=Module(Import(alias)ImportFrom(alias)ImportFrom(aliasaliasaliasalias)ImportFrom(aliasalias)FunctionDef(arguments(arg(Name(Load))arg)Expr(Constant)Expr(Call(Name(Load)Name(Load)Name(Load)))Expr(Call(Name(Load)Name(Load)))AnnAssign(Name(Store)Name(Load)Call(Attribute(Name(Load)Load)Name(Load)keyword(Name(Load))))Expr(Call(Name(Load)Name(Load)))Expr(Call(Name(Load)Name(Load)))Return(Call(Name(Load)Name(Load)))Name(Load)))", "id": "maxhumber_redframes_maxhumber_redframes-redframes-io-load.py_0-23"}
{"title": "maxhumber_redframes-redframes-io-save.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "io", "save.py"], "line_no": 0, "start_line_no": 0, "end_line_no": 17, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}, {"fpath_tuple": ["maxhumber_redframes", "redframes", "io", "save.py"], "line_no": 10, "start_line_no": 0, "end_line_no": 17, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "from ..checks import _check_file, _check_type\nfrom ..core import DataFrame\n\n\ndef save(df: DataFrame, path: str, **kwargs) -> None:\n    \"\"\"Save a rf.DataFrame to a csv file (opposite of `load`)\n\n    Example:\n\n    ```python\n    rf.save(df, \"example.csv\")\n    ```\n    \"\"\"\n    _check_type(df, DataFrame)\n    _check_type(path, str)\n    _check_file(path)\n    df._data.to_csv(path, index=False, **kwargs)\n\nAST=Module(ImportFrom(aliasalias)ImportFrom(alias)FunctionDef(arguments(arg(Name(Load))arg(Name(Load))arg)Expr(Constant)Expr(Call(Name(Load)Name(Load)Name(Load)))Expr(Call(Name(Load)Name(Load)Name(Load)))Expr(Call(Name(Load)Name(Load)))Expr(Call(Attribute(Attribute(Name(Load)Load)Load)Name(Load)keyword(Constant)keyword(Name(Load))))Constant))", "id": "maxhumber_redframes_maxhumber_redframes-redframes-io-save.py_0-17"}
{"title": "maxhumber_redframes-redframes-io-__init__.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "io", "__init__.py"], "line_no": 0, "start_line_no": 0, "end_line_no": 3, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "from .convert import unwrap, wrap\nfrom .load import load\nfrom .save import save\n\nAST=Module(ImportFrom(aliasalias)ImportFrom(alias)ImportFrom(alias))", "id": "maxhumber_redframes_maxhumber_redframes-redframes-io-__init__.py_0-3"}
{"title": "maxhumber_redframes-redframes-verbs-accumulate.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "verbs", "accumulate.py"], "line_no": 0, "start_line_no": 0, "end_line_no": 25, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}, {"fpath_tuple": ["maxhumber_redframes", "redframes", "verbs", "accumulate.py"], "line_no": 10, "start_line_no": 0, "end_line_no": 25, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}, {"fpath_tuple": ["maxhumber_redframes", "redframes", "verbs", "accumulate.py"], "line_no": 20, "start_line_no": 0, "end_line_no": 25, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "from __future__ import annotations\n\nimport warnings\n\nfrom ..checks import _check_type\nfrom ..types import Column, PandasDataFrame, PandasGroupedFrame\n\n\ndef accumulate(\n    df: PandasDataFrame | PandasGroupedFrame, column: Column, into: Column\n) -> PandasDataFrame:\n    _check_type(column, str)\n    _check_type(into, str)\n    if isinstance(df, PandasDataFrame):\n        into_is_not_column = into != column\n        into_is_in_df_columns = into in df.columns\n        if into_is_not_column and into_is_in_df_columns:\n            message = f\"overwriting existing column '{into}'\"\n            warnings.warn(message)\n        df = df.copy()\n    result = df[column].cumsum()\n    if isinstance(df, PandasGroupedFrame):\n        df = df.obj.copy()  # type: ignore\n    df[into] = result  # type: ignore\n    return df  # type: ignore\n\nAST=Module(ImportFrom(alias)Import(alias)ImportFrom(alias)ImportFrom(aliasaliasalias)FunctionDef(arguments(arg(BinOp(Name(Load)BitOrName(Load)))arg(Name(Load))arg(Name(Load)))Expr(Call(Name(Load)Name(Load)Name(Load)))Expr(Call(Name(Load)Name(Load)Name(Load)))If(Call(Name(Load)Name(Load)Name(Load))Assign(Name(Store)Compare(Name(Load)NotEqName(Load)))Assign(Name(Store)Compare(Name(Load)InAttribute(Name(Load)Load)))If(BoolOp(AndName(Load)Name(Load))Assign(Name(Store)JoinedStr(ConstantFormattedValue(Name(Load))Constant))Expr(Call(Attribute(Name(Load)Load)Name(Load))))Assign(Name(Store)Call(Attribute(Name(Load)Load))))Assign(Name(Store)Call(Attribute(Subscript(Name(Load)Name(Load)Load)Load)))If(Call(Name(Load)Name(Load)Name(Load))Assign(Name(Store)Call(Attribute(Attribute(Name(Load)Load)Load))))Assign(Subscript(Name(Load)Name(Load)Store)Name(Load))Return(Name(Load))Name(Load)))", "id": "maxhumber_redframes_maxhumber_redframes-redframes-verbs-accumulate.py_0-25"}
{"title": "maxhumber_redframes-redframes-verbs-append.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "verbs", "append.py"], "line_no": 0, "start_line_no": 0, "end_line_no": 9, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "import pandas as pd  # pyright: ignore[reportMissingImports]\n\nfrom ..types import PandasDataFrame\n\n\ndef append(top: PandasDataFrame, bottom: PandasDataFrame) -> PandasDataFrame:\n    df = pd.concat([top, bottom])\n    df = df.reset_index(drop=True)\n    return df\n\nAST=Module(Import(alias)ImportFrom(alias)FunctionDef(arguments(arg(Name(Load))arg(Name(Load)))Assign(Name(Store)Call(Attribute(Name(Load)Load)List(Name(Load)Name(Load)Load)))Assign(Name(Store)Call(Attribute(Name(Load)Load)keyword(Constant)))Return(Name(Load))Name(Load)))", "id": "maxhumber_redframes_maxhumber_redframes-redframes-verbs-append.py_0-9"}
{"title": "maxhumber_redframes-redframes-verbs-combine.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "verbs", "combine.py"], "line_no": 0, "start_line_no": 0, "end_line_no": 25, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "from __future__ import annotations\n\nimport warnings\n\nfrom ..checks import _check_type\nfrom ..types import Column, Columns, PandasDataFrame\n\n\ndef combine(\n    df: PandasDataFrame, columns: Columns, into: Column, sep: str, drop: bool = True\n) -> PandasDataFrame:\n    _check_type(columns, list)\n    _check_type(into, str)\n    _check_type(sep, str)\n    _check_type(drop, bool)\n    into_is_in_columns = into in columns\n    into_is_not_in_columns = not into_is_in_columns\n    into_is_in_df_columns = into in df.columns\n    if into_is_not_in_columns and into_is_in_df_columns:\n        message = f\"overwriting existing column '{into}'\"\n        warnings.warn(message)\n    df = df.copy()\n    new = df[columns].apply(lambda row: sep.join(row.values.astype(str)), axis=1)\n    if drop:\n        df = df.drop(columns, axis=1)\n\nAST=Module(ImportFrom(alias)Import(alias)ImportFrom(alias)ImportFrom(aliasaliasalias)FunctionDef(arguments(arg(Name(Load))arg(Name(Load))arg(Name(Load))arg(Name(Load))arg(Name(Load))Constant)Expr(Call(Name(Load)Name(Load)Name(Load)))Expr(Call(Name(Load)Name(Load)Name(Load)))Expr(Call(Name(Load)Name(Load)Name(Load)))Expr(Call(Name(Load)Name(Load)Name(Load)))Assign(Name(Store)Compare(Name(Load)InName(Load)))Assign(Name(Store)UnaryOp(NotName(Load)))Assign(Name(Store)Compare(Name(Load)InAttribute(Name(Load)Load)))If(BoolOp(AndName(Load)Name(Load))Assign(Name(Store)JoinedStr(ConstantFormattedValue(Name(Load))Constant))Expr(Call(Attribute(Name(Load)Load)Name(Load))))Assign(Name(Store)Call(Attribute(Name(Load)Load)))Assign(Name(Store)Call(Attribute(Subscript(Name(Load)Name(Load)Load)Load)Lambda(arguments(arg)Call(Attribute(Name(Load)Load)Call(Attribute(Attribute(Name(Load)Load)Load)Name(Load))))keyword(Constant)))If(Name(Load)Assign(Name(Store)Call(Attribute(Name(Load)Load)Name(Load)keyword(Constant))))Name(Load)))", "id": "maxhumber_redframes_maxhumber_redframes-redframes-verbs-combine.py_0-25"}
{"title": "maxhumber_redframes-redframes-verbs-combine.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "verbs", "combine.py"], "line_no": 10, "start_line_no": 0, "end_line_no": 27, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}, {"fpath_tuple": ["maxhumber_redframes", "redframes", "verbs", "combine.py"], "line_no": 20, "start_line_no": 0, "end_line_no": 27, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "from __future__ import annotations\n\nimport warnings\n\nfrom ..checks import _check_type\nfrom ..types import Column, Columns, PandasDataFrame\n\n\ndef combine(\n    df: PandasDataFrame, columns: Columns, into: Column, sep: str, drop: bool = True\n) -> PandasDataFrame:\n    _check_type(columns, list)\n    _check_type(into, str)\n    _check_type(sep, str)\n    _check_type(drop, bool)\n    into_is_in_columns = into in columns\n    into_is_not_in_columns = not into_is_in_columns\n    into_is_in_df_columns = into in df.columns\n    if into_is_not_in_columns and into_is_in_df_columns:\n        message = f\"overwriting existing column '{into}'\"\n        warnings.warn(message)\n    df = df.copy()\n    new = df[columns].apply(lambda row: sep.join(row.values.astype(str)), axis=1)\n    if drop:\n        df = df.drop(columns, axis=1)\n    df[into] = new\n    return df\n\nAST=Module(ImportFrom(alias)Import(alias)ImportFrom(alias)ImportFrom(aliasaliasalias)FunctionDef(arguments(arg(Name(Load))arg(Name(Load))arg(Name(Load))arg(Name(Load))arg(Name(Load))Constant)Expr(Call(Name(Load)Name(Load)Name(Load)))Expr(Call(Name(Load)Name(Load)Name(Load)))Expr(Call(Name(Load)Name(Load)Name(Load)))Expr(Call(Name(Load)Name(Load)Name(Load)))Assign(Name(Store)Compare(Name(Load)InName(Load)))Assign(Name(Store)UnaryOp(NotName(Load)))Assign(Name(Store)Compare(Name(Load)InAttribute(Name(Load)Load)))If(BoolOp(AndName(Load)Name(Load))Assign(Name(Store)JoinedStr(ConstantFormattedValue(Name(Load))Constant))Expr(Call(Attribute(Name(Load)Load)Name(Load))))Assign(Name(Store)Call(Attribute(Name(Load)Load)))Assign(Name(Store)Call(Attribute(Subscript(Name(Load)Name(Load)Load)Load)Lambda(arguments(arg)Call(Attribute(Name(Load)Load)Call(Attribute(Attribute(Name(Load)Load)Load)Name(Load))))keyword(Constant)))If(Name(Load)Assign(Name(Store)Call(Attribute(Name(Load)Load)Name(Load)keyword(Constant))))Assign(Subscript(Name(Load)Name(Load)Store)Name(Load))Return(Name(Load))Name(Load)))", "id": "maxhumber_redframes_maxhumber_redframes-redframes-verbs-combine.py_0-27"}
{"title": "maxhumber_redframes-redframes-verbs-cross.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "verbs", "cross.py"], "line_no": 0, "start_line_no": 0, "end_line_no": 17, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}, {"fpath_tuple": ["maxhumber_redframes", "redframes", "verbs", "cross.py"], "line_no": 10, "start_line_no": 0, "end_line_no": 17, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "from __future__ import annotations\n\nimport pandas as pd  # pyright: ignore[reportMissingImports]\n\nfrom ..checks import _check_type\nfrom ..types import PandasDataFrame\n\n\ndef cross(\n    lhs: PandasDataFrame,\n    rhs: PandasDataFrame,\n    postfix: tuple[str, str] = (\"_lhs\", \"_rhs\"),\n) -> PandasDataFrame:\n    _check_type(postfix, tuple)\n    df = pd.merge(lhs, rhs, how=\"cross\", suffixes=postfix)\n    df = df.reset_index(drop=True)\n    return df\n\nAST=Module(ImportFrom(alias)Import(alias)ImportFrom(alias)ImportFrom(alias)FunctionDef(arguments(arg(Name(Load))arg(Name(Load))arg(Subscript(Name(Load)Tuple(Name(Load)Name(Load)Load)Load))Tuple(ConstantConstantLoad))Expr(Call(Name(Load)Name(Load)Name(Load)))Assign(Name(Store)Call(Attribute(Name(Load)Load)Name(Load)Name(Load)keyword(Constant)keyword(Name(Load))))Assign(Name(Store)Call(Attribute(Name(Load)Load)keyword(Constant)))Return(Name(Load))Name(Load)))", "id": "maxhumber_redframes_maxhumber_redframes-redframes-verbs-cross.py_0-17"}
{"title": "maxhumber_redframes-redframes-verbs-dedupe.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "verbs", "dedupe.py"], "line_no": 0, "start_line_no": 0, "end_line_no": 12, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}, {"fpath_tuple": ["maxhumber_redframes", "redframes", "verbs", "dedupe.py"], "line_no": 10, "start_line_no": 0, "end_line_no": 12, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "from __future__ import annotations\n\nfrom ..checks import _check_keys, _check_type\nfrom ..types import LazyColumns, PandasDataFrame\n\n\ndef dedupe(df: PandasDataFrame, columns: LazyColumns | None = None) -> PandasDataFrame:\n    _check_type(columns, {list, str, None})\n    _check_keys(columns, df.columns)\n    df = df.drop_duplicates(subset=columns, keep=\"first\")\n    df = df.reset_index(drop=True)\n    return df\n\nAST=Module(ImportFrom(alias)ImportFrom(aliasalias)ImportFrom(aliasalias)FunctionDef(arguments(arg(Name(Load))arg(BinOp(Name(Load)BitOrConstant))Constant)Expr(Call(Name(Load)Name(Load)Set(Name(Load)Name(Load)Constant)))Expr(Call(Name(Load)Name(Load)Attribute(Name(Load)Load)))Assign(Name(Store)Call(Attribute(Name(Load)Load)keyword(Name(Load))keyword(Constant)))Assign(Name(Store)Call(Attribute(Name(Load)Load)keyword(Constant)))Return(Name(Load))Name(Load)))", "id": "maxhumber_redframes_maxhumber_redframes-redframes-verbs-dedupe.py_0-12"}
{"title": "maxhumber_redframes-redframes-verbs-denix.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "verbs", "denix.py"], "line_no": 0, "start_line_no": 0, "end_line_no": 20, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}, {"fpath_tuple": ["maxhumber_redframes", "redframes", "verbs", "denix.py"], "line_no": 10, "start_line_no": 0, "end_line_no": 20, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "from __future__ import annotations\n\nfrom ..checks import _check_type\nfrom ..types import LazyColumns, PandasDataFrame\n\n\ndef denix(df: PandasDataFrame, columns: LazyColumns | None = None) -> PandasDataFrame:\n    _check_type(columns, {list, str, None})\n    columns = [columns] if isinstance(columns, str) else columns\n    if isinstance(columns, list):\n        bad_keys = set(columns).difference(df.columns)\n        if bad_keys:\n            if len(bad_keys) == 1:\n                message = f\"columns argument contains invalid key {bad_keys}\"\n            else:\n                message = f\"columns argument contains invalid keys {bad_keys}\"\n            raise KeyError(message)\n    df = df.dropna(subset=columns)\n    df = df.reset_index(drop=True)\n    return df\n\nAST=Module(ImportFrom(alias)ImportFrom(alias)ImportFrom(aliasalias)FunctionDef(arguments(arg(Name(Load))arg(BinOp(Name(Load)BitOrConstant))Constant)Expr(Call(Name(Load)Name(Load)Set(Name(Load)Name(Load)Constant)))Assign(Name(Store)IfExp(Call(Name(Load)Name(Load)Name(Load))List(Name(Load)Load)Name(Load)))If(Call(Name(Load)Name(Load)Name(Load))Assign(Name(Store)Call(Attribute(Call(Name(Load)Name(Load))Load)Attribute(Name(Load)Load)))If(Name(Load)If(Compare(Call(Name(Load)Name(Load))EqConstant)Assign(Name(Store)JoinedStr(ConstantFormattedValue(Name(Load))))Assign(Name(Store)JoinedStr(ConstantFormattedValue(Name(Load)))))Raise(Call(Name(Load)Name(Load)))))Assign(Name(Store)Call(Attribute(Name(Load)Load)keyword(Name(Load))))Assign(Name(Store)Call(Attribute(Name(Load)Load)keyword(Constant)))Return(Name(Load))Name(Load)))", "id": "maxhumber_redframes_maxhumber_redframes-redframes-verbs-denix.py_0-20"}
{"title": "maxhumber_redframes-redframes-verbs-drop.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "verbs", "drop.py"], "line_no": 0, "start_line_no": 0, "end_line_no": 10, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "from __future__ import annotations\n\nfrom ..checks import _check_type\nfrom ..types import LazyColumns, PandasDataFrame\n\n\ndef drop(df: PandasDataFrame, columns: LazyColumns) -> PandasDataFrame:\n    _check_type(columns, {list, str})\n    df = df.drop(columns, axis=1)\n    return df\n\nAST=Module(ImportFrom(alias)ImportFrom(alias)ImportFrom(aliasalias)FunctionDef(arguments(arg(Name(Load))arg(Name(Load)))Expr(Call(Name(Load)Name(Load)Set(Name(Load)Name(Load))))Assign(Name(Store)Call(Attribute(Name(Load)Load)Name(Load)keyword(Constant)))Return(Name(Load))Name(Load)))", "id": "maxhumber_redframes_maxhumber_redframes-redframes-verbs-drop.py_0-10"}
{"title": "maxhumber_redframes-redframes-verbs-fill.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "verbs", "fill.py"], "line_no": 0, "start_line_no": 0, "end_line_no": 25, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "from __future__ import annotations\n\nfrom ..checks import _check_type\nfrom ..types import Direction, LazyColumns, PandasDataFrame, Value\n\n\ndef fill(\n    df: PandasDataFrame,\n    columns: LazyColumns | None = None,\n    direction: Direction | None = None,\n    constant: Value | None = None,\n) -> PandasDataFrame:\n    _check_type(columns, {list, str, None})\n    _check_type(direction, {str, None})\n    columns = [columns] if isinstance(columns, str) else columns\n    if (direction != None) and (constant != None):\n        raise ValueError(\"either direction OR constant must be None\")\n    if (direction == None) and (constant == None):\n        raise ValueError(\"either direction OR constant must not be None\")\n    if direction != None:\n        if not (direction in [\"down\", \"up\"]):\n            raise ValueError(\"must be one of {'down', 'up'}\")\n        method = {\"down\": \"ffill\", \"up\": \"bfill\"}.get(direction)\n        value = None\n    if constant != None:", "id": "maxhumber_redframes_maxhumber_redframes-redframes-verbs-fill.py_0-25"}
{"title": "maxhumber_redframes-redframes-verbs-fill.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "verbs", "fill.py"], "line_no": 10, "start_line_no": 0, "end_line_no": 33, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}, {"fpath_tuple": ["maxhumber_redframes", "redframes", "verbs", "fill.py"], "line_no": 20, "start_line_no": 0, "end_line_no": 33, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "from __future__ import annotations\n\nfrom ..checks import _check_type\nfrom ..types import Direction, LazyColumns, PandasDataFrame, Value\n\n\ndef fill(\n    df: PandasDataFrame,\n    columns: LazyColumns | None = None,\n    direction: Direction | None = None,\n    constant: Value | None = None,\n) -> PandasDataFrame:\n    _check_type(columns, {list, str, None})\n    _check_type(direction, {str, None})\n    columns = [columns] if isinstance(columns, str) else columns\n    if (direction != None) and (constant != None):\n        raise ValueError(\"either direction OR constant must be None\")\n    if (direction == None) and (constant == None):\n        raise ValueError(\"either direction OR constant must not be None\")\n    if direction != None:\n        if not (direction in [\"down\", \"up\"]):\n            raise ValueError(\"must be one of {'down', 'up'}\")\n        method = {\"down\": \"ffill\", \"up\": \"bfill\"}.get(direction)\n        value = None\n    if constant != None:\n        value = constant\n        method = None\n    df = df.copy()\n    if columns:\n        df[columns] = df[columns].fillna(value=value, method=method)  # type: ignore\n    else:\n        df = df.fillna(value=value, method=method)  # type: ignore\n    return df\n\nAST=Module(ImportFrom(alias)ImportFrom(alias)ImportFrom(aliasaliasaliasalias)FunctionDef(arguments(arg(Name(Load))arg(BinOp(Name(Load)BitOrConstant))arg(BinOp(Name(Load)BitOrConstant))arg(BinOp(Name(Load)BitOrConstant))ConstantConstantConstant)Expr(Call(Name(Load)Name(Load)Set(Name(Load)Name(Load)Constant)))Expr(Call(Name(Load)Name(Load)Set(Name(Load)Constant)))Assign(Name(Store)IfExp(Call(Name(Load)Name(Load)Name(Load))List(Name(Load)Load)Name(Load)))If(BoolOp(AndCompare(Name(Load)NotEqConstant)Compare(Name(Load)NotEqConstant))Raise(Call(Name(Load)Constant)))If(BoolOp(AndCompare(Name(Load)EqConstant)Compare(Name(Load)EqConstant))Raise(Call(Name(Load)Constant)))If(Compare(Name(Load)NotEqConstant)If(UnaryOp(NotCompare(Name(Load)InList(ConstantConstantLoad)))Raise(Call(Name(Load)Constant)))Assign(Name(Store)Call(Attribute(Dict(ConstantConstantConstantConstant)Load)Name(Load)))Assign(Name(Store)Constant))If(Compare(Name(Load)NotEqConstant)Assign(Name(Store)Name(Load))Assign(Name(Store)Constant))Assign(Name(Store)Call(Attribute(Name(Load)Load)))If(Name(Load)Assign(Subscript(Name(Load)Name(Load)Store)Call(Attribute(Subscript(Name(Load)Name(Load)Load)Load)keyword(Name(Load))keyword(Name(Load))))Assign(Name(Store)Call(Attribute(Name(Load)Load)keyword(Name(Load))keyword(Name(Load)))))Return(Name(Load))Name(Load)))", "id": "maxhumber_redframes_maxhumber_redframes-redframes-verbs-fill.py_0-33"}
{"title": "maxhumber_redframes-redframes-verbs-fill.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "verbs", "fill.py"], "line_no": 30, "start_line_no": 5, "end_line_no": 33, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "\ndef fill(\n    df: PandasDataFrame,\n    columns: LazyColumns | None = None,\n    direction: Direction | None = None,\n    constant: Value | None = None,\n) -> PandasDataFrame:\n    _check_type(columns, {list, str, None})\n    _check_type(direction, {str, None})\n    columns = [columns] if isinstance(columns, str) else columns\n    if (direction != None) and (constant != None):\n        raise ValueError(\"either direction OR constant must be None\")\n    if (direction == None) and (constant == None):\n        raise ValueError(\"either direction OR constant must not be None\")\n    if direction != None:\n        if not (direction in [\"down\", \"up\"]):\n            raise ValueError(\"must be one of {'down', 'up'}\")\n        method = {\"down\": \"ffill\", \"up\": \"bfill\"}.get(direction)\n        value = None\n    if constant != None:\n        value = constant\n        method = None\n    df = df.copy()\n    if columns:\n        df[columns] = df[columns].fillna(value=value, method=method)  # type: ignore\n    else:\n        df = df.fillna(value=value, method=method)  # type: ignore\n    return df\n\nAST=Module(FunctionDef(arguments(arg(Name(Load))arg(BinOp(Name(Load)BitOrConstant))arg(BinOp(Name(Load)BitOrConstant))arg(BinOp(Name(Load)BitOrConstant))ConstantConstantConstant)Expr(Call(Name(Load)Name(Load)Set(Name(Load)Name(Load)Constant)))Expr(Call(Name(Load)Name(Load)Set(Name(Load)Constant)))Assign(Name(Store)IfExp(Call(Name(Load)Name(Load)Name(Load))List(Name(Load)Load)Name(Load)))If(BoolOp(AndCompare(Name(Load)NotEqConstant)Compare(Name(Load)NotEqConstant))Raise(Call(Name(Load)Constant)))If(BoolOp(AndCompare(Name(Load)EqConstant)Compare(Name(Load)EqConstant))Raise(Call(Name(Load)Constant)))If(Compare(Name(Load)NotEqConstant)If(UnaryOp(NotCompare(Name(Load)InList(ConstantConstantLoad)))Raise(Call(Name(Load)Constant)))Assign(Name(Store)Call(Attribute(Dict(ConstantConstantConstantConstant)Load)Name(Load)))Assign(Name(Store)Constant))If(Compare(Name(Load)NotEqConstant)Assign(Name(Store)Name(Load))Assign(Name(Store)Constant))Assign(Name(Store)Call(Attribute(Name(Load)Load)))If(Name(Load)Assign(Subscript(Name(Load)Name(Load)Store)Call(Attribute(Subscript(Name(Load)Name(Load)Load)Load)keyword(Name(Load))keyword(Name(Load))))Assign(Name(Store)Call(Attribute(Name(Load)Load)keyword(Name(Load))keyword(Name(Load)))))Return(Name(Load))Name(Load)))", "id": "maxhumber_redframes_maxhumber_redframes-redframes-verbs-fill.py_5-33"}
{"title": "maxhumber_redframes-redframes-verbs-filter.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "verbs", "filter.py"], "line_no": 0, "start_line_no": 0, "end_line_no": 9, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "from ..types import Func, PandasDataFrame\n\n\ndef filter(df: PandasDataFrame, func: Func) -> PandasDataFrame:\n    if not callable(func):\n        raise TypeError(\"must be Func\")\n    df = df.loc[func]  # type: ignore\n    df = df.reset_index(drop=True)\n    return df\n\nAST=Module(ImportFrom(aliasalias)FunctionDef(arguments(arg(Name(Load))arg(Name(Load)))If(UnaryOp(NotCall(Name(Load)Name(Load)))Raise(Call(Name(Load)Constant)))Assign(Name(Store)Subscript(Attribute(Name(Load)Load)Name(Load)Load))Assign(Name(Store)Call(Attribute(Name(Load)Load)keyword(Constant)))Return(Name(Load))Name(Load)))", "id": "maxhumber_redframes_maxhumber_redframes-redframes-verbs-filter.py_0-9"}
{"title": "maxhumber_redframes-redframes-verbs-gather.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "verbs", "gather.py"], "line_no": 0, "start_line_no": 0, "end_line_no": 25, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "from __future__ import annotations\n\nimport warnings\n\nimport pandas as pd  # pyright: ignore[reportMissingImports]\n\nfrom ..checks import _check_type\nfrom ..types import Column, Columns, LazyColumns, PandasDataFrame, PandasGroupedFrame\n\n\ndef _melt(\n    df: PandasDataFrame,\n    cols_to_keep: list[str],\n    cols_to_gather: list[str],\n    into: tuple[str, str],\n) -> PandasDataFrame:\n    df = pd.melt(\n        df,\n        id_vars=cols_to_keep,\n        value_vars=cols_to_gather,\n        var_name=into[0],\n        value_name=into[1],\n    )\n    df = df.dropna(subset=into[1])  # type: ignore\n    df = df.reset_index(drop=True)\n\nAST=Module(ImportFrom(alias)Import(alias)Import(alias)ImportFrom(alias)ImportFrom(aliasaliasaliasaliasalias)FunctionDef(arguments(arg(Name(Load))arg(Subscript(Name(Load)Name(Load)Load))arg(Subscript(Name(Load)Name(Load)Load))arg(Subscript(Name(Load)Tuple(Name(Load)Name(Load)Load)Load)))Assign(Name(Store)Call(Attribute(Name(Load)Load)Name(Load)keyword(Name(Load))keyword(Name(Load))keyword(Subscript(Name(Load)ConstantLoad))keyword(Subscript(Name(Load)ConstantLoad))))Assign(Name(Store)Call(Attribute(Name(Load)Load)keyword(Subscript(Name(Load)ConstantLoad))))Assign(Name(Store)Call(Attribute(Name(Load)Load)keyword(Constant)))Name(Load)))", "id": "maxhumber_redframes_maxhumber_redframes-redframes-verbs-gather.py_0-25"}
{"title": "maxhumber_redframes-redframes-verbs-gather.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "verbs", "gather.py"], "line_no": 10, "start_line_no": 0, "end_line_no": 35, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "from __future__ import annotations\n\nimport warnings\n\nimport pandas as pd  # pyright: ignore[reportMissingImports]\n\nfrom ..checks import _check_type\nfrom ..types import Column, Columns, LazyColumns, PandasDataFrame, PandasGroupedFrame\n\n\ndef _melt(\n    df: PandasDataFrame,\n    cols_to_keep: list[str],\n    cols_to_gather: list[str],\n    into: tuple[str, str],\n) -> PandasDataFrame:\n    df = pd.melt(\n        df,\n        id_vars=cols_to_keep,\n        value_vars=cols_to_gather,\n        var_name=into[0],\n        value_name=into[1],\n    )\n    df = df.dropna(subset=into[1])  # type: ignore\n    df = df.reset_index(drop=True)\n    return df\n\n\ndef _grouped_melt(df: PandasGroupedFrame, into: tuple[str, str]) -> PandasDataFrame:\n    cols_to_keep = df.grouper.names  # type: ignore\n    cols_to_gather = [col for col in df.obj.columns if col not in cols_to_keep]  # type: ignore\n    df = _melt(df.obj, cols_to_keep, cols_to_gather, into)  # type: ignore\n    return df\n\n\n\nAST=Module(ImportFrom(alias)Import(alias)Import(alias)ImportFrom(alias)ImportFrom(aliasaliasaliasaliasalias)FunctionDef(arguments(arg(Name(Load))arg(Subscript(Name(Load)Name(Load)Load))arg(Subscript(Name(Load)Name(Load)Load))arg(Subscript(Name(Load)Tuple(Name(Load)Name(Load)Load)Load)))Assign(Name(Store)Call(Attribute(Name(Load)Load)Name(Load)keyword(Name(Load))keyword(Name(Load))keyword(Subscript(Name(Load)ConstantLoad))keyword(Subscript(Name(Load)ConstantLoad))))Assign(Name(Store)Call(Attribute(Name(Load)Load)keyword(Subscript(Name(Load)ConstantLoad))))Assign(Name(Store)Call(Attribute(Name(Load)Load)keyword(Constant)))Return(Name(Load))Name(Load))FunctionDef(arguments(arg(Name(Load))arg(Subscript(Name(Load)Tuple(Name(Load)Name(Load)Load)Load)))Assign(Name(Store)Attribute(Attribute(Name(Load)Load)Load))Assign(Name(Store)ListComp(Name(Load)comprehension(Name(Store)Attribute(Attribute(Name(Load)Load)Load)Compare(Name(Load)NotInName(Load)))))Assign(Name(Store)Call(Name(Load)Attribute(Name(Load)Load)Name(Load)Name(Load)Name(Load)))Return(Name(Load))Name(Load)))", "id": "maxhumber_redframes_maxhumber_redframes-redframes-verbs-gather.py_0-35"}
{"title": "maxhumber_redframes-redframes-verbs-gather.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "verbs", "gather.py"], "line_no": 20, "start_line_no": 0, "end_line_no": 45, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "from __future__ import annotations\n\nimport warnings\n\nimport pandas as pd  # pyright: ignore[reportMissingImports]\n\nfrom ..checks import _check_type\nfrom ..types import Column, Columns, LazyColumns, PandasDataFrame, PandasGroupedFrame\n\n\ndef _melt(\n    df: PandasDataFrame,\n    cols_to_keep: list[str],\n    cols_to_gather: list[str],\n    into: tuple[str, str],\n) -> PandasDataFrame:\n    df = pd.melt(\n        df,\n        id_vars=cols_to_keep,\n        value_vars=cols_to_gather,\n        var_name=into[0],\n        value_name=into[1],\n    )\n    df = df.dropna(subset=into[1])  # type: ignore\n    df = df.reset_index(drop=True)\n    return df\n\n\ndef _grouped_melt(df: PandasGroupedFrame, into: tuple[str, str]) -> PandasDataFrame:\n    cols_to_keep = df.grouper.names  # type: ignore\n    cols_to_gather = [col for col in df.obj.columns if col not in cols_to_keep]  # type: ignore\n    df = _melt(df.obj, cols_to_keep, cols_to_gather, into)  # type: ignore\n    return df\n\n\ndef gather(\n    df: PandasDataFrame | PandasGroupedFrame,\n    columns: Columns | None = None,\n    beside: LazyColumns | None = None,\n    into: tuple[Column, Column] = (\"variable\", \"value\"),\n) -> PandasDataFrame:\n    _check_type(columns, {list, None})\n    _check_type(beside, {str, list, None})\n    _check_type(into, tuple)\n    if (columns == None) and (beside != None) and isinstance(df, PandasDataFrame):", "id": "maxhumber_redframes_maxhumber_redframes-redframes-verbs-gather.py_0-45"}
{"title": "maxhumber_redframes-redframes-verbs-gather.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "verbs", "gather.py"], "line_no": 30, "start_line_no": 5, "end_line_no": 55, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "\nfrom ..checks import _check_type\nfrom ..types import Column, Columns, LazyColumns, PandasDataFrame, PandasGroupedFrame\n\n\ndef _melt(\n    df: PandasDataFrame,\n    cols_to_keep: list[str],\n    cols_to_gather: list[str],\n    into: tuple[str, str],\n) -> PandasDataFrame:\n    df = pd.melt(\n        df,\n        id_vars=cols_to_keep,\n        value_vars=cols_to_gather,\n        var_name=into[0],\n        value_name=into[1],\n    )\n    df = df.dropna(subset=into[1])  # type: ignore\n    df = df.reset_index(drop=True)\n    return df\n\n\ndef _grouped_melt(df: PandasGroupedFrame, into: tuple[str, str]) -> PandasDataFrame:\n    cols_to_keep = df.grouper.names  # type: ignore\n    cols_to_gather = [col for col in df.obj.columns if col not in cols_to_keep]  # type: ignore\n    df = _melt(df.obj, cols_to_keep, cols_to_gather, into)  # type: ignore\n    return df\n\n\ndef gather(\n    df: PandasDataFrame | PandasGroupedFrame,\n    columns: Columns | None = None,\n    beside: LazyColumns | None = None,\n    into: tuple[Column, Column] = (\"variable\", \"value\"),\n) -> PandasDataFrame:\n    _check_type(columns, {list, None})\n    _check_type(beside, {str, list, None})\n    _check_type(into, tuple)\n    if (columns == None) and (beside != None) and isinstance(df, PandasDataFrame):\n        warnings.warn(\n            \"Marked for removal, please use `df.group(...).gather(...)` instead\",\n            FutureWarning,\n        )\n    if not (isinstance(into, tuple) and (len(into) == 2)):\n        raise TypeError(\"must be tuple[str, str]\")\n    if into[0] == into[1]:\n        raise TypeError(\"must be unique\")\n    if isinstance(df, PandasGroupedFrame):\n        if (into[0] in df.obj.columns) or (into[1] in df.obj.columns):  # type: ignore", "id": "maxhumber_redframes_maxhumber_redframes-redframes-verbs-gather.py_5-55"}
{"title": "maxhumber_redframes-redframes-verbs-gather.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "verbs", "gather.py"], "line_no": 40, "start_line_no": 15, "end_line_no": 65, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": ") -> PandasDataFrame:\n    df = pd.melt(\n        df,\n        id_vars=cols_to_keep,\n        value_vars=cols_to_gather,\n        var_name=into[0],\n        value_name=into[1],\n    )\n    df = df.dropna(subset=into[1])  # type: ignore\n    df = df.reset_index(drop=True)\n    return df\n\n\ndef _grouped_melt(df: PandasGroupedFrame, into: tuple[str, str]) -> PandasDataFrame:\n    cols_to_keep = df.grouper.names  # type: ignore\n    cols_to_gather = [col for col in df.obj.columns if col not in cols_to_keep]  # type: ignore\n    df = _melt(df.obj, cols_to_keep, cols_to_gather, into)  # type: ignore\n    return df\n\n\ndef gather(\n    df: PandasDataFrame | PandasGroupedFrame,\n    columns: Columns | None = None,\n    beside: LazyColumns | None = None,\n    into: tuple[Column, Column] = (\"variable\", \"value\"),\n) -> PandasDataFrame:\n    _check_type(columns, {list, None})\n    _check_type(beside, {str, list, None})\n    _check_type(into, tuple)\n    if (columns == None) and (beside != None) and isinstance(df, PandasDataFrame):\n        warnings.warn(\n            \"Marked for removal, please use `df.group(...).gather(...)` instead\",\n            FutureWarning,\n        )\n    if not (isinstance(into, tuple) and (len(into) == 2)):\n        raise TypeError(\"must be tuple[str, str]\")\n    if into[0] == into[1]:\n        raise TypeError(\"must be unique\")\n    if isinstance(df, PandasGroupedFrame):\n        if (into[0] in df.obj.columns) or (into[1] in df.obj.columns):  # type: ignore\n            raise ValueError(\"must not be an existing column key\")\n        if columns != None:\n            raise ValueError(\"columns is incompatible with group+gather\")\n        if beside != None:\n            raise ValueError(\"beside is incompatible with group+gather\")\n        df = _grouped_melt(df, into)\n        return df\n    if (into[0] in df.columns) or (into[1] in df.columns):\n        raise ValueError(\"must not be an existing column key\")\n    if (columns != None) and (beside != None):", "id": "maxhumber_redframes_maxhumber_redframes-redframes-verbs-gather.py_15-65"}
{"title": "maxhumber_redframes-redframes-verbs-gather.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "verbs", "gather.py"], "line_no": 50, "start_line_no": 25, "end_line_no": 75, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "    return df\n\n\ndef _grouped_melt(df: PandasGroupedFrame, into: tuple[str, str]) -> PandasDataFrame:\n    cols_to_keep = df.grouper.names  # type: ignore\n    cols_to_gather = [col for col in df.obj.columns if col not in cols_to_keep]  # type: ignore\n    df = _melt(df.obj, cols_to_keep, cols_to_gather, into)  # type: ignore\n    return df\n\n\ndef gather(\n    df: PandasDataFrame | PandasGroupedFrame,\n    columns: Columns | None = None,\n    beside: LazyColumns | None = None,\n    into: tuple[Column, Column] = (\"variable\", \"value\"),\n) -> PandasDataFrame:\n    _check_type(columns, {list, None})\n    _check_type(beside, {str, list, None})\n    _check_type(into, tuple)\n    if (columns == None) and (beside != None) and isinstance(df, PandasDataFrame):\n        warnings.warn(\n            \"Marked for removal, please use `df.group(...).gather(...)` instead\",\n            FutureWarning,\n        )\n    if not (isinstance(into, tuple) and (len(into) == 2)):\n        raise TypeError(\"must be tuple[str, str]\")\n    if into[0] == into[1]:\n        raise TypeError(\"must be unique\")\n    if isinstance(df, PandasGroupedFrame):\n        if (into[0] in df.obj.columns) or (into[1] in df.obj.columns):  # type: ignore\n            raise ValueError(\"must not be an existing column key\")\n        if columns != None:\n            raise ValueError(\"columns is incompatible with group+gather\")\n        if beside != None:\n            raise ValueError(\"beside is incompatible with group+gather\")\n        df = _grouped_melt(df, into)\n        return df\n    if (into[0] in df.columns) or (into[1] in df.columns):\n        raise ValueError(\"must not be an existing column key\")\n    if (columns != None) and (beside != None):\n        raise ValueError(\"columns OR beside must be None\")\n    if (columns == None) and (beside == None):\n        id_vars = []\n        value_vars = list(df.columns)\n    if isinstance(beside, str):\n        beside = [beside]\n    if isinstance(beside, list):\n        id_vars = beside\n        value_vars = [col for col in df.columns if col not in id_vars]\n    if isinstance(columns, list):", "id": "maxhumber_redframes_maxhumber_redframes-redframes-verbs-gather.py_25-75"}
{"title": "maxhumber_redframes-redframes-verbs-gather.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "verbs", "gather.py"], "line_no": 60, "start_line_no": 35, "end_line_no": 79, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "def gather(\n    df: PandasDataFrame | PandasGroupedFrame,\n    columns: Columns | None = None,\n    beside: LazyColumns | None = None,\n    into: tuple[Column, Column] = (\"variable\", \"value\"),\n) -> PandasDataFrame:\n    _check_type(columns, {list, None})\n    _check_type(beside, {str, list, None})\n    _check_type(into, tuple)\n    if (columns == None) and (beside != None) and isinstance(df, PandasDataFrame):\n        warnings.warn(\n            \"Marked for removal, please use `df.group(...).gather(...)` instead\",\n            FutureWarning,\n        )\n    if not (isinstance(into, tuple) and (len(into) == 2)):\n        raise TypeError(\"must be tuple[str, str]\")\n    if into[0] == into[1]:\n        raise TypeError(\"must be unique\")\n    if isinstance(df, PandasGroupedFrame):\n        if (into[0] in df.obj.columns) or (into[1] in df.obj.columns):  # type: ignore\n            raise ValueError(\"must not be an existing column key\")\n        if columns != None:\n            raise ValueError(\"columns is incompatible with group+gather\")\n        if beside != None:\n            raise ValueError(\"beside is incompatible with group+gather\")\n        df = _grouped_melt(df, into)\n        return df\n    if (into[0] in df.columns) or (into[1] in df.columns):\n        raise ValueError(\"must not be an existing column key\")\n    if (columns != None) and (beside != None):\n        raise ValueError(\"columns OR beside must be None\")\n    if (columns == None) and (beside == None):\n        id_vars = []\n        value_vars = list(df.columns)\n    if isinstance(beside, str):\n        beside = [beside]\n    if isinstance(beside, list):\n        id_vars = beside\n        value_vars = [col for col in df.columns if col not in id_vars]\n    if isinstance(columns, list):\n        id_vars = [col for col in df.columns if col not in columns]\n        value_vars = columns\n    df = _melt(df, id_vars, value_vars, into)  # pyright: ignore[reportUnboundVariable]\n    return df\n\nAST=Module(FunctionDef(arguments(arg(BinOp(Name(Load)BitOrName(Load)))arg(BinOp(Name(Load)BitOrConstant))arg(BinOp(Name(Load)BitOrConstant))arg(Subscript(Name(Load)Tuple(Name(Load)Name(Load)Load)Load))ConstantConstantTuple(ConstantConstantLoad))Expr(Call(Name(Load)Name(Load)Set(Name(Load)Constant)))Expr(Call(Name(Load)Name(Load)Set(Name(Load)Name(Load)Constant)))Expr(Call(Name(Load)Name(Load)Name(Load)))If(BoolOp(AndCompare(Name(Load)EqConstant)Compare(Name(Load)NotEqConstant)Call(Name(Load)Name(Load)Name(Load)))Expr(Call(Attribute(Name(Load)Load)ConstantName(Load))))If(UnaryOp(NotBoolOp(AndCall(Name(Load)Name(Load)Name(Load))Compare(Call(Name(Load)Name(Load))EqConstant)))Raise(Call(Name(Load)Constant)))If(Compare(Subscript(Name(Load)ConstantLoad)EqSubscript(Name(Load)ConstantLoad))Raise(Call(Name(Load)Constant)))If(Call(Name(Load)Name(Load)Name(Load))If(BoolOp(OrCompare(Subscript(Name(Load)ConstantLoad)InAttribute(Attribute(Name(Load)Load)Load))Compare(Subscript(Name(Load)ConstantLoad)InAttribute(Attribute(Name(Load)Load)Load)))Raise(Call(Name(Load)Constant)))If(Compare(Name(Load)NotEqConstant)Raise(Call(Name(Load)Constant)))If(Compare(Name(Load)NotEqConstant)Raise(Call(Name(Load)Constant)))Assign(Name(Store)Call(Name(Load)Name(Load)Name(Load)))Return(Name(Load)))If(BoolOp(OrCompare(Subscript(Name(Load)ConstantLoad)InAttribute(Name(Load)Load))Compare(Subscript(Name(Load)ConstantLoad)InAttribute(Name(Load)Load)))Raise(Call(Name(Load)Constant)))If(BoolOp(AndCompare(Name(Load)NotEqConstant)Compare(Name(Load)NotEqConstant))Raise(Call(Name(Load)Constant)))If(BoolOp(AndCompare(Name(Load)EqConstant)Compare(Name(Load)EqConstant))Assign(Name(Store)List(Load))Assign(Name(Store)Call(Name(Load)Attribute(Name(Load)Load))))If(Call(Name(Load)Name(Load)Name(Load))Assign(Name(Store)List(Name(Load)Load)))If(Call(Name(Load)Name(Load)Name(Load))Assign(Name(Store)Name(Load))Assign(Name(Store)ListComp(Name(Load)comprehension(Name(Store)Attribute(Name(Load)Load)Compare(Name(Load)NotInName(Load))))))If(Call(Name(Load)Name(Load)Name(Load))Assign(Name(Store)ListComp(Name(Load)comprehension(Name(Store)Attribute(Name(Load)Load)Compare(Name(Load)NotInName(Load)))))Assign(Name(Store)Name(Load)))Assign(Name(Store)Call(Name(Load)Name(Load)Name(Load)Name(Load)Name(Load)))Return(Name(Load))Name(Load)))", "id": "maxhumber_redframes_maxhumber_redframes-redframes-verbs-gather.py_35-79"}
{"title": "maxhumber_redframes-redframes-verbs-gather.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "verbs", "gather.py"], "line_no": 70, "start_line_no": 45, "end_line_no": 79, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        warnings.warn(\n            \"Marked for removal, please use `df.group(...).gather(...)` instead\",\n            FutureWarning,\n        )\n    if not (isinstance(into, tuple) and (len(into) == 2)):\n        raise TypeError(\"must be tuple[str, str]\")\n    if into[0] == into[1]:\n        raise TypeError(\"must be unique\")\n    if isinstance(df, PandasGroupedFrame):\n        if (into[0] in df.obj.columns) or (into[1] in df.obj.columns):  # type: ignore\n            raise ValueError(\"must not be an existing column key\")\n        if columns != None:\n            raise ValueError(\"columns is incompatible with group+gather\")\n        if beside != None:\n            raise ValueError(\"beside is incompatible with group+gather\")\n        df = _grouped_melt(df, into)\n        return df\n    if (into[0] in df.columns) or (into[1] in df.columns):\n        raise ValueError(\"must not be an existing column key\")\n    if (columns != None) and (beside != None):\n        raise ValueError(\"columns OR beside must be None\")\n    if (columns == None) and (beside == None):\n        id_vars = []\n        value_vars = list(df.columns)\n    if isinstance(beside, str):\n        beside = [beside]\n    if isinstance(beside, list):\n        id_vars = beside\n        value_vars = [col for col in df.columns if col not in id_vars]\n    if isinstance(columns, list):\n        id_vars = [col for col in df.columns if col not in columns]\n        value_vars = columns\n    df = _melt(df, id_vars, value_vars, into)  # pyright: ignore[reportUnboundVariable]\n    return df", "id": "maxhumber_redframes_maxhumber_redframes-redframes-verbs-gather.py_45-79"}
{"title": "maxhumber_redframes-redframes-verbs-group.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "verbs", "group.py"], "line_no": 0, "start_line_no": 0, "end_line_no": 10, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "from __future__ import annotations\n\nfrom ..checks import _check_type\nfrom ..types import LazyColumns, PandasDataFrame, PandasGroupedFrame\n\n\ndef group(df: PandasDataFrame, by: LazyColumns) -> PandasGroupedFrame:\n    _check_type(by, {list, str})\n    gdf = df.groupby(by, as_index=False, sort=False)\n    return gdf\n\nAST=Module(ImportFrom(alias)ImportFrom(alias)ImportFrom(aliasaliasalias)FunctionDef(arguments(arg(Name(Load))arg(Name(Load)))Expr(Call(Name(Load)Name(Load)Set(Name(Load)Name(Load))))Assign(Name(Store)Call(Attribute(Name(Load)Load)Name(Load)keyword(Constant)keyword(Constant)))Return(Name(Load))Name(Load)))", "id": "maxhumber_redframes_maxhumber_redframes-redframes-verbs-group.py_0-10"}
{"title": "maxhumber_redframes-redframes-verbs-join.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "verbs", "join.py"], "line_no": 0, "start_line_no": 0, "end_line_no": 25, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "from __future__ import annotations\n\nimport pandas as pd  # pyright: ignore[reportMissingImports]\n\nfrom ..checks import _check_type\nfrom ..types import Join, LazyColumns, PandasDataFrame\n\n\ndef join(\n    lhs: PandasDataFrame,\n    rhs: PandasDataFrame,\n    on: LazyColumns,\n    how: Join = \"left\",\n    postfix: tuple[str, str] = (\"_lhs\", \"_rhs\"),\n) -> PandasDataFrame:\n    _check_type(on, {list, str})\n    _check_type(how, str)\n    _check_type(postfix, tuple)\n    if not how in [\"left\", \"right\", \"inner\", \"full\"]:\n        message = (\n            \"on argument is invalid, must be one of {'left', 'right', 'inner', 'full'}\"\n        )\n        raise ValueError(message)\n    how = \"outer\" if (how == \"full\") else how  # type: ignore\n    df = pd.merge(lhs, rhs, on=on, how=how, suffixes=postfix)\n\nAST=Module(ImportFrom(alias)Import(alias)ImportFrom(alias)ImportFrom(aliasaliasalias)FunctionDef(arguments(arg(Name(Load))arg(Name(Load))arg(Name(Load))arg(Name(Load))arg(Subscript(Name(Load)Tuple(Name(Load)Name(Load)Load)Load))ConstantTuple(ConstantConstantLoad))Expr(Call(Name(Load)Name(Load)Set(Name(Load)Name(Load))))Expr(Call(Name(Load)Name(Load)Name(Load)))Expr(Call(Name(Load)Name(Load)Name(Load)))If(UnaryOp(NotCompare(Name(Load)InList(ConstantConstantConstantConstantLoad)))Assign(Name(Store)Constant)Raise(Call(Name(Load)Name(Load))))Assign(Name(Store)IfExp(Compare(Name(Load)EqConstant)ConstantName(Load)))Assign(Name(Store)Call(Attribute(Name(Load)Load)Name(Load)Name(Load)keyword(Name(Load))keyword(Name(Load))keyword(Name(Load))))Name(Load)))", "id": "maxhumber_redframes_maxhumber_redframes-redframes-verbs-join.py_0-25"}
{"title": "maxhumber_redframes-redframes-verbs-join.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "verbs", "join.py"], "line_no": 10, "start_line_no": 0, "end_line_no": 27, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}, {"fpath_tuple": ["maxhumber_redframes", "redframes", "verbs", "join.py"], "line_no": 20, "start_line_no": 0, "end_line_no": 27, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "from __future__ import annotations\n\nimport pandas as pd  # pyright: ignore[reportMissingImports]\n\nfrom ..checks import _check_type\nfrom ..types import Join, LazyColumns, PandasDataFrame\n\n\ndef join(\n    lhs: PandasDataFrame,\n    rhs: PandasDataFrame,\n    on: LazyColumns,\n    how: Join = \"left\",\n    postfix: tuple[str, str] = (\"_lhs\", \"_rhs\"),\n) -> PandasDataFrame:\n    _check_type(on, {list, str})\n    _check_type(how, str)\n    _check_type(postfix, tuple)\n    if not how in [\"left\", \"right\", \"inner\", \"full\"]:\n        message = (\n            \"on argument is invalid, must be one of {'left', 'right', 'inner', 'full'}\"\n        )\n        raise ValueError(message)\n    how = \"outer\" if (how == \"full\") else how  # type: ignore\n    df = pd.merge(lhs, rhs, on=on, how=how, suffixes=postfix)\n    df = df.reset_index(drop=True)\n    return df\n\nAST=Module(ImportFrom(alias)Import(alias)ImportFrom(alias)ImportFrom(aliasaliasalias)FunctionDef(arguments(arg(Name(Load))arg(Name(Load))arg(Name(Load))arg(Name(Load))arg(Subscript(Name(Load)Tuple(Name(Load)Name(Load)Load)Load))ConstantTuple(ConstantConstantLoad))Expr(Call(Name(Load)Name(Load)Set(Name(Load)Name(Load))))Expr(Call(Name(Load)Name(Load)Name(Load)))Expr(Call(Name(Load)Name(Load)Name(Load)))If(UnaryOp(NotCompare(Name(Load)InList(ConstantConstantConstantConstantLoad)))Assign(Name(Store)Constant)Raise(Call(Name(Load)Name(Load))))Assign(Name(Store)IfExp(Compare(Name(Load)EqConstant)ConstantName(Load)))Assign(Name(Store)Call(Attribute(Name(Load)Load)Name(Load)Name(Load)keyword(Name(Load))keyword(Name(Load))keyword(Name(Load))))Assign(Name(Store)Call(Attribute(Name(Load)Load)keyword(Constant)))Return(Name(Load))Name(Load)))", "id": "maxhumber_redframes_maxhumber_redframes-redframes-verbs-join.py_0-27"}
{"title": "maxhumber_redframes-redframes-verbs-mutate.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "verbs", "mutate.py"], "line_no": 0, "start_line_no": 0, "end_line_no": 12, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}, {"fpath_tuple": ["maxhumber_redframes", "redframes", "verbs", "mutate.py"], "line_no": 10, "start_line_no": 0, "end_line_no": 12, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "from __future__ import annotations\n\nfrom ..checks import _check_type\nfrom ..types import Column, Func, PandasDataFrame\n\n\ndef mutate(df: PandasDataFrame, over: dict[Column, Func]) -> PandasDataFrame:\n    _check_type(over, dict)\n    df = df.copy()\n    for column, mutation in over.items():\n        df[column] = df.apply(mutation, axis=1)\n    return df  # type: ignore\n\nAST=Module(ImportFrom(alias)ImportFrom(alias)ImportFrom(aliasaliasalias)FunctionDef(arguments(arg(Name(Load))arg(Subscript(Name(Load)Tuple(Name(Load)Name(Load)Load)Load)))Expr(Call(Name(Load)Name(Load)Name(Load)))Assign(Name(Store)Call(Attribute(Name(Load)Load)))For(Tuple(Name(Store)Name(Store)Store)Call(Attribute(Name(Load)Load))Assign(Subscript(Name(Load)Name(Load)Store)Call(Attribute(Name(Load)Load)Name(Load)keyword(Constant))))Return(Name(Load))Name(Load)))", "id": "maxhumber_redframes_maxhumber_redframes-redframes-verbs-mutate.py_0-12"}
{"title": "maxhumber_redframes-redframes-verbs-pack.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "verbs", "pack.py"], "line_no": 0, "start_line_no": 0, "end_line_no": 16, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}, {"fpath_tuple": ["maxhumber_redframes", "redframes", "verbs", "pack.py"], "line_no": 10, "start_line_no": 0, "end_line_no": 16, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "from __future__ import annotations\n\nfrom ..checks import _check_type\nfrom ..types import Column, PandasDataFrame, PandasGroupedFrame\n\n\ndef pack(\n    df: PandasDataFrame | PandasGroupedFrame, column: Column, sep: str\n) -> PandasDataFrame:\n    _check_type(column, str)\n    _check_type(sep, str)\n    order = df.obj.columns if isinstance(df, PandasGroupedFrame) else df.columns  # type: ignore\n    df = df.agg(**{column: (column, lambda x: x.astype(str).str.cat(sep=sep))})  # type: ignore\n    df = df[[col for col in df.columns if col in order]]\n    df = df.reset_index(drop=True)\n    return df\n\nAST=Module(ImportFrom(alias)ImportFrom(alias)ImportFrom(aliasaliasalias)FunctionDef(arguments(arg(BinOp(Name(Load)BitOrName(Load)))arg(Name(Load))arg(Name(Load)))Expr(Call(Name(Load)Name(Load)Name(Load)))Expr(Call(Name(Load)Name(Load)Name(Load)))Assign(Name(Store)IfExp(Call(Name(Load)Name(Load)Name(Load))Attribute(Attribute(Name(Load)Load)Load)Attribute(Name(Load)Load)))Assign(Name(Store)Call(Attribute(Name(Load)Load)keyword(Dict(Name(Load)Tuple(Name(Load)Lambda(arguments(arg)Call(Attribute(Attribute(Call(Attribute(Name(Load)Load)Name(Load))Load)Load)keyword(Name(Load))))Load)))))Assign(Name(Store)Subscript(Name(Load)ListComp(Name(Load)comprehension(Name(Store)Attribute(Name(Load)Load)Compare(Name(Load)InName(Load))))Load))Assign(Name(Store)Call(Attribute(Name(Load)Load)keyword(Constant)))Return(Name(Load))Name(Load)))", "id": "maxhumber_redframes_maxhumber_redframes-redframes-verbs-pack.py_0-16"}
{"title": "maxhumber_redframes-redframes-verbs-rank.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "verbs", "rank.py"], "line_no": 0, "start_line_no": 0, "end_line_no": 25, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "from __future__ import annotations\n\nimport warnings\n\nfrom ..checks import _check_type\nfrom ..types import Column, PandasDataFrame, PandasGroupedFrame\n\n\ndef rank(\n    df: PandasDataFrame | PandasGroupedFrame,\n    column: Column,\n    into: Column,\n    descending: bool = False,\n) -> PandasDataFrame:\n    _check_type(column, str)\n    _check_type(into, str)\n    _check_type(descending, bool)\n    if isinstance(df, PandasDataFrame):\n        into_is_not_column = into != column\n        into_is_in_df_columns = into in df.columns\n        if into_is_not_column and into_is_in_df_columns:\n            message = f\"overwriting existing column '{into}'\"\n            warnings.warn(message)\n        df = df.copy()\n    result = df[column].rank(method=\"dense\", ascending=not descending)\n\nAST=Module(ImportFrom(alias)Import(alias)ImportFrom(alias)ImportFrom(aliasaliasalias)FunctionDef(arguments(arg(BinOp(Name(Load)BitOrName(Load)))arg(Name(Load))arg(Name(Load))arg(Name(Load))Constant)Expr(Call(Name(Load)Name(Load)Name(Load)))Expr(Call(Name(Load)Name(Load)Name(Load)))Expr(Call(Name(Load)Name(Load)Name(Load)))If(Call(Name(Load)Name(Load)Name(Load))Assign(Name(Store)Compare(Name(Load)NotEqName(Load)))Assign(Name(Store)Compare(Name(Load)InAttribute(Name(Load)Load)))If(BoolOp(AndName(Load)Name(Load))Assign(Name(Store)JoinedStr(ConstantFormattedValue(Name(Load))Constant))Expr(Call(Attribute(Name(Load)Load)Name(Load))))Assign(Name(Store)Call(Attribute(Name(Load)Load))))Assign(Name(Store)Call(Attribute(Subscript(Name(Load)Name(Load)Load)Load)keyword(Constant)keyword(UnaryOp(NotName(Load)))))Name(Load)))", "id": "maxhumber_redframes_maxhumber_redframes-redframes-verbs-rank.py_0-25"}
{"title": "maxhumber_redframes-redframes-verbs-rank.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "verbs", "rank.py"], "line_no": 10, "start_line_no": 0, "end_line_no": 29, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}, {"fpath_tuple": ["maxhumber_redframes", "redframes", "verbs", "rank.py"], "line_no": 20, "start_line_no": 0, "end_line_no": 29, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "from __future__ import annotations\n\nimport warnings\n\nfrom ..checks import _check_type\nfrom ..types import Column, PandasDataFrame, PandasGroupedFrame\n\n\ndef rank(\n    df: PandasDataFrame | PandasGroupedFrame,\n    column: Column,\n    into: Column,\n    descending: bool = False,\n) -> PandasDataFrame:\n    _check_type(column, str)\n    _check_type(into, str)\n    _check_type(descending, bool)\n    if isinstance(df, PandasDataFrame):\n        into_is_not_column = into != column\n        into_is_in_df_columns = into in df.columns\n        if into_is_not_column and into_is_in_df_columns:\n            message = f\"overwriting existing column '{into}'\"\n            warnings.warn(message)\n        df = df.copy()\n    result = df[column].rank(method=\"dense\", ascending=not descending)\n    if isinstance(df, PandasGroupedFrame):\n        df = df.obj.copy()  # type: ignore\n    df[into] = result  # type: ignore\n    return df  # type: ignore\n\nAST=Module(ImportFrom(alias)Import(alias)ImportFrom(alias)ImportFrom(aliasaliasalias)FunctionDef(arguments(arg(BinOp(Name(Load)BitOrName(Load)))arg(Name(Load))arg(Name(Load))arg(Name(Load))Constant)Expr(Call(Name(Load)Name(Load)Name(Load)))Expr(Call(Name(Load)Name(Load)Name(Load)))Expr(Call(Name(Load)Name(Load)Name(Load)))If(Call(Name(Load)Name(Load)Name(Load))Assign(Name(Store)Compare(Name(Load)NotEqName(Load)))Assign(Name(Store)Compare(Name(Load)InAttribute(Name(Load)Load)))If(BoolOp(AndName(Load)Name(Load))Assign(Name(Store)JoinedStr(ConstantFormattedValue(Name(Load))Constant))Expr(Call(Attribute(Name(Load)Load)Name(Load))))Assign(Name(Store)Call(Attribute(Name(Load)Load))))Assign(Name(Store)Call(Attribute(Subscript(Name(Load)Name(Load)Load)Load)keyword(Constant)keyword(UnaryOp(NotName(Load)))))If(Call(Name(Load)Name(Load)Name(Load))Assign(Name(Store)Call(Attribute(Attribute(Name(Load)Load)Load))))Assign(Subscript(Name(Load)Name(Load)Store)Name(Load))Return(Name(Load))Name(Load)))", "id": "maxhumber_redframes_maxhumber_redframes-redframes-verbs-rank.py_0-29"}
{"title": "maxhumber_redframes-redframes-verbs-rename.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "verbs", "rename.py"], "line_no": 0, "start_line_no": 0, "end_line_no": 17, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}, {"fpath_tuple": ["maxhumber_redframes", "redframes", "verbs", "rename.py"], "line_no": 10, "start_line_no": 0, "end_line_no": 17, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "from ..checks import _check_type, _check_values\nfrom ..types import NewColumn, OldColumn, PandasDataFrame\n\n\ndef rename(df: PandasDataFrame, columns: dict[OldColumn, NewColumn]) -> PandasDataFrame:\n    _check_type(columns, dict)\n    cv = columns.values()\n    _check_values(cv, str)\n    if len(set(cv)) != len(cv):\n        raise KeyError(\"columns must be unique\")\n    missing_keys = set(columns.keys()) - set(df.columns)\n    if missing_keys and len(missing_keys) == 1:\n        raise KeyError(f\"column key ({missing_keys}) is invalid\")\n    if missing_keys and len(missing_keys) > 1:\n        raise KeyError(f\"column keys ({missing_keys}) are invalid\")\n    df = df.rename(columns=columns)\n    return df\n\nAST=Module(ImportFrom(aliasalias)ImportFrom(aliasaliasalias)FunctionDef(arguments(arg(Name(Load))arg(Subscript(Name(Load)Tuple(Name(Load)Name(Load)Load)Load)))Expr(Call(Name(Load)Name(Load)Name(Load)))Assign(Name(Store)Call(Attribute(Name(Load)Load)))Expr(Call(Name(Load)Name(Load)Name(Load)))If(Compare(Call(Name(Load)Call(Name(Load)Name(Load)))NotEqCall(Name(Load)Name(Load)))Raise(Call(Name(Load)Constant)))Assign(Name(Store)BinOp(Call(Name(Load)Call(Attribute(Name(Load)Load)))SubCall(Name(Load)Attribute(Name(Load)Load))))If(BoolOp(AndName(Load)Compare(Call(Name(Load)Name(Load))EqConstant))Raise(Call(Name(Load)JoinedStr(ConstantFormattedValue(Name(Load))Constant))))If(BoolOp(AndName(Load)Compare(Call(Name(Load)Name(Load))GtConstant))Raise(Call(Name(Load)JoinedStr(ConstantFormattedValue(Name(Load))Constant))))Assign(Name(Store)Call(Attribute(Name(Load)Load)keyword(Name(Load))))Return(Name(Load))Name(Load)))", "id": "maxhumber_redframes_maxhumber_redframes-redframes-verbs-rename.py_0-17"}
{"title": "maxhumber_redframes-redframes-verbs-replace.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "verbs", "replace.py"], "line_no": 0, "start_line_no": 0, "end_line_no": 15, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}, {"fpath_tuple": ["maxhumber_redframes", "redframes", "verbs", "replace.py"], "line_no": 10, "start_line_no": 0, "end_line_no": 15, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "from ..checks import _check_type\nfrom ..types import Column, NewValue, OldValue, PandasDataFrame\n\n\ndef replace(\n    df: PandasDataFrame, over: dict[Column, dict[OldValue, NewValue]]\n) -> PandasDataFrame:\n    _check_type(over, dict)\n    bad_columns = list(set(over.keys()) - set(df.columns))\n    if bad_columns and len(bad_columns) == 1:\n        raise KeyError(f\"column key: {bad_columns} is invalid\")\n    if bad_columns and len(bad_columns) > 1:\n        raise KeyError(f\"column keys: {bad_columns} are invalid\")\n    df = df.replace(over)\n    return df\n\nAST=Module(ImportFrom(alias)ImportFrom(aliasaliasaliasalias)FunctionDef(arguments(arg(Name(Load))arg(Subscript(Name(Load)Tuple(Name(Load)Subscript(Name(Load)Tuple(Name(Load)Name(Load)Load)Load)Load)Load)))Expr(Call(Name(Load)Name(Load)Name(Load)))Assign(Name(Store)Call(Name(Load)BinOp(Call(Name(Load)Call(Attribute(Name(Load)Load)))SubCall(Name(Load)Attribute(Name(Load)Load)))))If(BoolOp(AndName(Load)Compare(Call(Name(Load)Name(Load))EqConstant))Raise(Call(Name(Load)JoinedStr(ConstantFormattedValue(Name(Load))Constant))))If(BoolOp(AndName(Load)Compare(Call(Name(Load)Name(Load))GtConstant))Raise(Call(Name(Load)JoinedStr(ConstantFormattedValue(Name(Load))Constant))))Assign(Name(Store)Call(Attribute(Name(Load)Load)Name(Load)))Return(Name(Load))Name(Load)))", "id": "maxhumber_redframes_maxhumber_redframes-redframes-verbs-replace.py_0-15"}
{"title": "maxhumber_redframes-redframes-verbs-rollup.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "verbs", "rollup.py"], "line_no": 0, "start_line_no": 0, "end_line_no": 25, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "from __future__ import annotations\n\nfrom ..checks import _check_type\nfrom ..types import Column, Func, PandasDataFrame, PandasGroupedFrame\n\n\ndef rollup(\n    df: PandasDataFrame | PandasGroupedFrame,\n    over: dict[Column, tuple[Column, Func]],\n) -> PandasDataFrame:\n    _check_type(over, dict)\n    if isinstance(df, PandasGroupedFrame):\n        groups = set(df.grouper.names)  # type: ignore\n        keys = set(over.keys())\n        if groups.intersection(keys):\n            raise KeyError(\"unable to overwrite group keys\")\n        df = df.agg(**over)\n        df = df.reset_index(drop=True)\n    else:\n        df = df.agg(**over)  # type: ignore\n        df = df.T  # type: ignore\n        df = df.reset_index(drop=True)  # type: ignore\n        df = df.fillna(method=\"ffill\")  # type: ignore\n        df = df.fillna(method=\"bfill\")  # type: ignore\n        df = df.head(1)  # type: ignore\n\nAST=Module(ImportFrom(alias)ImportFrom(alias)ImportFrom(aliasaliasaliasalias)FunctionDef(arguments(arg(BinOp(Name(Load)BitOrName(Load)))arg(Subscript(Name(Load)Tuple(Name(Load)Subscript(Name(Load)Tuple(Name(Load)Name(Load)Load)Load)Load)Load)))Expr(Call(Name(Load)Name(Load)Name(Load)))If(Call(Name(Load)Name(Load)Name(Load))Assign(Name(Store)Call(Name(Load)Attribute(Attribute(Name(Load)Load)Load)))Assign(Name(Store)Call(Name(Load)Call(Attribute(Name(Load)Load))))If(Call(Attribute(Name(Load)Load)Name(Load))Raise(Call(Name(Load)Constant)))Assign(Name(Store)Call(Attribute(Name(Load)Load)keyword(Name(Load))))Assign(Name(Store)Call(Attribute(Name(Load)Load)keyword(Constant)))Assign(Name(Store)Call(Attribute(Name(Load)Load)keyword(Name(Load))))Assign(Name(Store)Attribute(Name(Load)Load))Assign(Name(Store)Call(Attribute(Name(Load)Load)keyword(Constant)))Assign(Name(Store)Call(Attribute(Name(Load)Load)keyword(Constant)))Assign(Name(Store)Call(Attribute(Name(Load)Load)keyword(Constant)))Assign(Name(Store)Call(Attribute(Name(Load)Load)Constant)))Name(Load)))", "id": "maxhumber_redframes_maxhumber_redframes-redframes-verbs-rollup.py_0-25"}
{"title": "maxhumber_redframes-redframes-verbs-rollup.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "verbs", "rollup.py"], "line_no": 10, "start_line_no": 0, "end_line_no": 26, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}, {"fpath_tuple": ["maxhumber_redframes", "redframes", "verbs", "rollup.py"], "line_no": 20, "start_line_no": 0, "end_line_no": 26, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "from __future__ import annotations\n\nfrom ..checks import _check_type\nfrom ..types import Column, Func, PandasDataFrame, PandasGroupedFrame\n\n\ndef rollup(\n    df: PandasDataFrame | PandasGroupedFrame,\n    over: dict[Column, tuple[Column, Func]],\n) -> PandasDataFrame:\n    _check_type(over, dict)\n    if isinstance(df, PandasGroupedFrame):\n        groups = set(df.grouper.names)  # type: ignore\n        keys = set(over.keys())\n        if groups.intersection(keys):\n            raise KeyError(\"unable to overwrite group keys\")\n        df = df.agg(**over)\n        df = df.reset_index(drop=True)\n    else:\n        df = df.agg(**over)  # type: ignore\n        df = df.T  # type: ignore\n        df = df.reset_index(drop=True)  # type: ignore\n        df = df.fillna(method=\"ffill\")  # type: ignore\n        df = df.fillna(method=\"bfill\")  # type: ignore\n        df = df.head(1)  # type: ignore\n    return df\n\nAST=Module(ImportFrom(alias)ImportFrom(alias)ImportFrom(aliasaliasaliasalias)FunctionDef(arguments(arg(BinOp(Name(Load)BitOrName(Load)))arg(Subscript(Name(Load)Tuple(Name(Load)Subscript(Name(Load)Tuple(Name(Load)Name(Load)Load)Load)Load)Load)))Expr(Call(Name(Load)Name(Load)Name(Load)))If(Call(Name(Load)Name(Load)Name(Load))Assign(Name(Store)Call(Name(Load)Attribute(Attribute(Name(Load)Load)Load)))Assign(Name(Store)Call(Name(Load)Call(Attribute(Name(Load)Load))))If(Call(Attribute(Name(Load)Load)Name(Load))Raise(Call(Name(Load)Constant)))Assign(Name(Store)Call(Attribute(Name(Load)Load)keyword(Name(Load))))Assign(Name(Store)Call(Attribute(Name(Load)Load)keyword(Constant)))Assign(Name(Store)Call(Attribute(Name(Load)Load)keyword(Name(Load))))Assign(Name(Store)Attribute(Name(Load)Load))Assign(Name(Store)Call(Attribute(Name(Load)Load)keyword(Constant)))Assign(Name(Store)Call(Attribute(Name(Load)Load)keyword(Constant)))Assign(Name(Store)Call(Attribute(Name(Load)Load)keyword(Constant)))Assign(Name(Store)Call(Attribute(Name(Load)Load)Constant)))Return(Name(Load))Name(Load)))", "id": "maxhumber_redframes_maxhumber_redframes-redframes-verbs-rollup.py_0-26"}
{"title": "maxhumber_redframes-redframes-verbs-sample.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "verbs", "sample.py"], "line_no": 0, "start_line_no": 0, "end_line_no": 20, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}, {"fpath_tuple": ["maxhumber_redframes", "redframes", "verbs", "sample.py"], "line_no": 10, "start_line_no": 0, "end_line_no": 20, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "from __future__ import annotations\n\nfrom ..checks import _check_type\nfrom ..types import PandasDataFrame\n\n\ndef sample(\n    df: PandasDataFrame, rows: int | float, seed: int | None = None\n) -> PandasDataFrame:\n    _check_type(rows, {int, float})\n    if rows >= 1:\n        if isinstance(rows, float):\n            raise ValueError(\"must be int if > 1\")\n        df = df.sample(rows, random_state=seed)\n    elif 0 < rows < 1:\n        df = df.sample(frac=rows, random_state=seed)\n    else:\n        raise ValueError(\"must be > 0\")\n    df = df.reset_index(drop=True)\n    return df\n\nAST=Module(ImportFrom(alias)ImportFrom(alias)ImportFrom(alias)FunctionDef(arguments(arg(Name(Load))arg(BinOp(Name(Load)BitOrName(Load)))arg(BinOp(Name(Load)BitOrConstant))Constant)Expr(Call(Name(Load)Name(Load)Set(Name(Load)Name(Load))))If(Compare(Name(Load)GtEConstant)If(Call(Name(Load)Name(Load)Name(Load))Raise(Call(Name(Load)Constant)))Assign(Name(Store)Call(Attribute(Name(Load)Load)Name(Load)keyword(Name(Load))))If(Compare(ConstantLtLtName(Load)Constant)Assign(Name(Store)Call(Attribute(Name(Load)Load)keyword(Name(Load))keyword(Name(Load))))Raise(Call(Name(Load)Constant))))Assign(Name(Store)Call(Attribute(Name(Load)Load)keyword(Constant)))Return(Name(Load))Name(Load)))", "id": "maxhumber_redframes_maxhumber_redframes-redframes-verbs-sample.py_0-20"}
{"title": "maxhumber_redframes-redframes-verbs-select.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "verbs", "select.py"], "line_no": 0, "start_line_no": 0, "end_line_no": 18, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}, {"fpath_tuple": ["maxhumber_redframes", "redframes", "verbs", "select.py"], "line_no": 10, "start_line_no": 0, "end_line_no": 18, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "import pandas as pd  # pyright: ignore[reportMissingImports]\n\nfrom ..checks import _check_type\nfrom ..types import LazyColumns, PandasDataFrame\n\n\ndef select(df: PandasDataFrame, columns: LazyColumns) -> PandasDataFrame:\n    _check_type(columns, {list, str})\n    columns = [columns] if isinstance(columns, str) else columns\n    if len(set(columns)) != len(columns):\n        raise KeyError(f\"column keys must be unique\")\n    bad_columns = list(set(columns) - set(df.columns))\n    if bad_columns and len(bad_columns) == 1:\n        raise KeyError(f\"column key: {bad_columns} is invalid\")\n    if bad_columns and len(bad_columns) > 1:\n        raise KeyError(f\"column keys: {bad_columns} are invalid\")\n    df = df[columns]\n    return df\n\nAST=Module(Import(alias)ImportFrom(alias)ImportFrom(aliasalias)FunctionDef(arguments(arg(Name(Load))arg(Name(Load)))Expr(Call(Name(Load)Name(Load)Set(Name(Load)Name(Load))))Assign(Name(Store)IfExp(Call(Name(Load)Name(Load)Name(Load))List(Name(Load)Load)Name(Load)))If(Compare(Call(Name(Load)Call(Name(Load)Name(Load)))NotEqCall(Name(Load)Name(Load)))Raise(Call(Name(Load)JoinedStr(Constant))))Assign(Name(Store)Call(Name(Load)BinOp(Call(Name(Load)Name(Load))SubCall(Name(Load)Attribute(Name(Load)Load)))))If(BoolOp(AndName(Load)Compare(Call(Name(Load)Name(Load))EqConstant))Raise(Call(Name(Load)JoinedStr(ConstantFormattedValue(Name(Load))Constant))))If(BoolOp(AndName(Load)Compare(Call(Name(Load)Name(Load))GtConstant))Raise(Call(Name(Load)JoinedStr(ConstantFormattedValue(Name(Load))Constant))))Assign(Name(Store)Subscript(Name(Load)Name(Load)Load))Return(Name(Load))Name(Load)))", "id": "maxhumber_redframes_maxhumber_redframes-redframes-verbs-select.py_0-18"}
{"title": "maxhumber_redframes-redframes-verbs-shuffle.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "verbs", "shuffle.py"], "line_no": 0, "start_line_no": 0, "end_line_no": 11, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}, {"fpath_tuple": ["maxhumber_redframes", "redframes", "verbs", "shuffle.py"], "line_no": 10, "start_line_no": 0, "end_line_no": 11, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "from __future__ import annotations\n\nfrom ..checks import _check_type\nfrom ..types import PandasDataFrame\n\n\ndef shuffle(df: PandasDataFrame, seed: int | None = None) -> PandasDataFrame:\n    _check_type(seed, {int, None})\n    df = df.sample(frac=1, random_state=seed)\n    df = df.reset_index(drop=True)\n    return df\n\nAST=Module(ImportFrom(alias)ImportFrom(alias)ImportFrom(alias)FunctionDef(arguments(arg(Name(Load))arg(BinOp(Name(Load)BitOrConstant))Constant)Expr(Call(Name(Load)Name(Load)Set(Name(Load)Constant)))Assign(Name(Store)Call(Attribute(Name(Load)Load)keyword(Constant)keyword(Name(Load))))Assign(Name(Store)Call(Attribute(Name(Load)Load)keyword(Constant)))Return(Name(Load))Name(Load)))", "id": "maxhumber_redframes_maxhumber_redframes-redframes-verbs-shuffle.py_0-11"}
{"title": "maxhumber_redframes-redframes-verbs-sort.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "verbs", "sort.py"], "line_no": 0, "start_line_no": 0, "end_line_no": 15, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}, {"fpath_tuple": ["maxhumber_redframes", "redframes", "verbs", "sort.py"], "line_no": 10, "start_line_no": 0, "end_line_no": 15, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "from __future__ import annotations\n\nfrom ..checks import _check_keys, _check_type\nfrom ..types import LazyColumns, PandasDataFrame\n\n\ndef sort(\n    df: PandasDataFrame, columns: LazyColumns, descending: bool = False\n) -> PandasDataFrame:\n    _check_type(columns, {list, str})\n    _check_type(descending, bool)\n    _check_keys(columns, df.columns)\n    df = df.sort_values(by=columns, ascending=not descending)\n    df = df.reset_index(drop=True)\n    return df\n\nAST=Module(ImportFrom(alias)ImportFrom(aliasalias)ImportFrom(aliasalias)FunctionDef(arguments(arg(Name(Load))arg(Name(Load))arg(Name(Load))Constant)Expr(Call(Name(Load)Name(Load)Set(Name(Load)Name(Load))))Expr(Call(Name(Load)Name(Load)Name(Load)))Expr(Call(Name(Load)Name(Load)Attribute(Name(Load)Load)))Assign(Name(Store)Call(Attribute(Name(Load)Load)keyword(Name(Load))keyword(UnaryOp(NotName(Load)))))Assign(Name(Store)Call(Attribute(Name(Load)Load)keyword(Constant)))Return(Name(Load))Name(Load)))", "id": "maxhumber_redframes_maxhumber_redframes-redframes-verbs-sort.py_0-15"}
{"title": "maxhumber_redframes-redframes-verbs-split.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "verbs", "split.py"], "line_no": 0, "start_line_no": 0, "end_line_no": 25, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "import uuid\n\nfrom ..checks import _check_type\nfrom ..types import Column, Columns, PandasDataFrame\n\n\ndef split(\n    df: PandasDataFrame, column: Column, into: Columns, sep: str, drop: bool = True\n) -> PandasDataFrame:\n    _check_type(column, str)\n    _check_type(into, list)\n    _check_type(sep, str)\n    _check_type(drop, bool)\n    if len(into) != len(set(into)):\n        raise KeyError(\"into keys must be unique\")\n    if (column in into) and (not drop):\n        raise KeyError(\"into keys must be unique\")\n    bad_keys = set(df.columns).difference(set([column])).intersection(set(into))\n    if bad_keys:\n        raise KeyError(\"into keys must be unique\")\n    columns = {uuid.uuid4().hex: col for col in into}\n    temp = list(columns.keys())\n    df = df.copy()\n    df[temp] = df[column].str.split(sep, expand=True)\n    if drop:", "id": "maxhumber_redframes_maxhumber_redframes-redframes-verbs-split.py_0-25"}
{"title": "maxhumber_redframes-redframes-verbs-split.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "verbs", "split.py"], "line_no": 10, "start_line_no": 0, "end_line_no": 28, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}, {"fpath_tuple": ["maxhumber_redframes", "redframes", "verbs", "split.py"], "line_no": 20, "start_line_no": 0, "end_line_no": 28, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "import uuid\n\nfrom ..checks import _check_type\nfrom ..types import Column, Columns, PandasDataFrame\n\n\ndef split(\n    df: PandasDataFrame, column: Column, into: Columns, sep: str, drop: bool = True\n) -> PandasDataFrame:\n    _check_type(column, str)\n    _check_type(into, list)\n    _check_type(sep, str)\n    _check_type(drop, bool)\n    if len(into) != len(set(into)):\n        raise KeyError(\"into keys must be unique\")\n    if (column in into) and (not drop):\n        raise KeyError(\"into keys must be unique\")\n    bad_keys = set(df.columns).difference(set([column])).intersection(set(into))\n    if bad_keys:\n        raise KeyError(\"into keys must be unique\")\n    columns = {uuid.uuid4().hex: col for col in into}\n    temp = list(columns.keys())\n    df = df.copy()\n    df[temp] = df[column].str.split(sep, expand=True)\n    if drop:\n        df = df.drop(column, axis=1)\n    df = df.rename(columns=columns)\n    return df\n\nAST=Module(Import(alias)ImportFrom(alias)ImportFrom(aliasaliasalias)FunctionDef(arguments(arg(Name(Load))arg(Name(Load))arg(Name(Load))arg(Name(Load))arg(Name(Load))Constant)Expr(Call(Name(Load)Name(Load)Name(Load)))Expr(Call(Name(Load)Name(Load)Name(Load)))Expr(Call(Name(Load)Name(Load)Name(Load)))Expr(Call(Name(Load)Name(Load)Name(Load)))If(Compare(Call(Name(Load)Name(Load))NotEqCall(Name(Load)Call(Name(Load)Name(Load))))Raise(Call(Name(Load)Constant)))If(BoolOp(AndCompare(Name(Load)InName(Load))UnaryOp(NotName(Load)))Raise(Call(Name(Load)Constant)))Assign(Name(Store)Call(Attribute(Call(Attribute(Call(Name(Load)Attribute(Name(Load)Load))Load)Call(Name(Load)List(Name(Load)Load)))Load)Call(Name(Load)Name(Load))))If(Name(Load)Raise(Call(Name(Load)Constant)))Assign(Name(Store)DictComp(Attribute(Call(Attribute(Name(Load)Load))Load)Name(Load)comprehension(Name(Store)Name(Load))))Assign(Name(Store)Call(Name(Load)Call(Attribute(Name(Load)Load))))Assign(Name(Store)Call(Attribute(Name(Load)Load)))Assign(Subscript(Name(Load)Name(Load)Store)Call(Attribute(Attribute(Subscript(Name(Load)Name(Load)Load)Load)Load)Name(Load)keyword(Constant)))If(Name(Load)Assign(Name(Store)Call(Attribute(Name(Load)Load)Name(Load)keyword(Constant))))Assign(Name(Store)Call(Attribute(Name(Load)Load)keyword(Name(Load))))Return(Name(Load))Name(Load)))", "id": "maxhumber_redframes_maxhumber_redframes-redframes-verbs-split.py_0-28"}
{"title": "maxhumber_redframes-redframes-verbs-spread.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "verbs", "spread.py"], "line_no": 0, "start_line_no": 0, "end_line_no": 24, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}, {"fpath_tuple": ["maxhumber_redframes", "redframes", "verbs", "spread.py"], "line_no": 10, "start_line_no": 0, "end_line_no": 24, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}, {"fpath_tuple": ["maxhumber_redframes", "redframes", "verbs", "spread.py"], "line_no": 20, "start_line_no": 0, "end_line_no": 24, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "import uuid\n\nimport pandas as pd  # pyright: ignore[reportMissingImports]\n\nfrom ..checks import _check_type\nfrom ..types import Column, PandasDataFrame\n\n\ndef spread(df: PandasDataFrame, column: Column, using: Column) -> PandasDataFrame:\n    _check_type(column, str)\n    _check_type(using, str)\n    if column == using:\n        raise KeyError(\"column and using must be unique\")\n    original_shape = df.shape[1]\n    if original_shape == 2:\n        temp = uuid.uuid4().hex\n        df[temp] = df.groupby(column).cumcount()\n    index = [col for col in df.columns if col not in [column, using]]\n    df = pd.pivot_table(df, index=index, columns=[column], values=[using], aggfunc=\"first\")  # type: ignore\n    df.columns = [col for col in df.columns.get_level_values(1)]  # type: ignore\n    df = df.reset_index().rename_axis(None, axis=0)\n    if original_shape == 2:\n        df = df.drop(temp, axis=1)  # type: ignore\n    return df\n\nAST=Module(Import(alias)Import(alias)ImportFrom(alias)ImportFrom(aliasalias)FunctionDef(arguments(arg(Name(Load))arg(Name(Load))arg(Name(Load)))Expr(Call(Name(Load)Name(Load)Name(Load)))Expr(Call(Name(Load)Name(Load)Name(Load)))If(Compare(Name(Load)EqName(Load))Raise(Call(Name(Load)Constant)))Assign(Name(Store)Subscript(Attribute(Name(Load)Load)ConstantLoad))If(Compare(Name(Load)EqConstant)Assign(Name(Store)Attribute(Call(Attribute(Name(Load)Load))Load))Assign(Subscript(Name(Load)Name(Load)Store)Call(Attribute(Call(Attribute(Name(Load)Load)Name(Load))Load))))Assign(Name(Store)ListComp(Name(Load)comprehension(Name(Store)Attribute(Name(Load)Load)Compare(Name(Load)NotInList(Name(Load)Name(Load)Load)))))Assign(Name(Store)Call(Attribute(Name(Load)Load)Name(Load)keyword(Name(Load))keyword(List(Name(Load)Load))keyword(List(Name(Load)Load))keyword(Constant)))Assign(Attribute(Name(Load)Store)ListComp(Name(Load)comprehension(Name(Store)Call(Attribute(Attribute(Name(Load)Load)Load)Constant))))Assign(Name(Store)Call(Attribute(Call(Attribute(Name(Load)Load))Load)Constantkeyword(Constant)))If(Compare(Name(Load)EqConstant)Assign(Name(Store)Call(Attribute(Name(Load)Load)Name(Load)keyword(Constant))))Return(Name(Load))Name(Load)))", "id": "maxhumber_redframes_maxhumber_redframes-redframes-verbs-spread.py_0-24"}
{"title": "maxhumber_redframes-redframes-verbs-take.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "verbs", "take.py"], "line_no": 0, "start_line_no": 0, "end_line_no": 25, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "from __future__ import annotations\n\nfrom ..checks import _check_type\nfrom ..types import PandasDataFrame, PandasGroupedFrame\n\n\ndef take(\n    df: PandasDataFrame | PandasGroupedFrame, rows: int = 1, **kwargs\n) -> PandasDataFrame:\n    if kwargs:  # compatibility: sklearn / train_test_split\n        df = df.take(rows, **kwargs)  # type: ignore\n        df = df.reset_index(drop=True)\n        return df\n    _check_type(rows, int)\n    if isinstance(df, PandasDataFrame):\n        if rows > df.shape[0]:\n            raise ValueError(\"rows argument is invalid, exceeds total size\")\n    if rows == 0:\n        raise ValueError(\"rows argument is invalid, must not be 0\")\n    if rows <= -1:\n        df = df.tail(rows * -1)\n    else:\n        df = df.head(rows)\n    if isinstance(df, PandasGroupedFrame):\n        df = df.reset_index()\n\nAST=Module(ImportFrom(alias)ImportFrom(alias)ImportFrom(aliasalias)FunctionDef(arguments(arg(BinOp(Name(Load)BitOrName(Load)))arg(Name(Load))argConstant)If(Name(Load)Assign(Name(Store)Call(Attribute(Name(Load)Load)Name(Load)keyword(Name(Load))))Assign(Name(Store)Call(Attribute(Name(Load)Load)keyword(Constant)))Return(Name(Load)))Expr(Call(Name(Load)Name(Load)Name(Load)))If(Call(Name(Load)Name(Load)Name(Load))If(Compare(Name(Load)GtSubscript(Attribute(Name(Load)Load)ConstantLoad))Raise(Call(Name(Load)Constant))))If(Compare(Name(Load)EqConstant)Raise(Call(Name(Load)Constant)))If(Compare(Name(Load)LtEUnaryOp(USubConstant))Assign(Name(Store)Call(Attribute(Name(Load)Load)BinOp(Name(Load)MultUnaryOp(USubConstant))))Assign(Name(Store)Call(Attribute(Name(Load)Load)Name(Load))))If(Call(Name(Load)Name(Load)Name(Load))Assign(Name(Store)Call(Attribute(Name(Load)Load))))Name(Load)))", "id": "maxhumber_redframes_maxhumber_redframes-redframes-verbs-take.py_0-25"}
{"title": "maxhumber_redframes-redframes-verbs-take.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "verbs", "take.py"], "line_no": 10, "start_line_no": 0, "end_line_no": 28, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}, {"fpath_tuple": ["maxhumber_redframes", "redframes", "verbs", "take.py"], "line_no": 20, "start_line_no": 0, "end_line_no": 28, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "from __future__ import annotations\n\nfrom ..checks import _check_type\nfrom ..types import PandasDataFrame, PandasGroupedFrame\n\n\ndef take(\n    df: PandasDataFrame | PandasGroupedFrame, rows: int = 1, **kwargs\n) -> PandasDataFrame:\n    if kwargs:  # compatibility: sklearn / train_test_split\n        df = df.take(rows, **kwargs)  # type: ignore\n        df = df.reset_index(drop=True)\n        return df\n    _check_type(rows, int)\n    if isinstance(df, PandasDataFrame):\n        if rows > df.shape[0]:\n            raise ValueError(\"rows argument is invalid, exceeds total size\")\n    if rows == 0:\n        raise ValueError(\"rows argument is invalid, must not be 0\")\n    if rows <= -1:\n        df = df.tail(rows * -1)\n    else:\n        df = df.head(rows)\n    if isinstance(df, PandasGroupedFrame):\n        df = df.reset_index()\n    else:\n        df = df.reset_index(drop=True)\n    return df\n\nAST=Module(ImportFrom(alias)ImportFrom(alias)ImportFrom(aliasalias)FunctionDef(arguments(arg(BinOp(Name(Load)BitOrName(Load)))arg(Name(Load))argConstant)If(Name(Load)Assign(Name(Store)Call(Attribute(Name(Load)Load)Name(Load)keyword(Name(Load))))Assign(Name(Store)Call(Attribute(Name(Load)Load)keyword(Constant)))Return(Name(Load)))Expr(Call(Name(Load)Name(Load)Name(Load)))If(Call(Name(Load)Name(Load)Name(Load))If(Compare(Name(Load)GtSubscript(Attribute(Name(Load)Load)ConstantLoad))Raise(Call(Name(Load)Constant))))If(Compare(Name(Load)EqConstant)Raise(Call(Name(Load)Constant)))If(Compare(Name(Load)LtEUnaryOp(USubConstant))Assign(Name(Store)Call(Attribute(Name(Load)Load)BinOp(Name(Load)MultUnaryOp(USubConstant))))Assign(Name(Store)Call(Attribute(Name(Load)Load)Name(Load))))If(Call(Name(Load)Name(Load)Name(Load))Assign(Name(Store)Call(Attribute(Name(Load)Load)))Assign(Name(Store)Call(Attribute(Name(Load)Load)keyword(Constant))))Return(Name(Load))Name(Load)))", "id": "maxhumber_redframes_maxhumber_redframes-redframes-verbs-take.py_0-28"}
{"title": "maxhumber_redframes-redframes-verbs-unpack.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "verbs", "unpack.py"], "line_no": 0, "start_line_no": 0, "end_line_no": 13, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}, {"fpath_tuple": ["maxhumber_redframes", "redframes", "verbs", "unpack.py"], "line_no": 10, "start_line_no": 0, "end_line_no": 13, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "from __future__ import annotations\n\nfrom ..checks import _check_type\nfrom ..types import Column, PandasDataFrame\n\n\ndef unpack(df: PandasDataFrame, column: Column, sep: str) -> PandasDataFrame:\n    _check_type(column, str)\n    _check_type(sep, str)\n    df = df.assign(**{column: df[column].str.split(sep)})\n    df = df.explode(column)\n    df = df.reset_index(drop=True)\n    return df\n\nAST=Module(ImportFrom(alias)ImportFrom(alias)ImportFrom(aliasalias)FunctionDef(arguments(arg(Name(Load))arg(Name(Load))arg(Name(Load)))Expr(Call(Name(Load)Name(Load)Name(Load)))Expr(Call(Name(Load)Name(Load)Name(Load)))Assign(Name(Store)Call(Attribute(Name(Load)Load)keyword(Dict(Name(Load)Call(Attribute(Attribute(Subscript(Name(Load)Name(Load)Load)Load)Load)Name(Load))))))Assign(Name(Store)Call(Attribute(Name(Load)Load)Name(Load)))Assign(Name(Store)Call(Attribute(Name(Load)Load)keyword(Constant)))Return(Name(Load))Name(Load)))", "id": "maxhumber_redframes_maxhumber_redframes-redframes-verbs-unpack.py_0-13"}
{"title": "maxhumber_redframes-redframes-verbs-__init__.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "verbs", "__init__.py"], "line_no": 0, "start_line_no": 0, "end_line_no": 25, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "from .accumulate import accumulate\nfrom .append import append\nfrom .combine import combine\nfrom .cross import cross\nfrom .dedupe import dedupe\nfrom .denix import denix\nfrom .drop import drop\nfrom .fill import fill\nfrom .filter import filter\nfrom .gather import gather\nfrom .group import group\nfrom .join import join\nfrom .mutate import mutate\nfrom .pack import pack\nfrom .rank import rank\nfrom .rename import rename\nfrom .replace import replace\nfrom .rollup import rollup\nfrom .sample import sample\nfrom .select import select\nfrom .shuffle import shuffle\nfrom .sort import sort\nfrom .split import split\nfrom .spread import spread\nfrom .take import take\n\nAST=Module(ImportFrom(alias)ImportFrom(alias)ImportFrom(alias)ImportFrom(alias)ImportFrom(alias)ImportFrom(alias)ImportFrom(alias)ImportFrom(alias)ImportFrom(alias)ImportFrom(alias)ImportFrom(alias)ImportFrom(alias)ImportFrom(alias)ImportFrom(alias)ImportFrom(alias)ImportFrom(alias)ImportFrom(alias)ImportFrom(alias)ImportFrom(alias)ImportFrom(alias)ImportFrom(alias)ImportFrom(alias)ImportFrom(alias)ImportFrom(alias)ImportFrom(alias))", "id": "maxhumber_redframes_maxhumber_redframes-redframes-verbs-__init__.py_0-25"}
{"title": "maxhumber_redframes-redframes-verbs-__init__.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "verbs", "__init__.py"], "line_no": 10, "start_line_no": 0, "end_line_no": 26, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}, {"fpath_tuple": ["maxhumber_redframes", "redframes", "verbs", "__init__.py"], "line_no": 20, "start_line_no": 0, "end_line_no": 26, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "from .accumulate import accumulate\nfrom .append import append\nfrom .combine import combine\nfrom .cross import cross\nfrom .dedupe import dedupe\nfrom .denix import denix\nfrom .drop import drop\nfrom .fill import fill\nfrom .filter import filter\nfrom .gather import gather\nfrom .group import group\nfrom .join import join\nfrom .mutate import mutate\nfrom .pack import pack\nfrom .rank import rank\nfrom .rename import rename\nfrom .replace import replace\nfrom .rollup import rollup\nfrom .sample import sample\nfrom .select import select\nfrom .shuffle import shuffle\nfrom .sort import sort\nfrom .split import split\nfrom .spread import spread\nfrom .take import take\nfrom .unpack import unpack\n\nAST=Module(ImportFrom(alias)ImportFrom(alias)ImportFrom(alias)ImportFrom(alias)ImportFrom(alias)ImportFrom(alias)ImportFrom(alias)ImportFrom(alias)ImportFrom(alias)ImportFrom(alias)ImportFrom(alias)ImportFrom(alias)ImportFrom(alias)ImportFrom(alias)ImportFrom(alias)ImportFrom(alias)ImportFrom(alias)ImportFrom(alias)ImportFrom(alias)ImportFrom(alias)ImportFrom(alias)ImportFrom(alias)ImportFrom(alias)ImportFrom(alias)ImportFrom(alias)ImportFrom(alias))", "id": "maxhumber_redframes_maxhumber_redframes-redframes-verbs-__init__.py_0-26"}
{"title": "maxhumber_redframes-tests-test_deprecations.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_deprecations.py"], "line_no": 0, "start_line_no": 0, "end_line_no": 25, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "import unittest\n\nimport redframes as rf\n\n\nclass TestDeprecations(unittest.TestCase):\n    def test_summarize_deprecation(self):\n        df = rf.DataFrame({\"foo\": range(10)})\n        expected = rf.DataFrame({\"foo\": [4.5]})\n        message = \"Marked for removal, please use `rollup` instead\"\n        with self.assertWarnsRegex(FutureWarning, message):\n            result = df.summarize({\"foo\": (\"foo\", rf.stat.mean)})\n            self.assertEqual(result, expected)\n\n    def test_gather_beside_deprecation(self):\n        df = rf.DataFrame({\"foo\": [1, 1, 2, 2], \"bar\": [1, 2, 3, 4]})\n        expected = rf.DataFrame(\n            {\n                \"foo\": [1, 1, 2, 2],\n                \"variable\": [\"bar\", \"bar\", \"bar\", \"bar\"],\n                \"value\": [1, 2, 3, 4],\n            }\n        )\n        with self.assertWarnsRegex(FutureWarning, \"Marked for removal*\"):\n            result = df.gather(beside=\"foo\")\n\nAST=Module(Import(alias)Import(alias)ClassDef(Attribute(Name(Load)Load)FunctionDef(arguments(arg)Assign(Name(Store)Call(Attribute(Name(Load)Load)Dict(ConstantCall(Name(Load)Constant))))Assign(Name(Store)Call(Attribute(Name(Load)Load)Dict(ConstantList(ConstantLoad))))Assign(Name(Store)Constant)With(withitem(Call(Attribute(Name(Load)Load)Name(Load)Name(Load)))Assign(Name(Store)Call(Attribute(Name(Load)Load)Dict(ConstantTuple(ConstantAttribute(Attribute(Name(Load)Load)Load)Load))))Expr(Call(Attribute(Name(Load)Load)Name(Load)Name(Load)))))FunctionDef(arguments(arg)Assign(Name(Store)Call(Attribute(Name(Load)Load)Dict(ConstantConstantList(ConstantConstantConstantConstantLoad)List(ConstantConstantConstantConstantLoad))))Assign(Name(Store)Call(Attribute(Name(Load)Load)Dict(ConstantConstantConstantList(ConstantConstantConstantConstantLoad)List(ConstantConstantConstantConstantLoad)List(ConstantConstantConstantConstantLoad))))With(withitem(Call(Attribute(Name(Load)Load)Name(Load)Constant))Assign(Name(Store)Call(Attribute(Name(Load)Load)keyword(Constant)))))))", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_deprecations.py_0-25"}
{"title": "maxhumber_redframes-tests-test_deprecations.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_deprecations.py"], "line_no": 10, "start_line_no": 0, "end_line_no": 26, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}, {"fpath_tuple": ["maxhumber_redframes", "tests", "test_deprecations.py"], "line_no": 20, "start_line_no": 0, "end_line_no": 26, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "import unittest\n\nimport redframes as rf\n\n\nclass TestDeprecations(unittest.TestCase):\n    def test_summarize_deprecation(self):\n        df = rf.DataFrame({\"foo\": range(10)})\n        expected = rf.DataFrame({\"foo\": [4.5]})\n        message = \"Marked for removal, please use `rollup` instead\"\n        with self.assertWarnsRegex(FutureWarning, message):\n            result = df.summarize({\"foo\": (\"foo\", rf.stat.mean)})\n            self.assertEqual(result, expected)\n\n    def test_gather_beside_deprecation(self):\n        df = rf.DataFrame({\"foo\": [1, 1, 2, 2], \"bar\": [1, 2, 3, 4]})\n        expected = rf.DataFrame(\n            {\n                \"foo\": [1, 1, 2, 2],\n                \"variable\": [\"bar\", \"bar\", \"bar\", \"bar\"],\n                \"value\": [1, 2, 3, 4],\n            }\n        )\n        with self.assertWarnsRegex(FutureWarning, \"Marked for removal*\"):\n            result = df.gather(beside=\"foo\")\n            self.assertEqual(result, expected)\n\nAST=Module(Import(alias)Import(alias)ClassDef(Attribute(Name(Load)Load)FunctionDef(arguments(arg)Assign(Name(Store)Call(Attribute(Name(Load)Load)Dict(ConstantCall(Name(Load)Constant))))Assign(Name(Store)Call(Attribute(Name(Load)Load)Dict(ConstantList(ConstantLoad))))Assign(Name(Store)Constant)With(withitem(Call(Attribute(Name(Load)Load)Name(Load)Name(Load)))Assign(Name(Store)Call(Attribute(Name(Load)Load)Dict(ConstantTuple(ConstantAttribute(Attribute(Name(Load)Load)Load)Load))))Expr(Call(Attribute(Name(Load)Load)Name(Load)Name(Load)))))FunctionDef(arguments(arg)Assign(Name(Store)Call(Attribute(Name(Load)Load)Dict(ConstantConstantList(ConstantConstantConstantConstantLoad)List(ConstantConstantConstantConstantLoad))))Assign(Name(Store)Call(Attribute(Name(Load)Load)Dict(ConstantConstantConstantList(ConstantConstantConstantConstantLoad)List(ConstantConstantConstantConstantLoad)List(ConstantConstantConstantConstantLoad))))With(withitem(Call(Attribute(Name(Load)Load)Name(Load)Constant))Assign(Name(Store)Call(Attribute(Name(Load)Load)keyword(Constant)))Expr(Call(Attribute(Name(Load)Load)Name(Load)Name(Load)))))))", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_deprecations.py_0-26"}
{"title": "maxhumber_redframes-tests-test_docstrings.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_docstrings.py"], "line_no": 0, "start_line_no": 0, "end_line_no": 25, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "import unittest\n\nimport redframes as rf\n\n\nclass TestDocstrings(unittest.TestCase):\n    def test_take(self):\n        df = rf.DataFrame({\"foo\": range(10)})\n        result1 = df.take(1)\n        result2 = df.take(-2)\n        expected1 = rf.DataFrame({\"foo\": [0]})\n        expected2 = rf.DataFrame({\"foo\": [8, 9]})\n        self.assertEqual(result1, expected1)\n        self.assertEqual(result2, expected2)\n\n    def test_accumulate(self):\n        df = rf.DataFrame({\"foo\": [1, 2, 3, 4]})\n        result = df.accumulate(\"foo\", into=\"cumsum\")\n        expected = rf.DataFrame({\"foo\": [1, 2, 3, 4], \"cumsum\": [1, 3, 6, 10]})\n        self.assertEqual(result, expected)\n\n    def test_gather(self):\n        df = rf.DataFrame(\n            {\n                \"foo\": [1, 2, 1, 2],", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_docstrings.py_0-25"}
{"title": "maxhumber_redframes-tests-test_docstrings.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_docstrings.py"], "line_no": 10, "start_line_no": 0, "end_line_no": 35, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "import unittest\n\nimport redframes as rf\n\n\nclass TestDocstrings(unittest.TestCase):\n    def test_take(self):\n        df = rf.DataFrame({\"foo\": range(10)})\n        result1 = df.take(1)\n        result2 = df.take(-2)\n        expected1 = rf.DataFrame({\"foo\": [0]})\n        expected2 = rf.DataFrame({\"foo\": [8, 9]})\n        self.assertEqual(result1, expected1)\n        self.assertEqual(result2, expected2)\n\n    def test_accumulate(self):\n        df = rf.DataFrame({\"foo\": [1, 2, 3, 4]})\n        result = df.accumulate(\"foo\", into=\"cumsum\")\n        expected = rf.DataFrame({\"foo\": [1, 2, 3, 4], \"cumsum\": [1, 3, 6, 10]})\n        self.assertEqual(result, expected)\n\n    def test_gather(self):\n        df = rf.DataFrame(\n            {\n                \"foo\": [1, 2, 1, 2],\n                \"bar\": [\"A\", \"B\", \"C\", \"D\"],\n                \"baz\": [\"!\", \"@\", \"#\", \"$\"],\n                \"jaz\": range(4),\n            }\n        )\n        result1 = df.gather()\n        result2 = df.gather([\"foo\", \"bar\"], into=(\"var\", \"val\"))\n        result3 = df.group([\"foo\", \"bar\"]).gather(into=(\"variable\", \"value\"))\n        expected1 = rf.DataFrame(\n            {", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_docstrings.py_0-35"}
{"title": "maxhumber_redframes-tests-test_docstrings.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_docstrings.py"], "line_no": 20, "start_line_no": 0, "end_line_no": 45, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "import unittest\n\nimport redframes as rf\n\n\nclass TestDocstrings(unittest.TestCase):\n    def test_take(self):\n        df = rf.DataFrame({\"foo\": range(10)})\n        result1 = df.take(1)\n        result2 = df.take(-2)\n        expected1 = rf.DataFrame({\"foo\": [0]})\n        expected2 = rf.DataFrame({\"foo\": [8, 9]})\n        self.assertEqual(result1, expected1)\n        self.assertEqual(result2, expected2)\n\n    def test_accumulate(self):\n        df = rf.DataFrame({\"foo\": [1, 2, 3, 4]})\n        result = df.accumulate(\"foo\", into=\"cumsum\")\n        expected = rf.DataFrame({\"foo\": [1, 2, 3, 4], \"cumsum\": [1, 3, 6, 10]})\n        self.assertEqual(result, expected)\n\n    def test_gather(self):\n        df = rf.DataFrame(\n            {\n                \"foo\": [1, 2, 1, 2],\n                \"bar\": [\"A\", \"B\", \"C\", \"D\"],\n                \"baz\": [\"!\", \"@\", \"#\", \"$\"],\n                \"jaz\": range(4),\n            }\n        )\n        result1 = df.gather()\n        result2 = df.gather([\"foo\", \"bar\"], into=(\"var\", \"val\"))\n        result3 = df.group([\"foo\", \"bar\"]).gather(into=(\"variable\", \"value\"))\n        expected1 = rf.DataFrame(\n            {\n                \"variable\": [\n                    \"foo\",\n                    \"foo\",\n                    \"foo\",\n                    \"foo\",\n                    \"bar\",\n                    \"bar\",\n                    \"bar\",\n                    \"bar\",\n                    \"baz\",", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_docstrings.py_0-45"}
{"title": "maxhumber_redframes-tests-test_docstrings.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_docstrings.py"], "line_no": 30, "start_line_no": 5, "end_line_no": 55, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "class TestDocstrings(unittest.TestCase):\n    def test_take(self):\n        df = rf.DataFrame({\"foo\": range(10)})\n        result1 = df.take(1)\n        result2 = df.take(-2)\n        expected1 = rf.DataFrame({\"foo\": [0]})\n        expected2 = rf.DataFrame({\"foo\": [8, 9]})\n        self.assertEqual(result1, expected1)\n        self.assertEqual(result2, expected2)\n\n    def test_accumulate(self):\n        df = rf.DataFrame({\"foo\": [1, 2, 3, 4]})\n        result = df.accumulate(\"foo\", into=\"cumsum\")\n        expected = rf.DataFrame({\"foo\": [1, 2, 3, 4], \"cumsum\": [1, 3, 6, 10]})\n        self.assertEqual(result, expected)\n\n    def test_gather(self):\n        df = rf.DataFrame(\n            {\n                \"foo\": [1, 2, 1, 2],\n                \"bar\": [\"A\", \"B\", \"C\", \"D\"],\n                \"baz\": [\"!\", \"@\", \"#\", \"$\"],\n                \"jaz\": range(4),\n            }\n        )\n        result1 = df.gather()\n        result2 = df.gather([\"foo\", \"bar\"], into=(\"var\", \"val\"))\n        result3 = df.group([\"foo\", \"bar\"]).gather(into=(\"variable\", \"value\"))\n        expected1 = rf.DataFrame(\n            {\n                \"variable\": [\n                    \"foo\",\n                    \"foo\",\n                    \"foo\",\n                    \"foo\",\n                    \"bar\",\n                    \"bar\",\n                    \"bar\",\n                    \"bar\",\n                    \"baz\",\n                    \"baz\",\n                    \"baz\",\n                    \"baz\",\n                    \"jaz\",\n                    \"jaz\",\n                    \"jaz\",\n                    \"jaz\",\n                ],\n                \"value\": [\n                    1,", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_docstrings.py_5-55"}
{"title": "maxhumber_redframes-tests-test_docstrings.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_docstrings.py"], "line_no": 40, "start_line_no": 15, "end_line_no": 65, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "    def test_accumulate(self):\n        df = rf.DataFrame({\"foo\": [1, 2, 3, 4]})\n        result = df.accumulate(\"foo\", into=\"cumsum\")\n        expected = rf.DataFrame({\"foo\": [1, 2, 3, 4], \"cumsum\": [1, 3, 6, 10]})\n        self.assertEqual(result, expected)\n\n    def test_gather(self):\n        df = rf.DataFrame(\n            {\n                \"foo\": [1, 2, 1, 2],\n                \"bar\": [\"A\", \"B\", \"C\", \"D\"],\n                \"baz\": [\"!\", \"@\", \"#\", \"$\"],\n                \"jaz\": range(4),\n            }\n        )\n        result1 = df.gather()\n        result2 = df.gather([\"foo\", \"bar\"], into=(\"var\", \"val\"))\n        result3 = df.group([\"foo\", \"bar\"]).gather(into=(\"variable\", \"value\"))\n        expected1 = rf.DataFrame(\n            {\n                \"variable\": [\n                    \"foo\",\n                    \"foo\",\n                    \"foo\",\n                    \"foo\",\n                    \"bar\",\n                    \"bar\",\n                    \"bar\",\n                    \"bar\",\n                    \"baz\",\n                    \"baz\",\n                    \"baz\",\n                    \"baz\",\n                    \"jaz\",\n                    \"jaz\",\n                    \"jaz\",\n                    \"jaz\",\n                ],\n                \"value\": [\n                    1,\n                    2,\n                    1,\n                    2,\n                    \"A\",\n                    \"B\",\n                    \"C\",\n                    \"D\",\n                    \"!\",\n                    \"@\",\n                    \"#\",", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_docstrings.py_15-65"}
{"title": "maxhumber_redframes-tests-test_docstrings.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_docstrings.py"], "line_no": 50, "start_line_no": 25, "end_line_no": 75, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "                \"bar\": [\"A\", \"B\", \"C\", \"D\"],\n                \"baz\": [\"!\", \"@\", \"#\", \"$\"],\n                \"jaz\": range(4),\n            }\n        )\n        result1 = df.gather()\n        result2 = df.gather([\"foo\", \"bar\"], into=(\"var\", \"val\"))\n        result3 = df.group([\"foo\", \"bar\"]).gather(into=(\"variable\", \"value\"))\n        expected1 = rf.DataFrame(\n            {\n                \"variable\": [\n                    \"foo\",\n                    \"foo\",\n                    \"foo\",\n                    \"foo\",\n                    \"bar\",\n                    \"bar\",\n                    \"bar\",\n                    \"bar\",\n                    \"baz\",\n                    \"baz\",\n                    \"baz\",\n                    \"baz\",\n                    \"jaz\",\n                    \"jaz\",\n                    \"jaz\",\n                    \"jaz\",\n                ],\n                \"value\": [\n                    1,\n                    2,\n                    1,\n                    2,\n                    \"A\",\n                    \"B\",\n                    \"C\",\n                    \"D\",\n                    \"!\",\n                    \"@\",\n                    \"#\",\n                    \"$\",\n                    0,\n                    1,\n                    2,\n                    3,\n                ],\n            }\n        )\n        expected2 = rf.DataFrame(\n            {", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_docstrings.py_25-75"}
{"title": "maxhumber_redframes-tests-test_docstrings.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_docstrings.py"], "line_no": 60, "start_line_no": 35, "end_line_no": 85, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "                \"variable\": [\n                    \"foo\",\n                    \"foo\",\n                    \"foo\",\n                    \"foo\",\n                    \"bar\",\n                    \"bar\",\n                    \"bar\",\n                    \"bar\",\n                    \"baz\",\n                    \"baz\",\n                    \"baz\",\n                    \"baz\",\n                    \"jaz\",\n                    \"jaz\",\n                    \"jaz\",\n                    \"jaz\",\n                ],\n                \"value\": [\n                    1,\n                    2,\n                    1,\n                    2,\n                    \"A\",\n                    \"B\",\n                    \"C\",\n                    \"D\",\n                    \"!\",\n                    \"@\",\n                    \"#\",\n                    \"$\",\n                    0,\n                    1,\n                    2,\n                    3,\n                ],\n            }\n        )\n        expected2 = rf.DataFrame(\n            {\n                \"baz\": [\"!\", \"@\", \"#\", \"$\", \"!\", \"@\", \"#\", \"$\"],\n                \"jaz\": [0, 1, 2, 3, 0, 1, 2, 3],\n                \"var\": [\"foo\", \"foo\", \"foo\", \"foo\", \"bar\", \"bar\", \"bar\", \"bar\"],\n                \"val\": [1, 2, 1, 2, \"A\", \"B\", \"C\", \"D\"],\n            }\n        )\n        expected3 = rf.DataFrame(\n            {\n                \"foo\": [1, 2, 1, 2, 1, 2, 1, 2],\n                \"bar\": [\"A\", \"B\", \"C\", \"D\", \"A\", \"B\", \"C\", \"D\"],", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_docstrings.py_35-85"}
{"title": "maxhumber_redframes-tests-test_docstrings.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_docstrings.py"], "line_no": 70, "start_line_no": 45, "end_line_no": 95, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "                    \"baz\",\n                    \"baz\",\n                    \"baz\",\n                    \"jaz\",\n                    \"jaz\",\n                    \"jaz\",\n                    \"jaz\",\n                ],\n                \"value\": [\n                    1,\n                    2,\n                    1,\n                    2,\n                    \"A\",\n                    \"B\",\n                    \"C\",\n                    \"D\",\n                    \"!\",\n                    \"@\",\n                    \"#\",\n                    \"$\",\n                    0,\n                    1,\n                    2,\n                    3,\n                ],\n            }\n        )\n        expected2 = rf.DataFrame(\n            {\n                \"baz\": [\"!\", \"@\", \"#\", \"$\", \"!\", \"@\", \"#\", \"$\"],\n                \"jaz\": [0, 1, 2, 3, 0, 1, 2, 3],\n                \"var\": [\"foo\", \"foo\", \"foo\", \"foo\", \"bar\", \"bar\", \"bar\", \"bar\"],\n                \"val\": [1, 2, 1, 2, \"A\", \"B\", \"C\", \"D\"],\n            }\n        )\n        expected3 = rf.DataFrame(\n            {\n                \"foo\": [1, 2, 1, 2, 1, 2, 1, 2],\n                \"bar\": [\"A\", \"B\", \"C\", \"D\", \"A\", \"B\", \"C\", \"D\"],\n                \"variable\": [\"baz\", \"baz\", \"baz\", \"baz\", \"jaz\", \"jaz\", \"jaz\", \"jaz\"],\n                \"value\": [\"!\", \"@\", \"#\", \"$\", 0, 1, 2, 3],\n            }\n        )\n        self.assertEqual(result1, expected1)\n        self.assertEqual(result2, expected2)\n        self.assertEqual(result3, expected3)\n\n    def test_pack(self):\n        df = rf.DataFrame(", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_docstrings.py_45-95"}
{"title": "maxhumber_redframes-tests-test_docstrings.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_docstrings.py"], "line_no": 80, "start_line_no": 55, "end_line_no": 105, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "                    2,\n                    1,\n                    2,\n                    \"A\",\n                    \"B\",\n                    \"C\",\n                    \"D\",\n                    \"!\",\n                    \"@\",\n                    \"#\",\n                    \"$\",\n                    0,\n                    1,\n                    2,\n                    3,\n                ],\n            }\n        )\n        expected2 = rf.DataFrame(\n            {\n                \"baz\": [\"!\", \"@\", \"#\", \"$\", \"!\", \"@\", \"#\", \"$\"],\n                \"jaz\": [0, 1, 2, 3, 0, 1, 2, 3],\n                \"var\": [\"foo\", \"foo\", \"foo\", \"foo\", \"bar\", \"bar\", \"bar\", \"bar\"],\n                \"val\": [1, 2, 1, 2, \"A\", \"B\", \"C\", \"D\"],\n            }\n        )\n        expected3 = rf.DataFrame(\n            {\n                \"foo\": [1, 2, 1, 2, 1, 2, 1, 2],\n                \"bar\": [\"A\", \"B\", \"C\", \"D\", \"A\", \"B\", \"C\", \"D\"],\n                \"variable\": [\"baz\", \"baz\", \"baz\", \"baz\", \"jaz\", \"jaz\", \"jaz\", \"jaz\"],\n                \"value\": [\"!\", \"@\", \"#\", \"$\", 0, 1, 2, 3],\n            }\n        )\n        self.assertEqual(result1, expected1)\n        self.assertEqual(result2, expected2)\n        self.assertEqual(result3, expected3)\n\n    def test_pack(self):\n        df = rf.DataFrame(\n            {\"foo\": [\"A\", \"A\", \"B\", \"A\", \"B\", \"C\"], \"bar\": [1, 2, 3, 4, 5, 6]}\n        )\n        result1 = df.pack(\"foo\", sep=\"+\")\n        result2 = df.group(\"foo\").pack(\"bar\", sep=\"|\")\n        expected1 = rf.DataFrame({\"foo\": [\"A+A+B+A+B+C\"]})\n        expected2 = rf.DataFrame({\"foo\": [\"A\", \"B\", \"C\"], \"bar\": [\"1|2|4\", \"3|5\", \"6\"]})\n        self.assertEqual(result1, expected1)\n        self.assertEqual(result2, expected2)\n\n    def test_rank(self):", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_docstrings.py_55-105"}
{"title": "maxhumber_redframes-tests-test_docstrings.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_docstrings.py"], "line_no": 90, "start_line_no": 65, "end_line_no": 115, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "                    \"$\",\n                    0,\n                    1,\n                    2,\n                    3,\n                ],\n            }\n        )\n        expected2 = rf.DataFrame(\n            {\n                \"baz\": [\"!\", \"@\", \"#\", \"$\", \"!\", \"@\", \"#\", \"$\"],\n                \"jaz\": [0, 1, 2, 3, 0, 1, 2, 3],\n                \"var\": [\"foo\", \"foo\", \"foo\", \"foo\", \"bar\", \"bar\", \"bar\", \"bar\"],\n                \"val\": [1, 2, 1, 2, \"A\", \"B\", \"C\", \"D\"],\n            }\n        )\n        expected3 = rf.DataFrame(\n            {\n                \"foo\": [1, 2, 1, 2, 1, 2, 1, 2],\n                \"bar\": [\"A\", \"B\", \"C\", \"D\", \"A\", \"B\", \"C\", \"D\"],\n                \"variable\": [\"baz\", \"baz\", \"baz\", \"baz\", \"jaz\", \"jaz\", \"jaz\", \"jaz\"],\n                \"value\": [\"!\", \"@\", \"#\", \"$\", 0, 1, 2, 3],\n            }\n        )\n        self.assertEqual(result1, expected1)\n        self.assertEqual(result2, expected2)\n        self.assertEqual(result3, expected3)\n\n    def test_pack(self):\n        df = rf.DataFrame(\n            {\"foo\": [\"A\", \"A\", \"B\", \"A\", \"B\", \"C\"], \"bar\": [1, 2, 3, 4, 5, 6]}\n        )\n        result1 = df.pack(\"foo\", sep=\"+\")\n        result2 = df.group(\"foo\").pack(\"bar\", sep=\"|\")\n        expected1 = rf.DataFrame({\"foo\": [\"A+A+B+A+B+C\"]})\n        expected2 = rf.DataFrame({\"foo\": [\"A\", \"B\", \"C\"], \"bar\": [\"1|2|4\", \"3|5\", \"6\"]})\n        self.assertEqual(result1, expected1)\n        self.assertEqual(result2, expected2)\n\n    def test_rank(self):\n        df = rf.DataFrame({\"foo\": [2, 3, 3, 99, 1000, 1, -6, 4]})\n        result = df.rank(\"foo\", into=\"rank\", descending=True)\n        expected = rf.DataFrame(\n            {\"foo\": [2, 3, 3, 99, 1000, 1, -6, 4], \"rank\": [5.0, 4, 4, 2, 1, 6, 7, 3]}\n        )\n        self.assertEqual(result, expected)\n\n    def test_rollup(self):\n        df = rf.DataFrame({\"foo\": [1, 2, 3, 4, 5], \"bar\": [99, 100, 1, -5, 2]})\n        result = df.rollup(", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_docstrings.py_65-115"}
{"title": "maxhumber_redframes-tests-test_docstrings.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_docstrings.py"], "line_no": 100, "start_line_no": 75, "end_line_no": 125, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "                \"baz\": [\"!\", \"@\", \"#\", \"$\", \"!\", \"@\", \"#\", \"$\"],\n                \"jaz\": [0, 1, 2, 3, 0, 1, 2, 3],\n                \"var\": [\"foo\", \"foo\", \"foo\", \"foo\", \"bar\", \"bar\", \"bar\", \"bar\"],\n                \"val\": [1, 2, 1, 2, \"A\", \"B\", \"C\", \"D\"],\n            }\n        )\n        expected3 = rf.DataFrame(\n            {\n                \"foo\": [1, 2, 1, 2, 1, 2, 1, 2],\n                \"bar\": [\"A\", \"B\", \"C\", \"D\", \"A\", \"B\", \"C\", \"D\"],\n                \"variable\": [\"baz\", \"baz\", \"baz\", \"baz\", \"jaz\", \"jaz\", \"jaz\", \"jaz\"],\n                \"value\": [\"!\", \"@\", \"#\", \"$\", 0, 1, 2, 3],\n            }\n        )\n        self.assertEqual(result1, expected1)\n        self.assertEqual(result2, expected2)\n        self.assertEqual(result3, expected3)\n\n    def test_pack(self):\n        df = rf.DataFrame(\n            {\"foo\": [\"A\", \"A\", \"B\", \"A\", \"B\", \"C\"], \"bar\": [1, 2, 3, 4, 5, 6]}\n        )\n        result1 = df.pack(\"foo\", sep=\"+\")\n        result2 = df.group(\"foo\").pack(\"bar\", sep=\"|\")\n        expected1 = rf.DataFrame({\"foo\": [\"A+A+B+A+B+C\"]})\n        expected2 = rf.DataFrame({\"foo\": [\"A\", \"B\", \"C\"], \"bar\": [\"1|2|4\", \"3|5\", \"6\"]})\n        self.assertEqual(result1, expected1)\n        self.assertEqual(result2, expected2)\n\n    def test_rank(self):\n        df = rf.DataFrame({\"foo\": [2, 3, 3, 99, 1000, 1, -6, 4]})\n        result = df.rank(\"foo\", into=\"rank\", descending=True)\n        expected = rf.DataFrame(\n            {\"foo\": [2, 3, 3, 99, 1000, 1, -6, 4], \"rank\": [5.0, 4, 4, 2, 1, 6, 7, 3]}\n        )\n        self.assertEqual(result, expected)\n\n    def test_rollup(self):\n        df = rf.DataFrame({\"foo\": [1, 2, 3, 4, 5], \"bar\": [99, 100, 1, -5, 2]})\n        result = df.rollup(\n            {\n                \"fcount\": (\"foo\", rf.stat.count),\n                \"fmean\": (\"foo\", rf.stat.mean),\n                \"fsum\": (\"foo\", rf.stat.sum),\n                \"fmax\": (\"foo\", rf.stat.max),\n                \"bmedian\": (\"bar\", rf.stat.median),\n                \"bmin\": (\"bar\", rf.stat.min),\n                \"bstd\": (\"bar\", rf.stat.std),\n            }\n        )", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_docstrings.py_75-125"}
{"title": "maxhumber_redframes-tests-test_docstrings.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_docstrings.py"], "line_no": 110, "start_line_no": 85, "end_line_no": 135, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "                \"variable\": [\"baz\", \"baz\", \"baz\", \"baz\", \"jaz\", \"jaz\", \"jaz\", \"jaz\"],\n                \"value\": [\"!\", \"@\", \"#\", \"$\", 0, 1, 2, 3],\n            }\n        )\n        self.assertEqual(result1, expected1)\n        self.assertEqual(result2, expected2)\n        self.assertEqual(result3, expected3)\n\n    def test_pack(self):\n        df = rf.DataFrame(\n            {\"foo\": [\"A\", \"A\", \"B\", \"A\", \"B\", \"C\"], \"bar\": [1, 2, 3, 4, 5, 6]}\n        )\n        result1 = df.pack(\"foo\", sep=\"+\")\n        result2 = df.group(\"foo\").pack(\"bar\", sep=\"|\")\n        expected1 = rf.DataFrame({\"foo\": [\"A+A+B+A+B+C\"]})\n        expected2 = rf.DataFrame({\"foo\": [\"A\", \"B\", \"C\"], \"bar\": [\"1|2|4\", \"3|5\", \"6\"]})\n        self.assertEqual(result1, expected1)\n        self.assertEqual(result2, expected2)\n\n    def test_rank(self):\n        df = rf.DataFrame({\"foo\": [2, 3, 3, 99, 1000, 1, -6, 4]})\n        result = df.rank(\"foo\", into=\"rank\", descending=True)\n        expected = rf.DataFrame(\n            {\"foo\": [2, 3, 3, 99, 1000, 1, -6, 4], \"rank\": [5.0, 4, 4, 2, 1, 6, 7, 3]}\n        )\n        self.assertEqual(result, expected)\n\n    def test_rollup(self):\n        df = rf.DataFrame({\"foo\": [1, 2, 3, 4, 5], \"bar\": [99, 100, 1, -5, 2]})\n        result = df.rollup(\n            {\n                \"fcount\": (\"foo\", rf.stat.count),\n                \"fmean\": (\"foo\", rf.stat.mean),\n                \"fsum\": (\"foo\", rf.stat.sum),\n                \"fmax\": (\"foo\", rf.stat.max),\n                \"bmedian\": (\"bar\", rf.stat.median),\n                \"bmin\": (\"bar\", rf.stat.min),\n                \"bstd\": (\"bar\", rf.stat.std),\n            }\n        )\n        expected = rf.DataFrame(\n            {\n                \"fcount\": [5.0],\n                \"fmean\": [3.0],\n                \"fsum\": [15.0],\n                \"fmax\": [5.0],\n                \"bmedian\": [2.0],\n                \"bmin\": [-5.0],\n                \"bstd\": [54.929955397760885],\n            }", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_docstrings.py_85-135"}
{"title": "maxhumber_redframes-tests-test_docstrings.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_docstrings.py"], "line_no": 120, "start_line_no": 95, "end_line_no": 145, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "            {\"foo\": [\"A\", \"A\", \"B\", \"A\", \"B\", \"C\"], \"bar\": [1, 2, 3, 4, 5, 6]}\n        )\n        result1 = df.pack(\"foo\", sep=\"+\")\n        result2 = df.group(\"foo\").pack(\"bar\", sep=\"|\")\n        expected1 = rf.DataFrame({\"foo\": [\"A+A+B+A+B+C\"]})\n        expected2 = rf.DataFrame({\"foo\": [\"A\", \"B\", \"C\"], \"bar\": [\"1|2|4\", \"3|5\", \"6\"]})\n        self.assertEqual(result1, expected1)\n        self.assertEqual(result2, expected2)\n\n    def test_rank(self):\n        df = rf.DataFrame({\"foo\": [2, 3, 3, 99, 1000, 1, -6, 4]})\n        result = df.rank(\"foo\", into=\"rank\", descending=True)\n        expected = rf.DataFrame(\n            {\"foo\": [2, 3, 3, 99, 1000, 1, -6, 4], \"rank\": [5.0, 4, 4, 2, 1, 6, 7, 3]}\n        )\n        self.assertEqual(result, expected)\n\n    def test_rollup(self):\n        df = rf.DataFrame({\"foo\": [1, 2, 3, 4, 5], \"bar\": [99, 100, 1, -5, 2]})\n        result = df.rollup(\n            {\n                \"fcount\": (\"foo\", rf.stat.count),\n                \"fmean\": (\"foo\", rf.stat.mean),\n                \"fsum\": (\"foo\", rf.stat.sum),\n                \"fmax\": (\"foo\", rf.stat.max),\n                \"bmedian\": (\"bar\", rf.stat.median),\n                \"bmin\": (\"bar\", rf.stat.min),\n                \"bstd\": (\"bar\", rf.stat.std),\n            }\n        )\n        expected = rf.DataFrame(\n            {\n                \"fcount\": [5.0],\n                \"fmean\": [3.0],\n                \"fsum\": [15.0],\n                \"fmax\": [5.0],\n                \"bmedian\": [2.0],\n                \"bmin\": [-5.0],\n                \"bstd\": [54.929955397760885],\n            }\n        )\n        self.assertEqual(result, expected)\n\n    def test_init(self):\n        rf.DataFrame({\"foo\": [1, 2], \"bar\": [\"A\", \"B\"]})\n        self.assertTrue(True)\n\n    def test_eq(self):\n        adf = rf.DataFrame({\"foo\": [1]})\n        bdf = rf.DataFrame({\"bar\": [1]})", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_docstrings.py_95-145"}
{"title": "maxhumber_redframes-tests-test_docstrings.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_docstrings.py"], "line_no": 130, "start_line_no": 105, "end_line_no": 155, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        df = rf.DataFrame({\"foo\": [2, 3, 3, 99, 1000, 1, -6, 4]})\n        result = df.rank(\"foo\", into=\"rank\", descending=True)\n        expected = rf.DataFrame(\n            {\"foo\": [2, 3, 3, 99, 1000, 1, -6, 4], \"rank\": [5.0, 4, 4, 2, 1, 6, 7, 3]}\n        )\n        self.assertEqual(result, expected)\n\n    def test_rollup(self):\n        df = rf.DataFrame({\"foo\": [1, 2, 3, 4, 5], \"bar\": [99, 100, 1, -5, 2]})\n        result = df.rollup(\n            {\n                \"fcount\": (\"foo\", rf.stat.count),\n                \"fmean\": (\"foo\", rf.stat.mean),\n                \"fsum\": (\"foo\", rf.stat.sum),\n                \"fmax\": (\"foo\", rf.stat.max),\n                \"bmedian\": (\"bar\", rf.stat.median),\n                \"bmin\": (\"bar\", rf.stat.min),\n                \"bstd\": (\"bar\", rf.stat.std),\n            }\n        )\n        expected = rf.DataFrame(\n            {\n                \"fcount\": [5.0],\n                \"fmean\": [3.0],\n                \"fsum\": [15.0],\n                \"fmax\": [5.0],\n                \"bmedian\": [2.0],\n                \"bmin\": [-5.0],\n                \"bstd\": [54.929955397760885],\n            }\n        )\n        self.assertEqual(result, expected)\n\n    def test_init(self):\n        rf.DataFrame({\"foo\": [1, 2], \"bar\": [\"A\", \"B\"]})\n        self.assertTrue(True)\n\n    def test_eq(self):\n        adf = rf.DataFrame({\"foo\": [1]})\n        bdf = rf.DataFrame({\"bar\": [1]})\n        cdf = rf.DataFrame({\"foo\": [1]})\n        self.assertFalse(adf == bdf)\n        self.assertTrue(adf == cdf)\n\n    def test_getitem(self):\n        df = rf.DataFrame({\"foo\": [1, 2], \"bar\": [\"A\", \"B\"]})\n        result = df[\"foo\"]\n        expected = [1, 2]\n        self.assertEqual(result, expected)\n", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_docstrings.py_105-155"}
{"title": "maxhumber_redframes-tests-test_docstrings.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_docstrings.py"], "line_no": 140, "start_line_no": 115, "end_line_no": 165, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "            {\n                \"fcount\": (\"foo\", rf.stat.count),\n                \"fmean\": (\"foo\", rf.stat.mean),\n                \"fsum\": (\"foo\", rf.stat.sum),\n                \"fmax\": (\"foo\", rf.stat.max),\n                \"bmedian\": (\"bar\", rf.stat.median),\n                \"bmin\": (\"bar\", rf.stat.min),\n                \"bstd\": (\"bar\", rf.stat.std),\n            }\n        )\n        expected = rf.DataFrame(\n            {\n                \"fcount\": [5.0],\n                \"fmean\": [3.0],\n                \"fsum\": [15.0],\n                \"fmax\": [5.0],\n                \"bmedian\": [2.0],\n                \"bmin\": [-5.0],\n                \"bstd\": [54.929955397760885],\n            }\n        )\n        self.assertEqual(result, expected)\n\n    def test_init(self):\n        rf.DataFrame({\"foo\": [1, 2], \"bar\": [\"A\", \"B\"]})\n        self.assertTrue(True)\n\n    def test_eq(self):\n        adf = rf.DataFrame({\"foo\": [1]})\n        bdf = rf.DataFrame({\"bar\": [1]})\n        cdf = rf.DataFrame({\"foo\": [1]})\n        self.assertFalse(adf == bdf)\n        self.assertTrue(adf == cdf)\n\n    def test_getitem(self):\n        df = rf.DataFrame({\"foo\": [1, 2], \"bar\": [\"A\", \"B\"]})\n        result = df[\"foo\"]\n        expected = [1, 2]\n        self.assertEqual(result, expected)\n\n    def test_str(self):\n        df = rf.DataFrame({\"foo\": [1, 2], \"bar\": [\"A\", \"B\"]})\n        result = str(df)\n        expected = \"rf.DataFrame({'foo': [1, 2], 'bar': ['A', 'B']})\"\n        self.assertEqual(result, expected)\n\n    def test_columns(self):\n        df = rf.DataFrame({\"foo\": [1, 2], \"bar\": [\"A\", \"B\"], \"baz\": [True, False]})\n        result = df.columns\n        expected = [\"foo\", \"bar\", \"baz\"]", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_docstrings.py_115-165"}
{"title": "maxhumber_redframes-tests-test_docstrings.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_docstrings.py"], "line_no": 150, "start_line_no": 125, "end_line_no": 175, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        expected = rf.DataFrame(\n            {\n                \"fcount\": [5.0],\n                \"fmean\": [3.0],\n                \"fsum\": [15.0],\n                \"fmax\": [5.0],\n                \"bmedian\": [2.0],\n                \"bmin\": [-5.0],\n                \"bstd\": [54.929955397760885],\n            }\n        )\n        self.assertEqual(result, expected)\n\n    def test_init(self):\n        rf.DataFrame({\"foo\": [1, 2], \"bar\": [\"A\", \"B\"]})\n        self.assertTrue(True)\n\n    def test_eq(self):\n        adf = rf.DataFrame({\"foo\": [1]})\n        bdf = rf.DataFrame({\"bar\": [1]})\n        cdf = rf.DataFrame({\"foo\": [1]})\n        self.assertFalse(adf == bdf)\n        self.assertTrue(adf == cdf)\n\n    def test_getitem(self):\n        df = rf.DataFrame({\"foo\": [1, 2], \"bar\": [\"A\", \"B\"]})\n        result = df[\"foo\"]\n        expected = [1, 2]\n        self.assertEqual(result, expected)\n\n    def test_str(self):\n        df = rf.DataFrame({\"foo\": [1, 2], \"bar\": [\"A\", \"B\"]})\n        result = str(df)\n        expected = \"rf.DataFrame({'foo': [1, 2], 'bar': ['A', 'B']})\"\n        self.assertEqual(result, expected)\n\n    def test_columns(self):\n        df = rf.DataFrame({\"foo\": [1, 2], \"bar\": [\"A\", \"B\"], \"baz\": [True, False]})\n        result = df.columns\n        expected = [\"foo\", \"bar\", \"baz\"]\n        self.assertEqual(result, expected)\n\n    def test_dimensions(self):\n        df = rf.DataFrame({\"foo\": range(10), \"bar\": range(10, 20)})\n        result = df.dimensions\n        expected = {\"rows\": 10, \"columns\": 2}\n        self.assertEqual(result, expected)\n\n    def test_empty(self):\n        df = rf.DataFrame()", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_docstrings.py_125-175"}
{"title": "maxhumber_redframes-tests-test_docstrings.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_docstrings.py"], "line_no": 160, "start_line_no": 135, "end_line_no": 185, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        )\n        self.assertEqual(result, expected)\n\n    def test_init(self):\n        rf.DataFrame({\"foo\": [1, 2], \"bar\": [\"A\", \"B\"]})\n        self.assertTrue(True)\n\n    def test_eq(self):\n        adf = rf.DataFrame({\"foo\": [1]})\n        bdf = rf.DataFrame({\"bar\": [1]})\n        cdf = rf.DataFrame({\"foo\": [1]})\n        self.assertFalse(adf == bdf)\n        self.assertTrue(adf == cdf)\n\n    def test_getitem(self):\n        df = rf.DataFrame({\"foo\": [1, 2], \"bar\": [\"A\", \"B\"]})\n        result = df[\"foo\"]\n        expected = [1, 2]\n        self.assertEqual(result, expected)\n\n    def test_str(self):\n        df = rf.DataFrame({\"foo\": [1, 2], \"bar\": [\"A\", \"B\"]})\n        result = str(df)\n        expected = \"rf.DataFrame({'foo': [1, 2], 'bar': ['A', 'B']})\"\n        self.assertEqual(result, expected)\n\n    def test_columns(self):\n        df = rf.DataFrame({\"foo\": [1, 2], \"bar\": [\"A\", \"B\"], \"baz\": [True, False]})\n        result = df.columns\n        expected = [\"foo\", \"bar\", \"baz\"]\n        self.assertEqual(result, expected)\n\n    def test_dimensions(self):\n        df = rf.DataFrame({\"foo\": range(10), \"bar\": range(10, 20)})\n        result = df.dimensions\n        expected = {\"rows\": 10, \"columns\": 2}\n        self.assertEqual(result, expected)\n\n    def test_empty(self):\n        df = rf.DataFrame()\n        result = df.empty\n        expected = True\n        self.assertEqual(result, expected)\n\n    def test_memory(self):\n        df = rf.DataFrame({\"foo\": [1, 2, 3], \"bar\": [\"A\", \"B\", \"C\"]})\n        result = df.memory\n        expected = \"326 B\"\n        self.assertEqual(result, expected)\n", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_docstrings.py_135-185"}
{"title": "maxhumber_redframes-tests-test_docstrings.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_docstrings.py"], "line_no": 170, "start_line_no": 145, "end_line_no": 195, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        cdf = rf.DataFrame({\"foo\": [1]})\n        self.assertFalse(adf == bdf)\n        self.assertTrue(adf == cdf)\n\n    def test_getitem(self):\n        df = rf.DataFrame({\"foo\": [1, 2], \"bar\": [\"A\", \"B\"]})\n        result = df[\"foo\"]\n        expected = [1, 2]\n        self.assertEqual(result, expected)\n\n    def test_str(self):\n        df = rf.DataFrame({\"foo\": [1, 2], \"bar\": [\"A\", \"B\"]})\n        result = str(df)\n        expected = \"rf.DataFrame({'foo': [1, 2], 'bar': ['A', 'B']})\"\n        self.assertEqual(result, expected)\n\n    def test_columns(self):\n        df = rf.DataFrame({\"foo\": [1, 2], \"bar\": [\"A\", \"B\"], \"baz\": [True, False]})\n        result = df.columns\n        expected = [\"foo\", \"bar\", \"baz\"]\n        self.assertEqual(result, expected)\n\n    def test_dimensions(self):\n        df = rf.DataFrame({\"foo\": range(10), \"bar\": range(10, 20)})\n        result = df.dimensions\n        expected = {\"rows\": 10, \"columns\": 2}\n        self.assertEqual(result, expected)\n\n    def test_empty(self):\n        df = rf.DataFrame()\n        result = df.empty\n        expected = True\n        self.assertEqual(result, expected)\n\n    def test_memory(self):\n        df = rf.DataFrame({\"foo\": [1, 2, 3], \"bar\": [\"A\", \"B\", \"C\"]})\n        result = df.memory\n        expected = \"326 B\"\n        self.assertEqual(result, expected)\n\n    def test_types(self):\n        df = rf.DataFrame({\"foo\": [1, 2], \"bar\": [\"A\", \"B\"], \"baz\": [True, False]})\n        result = df.types\n        expected = {\"foo\": int, \"bar\": object, \"baz\": bool}\n        self.assertEqual(result, expected)\n\n    def test_append(self):\n        df1 = rf.DataFrame({\"foo\": [1, 2], \"bar\": [\"A\", \"B\"]})\n        df2 = rf.DataFrame({\"bar\": [\"C\", \"D\"], \"foo\": [3, 4], \"baz\": [\"$\", \"@\"]})\n        result = df1.append(df2)", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_docstrings.py_145-195"}
{"title": "maxhumber_redframes-tests-test_docstrings.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_docstrings.py"], "line_no": 180, "start_line_no": 155, "end_line_no": 205, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "    def test_str(self):\n        df = rf.DataFrame({\"foo\": [1, 2], \"bar\": [\"A\", \"B\"]})\n        result = str(df)\n        expected = \"rf.DataFrame({'foo': [1, 2], 'bar': ['A', 'B']})\"\n        self.assertEqual(result, expected)\n\n    def test_columns(self):\n        df = rf.DataFrame({\"foo\": [1, 2], \"bar\": [\"A\", \"B\"], \"baz\": [True, False]})\n        result = df.columns\n        expected = [\"foo\", \"bar\", \"baz\"]\n        self.assertEqual(result, expected)\n\n    def test_dimensions(self):\n        df = rf.DataFrame({\"foo\": range(10), \"bar\": range(10, 20)})\n        result = df.dimensions\n        expected = {\"rows\": 10, \"columns\": 2}\n        self.assertEqual(result, expected)\n\n    def test_empty(self):\n        df = rf.DataFrame()\n        result = df.empty\n        expected = True\n        self.assertEqual(result, expected)\n\n    def test_memory(self):\n        df = rf.DataFrame({\"foo\": [1, 2, 3], \"bar\": [\"A\", \"B\", \"C\"]})\n        result = df.memory\n        expected = \"326 B\"\n        self.assertEqual(result, expected)\n\n    def test_types(self):\n        df = rf.DataFrame({\"foo\": [1, 2], \"bar\": [\"A\", \"B\"], \"baz\": [True, False]})\n        result = df.types\n        expected = {\"foo\": int, \"bar\": object, \"baz\": bool}\n        self.assertEqual(result, expected)\n\n    def test_append(self):\n        df1 = rf.DataFrame({\"foo\": [1, 2], \"bar\": [\"A\", \"B\"]})\n        df2 = rf.DataFrame({\"bar\": [\"C\", \"D\"], \"foo\": [3, 4], \"baz\": [\"$\", \"@\"]})\n        result = df1.append(df2)\n        expected = rf.DataFrame(\n            {\n                \"foo\": [1, 2, 3, 4],\n                \"bar\": [\"A\", \"B\", \"C\", \"D\"],\n                \"baz\": [None, None, \"$\", \"@\"],\n            }\n        )\n        self.assertEqual(result, expected)\n\n    def test_combine(self):", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_docstrings.py_155-205"}
{"title": "maxhumber_redframes-tests-test_docstrings.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_docstrings.py"], "line_no": 190, "start_line_no": 165, "end_line_no": 215, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        self.assertEqual(result, expected)\n\n    def test_dimensions(self):\n        df = rf.DataFrame({\"foo\": range(10), \"bar\": range(10, 20)})\n        result = df.dimensions\n        expected = {\"rows\": 10, \"columns\": 2}\n        self.assertEqual(result, expected)\n\n    def test_empty(self):\n        df = rf.DataFrame()\n        result = df.empty\n        expected = True\n        self.assertEqual(result, expected)\n\n    def test_memory(self):\n        df = rf.DataFrame({\"foo\": [1, 2, 3], \"bar\": [\"A\", \"B\", \"C\"]})\n        result = df.memory\n        expected = \"326 B\"\n        self.assertEqual(result, expected)\n\n    def test_types(self):\n        df = rf.DataFrame({\"foo\": [1, 2], \"bar\": [\"A\", \"B\"], \"baz\": [True, False]})\n        result = df.types\n        expected = {\"foo\": int, \"bar\": object, \"baz\": bool}\n        self.assertEqual(result, expected)\n\n    def test_append(self):\n        df1 = rf.DataFrame({\"foo\": [1, 2], \"bar\": [\"A\", \"B\"]})\n        df2 = rf.DataFrame({\"bar\": [\"C\", \"D\"], \"foo\": [3, 4], \"baz\": [\"$\", \"@\"]})\n        result = df1.append(df2)\n        expected = rf.DataFrame(\n            {\n                \"foo\": [1, 2, 3, 4],\n                \"bar\": [\"A\", \"B\", \"C\", \"D\"],\n                \"baz\": [None, None, \"$\", \"@\"],\n            }\n        )\n        self.assertEqual(result, expected)\n\n    def test_combine(self):\n        df = rf.DataFrame({\"foo\": [1, 2], \"bar\": [\"A\", \"B\"]})\n        result = df.combine([\"bar\", \"foo\"], into=\"baz\", sep=\"::\", drop=True)\n        expected = rf.DataFrame({\"baz\": [\"A::1\", \"B::2\"]})\n        self.assertEqual(result, expected)\n\n    def test_cross(self):\n        df = rf.DataFrame({\"foo\": [\"a\", \"b\", \"c\"], \"bar\": [1, 2, 3]})\n        dfa = rf.DataFrame({\"foo\": [1, 2, 3]})\n        dfb = rf.DataFrame({\"bar\": [1, 2, 3]})\n        result1 = df.cross()", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_docstrings.py_165-215"}
{"title": "maxhumber_redframes-tests-test_docstrings.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_docstrings.py"], "line_no": 200, "start_line_no": 175, "end_line_no": 225, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        result = df.empty\n        expected = True\n        self.assertEqual(result, expected)\n\n    def test_memory(self):\n        df = rf.DataFrame({\"foo\": [1, 2, 3], \"bar\": [\"A\", \"B\", \"C\"]})\n        result = df.memory\n        expected = \"326 B\"\n        self.assertEqual(result, expected)\n\n    def test_types(self):\n        df = rf.DataFrame({\"foo\": [1, 2], \"bar\": [\"A\", \"B\"], \"baz\": [True, False]})\n        result = df.types\n        expected = {\"foo\": int, \"bar\": object, \"baz\": bool}\n        self.assertEqual(result, expected)\n\n    def test_append(self):\n        df1 = rf.DataFrame({\"foo\": [1, 2], \"bar\": [\"A\", \"B\"]})\n        df2 = rf.DataFrame({\"bar\": [\"C\", \"D\"], \"foo\": [3, 4], \"baz\": [\"$\", \"@\"]})\n        result = df1.append(df2)\n        expected = rf.DataFrame(\n            {\n                \"foo\": [1, 2, 3, 4],\n                \"bar\": [\"A\", \"B\", \"C\", \"D\"],\n                \"baz\": [None, None, \"$\", \"@\"],\n            }\n        )\n        self.assertEqual(result, expected)\n\n    def test_combine(self):\n        df = rf.DataFrame({\"foo\": [1, 2], \"bar\": [\"A\", \"B\"]})\n        result = df.combine([\"bar\", \"foo\"], into=\"baz\", sep=\"::\", drop=True)\n        expected = rf.DataFrame({\"baz\": [\"A::1\", \"B::2\"]})\n        self.assertEqual(result, expected)\n\n    def test_cross(self):\n        df = rf.DataFrame({\"foo\": [\"a\", \"b\", \"c\"], \"bar\": [1, 2, 3]})\n        dfa = rf.DataFrame({\"foo\": [1, 2, 3]})\n        dfb = rf.DataFrame({\"bar\": [1, 2, 3]})\n        result1 = df.cross()\n        result2 = dfa.cross(dfb, postfix=(\"_a\", \"_b\"))\n        expected1 = rf.DataFrame(\n            {\n                \"foo_lhs\": [\"a\", \"a\", \"a\", \"b\", \"b\", \"b\", \"c\", \"c\", \"c\"],\n                \"bar_lhs\": [1, 1, 1, 2, 2, 2, 3, 3, 3],\n                \"foo_rhs\": [\"a\", \"b\", \"c\", \"a\", \"b\", \"c\", \"a\", \"b\", \"c\"],\n                \"bar_rhs\": [1, 2, 3, 1, 2, 3, 1, 2, 3],\n            }\n        )\n        expected2 = rf.DataFrame(", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_docstrings.py_175-225"}
{"title": "maxhumber_redframes-tests-test_docstrings.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_docstrings.py"], "line_no": 210, "start_line_no": 185, "end_line_no": 235, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "    def test_types(self):\n        df = rf.DataFrame({\"foo\": [1, 2], \"bar\": [\"A\", \"B\"], \"baz\": [True, False]})\n        result = df.types\n        expected = {\"foo\": int, \"bar\": object, \"baz\": bool}\n        self.assertEqual(result, expected)\n\n    def test_append(self):\n        df1 = rf.DataFrame({\"foo\": [1, 2], \"bar\": [\"A\", \"B\"]})\n        df2 = rf.DataFrame({\"bar\": [\"C\", \"D\"], \"foo\": [3, 4], \"baz\": [\"$\", \"@\"]})\n        result = df1.append(df2)\n        expected = rf.DataFrame(\n            {\n                \"foo\": [1, 2, 3, 4],\n                \"bar\": [\"A\", \"B\", \"C\", \"D\"],\n                \"baz\": [None, None, \"$\", \"@\"],\n            }\n        )\n        self.assertEqual(result, expected)\n\n    def test_combine(self):\n        df = rf.DataFrame({\"foo\": [1, 2], \"bar\": [\"A\", \"B\"]})\n        result = df.combine([\"bar\", \"foo\"], into=\"baz\", sep=\"::\", drop=True)\n        expected = rf.DataFrame({\"baz\": [\"A::1\", \"B::2\"]})\n        self.assertEqual(result, expected)\n\n    def test_cross(self):\n        df = rf.DataFrame({\"foo\": [\"a\", \"b\", \"c\"], \"bar\": [1, 2, 3]})\n        dfa = rf.DataFrame({\"foo\": [1, 2, 3]})\n        dfb = rf.DataFrame({\"bar\": [1, 2, 3]})\n        result1 = df.cross()\n        result2 = dfa.cross(dfb, postfix=(\"_a\", \"_b\"))\n        expected1 = rf.DataFrame(\n            {\n                \"foo_lhs\": [\"a\", \"a\", \"a\", \"b\", \"b\", \"b\", \"c\", \"c\", \"c\"],\n                \"bar_lhs\": [1, 1, 1, 2, 2, 2, 3, 3, 3],\n                \"foo_rhs\": [\"a\", \"b\", \"c\", \"a\", \"b\", \"c\", \"a\", \"b\", \"c\"],\n                \"bar_rhs\": [1, 2, 3, 1, 2, 3, 1, 2, 3],\n            }\n        )\n        expected2 = rf.DataFrame(\n            {\"foo\": [1, 1, 1, 2, 2, 2, 3, 3, 3], \"bar\": [1, 2, 3, 1, 2, 3, 1, 2, 3]}\n        )\n        self.assertEqual(result1, expected1)\n        self.assertEqual(result2, expected2)\n\n    def test_dedupe(self):\n        df = rf.DataFrame({\"foo\": [1, 1, 2, 2], \"bar\": [\"A\", \"A\", \"B\", \"A\"]})\n        result1 = df.dedupe()\n        result2 = df.dedupe(\"foo\")\n        result3 = df.dedupe([\"foo\", \"bar\"])", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_docstrings.py_185-235"}
{"title": "maxhumber_redframes-tests-test_docstrings.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_docstrings.py"], "line_no": 220, "start_line_no": 195, "end_line_no": 245, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        expected = rf.DataFrame(\n            {\n                \"foo\": [1, 2, 3, 4],\n                \"bar\": [\"A\", \"B\", \"C\", \"D\"],\n                \"baz\": [None, None, \"$\", \"@\"],\n            }\n        )\n        self.assertEqual(result, expected)\n\n    def test_combine(self):\n        df = rf.DataFrame({\"foo\": [1, 2], \"bar\": [\"A\", \"B\"]})\n        result = df.combine([\"bar\", \"foo\"], into=\"baz\", sep=\"::\", drop=True)\n        expected = rf.DataFrame({\"baz\": [\"A::1\", \"B::2\"]})\n        self.assertEqual(result, expected)\n\n    def test_cross(self):\n        df = rf.DataFrame({\"foo\": [\"a\", \"b\", \"c\"], \"bar\": [1, 2, 3]})\n        dfa = rf.DataFrame({\"foo\": [1, 2, 3]})\n        dfb = rf.DataFrame({\"bar\": [1, 2, 3]})\n        result1 = df.cross()\n        result2 = dfa.cross(dfb, postfix=(\"_a\", \"_b\"))\n        expected1 = rf.DataFrame(\n            {\n                \"foo_lhs\": [\"a\", \"a\", \"a\", \"b\", \"b\", \"b\", \"c\", \"c\", \"c\"],\n                \"bar_lhs\": [1, 1, 1, 2, 2, 2, 3, 3, 3],\n                \"foo_rhs\": [\"a\", \"b\", \"c\", \"a\", \"b\", \"c\", \"a\", \"b\", \"c\"],\n                \"bar_rhs\": [1, 2, 3, 1, 2, 3, 1, 2, 3],\n            }\n        )\n        expected2 = rf.DataFrame(\n            {\"foo\": [1, 1, 1, 2, 2, 2, 3, 3, 3], \"bar\": [1, 2, 3, 1, 2, 3, 1, 2, 3]}\n        )\n        self.assertEqual(result1, expected1)\n        self.assertEqual(result2, expected2)\n\n    def test_dedupe(self):\n        df = rf.DataFrame({\"foo\": [1, 1, 2, 2], \"bar\": [\"A\", \"A\", \"B\", \"A\"]})\n        result1 = df.dedupe()\n        result2 = df.dedupe(\"foo\")\n        result3 = df.dedupe([\"foo\", \"bar\"])\n        expected1 = rf.DataFrame({\"foo\": [1, 2, 2], \"bar\": [\"A\", \"B\", \"A\"]})\n        expected2 = rf.DataFrame({\"foo\": [1, 2], \"bar\": [\"A\", \"B\"]})\n        expected3 = rf.DataFrame({\"foo\": [1, 2, 2], \"bar\": [\"A\", \"B\", \"A\"]})\n        self.assertEqual(result1, expected1)\n        self.assertEqual(result2, expected2)\n        self.assertEqual(result3, expected3)\n\n    def test_denix(self):\n        df = rf.DataFrame(\n            {\"foo\": [1, None, 3, None, 5, 6], \"bar\": [1, None, 3, 4, None, None]}", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_docstrings.py_195-245"}
{"title": "maxhumber_redframes-tests-test_docstrings.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_docstrings.py"], "line_no": 230, "start_line_no": 205, "end_line_no": 255, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        df = rf.DataFrame({\"foo\": [1, 2], \"bar\": [\"A\", \"B\"]})\n        result = df.combine([\"bar\", \"foo\"], into=\"baz\", sep=\"::\", drop=True)\n        expected = rf.DataFrame({\"baz\": [\"A::1\", \"B::2\"]})\n        self.assertEqual(result, expected)\n\n    def test_cross(self):\n        df = rf.DataFrame({\"foo\": [\"a\", \"b\", \"c\"], \"bar\": [1, 2, 3]})\n        dfa = rf.DataFrame({\"foo\": [1, 2, 3]})\n        dfb = rf.DataFrame({\"bar\": [1, 2, 3]})\n        result1 = df.cross()\n        result2 = dfa.cross(dfb, postfix=(\"_a\", \"_b\"))\n        expected1 = rf.DataFrame(\n            {\n                \"foo_lhs\": [\"a\", \"a\", \"a\", \"b\", \"b\", \"b\", \"c\", \"c\", \"c\"],\n                \"bar_lhs\": [1, 1, 1, 2, 2, 2, 3, 3, 3],\n                \"foo_rhs\": [\"a\", \"b\", \"c\", \"a\", \"b\", \"c\", \"a\", \"b\", \"c\"],\n                \"bar_rhs\": [1, 2, 3, 1, 2, 3, 1, 2, 3],\n            }\n        )\n        expected2 = rf.DataFrame(\n            {\"foo\": [1, 1, 1, 2, 2, 2, 3, 3, 3], \"bar\": [1, 2, 3, 1, 2, 3, 1, 2, 3]}\n        )\n        self.assertEqual(result1, expected1)\n        self.assertEqual(result2, expected2)\n\n    def test_dedupe(self):\n        df = rf.DataFrame({\"foo\": [1, 1, 2, 2], \"bar\": [\"A\", \"A\", \"B\", \"A\"]})\n        result1 = df.dedupe()\n        result2 = df.dedupe(\"foo\")\n        result3 = df.dedupe([\"foo\", \"bar\"])\n        expected1 = rf.DataFrame({\"foo\": [1, 2, 2], \"bar\": [\"A\", \"B\", \"A\"]})\n        expected2 = rf.DataFrame({\"foo\": [1, 2], \"bar\": [\"A\", \"B\"]})\n        expected3 = rf.DataFrame({\"foo\": [1, 2, 2], \"bar\": [\"A\", \"B\", \"A\"]})\n        self.assertEqual(result1, expected1)\n        self.assertEqual(result2, expected2)\n        self.assertEqual(result3, expected3)\n\n    def test_denix(self):\n        df = rf.DataFrame(\n            {\"foo\": [1, None, 3, None, 5, 6], \"bar\": [1, None, 3, 4, None, None]}\n        )\n        result1 = df.denix()\n        result2 = df.denix(\"bar\")\n        result3 = df.denix([\"foo\", \"bar\"])\n        expected1 = rf.DataFrame({\"foo\": [1.0, 3.0], \"bar\": [1.0, 3.0]})\n        expected2 = rf.DataFrame({\"foo\": [1.0, 3.0, None], \"bar\": [1.0, 3.0, 4.0]})\n        expected3 = rf.DataFrame({\"foo\": [1.0, 3.0], \"bar\": [1.0, 3.0]})\n        self.assertEqual(result1, expected1)\n        self.assertEqual(result2, expected2)\n        self.assertEqual(result3, expected3)", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_docstrings.py_205-255"}
{"title": "maxhumber_redframes-tests-test_docstrings.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_docstrings.py"], "line_no": 240, "start_line_no": 215, "end_line_no": 265, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        result2 = dfa.cross(dfb, postfix=(\"_a\", \"_b\"))\n        expected1 = rf.DataFrame(\n            {\n                \"foo_lhs\": [\"a\", \"a\", \"a\", \"b\", \"b\", \"b\", \"c\", \"c\", \"c\"],\n                \"bar_lhs\": [1, 1, 1, 2, 2, 2, 3, 3, 3],\n                \"foo_rhs\": [\"a\", \"b\", \"c\", \"a\", \"b\", \"c\", \"a\", \"b\", \"c\"],\n                \"bar_rhs\": [1, 2, 3, 1, 2, 3, 1, 2, 3],\n            }\n        )\n        expected2 = rf.DataFrame(\n            {\"foo\": [1, 1, 1, 2, 2, 2, 3, 3, 3], \"bar\": [1, 2, 3, 1, 2, 3, 1, 2, 3]}\n        )\n        self.assertEqual(result1, expected1)\n        self.assertEqual(result2, expected2)\n\n    def test_dedupe(self):\n        df = rf.DataFrame({\"foo\": [1, 1, 2, 2], \"bar\": [\"A\", \"A\", \"B\", \"A\"]})\n        result1 = df.dedupe()\n        result2 = df.dedupe(\"foo\")\n        result3 = df.dedupe([\"foo\", \"bar\"])\n        expected1 = rf.DataFrame({\"foo\": [1, 2, 2], \"bar\": [\"A\", \"B\", \"A\"]})\n        expected2 = rf.DataFrame({\"foo\": [1, 2], \"bar\": [\"A\", \"B\"]})\n        expected3 = rf.DataFrame({\"foo\": [1, 2, 2], \"bar\": [\"A\", \"B\", \"A\"]})\n        self.assertEqual(result1, expected1)\n        self.assertEqual(result2, expected2)\n        self.assertEqual(result3, expected3)\n\n    def test_denix(self):\n        df = rf.DataFrame(\n            {\"foo\": [1, None, 3, None, 5, 6], \"bar\": [1, None, 3, 4, None, None]}\n        )\n        result1 = df.denix()\n        result2 = df.denix(\"bar\")\n        result3 = df.denix([\"foo\", \"bar\"])\n        expected1 = rf.DataFrame({\"foo\": [1.0, 3.0], \"bar\": [1.0, 3.0]})\n        expected2 = rf.DataFrame({\"foo\": [1.0, 3.0, None], \"bar\": [1.0, 3.0, 4.0]})\n        expected3 = rf.DataFrame({\"foo\": [1.0, 3.0], \"bar\": [1.0, 3.0]})\n        self.assertEqual(result1, expected1)\n        self.assertEqual(result2, expected2)\n        self.assertEqual(result3, expected3)\n\n    def test_drop(self):\n        df = rf.DataFrame({\"foo\": [1, 2], \"bar\": [3, 4], \"baz\": [5, 6]})\n        result1 = df.drop(\"baz\")\n        result2 = df.drop([\"foo\", \"baz\"])\n        expected1 = rf.DataFrame({\"foo\": [1, 2], \"bar\": [3, 4]})\n        expected2 = rf.DataFrame({\"bar\": [3, 4]})\n        self.assertEqual(result1, expected1)\n        self.assertEqual(result2, expected2)\n", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_docstrings.py_215-265"}
{"title": "maxhumber_redframes-tests-test_docstrings.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_docstrings.py"], "line_no": 250, "start_line_no": 225, "end_line_no": 275, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "            {\"foo\": [1, 1, 1, 2, 2, 2, 3, 3, 3], \"bar\": [1, 2, 3, 1, 2, 3, 1, 2, 3]}\n        )\n        self.assertEqual(result1, expected1)\n        self.assertEqual(result2, expected2)\n\n    def test_dedupe(self):\n        df = rf.DataFrame({\"foo\": [1, 1, 2, 2], \"bar\": [\"A\", \"A\", \"B\", \"A\"]})\n        result1 = df.dedupe()\n        result2 = df.dedupe(\"foo\")\n        result3 = df.dedupe([\"foo\", \"bar\"])\n        expected1 = rf.DataFrame({\"foo\": [1, 2, 2], \"bar\": [\"A\", \"B\", \"A\"]})\n        expected2 = rf.DataFrame({\"foo\": [1, 2], \"bar\": [\"A\", \"B\"]})\n        expected3 = rf.DataFrame({\"foo\": [1, 2, 2], \"bar\": [\"A\", \"B\", \"A\"]})\n        self.assertEqual(result1, expected1)\n        self.assertEqual(result2, expected2)\n        self.assertEqual(result3, expected3)\n\n    def test_denix(self):\n        df = rf.DataFrame(\n            {\"foo\": [1, None, 3, None, 5, 6], \"bar\": [1, None, 3, 4, None, None]}\n        )\n        result1 = df.denix()\n        result2 = df.denix(\"bar\")\n        result3 = df.denix([\"foo\", \"bar\"])\n        expected1 = rf.DataFrame({\"foo\": [1.0, 3.0], \"bar\": [1.0, 3.0]})\n        expected2 = rf.DataFrame({\"foo\": [1.0, 3.0, None], \"bar\": [1.0, 3.0, 4.0]})\n        expected3 = rf.DataFrame({\"foo\": [1.0, 3.0], \"bar\": [1.0, 3.0]})\n        self.assertEqual(result1, expected1)\n        self.assertEqual(result2, expected2)\n        self.assertEqual(result3, expected3)\n\n    def test_drop(self):\n        df = rf.DataFrame({\"foo\": [1, 2], \"bar\": [3, 4], \"baz\": [5, 6]})\n        result1 = df.drop(\"baz\")\n        result2 = df.drop([\"foo\", \"baz\"])\n        expected1 = rf.DataFrame({\"foo\": [1, 2], \"bar\": [3, 4]})\n        expected2 = rf.DataFrame({\"bar\": [3, 4]})\n        self.assertEqual(result1, expected1)\n        self.assertEqual(result2, expected2)\n\n    def test_fill(self):\n        df = rf.DataFrame(\n            {\"foo\": [1, None, None, 2, None], \"bar\": [None, \"A\", None, \"B\", None]}\n        )\n        result1 = df.fill(constant=0)\n        result2 = df.fill(direction=\"down\")\n        result3 = df.fill(\"foo\", direction=\"down\")\n        result4 = df.fill([\"foo\"], direction=\"up\")\n        expected1 = rf.DataFrame(\n            {\"foo\": [1.0, 0.0, 0.0, 2.0, 0.0], \"bar\": [0, \"A\", 0, \"B\", 0]}", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_docstrings.py_225-275"}
{"title": "maxhumber_redframes-tests-test_docstrings.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_docstrings.py"], "line_no": 260, "start_line_no": 235, "end_line_no": 285, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        expected1 = rf.DataFrame({\"foo\": [1, 2, 2], \"bar\": [\"A\", \"B\", \"A\"]})\n        expected2 = rf.DataFrame({\"foo\": [1, 2], \"bar\": [\"A\", \"B\"]})\n        expected3 = rf.DataFrame({\"foo\": [1, 2, 2], \"bar\": [\"A\", \"B\", \"A\"]})\n        self.assertEqual(result1, expected1)\n        self.assertEqual(result2, expected2)\n        self.assertEqual(result3, expected3)\n\n    def test_denix(self):\n        df = rf.DataFrame(\n            {\"foo\": [1, None, 3, None, 5, 6], \"bar\": [1, None, 3, 4, None, None]}\n        )\n        result1 = df.denix()\n        result2 = df.denix(\"bar\")\n        result3 = df.denix([\"foo\", \"bar\"])\n        expected1 = rf.DataFrame({\"foo\": [1.0, 3.0], \"bar\": [1.0, 3.0]})\n        expected2 = rf.DataFrame({\"foo\": [1.0, 3.0, None], \"bar\": [1.0, 3.0, 4.0]})\n        expected3 = rf.DataFrame({\"foo\": [1.0, 3.0], \"bar\": [1.0, 3.0]})\n        self.assertEqual(result1, expected1)\n        self.assertEqual(result2, expected2)\n        self.assertEqual(result3, expected3)\n\n    def test_drop(self):\n        df = rf.DataFrame({\"foo\": [1, 2], \"bar\": [3, 4], \"baz\": [5, 6]})\n        result1 = df.drop(\"baz\")\n        result2 = df.drop([\"foo\", \"baz\"])\n        expected1 = rf.DataFrame({\"foo\": [1, 2], \"bar\": [3, 4]})\n        expected2 = rf.DataFrame({\"bar\": [3, 4]})\n        self.assertEqual(result1, expected1)\n        self.assertEqual(result2, expected2)\n\n    def test_fill(self):\n        df = rf.DataFrame(\n            {\"foo\": [1, None, None, 2, None], \"bar\": [None, \"A\", None, \"B\", None]}\n        )\n        result1 = df.fill(constant=0)\n        result2 = df.fill(direction=\"down\")\n        result3 = df.fill(\"foo\", direction=\"down\")\n        result4 = df.fill([\"foo\"], direction=\"up\")\n        expected1 = rf.DataFrame(\n            {\"foo\": [1.0, 0.0, 0.0, 2.0, 0.0], \"bar\": [0, \"A\", 0, \"B\", 0]}\n        )\n        expected2 = rf.DataFrame(\n            {\"foo\": [1.0, 1.0, 1.0, 2.0, 2.0], \"bar\": [None, \"A\", \"A\", \"B\", \"B\"]}\n        )\n        expected3 = rf.DataFrame(\n            {\"foo\": [1.0, 1.0, 1.0, 2.0, 2.0], \"bar\": [None, \"A\", None, \"B\", None]}\n        )\n        expected4 = rf.DataFrame(\n            {\"foo\": [1.0, 2.0, 2.0, 2.0, None], \"bar\": [None, \"A\", None, \"B\", None]}\n        )", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_docstrings.py_235-285"}
{"title": "maxhumber_redframes-tests-test_docstrings.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_docstrings.py"], "line_no": 270, "start_line_no": 245, "end_line_no": 295, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        )\n        result1 = df.denix()\n        result2 = df.denix(\"bar\")\n        result3 = df.denix([\"foo\", \"bar\"])\n        expected1 = rf.DataFrame({\"foo\": [1.0, 3.0], \"bar\": [1.0, 3.0]})\n        expected2 = rf.DataFrame({\"foo\": [1.0, 3.0, None], \"bar\": [1.0, 3.0, 4.0]})\n        expected3 = rf.DataFrame({\"foo\": [1.0, 3.0], \"bar\": [1.0, 3.0]})\n        self.assertEqual(result1, expected1)\n        self.assertEqual(result2, expected2)\n        self.assertEqual(result3, expected3)\n\n    def test_drop(self):\n        df = rf.DataFrame({\"foo\": [1, 2], \"bar\": [3, 4], \"baz\": [5, 6]})\n        result1 = df.drop(\"baz\")\n        result2 = df.drop([\"foo\", \"baz\"])\n        expected1 = rf.DataFrame({\"foo\": [1, 2], \"bar\": [3, 4]})\n        expected2 = rf.DataFrame({\"bar\": [3, 4]})\n        self.assertEqual(result1, expected1)\n        self.assertEqual(result2, expected2)\n\n    def test_fill(self):\n        df = rf.DataFrame(\n            {\"foo\": [1, None, None, 2, None], \"bar\": [None, \"A\", None, \"B\", None]}\n        )\n        result1 = df.fill(constant=0)\n        result2 = df.fill(direction=\"down\")\n        result3 = df.fill(\"foo\", direction=\"down\")\n        result4 = df.fill([\"foo\"], direction=\"up\")\n        expected1 = rf.DataFrame(\n            {\"foo\": [1.0, 0.0, 0.0, 2.0, 0.0], \"bar\": [0, \"A\", 0, \"B\", 0]}\n        )\n        expected2 = rf.DataFrame(\n            {\"foo\": [1.0, 1.0, 1.0, 2.0, 2.0], \"bar\": [None, \"A\", \"A\", \"B\", \"B\"]}\n        )\n        expected3 = rf.DataFrame(\n            {\"foo\": [1.0, 1.0, 1.0, 2.0, 2.0], \"bar\": [None, \"A\", None, \"B\", None]}\n        )\n        expected4 = rf.DataFrame(\n            {\"foo\": [1.0, 2.0, 2.0, 2.0, None], \"bar\": [None, \"A\", None, \"B\", None]}\n        )\n        self.assertEqual(result1, expected1)\n        self.assertEqual(result2, expected2)\n        self.assertEqual(result3, expected3)\n        self.assertEqual(result4, expected4)\n\n    def test_filter(self):\n        df = rf.DataFrame({\"foo\": [\"A\", \"A\", \"A\", \"B\"], \"bar\": [1, 2, 3, 4]})\n        result1 = df.filter(lambda row: row[\"foo\"].isin([\"A\"]))\n        result2 = df.filter(lambda row: (row[\"foo\"] == \"A\") & (row[\"bar\"] <= 2))\n        result3 = df.filter(lambda row: (row[\"foo\"] == \"B\") | (row[\"bar\"] == 1))", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_docstrings.py_245-295"}
{"title": "maxhumber_redframes-tests-test_docstrings.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_docstrings.py"], "line_no": 280, "start_line_no": 255, "end_line_no": 305, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "\n    def test_drop(self):\n        df = rf.DataFrame({\"foo\": [1, 2], \"bar\": [3, 4], \"baz\": [5, 6]})\n        result1 = df.drop(\"baz\")\n        result2 = df.drop([\"foo\", \"baz\"])\n        expected1 = rf.DataFrame({\"foo\": [1, 2], \"bar\": [3, 4]})\n        expected2 = rf.DataFrame({\"bar\": [3, 4]})\n        self.assertEqual(result1, expected1)\n        self.assertEqual(result2, expected2)\n\n    def test_fill(self):\n        df = rf.DataFrame(\n            {\"foo\": [1, None, None, 2, None], \"bar\": [None, \"A\", None, \"B\", None]}\n        )\n        result1 = df.fill(constant=0)\n        result2 = df.fill(direction=\"down\")\n        result3 = df.fill(\"foo\", direction=\"down\")\n        result4 = df.fill([\"foo\"], direction=\"up\")\n        expected1 = rf.DataFrame(\n            {\"foo\": [1.0, 0.0, 0.0, 2.0, 0.0], \"bar\": [0, \"A\", 0, \"B\", 0]}\n        )\n        expected2 = rf.DataFrame(\n            {\"foo\": [1.0, 1.0, 1.0, 2.0, 2.0], \"bar\": [None, \"A\", \"A\", \"B\", \"B\"]}\n        )\n        expected3 = rf.DataFrame(\n            {\"foo\": [1.0, 1.0, 1.0, 2.0, 2.0], \"bar\": [None, \"A\", None, \"B\", None]}\n        )\n        expected4 = rf.DataFrame(\n            {\"foo\": [1.0, 2.0, 2.0, 2.0, None], \"bar\": [None, \"A\", None, \"B\", None]}\n        )\n        self.assertEqual(result1, expected1)\n        self.assertEqual(result2, expected2)\n        self.assertEqual(result3, expected3)\n        self.assertEqual(result4, expected4)\n\n    def test_filter(self):\n        df = rf.DataFrame({\"foo\": [\"A\", \"A\", \"A\", \"B\"], \"bar\": [1, 2, 3, 4]})\n        result1 = df.filter(lambda row: row[\"foo\"].isin([\"A\"]))\n        result2 = df.filter(lambda row: (row[\"foo\"] == \"A\") & (row[\"bar\"] <= 2))\n        result3 = df.filter(lambda row: (row[\"foo\"] == \"B\") | (row[\"bar\"] == 1))\n        expected1 = rf.DataFrame({\"foo\": [\"A\", \"A\", \"A\"], \"bar\": [1, 2, 3]})\n        expected2 = rf.DataFrame({\"foo\": [\"A\", \"A\"], \"bar\": [1, 2]})\n        expected3 = rf.DataFrame({\"foo\": [\"A\", \"B\"], \"bar\": [1, 4]})\n        self.assertEqual(result1, expected1)\n        self.assertEqual(result2, expected2)\n        self.assertEqual(result3, expected3)\n\n    def test_group(self):\n        df = rf.DataFrame(\n            {", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_docstrings.py_255-305"}
{"title": "maxhumber_redframes-tests-test_docstrings.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_docstrings.py"], "line_no": 290, "start_line_no": 265, "end_line_no": 315, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "    def test_fill(self):\n        df = rf.DataFrame(\n            {\"foo\": [1, None, None, 2, None], \"bar\": [None, \"A\", None, \"B\", None]}\n        )\n        result1 = df.fill(constant=0)\n        result2 = df.fill(direction=\"down\")\n        result3 = df.fill(\"foo\", direction=\"down\")\n        result4 = df.fill([\"foo\"], direction=\"up\")\n        expected1 = rf.DataFrame(\n            {\"foo\": [1.0, 0.0, 0.0, 2.0, 0.0], \"bar\": [0, \"A\", 0, \"B\", 0]}\n        )\n        expected2 = rf.DataFrame(\n            {\"foo\": [1.0, 1.0, 1.0, 2.0, 2.0], \"bar\": [None, \"A\", \"A\", \"B\", \"B\"]}\n        )\n        expected3 = rf.DataFrame(\n            {\"foo\": [1.0, 1.0, 1.0, 2.0, 2.0], \"bar\": [None, \"A\", None, \"B\", None]}\n        )\n        expected4 = rf.DataFrame(\n            {\"foo\": [1.0, 2.0, 2.0, 2.0, None], \"bar\": [None, \"A\", None, \"B\", None]}\n        )\n        self.assertEqual(result1, expected1)\n        self.assertEqual(result2, expected2)\n        self.assertEqual(result3, expected3)\n        self.assertEqual(result4, expected4)\n\n    def test_filter(self):\n        df = rf.DataFrame({\"foo\": [\"A\", \"A\", \"A\", \"B\"], \"bar\": [1, 2, 3, 4]})\n        result1 = df.filter(lambda row: row[\"foo\"].isin([\"A\"]))\n        result2 = df.filter(lambda row: (row[\"foo\"] == \"A\") & (row[\"bar\"] <= 2))\n        result3 = df.filter(lambda row: (row[\"foo\"] == \"B\") | (row[\"bar\"] == 1))\n        expected1 = rf.DataFrame({\"foo\": [\"A\", \"A\", \"A\"], \"bar\": [1, 2, 3]})\n        expected2 = rf.DataFrame({\"foo\": [\"A\", \"A\"], \"bar\": [1, 2]})\n        expected3 = rf.DataFrame({\"foo\": [\"A\", \"B\"], \"bar\": [1, 4]})\n        self.assertEqual(result1, expected1)\n        self.assertEqual(result2, expected2)\n        self.assertEqual(result3, expected3)\n\n    def test_group(self):\n        df = rf.DataFrame(\n            {\n                \"foo\": [\"A\", \"A\", \"A\", \"B\", \"B\"],\n                \"bar\": [1, 2, 3, 4, 5],\n                \"baz\": [9, 7, 7, 5, 6],\n            }\n        )\n        result1 = df.group(\"foo\").accumulate(\"bar\", into=\"bar_cumsum\")\n        result2 = df.group(\"foo\").gather()\n        result3 = df.group(\"foo\").pack(\"bar\", sep=\":\")\n        result4 = df.group(\"foo\").rank(\"baz\", into=\"baz_rank\", descending=True)\n        result5 = df.group(\"foo\").rollup(", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_docstrings.py_265-315"}
{"title": "maxhumber_redframes-tests-test_docstrings.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_docstrings.py"], "line_no": 300, "start_line_no": 275, "end_line_no": 325, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        )\n        expected2 = rf.DataFrame(\n            {\"foo\": [1.0, 1.0, 1.0, 2.0, 2.0], \"bar\": [None, \"A\", \"A\", \"B\", \"B\"]}\n        )\n        expected3 = rf.DataFrame(\n            {\"foo\": [1.0, 1.0, 1.0, 2.0, 2.0], \"bar\": [None, \"A\", None, \"B\", None]}\n        )\n        expected4 = rf.DataFrame(\n            {\"foo\": [1.0, 2.0, 2.0, 2.0, None], \"bar\": [None, \"A\", None, \"B\", None]}\n        )\n        self.assertEqual(result1, expected1)\n        self.assertEqual(result2, expected2)\n        self.assertEqual(result3, expected3)\n        self.assertEqual(result4, expected4)\n\n    def test_filter(self):\n        df = rf.DataFrame({\"foo\": [\"A\", \"A\", \"A\", \"B\"], \"bar\": [1, 2, 3, 4]})\n        result1 = df.filter(lambda row: row[\"foo\"].isin([\"A\"]))\n        result2 = df.filter(lambda row: (row[\"foo\"] == \"A\") & (row[\"bar\"] <= 2))\n        result3 = df.filter(lambda row: (row[\"foo\"] == \"B\") | (row[\"bar\"] == 1))\n        expected1 = rf.DataFrame({\"foo\": [\"A\", \"A\", \"A\"], \"bar\": [1, 2, 3]})\n        expected2 = rf.DataFrame({\"foo\": [\"A\", \"A\"], \"bar\": [1, 2]})\n        expected3 = rf.DataFrame({\"foo\": [\"A\", \"B\"], \"bar\": [1, 4]})\n        self.assertEqual(result1, expected1)\n        self.assertEqual(result2, expected2)\n        self.assertEqual(result3, expected3)\n\n    def test_group(self):\n        df = rf.DataFrame(\n            {\n                \"foo\": [\"A\", \"A\", \"A\", \"B\", \"B\"],\n                \"bar\": [1, 2, 3, 4, 5],\n                \"baz\": [9, 7, 7, 5, 6],\n            }\n        )\n        result1 = df.group(\"foo\").accumulate(\"bar\", into=\"bar_cumsum\")\n        result2 = df.group(\"foo\").gather()\n        result3 = df.group(\"foo\").pack(\"bar\", sep=\":\")\n        result4 = df.group(\"foo\").rank(\"baz\", into=\"baz_rank\", descending=True)\n        result5 = df.group(\"foo\").rollup(\n            {\"bar_mean\": (\"bar\", rf.stat.mean), \"baz_min\": (\"baz\", rf.stat.min)}\n        )\n        result6 = df.group(\"foo\").take(1)\n        expected1 = rf.DataFrame(\n            {\n                \"foo\": [\"A\", \"A\", \"A\", \"B\", \"B\"],\n                \"bar\": [1, 2, 3, 4, 5],\n                \"baz\": [9, 7, 7, 5, 6],\n                \"bar_cumsum\": [1, 3, 6, 4, 9],\n            }", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_docstrings.py_275-325"}
{"title": "maxhumber_redframes-tests-test_docstrings.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_docstrings.py"], "line_no": 310, "start_line_no": 285, "end_line_no": 335, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        self.assertEqual(result1, expected1)\n        self.assertEqual(result2, expected2)\n        self.assertEqual(result3, expected3)\n        self.assertEqual(result4, expected4)\n\n    def test_filter(self):\n        df = rf.DataFrame({\"foo\": [\"A\", \"A\", \"A\", \"B\"], \"bar\": [1, 2, 3, 4]})\n        result1 = df.filter(lambda row: row[\"foo\"].isin([\"A\"]))\n        result2 = df.filter(lambda row: (row[\"foo\"] == \"A\") & (row[\"bar\"] <= 2))\n        result3 = df.filter(lambda row: (row[\"foo\"] == \"B\") | (row[\"bar\"] == 1))\n        expected1 = rf.DataFrame({\"foo\": [\"A\", \"A\", \"A\"], \"bar\": [1, 2, 3]})\n        expected2 = rf.DataFrame({\"foo\": [\"A\", \"A\"], \"bar\": [1, 2]})\n        expected3 = rf.DataFrame({\"foo\": [\"A\", \"B\"], \"bar\": [1, 4]})\n        self.assertEqual(result1, expected1)\n        self.assertEqual(result2, expected2)\n        self.assertEqual(result3, expected3)\n\n    def test_group(self):\n        df = rf.DataFrame(\n            {\n                \"foo\": [\"A\", \"A\", \"A\", \"B\", \"B\"],\n                \"bar\": [1, 2, 3, 4, 5],\n                \"baz\": [9, 7, 7, 5, 6],\n            }\n        )\n        result1 = df.group(\"foo\").accumulate(\"bar\", into=\"bar_cumsum\")\n        result2 = df.group(\"foo\").gather()\n        result3 = df.group(\"foo\").pack(\"bar\", sep=\":\")\n        result4 = df.group(\"foo\").rank(\"baz\", into=\"baz_rank\", descending=True)\n        result5 = df.group(\"foo\").rollup(\n            {\"bar_mean\": (\"bar\", rf.stat.mean), \"baz_min\": (\"baz\", rf.stat.min)}\n        )\n        result6 = df.group(\"foo\").take(1)\n        expected1 = rf.DataFrame(\n            {\n                \"foo\": [\"A\", \"A\", \"A\", \"B\", \"B\"],\n                \"bar\": [1, 2, 3, 4, 5],\n                \"baz\": [9, 7, 7, 5, 6],\n                \"bar_cumsum\": [1, 3, 6, 4, 9],\n            }\n        )\n        expected2 = rf.DataFrame(\n            {\n                \"foo\": [\"A\", \"A\", \"A\", \"B\", \"B\", \"A\", \"A\", \"A\", \"B\", \"B\"],\n                \"variable\": [\n                    \"bar\",\n                    \"bar\",\n                    \"bar\",\n                    \"bar\",\n                    \"bar\",", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_docstrings.py_285-335"}
{"title": "maxhumber_redframes-tests-test_docstrings.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_docstrings.py"], "line_no": 320, "start_line_no": 295, "end_line_no": 345, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        expected1 = rf.DataFrame({\"foo\": [\"A\", \"A\", \"A\"], \"bar\": [1, 2, 3]})\n        expected2 = rf.DataFrame({\"foo\": [\"A\", \"A\"], \"bar\": [1, 2]})\n        expected3 = rf.DataFrame({\"foo\": [\"A\", \"B\"], \"bar\": [1, 4]})\n        self.assertEqual(result1, expected1)\n        self.assertEqual(result2, expected2)\n        self.assertEqual(result3, expected3)\n\n    def test_group(self):\n        df = rf.DataFrame(\n            {\n                \"foo\": [\"A\", \"A\", \"A\", \"B\", \"B\"],\n                \"bar\": [1, 2, 3, 4, 5],\n                \"baz\": [9, 7, 7, 5, 6],\n            }\n        )\n        result1 = df.group(\"foo\").accumulate(\"bar\", into=\"bar_cumsum\")\n        result2 = df.group(\"foo\").gather()\n        result3 = df.group(\"foo\").pack(\"bar\", sep=\":\")\n        result4 = df.group(\"foo\").rank(\"baz\", into=\"baz_rank\", descending=True)\n        result5 = df.group(\"foo\").rollup(\n            {\"bar_mean\": (\"bar\", rf.stat.mean), \"baz_min\": (\"baz\", rf.stat.min)}\n        )\n        result6 = df.group(\"foo\").take(1)\n        expected1 = rf.DataFrame(\n            {\n                \"foo\": [\"A\", \"A\", \"A\", \"B\", \"B\"],\n                \"bar\": [1, 2, 3, 4, 5],\n                \"baz\": [9, 7, 7, 5, 6],\n                \"bar_cumsum\": [1, 3, 6, 4, 9],\n            }\n        )\n        expected2 = rf.DataFrame(\n            {\n                \"foo\": [\"A\", \"A\", \"A\", \"B\", \"B\", \"A\", \"A\", \"A\", \"B\", \"B\"],\n                \"variable\": [\n                    \"bar\",\n                    \"bar\",\n                    \"bar\",\n                    \"bar\",\n                    \"bar\",\n                    \"baz\",\n                    \"baz\",\n                    \"baz\",\n                    \"baz\",\n                    \"baz\",\n                ],\n                \"value\": [1, 2, 3, 4, 5, 9, 7, 7, 5, 6],\n            }\n        )\n        expected3 = rf.DataFrame({\"foo\": [\"A\", \"B\"], \"bar\": [\"1:2:3\", \"4:5\"]})", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_docstrings.py_295-345"}
{"title": "maxhumber_redframes-tests-test_docstrings.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_docstrings.py"], "line_no": 330, "start_line_no": 305, "end_line_no": 355, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "                \"foo\": [\"A\", \"A\", \"A\", \"B\", \"B\"],\n                \"bar\": [1, 2, 3, 4, 5],\n                \"baz\": [9, 7, 7, 5, 6],\n            }\n        )\n        result1 = df.group(\"foo\").accumulate(\"bar\", into=\"bar_cumsum\")\n        result2 = df.group(\"foo\").gather()\n        result3 = df.group(\"foo\").pack(\"bar\", sep=\":\")\n        result4 = df.group(\"foo\").rank(\"baz\", into=\"baz_rank\", descending=True)\n        result5 = df.group(\"foo\").rollup(\n            {\"bar_mean\": (\"bar\", rf.stat.mean), \"baz_min\": (\"baz\", rf.stat.min)}\n        )\n        result6 = df.group(\"foo\").take(1)\n        expected1 = rf.DataFrame(\n            {\n                \"foo\": [\"A\", \"A\", \"A\", \"B\", \"B\"],\n                \"bar\": [1, 2, 3, 4, 5],\n                \"baz\": [9, 7, 7, 5, 6],\n                \"bar_cumsum\": [1, 3, 6, 4, 9],\n            }\n        )\n        expected2 = rf.DataFrame(\n            {\n                \"foo\": [\"A\", \"A\", \"A\", \"B\", \"B\", \"A\", \"A\", \"A\", \"B\", \"B\"],\n                \"variable\": [\n                    \"bar\",\n                    \"bar\",\n                    \"bar\",\n                    \"bar\",\n                    \"bar\",\n                    \"baz\",\n                    \"baz\",\n                    \"baz\",\n                    \"baz\",\n                    \"baz\",\n                ],\n                \"value\": [1, 2, 3, 4, 5, 9, 7, 7, 5, 6],\n            }\n        )\n        expected3 = rf.DataFrame({\"foo\": [\"A\", \"B\"], \"bar\": [\"1:2:3\", \"4:5\"]})\n        expected4 = rf.DataFrame(\n            {\n                \"foo\": [\"A\", \"A\", \"A\", \"B\", \"B\"],\n                \"bar\": [1, 2, 3, 4, 5],\n                \"baz\": [9, 7, 7, 5, 6],\n                \"baz_rank\": [1.0, 2.0, 2.0, 2.0, 1.0],\n            }\n        )\n        expected5 = rf.DataFrame(\n            {\"foo\": [\"A\", \"B\"], \"bar_mean\": [2.0, 4.5], \"baz_min\": [7, 5]}", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_docstrings.py_305-355"}
{"title": "maxhumber_redframes-tests-test_docstrings.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_docstrings.py"], "line_no": 340, "start_line_no": 315, "end_line_no": 365, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "            {\"bar_mean\": (\"bar\", rf.stat.mean), \"baz_min\": (\"baz\", rf.stat.min)}\n        )\n        result6 = df.group(\"foo\").take(1)\n        expected1 = rf.DataFrame(\n            {\n                \"foo\": [\"A\", \"A\", \"A\", \"B\", \"B\"],\n                \"bar\": [1, 2, 3, 4, 5],\n                \"baz\": [9, 7, 7, 5, 6],\n                \"bar_cumsum\": [1, 3, 6, 4, 9],\n            }\n        )\n        expected2 = rf.DataFrame(\n            {\n                \"foo\": [\"A\", \"A\", \"A\", \"B\", \"B\", \"A\", \"A\", \"A\", \"B\", \"B\"],\n                \"variable\": [\n                    \"bar\",\n                    \"bar\",\n                    \"bar\",\n                    \"bar\",\n                    \"bar\",\n                    \"baz\",\n                    \"baz\",\n                    \"baz\",\n                    \"baz\",\n                    \"baz\",\n                ],\n                \"value\": [1, 2, 3, 4, 5, 9, 7, 7, 5, 6],\n            }\n        )\n        expected3 = rf.DataFrame({\"foo\": [\"A\", \"B\"], \"bar\": [\"1:2:3\", \"4:5\"]})\n        expected4 = rf.DataFrame(\n            {\n                \"foo\": [\"A\", \"A\", \"A\", \"B\", \"B\"],\n                \"bar\": [1, 2, 3, 4, 5],\n                \"baz\": [9, 7, 7, 5, 6],\n                \"baz_rank\": [1.0, 2.0, 2.0, 2.0, 1.0],\n            }\n        )\n        expected5 = rf.DataFrame(\n            {\"foo\": [\"A\", \"B\"], \"bar_mean\": [2.0, 4.5], \"baz_min\": [7, 5]}\n        )\n        expected6 = rf.DataFrame({\"foo\": [\"A\", \"B\"], \"bar\": [1, 4], \"baz\": [9, 5]})\n        self.assertEqual(result1, expected1)\n        self.assertEqual(result2, expected2)\n        self.assertEqual(result3, expected3)\n        self.assertEqual(result4, expected4)\n        self.assertEqual(result5, expected5)\n        self.assertEqual(result6, expected6)\n\n    def test_join(self):", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_docstrings.py_315-365"}
{"title": "maxhumber_redframes-tests-test_docstrings.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_docstrings.py"], "line_no": 350, "start_line_no": 325, "end_line_no": 375, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        )\n        expected2 = rf.DataFrame(\n            {\n                \"foo\": [\"A\", \"A\", \"A\", \"B\", \"B\", \"A\", \"A\", \"A\", \"B\", \"B\"],\n                \"variable\": [\n                    \"bar\",\n                    \"bar\",\n                    \"bar\",\n                    \"bar\",\n                    \"bar\",\n                    \"baz\",\n                    \"baz\",\n                    \"baz\",\n                    \"baz\",\n                    \"baz\",\n                ],\n                \"value\": [1, 2, 3, 4, 5, 9, 7, 7, 5, 6],\n            }\n        )\n        expected3 = rf.DataFrame({\"foo\": [\"A\", \"B\"], \"bar\": [\"1:2:3\", \"4:5\"]})\n        expected4 = rf.DataFrame(\n            {\n                \"foo\": [\"A\", \"A\", \"A\", \"B\", \"B\"],\n                \"bar\": [1, 2, 3, 4, 5],\n                \"baz\": [9, 7, 7, 5, 6],\n                \"baz_rank\": [1.0, 2.0, 2.0, 2.0, 1.0],\n            }\n        )\n        expected5 = rf.DataFrame(\n            {\"foo\": [\"A\", \"B\"], \"bar_mean\": [2.0, 4.5], \"baz_min\": [7, 5]}\n        )\n        expected6 = rf.DataFrame({\"foo\": [\"A\", \"B\"], \"bar\": [1, 4], \"baz\": [9, 5]})\n        self.assertEqual(result1, expected1)\n        self.assertEqual(result2, expected2)\n        self.assertEqual(result3, expected3)\n        self.assertEqual(result4, expected4)\n        self.assertEqual(result5, expected5)\n        self.assertEqual(result6, expected6)\n\n    def test_join(self):\n        adf = rf.DataFrame({\"foo\": [\"A\", \"B\", \"C\"], \"bar\": [1, 2, 3]})\n        bdf = rf.DataFrame({\"foo\": [\"A\", \"B\", \"D\"], \"baz\": [\"!\", \"@\", \"#\"]})\n        result1 = adf.join(bdf, on=\"foo\", how=\"left\")\n        result2 = adf.join(bdf, on=\"foo\", how=\"right\")\n        result3 = adf.join(bdf, on=\"foo\", how=\"inner\")\n        result4 = adf.join(bdf, on=\"foo\", how=\"full\")\n        expected1 = rf.DataFrame(\n            {\"foo\": [\"A\", \"B\", \"C\"], \"bar\": [1, 2, 3], \"baz\": [\"!\", \"@\", None]}\n        )\n        expected2 = rf.DataFrame(", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_docstrings.py_325-375"}
{"title": "maxhumber_redframes-tests-test_docstrings.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_docstrings.py"], "line_no": 360, "start_line_no": 335, "end_line_no": 385, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "                    \"baz\",\n                    \"baz\",\n                    \"baz\",\n                    \"baz\",\n                    \"baz\",\n                ],\n                \"value\": [1, 2, 3, 4, 5, 9, 7, 7, 5, 6],\n            }\n        )\n        expected3 = rf.DataFrame({\"foo\": [\"A\", \"B\"], \"bar\": [\"1:2:3\", \"4:5\"]})\n        expected4 = rf.DataFrame(\n            {\n                \"foo\": [\"A\", \"A\", \"A\", \"B\", \"B\"],\n                \"bar\": [1, 2, 3, 4, 5],\n                \"baz\": [9, 7, 7, 5, 6],\n                \"baz_rank\": [1.0, 2.0, 2.0, 2.0, 1.0],\n            }\n        )\n        expected5 = rf.DataFrame(\n            {\"foo\": [\"A\", \"B\"], \"bar_mean\": [2.0, 4.5], \"baz_min\": [7, 5]}\n        )\n        expected6 = rf.DataFrame({\"foo\": [\"A\", \"B\"], \"bar\": [1, 4], \"baz\": [9, 5]})\n        self.assertEqual(result1, expected1)\n        self.assertEqual(result2, expected2)\n        self.assertEqual(result3, expected3)\n        self.assertEqual(result4, expected4)\n        self.assertEqual(result5, expected5)\n        self.assertEqual(result6, expected6)\n\n    def test_join(self):\n        adf = rf.DataFrame({\"foo\": [\"A\", \"B\", \"C\"], \"bar\": [1, 2, 3]})\n        bdf = rf.DataFrame({\"foo\": [\"A\", \"B\", \"D\"], \"baz\": [\"!\", \"@\", \"#\"]})\n        result1 = adf.join(bdf, on=\"foo\", how=\"left\")\n        result2 = adf.join(bdf, on=\"foo\", how=\"right\")\n        result3 = adf.join(bdf, on=\"foo\", how=\"inner\")\n        result4 = adf.join(bdf, on=\"foo\", how=\"full\")\n        expected1 = rf.DataFrame(\n            {\"foo\": [\"A\", \"B\", \"C\"], \"bar\": [1, 2, 3], \"baz\": [\"!\", \"@\", None]}\n        )\n        expected2 = rf.DataFrame(\n            {\"foo\": [\"A\", \"B\", \"D\"], \"bar\": [1.0, 2.0, None], \"baz\": [\"!\", \"@\", \"#\"]}\n        )\n        expected3 = rf.DataFrame({\"foo\": [\"A\", \"B\"], \"bar\": [1, 2], \"baz\": [\"!\", \"@\"]})\n        expected4 = rf.DataFrame(\n            {\n                \"foo\": [\"A\", \"B\", \"C\", \"D\"],\n                \"bar\": [1.0, 2.0, 3.0, None],\n                \"baz\": [\"!\", \"@\", None, \"#\"],\n            }\n        )", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_docstrings.py_335-385"}
{"title": "maxhumber_redframes-tests-test_docstrings.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_docstrings.py"], "line_no": 370, "start_line_no": 345, "end_line_no": 395, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        expected4 = rf.DataFrame(\n            {\n                \"foo\": [\"A\", \"A\", \"A\", \"B\", \"B\"],\n                \"bar\": [1, 2, 3, 4, 5],\n                \"baz\": [9, 7, 7, 5, 6],\n                \"baz_rank\": [1.0, 2.0, 2.0, 2.0, 1.0],\n            }\n        )\n        expected5 = rf.DataFrame(\n            {\"foo\": [\"A\", \"B\"], \"bar_mean\": [2.0, 4.5], \"baz_min\": [7, 5]}\n        )\n        expected6 = rf.DataFrame({\"foo\": [\"A\", \"B\"], \"bar\": [1, 4], \"baz\": [9, 5]})\n        self.assertEqual(result1, expected1)\n        self.assertEqual(result2, expected2)\n        self.assertEqual(result3, expected3)\n        self.assertEqual(result4, expected4)\n        self.assertEqual(result5, expected5)\n        self.assertEqual(result6, expected6)\n\n    def test_join(self):\n        adf = rf.DataFrame({\"foo\": [\"A\", \"B\", \"C\"], \"bar\": [1, 2, 3]})\n        bdf = rf.DataFrame({\"foo\": [\"A\", \"B\", \"D\"], \"baz\": [\"!\", \"@\", \"#\"]})\n        result1 = adf.join(bdf, on=\"foo\", how=\"left\")\n        result2 = adf.join(bdf, on=\"foo\", how=\"right\")\n        result3 = adf.join(bdf, on=\"foo\", how=\"inner\")\n        result4 = adf.join(bdf, on=\"foo\", how=\"full\")\n        expected1 = rf.DataFrame(\n            {\"foo\": [\"A\", \"B\", \"C\"], \"bar\": [1, 2, 3], \"baz\": [\"!\", \"@\", None]}\n        )\n        expected2 = rf.DataFrame(\n            {\"foo\": [\"A\", \"B\", \"D\"], \"bar\": [1.0, 2.0, None], \"baz\": [\"!\", \"@\", \"#\"]}\n        )\n        expected3 = rf.DataFrame({\"foo\": [\"A\", \"B\"], \"bar\": [1, 2], \"baz\": [\"!\", \"@\"]})\n        expected4 = rf.DataFrame(\n            {\n                \"foo\": [\"A\", \"B\", \"C\", \"D\"],\n                \"bar\": [1.0, 2.0, 3.0, None],\n                \"baz\": [\"!\", \"@\", None, \"#\"],\n            }\n        )\n        self.assertEqual(result1, expected1)\n        self.assertEqual(result2, expected2)\n        self.assertEqual(result3, expected3)\n        self.assertEqual(result4, expected4)\n\n    def test_mutate(self):\n        df = rf.DataFrame({\"foo\": [1, 2, 3]})\n        result = df.mutate(\n            {\n                \"bar\": lambda row: float(row[\"foo\"]),", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_docstrings.py_345-395"}
{"title": "maxhumber_redframes-tests-test_docstrings.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_docstrings.py"], "line_no": 380, "start_line_no": 355, "end_line_no": 405, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        )\n        expected6 = rf.DataFrame({\"foo\": [\"A\", \"B\"], \"bar\": [1, 4], \"baz\": [9, 5]})\n        self.assertEqual(result1, expected1)\n        self.assertEqual(result2, expected2)\n        self.assertEqual(result3, expected3)\n        self.assertEqual(result4, expected4)\n        self.assertEqual(result5, expected5)\n        self.assertEqual(result6, expected6)\n\n    def test_join(self):\n        adf = rf.DataFrame({\"foo\": [\"A\", \"B\", \"C\"], \"bar\": [1, 2, 3]})\n        bdf = rf.DataFrame({\"foo\": [\"A\", \"B\", \"D\"], \"baz\": [\"!\", \"@\", \"#\"]})\n        result1 = adf.join(bdf, on=\"foo\", how=\"left\")\n        result2 = adf.join(bdf, on=\"foo\", how=\"right\")\n        result3 = adf.join(bdf, on=\"foo\", how=\"inner\")\n        result4 = adf.join(bdf, on=\"foo\", how=\"full\")\n        expected1 = rf.DataFrame(\n            {\"foo\": [\"A\", \"B\", \"C\"], \"bar\": [1, 2, 3], \"baz\": [\"!\", \"@\", None]}\n        )\n        expected2 = rf.DataFrame(\n            {\"foo\": [\"A\", \"B\", \"D\"], \"bar\": [1.0, 2.0, None], \"baz\": [\"!\", \"@\", \"#\"]}\n        )\n        expected3 = rf.DataFrame({\"foo\": [\"A\", \"B\"], \"bar\": [1, 2], \"baz\": [\"!\", \"@\"]})\n        expected4 = rf.DataFrame(\n            {\n                \"foo\": [\"A\", \"B\", \"C\", \"D\"],\n                \"bar\": [1.0, 2.0, 3.0, None],\n                \"baz\": [\"!\", \"@\", None, \"#\"],\n            }\n        )\n        self.assertEqual(result1, expected1)\n        self.assertEqual(result2, expected2)\n        self.assertEqual(result3, expected3)\n        self.assertEqual(result4, expected4)\n\n    def test_mutate(self):\n        df = rf.DataFrame({\"foo\": [1, 2, 3]})\n        result = df.mutate(\n            {\n                \"bar\": lambda row: float(row[\"foo\"]),\n                \"baz\": lambda row: \"X\" + str(row[\"bar\"] * 2),\n                \"jaz\": lambda _: \"Jazz\",\n            }\n        )\n        expected = rf.DataFrame(\n            {\n                \"foo\": [1, 2, 3],\n                \"bar\": [1.0, 2.0, 3.0],\n                \"baz\": [\"X2.0\", \"X4.0\", \"X6.0\"],\n                \"jaz\": [\"Jazz\", \"Jazz\", \"Jazz\"],", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_docstrings.py_355-405"}
{"title": "maxhumber_redframes-tests-test_docstrings.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_docstrings.py"], "line_no": 390, "start_line_no": 365, "end_line_no": 415, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        adf = rf.DataFrame({\"foo\": [\"A\", \"B\", \"C\"], \"bar\": [1, 2, 3]})\n        bdf = rf.DataFrame({\"foo\": [\"A\", \"B\", \"D\"], \"baz\": [\"!\", \"@\", \"#\"]})\n        result1 = adf.join(bdf, on=\"foo\", how=\"left\")\n        result2 = adf.join(bdf, on=\"foo\", how=\"right\")\n        result3 = adf.join(bdf, on=\"foo\", how=\"inner\")\n        result4 = adf.join(bdf, on=\"foo\", how=\"full\")\n        expected1 = rf.DataFrame(\n            {\"foo\": [\"A\", \"B\", \"C\"], \"bar\": [1, 2, 3], \"baz\": [\"!\", \"@\", None]}\n        )\n        expected2 = rf.DataFrame(\n            {\"foo\": [\"A\", \"B\", \"D\"], \"bar\": [1.0, 2.0, None], \"baz\": [\"!\", \"@\", \"#\"]}\n        )\n        expected3 = rf.DataFrame({\"foo\": [\"A\", \"B\"], \"bar\": [1, 2], \"baz\": [\"!\", \"@\"]})\n        expected4 = rf.DataFrame(\n            {\n                \"foo\": [\"A\", \"B\", \"C\", \"D\"],\n                \"bar\": [1.0, 2.0, 3.0, None],\n                \"baz\": [\"!\", \"@\", None, \"#\"],\n            }\n        )\n        self.assertEqual(result1, expected1)\n        self.assertEqual(result2, expected2)\n        self.assertEqual(result3, expected3)\n        self.assertEqual(result4, expected4)\n\n    def test_mutate(self):\n        df = rf.DataFrame({\"foo\": [1, 2, 3]})\n        result = df.mutate(\n            {\n                \"bar\": lambda row: float(row[\"foo\"]),\n                \"baz\": lambda row: \"X\" + str(row[\"bar\"] * 2),\n                \"jaz\": lambda _: \"Jazz\",\n            }\n        )\n        expected = rf.DataFrame(\n            {\n                \"foo\": [1, 2, 3],\n                \"bar\": [1.0, 2.0, 3.0],\n                \"baz\": [\"X2.0\", \"X4.0\", \"X6.0\"],\n                \"jaz\": [\"Jazz\", \"Jazz\", \"Jazz\"],\n            }\n        )\n        self.assertEqual(result, expected)\n\n    def test_rename(self):\n        df = rf.DataFrame({\"foo\": [1, 2], \"bar\": [3, 4]})\n        result = df.rename({\"foo\": \"oof\", \"bar\": \"rab\"})\n        expected = rf.DataFrame({\"oof\": [1, 2], \"rab\": [3, 4]})\n        self.assertEqual(result, expected)\n", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_docstrings.py_365-415"}
{"title": "maxhumber_redframes-tests-test_docstrings.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_docstrings.py"], "line_no": 400, "start_line_no": 375, "end_line_no": 425, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "            {\"foo\": [\"A\", \"B\", \"D\"], \"bar\": [1.0, 2.0, None], \"baz\": [\"!\", \"@\", \"#\"]}\n        )\n        expected3 = rf.DataFrame({\"foo\": [\"A\", \"B\"], \"bar\": [1, 2], \"baz\": [\"!\", \"@\"]})\n        expected4 = rf.DataFrame(\n            {\n                \"foo\": [\"A\", \"B\", \"C\", \"D\"],\n                \"bar\": [1.0, 2.0, 3.0, None],\n                \"baz\": [\"!\", \"@\", None, \"#\"],\n            }\n        )\n        self.assertEqual(result1, expected1)\n        self.assertEqual(result2, expected2)\n        self.assertEqual(result3, expected3)\n        self.assertEqual(result4, expected4)\n\n    def test_mutate(self):\n        df = rf.DataFrame({\"foo\": [1, 2, 3]})\n        result = df.mutate(\n            {\n                \"bar\": lambda row: float(row[\"foo\"]),\n                \"baz\": lambda row: \"X\" + str(row[\"bar\"] * 2),\n                \"jaz\": lambda _: \"Jazz\",\n            }\n        )\n        expected = rf.DataFrame(\n            {\n                \"foo\": [1, 2, 3],\n                \"bar\": [1.0, 2.0, 3.0],\n                \"baz\": [\"X2.0\", \"X4.0\", \"X6.0\"],\n                \"jaz\": [\"Jazz\", \"Jazz\", \"Jazz\"],\n            }\n        )\n        self.assertEqual(result, expected)\n\n    def test_rename(self):\n        df = rf.DataFrame({\"foo\": [1, 2], \"bar\": [3, 4]})\n        result = df.rename({\"foo\": \"oof\", \"bar\": \"rab\"})\n        expected = rf.DataFrame({\"oof\": [1, 2], \"rab\": [3, 4]})\n        self.assertEqual(result, expected)\n\n    def test_replace(self):\n        df = rf.DataFrame({\"foo\": [1, 2, 2, 2, 1], \"bar\": [1, \"A\", \"B\", True, False]})\n        result = df.replace(\n            {\"foo\": {2: 222}, \"bar\": {False: 0, True: 1, \"A\": 2, \"B\": 3}}\n        )\n        expected = rf.DataFrame({\"foo\": [1, 222, 222, 222, 1], \"bar\": [1, 2, 3, 1, 0]})\n        self.assertEqual(result, expected)\n\n    def test_sample(self):\n        df = rf.DataFrame({\"foo\": range(10), \"bar\": range(10, 20)})", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_docstrings.py_375-425"}
{"title": "maxhumber_redframes-tests-test_docstrings.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_docstrings.py"], "line_no": 410, "start_line_no": 385, "end_line_no": 435, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        self.assertEqual(result1, expected1)\n        self.assertEqual(result2, expected2)\n        self.assertEqual(result3, expected3)\n        self.assertEqual(result4, expected4)\n\n    def test_mutate(self):\n        df = rf.DataFrame({\"foo\": [1, 2, 3]})\n        result = df.mutate(\n            {\n                \"bar\": lambda row: float(row[\"foo\"]),\n                \"baz\": lambda row: \"X\" + str(row[\"bar\"] * 2),\n                \"jaz\": lambda _: \"Jazz\",\n            }\n        )\n        expected = rf.DataFrame(\n            {\n                \"foo\": [1, 2, 3],\n                \"bar\": [1.0, 2.0, 3.0],\n                \"baz\": [\"X2.0\", \"X4.0\", \"X6.0\"],\n                \"jaz\": [\"Jazz\", \"Jazz\", \"Jazz\"],\n            }\n        )\n        self.assertEqual(result, expected)\n\n    def test_rename(self):\n        df = rf.DataFrame({\"foo\": [1, 2], \"bar\": [3, 4]})\n        result = df.rename({\"foo\": \"oof\", \"bar\": \"rab\"})\n        expected = rf.DataFrame({\"oof\": [1, 2], \"rab\": [3, 4]})\n        self.assertEqual(result, expected)\n\n    def test_replace(self):\n        df = rf.DataFrame({\"foo\": [1, 2, 2, 2, 1], \"bar\": [1, \"A\", \"B\", True, False]})\n        result = df.replace(\n            {\"foo\": {2: 222}, \"bar\": {False: 0, True: 1, \"A\": 2, \"B\": 3}}\n        )\n        expected = rf.DataFrame({\"foo\": [1, 222, 222, 222, 1], \"bar\": [1, 2, 3, 1, 0]})\n        self.assertEqual(result, expected)\n\n    def test_sample(self):\n        df = rf.DataFrame({\"foo\": range(10), \"bar\": range(10, 20)})\n        result1 = df.sample(1)\n        result2 = df.sample(3)\n        result3 = df.sample(0.3)\n        self.assertEqual(len(result1), 1)\n        self.assertEqual(len(result2), 3)\n        self.assertEqual(len(result3), 3)\n\n    def test_select(self):\n        df = rf.DataFrame({\"foo\": [1, 2], \"bar\": [3, 4], \"baz\": [5, 6]})\n        result1 = df.select(\"foo\")", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_docstrings.py_385-435"}
{"title": "maxhumber_redframes-tests-test_docstrings.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_docstrings.py"], "line_no": 420, "start_line_no": 395, "end_line_no": 445, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "                \"baz\": lambda row: \"X\" + str(row[\"bar\"] * 2),\n                \"jaz\": lambda _: \"Jazz\",\n            }\n        )\n        expected = rf.DataFrame(\n            {\n                \"foo\": [1, 2, 3],\n                \"bar\": [1.0, 2.0, 3.0],\n                \"baz\": [\"X2.0\", \"X4.0\", \"X6.0\"],\n                \"jaz\": [\"Jazz\", \"Jazz\", \"Jazz\"],\n            }\n        )\n        self.assertEqual(result, expected)\n\n    def test_rename(self):\n        df = rf.DataFrame({\"foo\": [1, 2], \"bar\": [3, 4]})\n        result = df.rename({\"foo\": \"oof\", \"bar\": \"rab\"})\n        expected = rf.DataFrame({\"oof\": [1, 2], \"rab\": [3, 4]})\n        self.assertEqual(result, expected)\n\n    def test_replace(self):\n        df = rf.DataFrame({\"foo\": [1, 2, 2, 2, 1], \"bar\": [1, \"A\", \"B\", True, False]})\n        result = df.replace(\n            {\"foo\": {2: 222}, \"bar\": {False: 0, True: 1, \"A\": 2, \"B\": 3}}\n        )\n        expected = rf.DataFrame({\"foo\": [1, 222, 222, 222, 1], \"bar\": [1, 2, 3, 1, 0]})\n        self.assertEqual(result, expected)\n\n    def test_sample(self):\n        df = rf.DataFrame({\"foo\": range(10), \"bar\": range(10, 20)})\n        result1 = df.sample(1)\n        result2 = df.sample(3)\n        result3 = df.sample(0.3)\n        self.assertEqual(len(result1), 1)\n        self.assertEqual(len(result2), 3)\n        self.assertEqual(len(result3), 3)\n\n    def test_select(self):\n        df = rf.DataFrame({\"foo\": [1, 2], \"bar\": [3, 4], \"baz\": [5, 6]})\n        result1 = df.select(\"foo\")\n        result2 = df.select([\"foo\", \"baz\"])\n        expected1 = rf.DataFrame({\"foo\": [1, 2]})\n        expected2 = rf.DataFrame({\"foo\": [1, 2], \"baz\": [5, 6]})\n        self.assertEqual(result1, expected1)\n        self.assertEqual(result2, expected2)\n\n    def test_shuffle(self):\n        df = rf.DataFrame({\"foo\": range(5), \"bar\": range(5, 10)})\n        result = df.shuffle()\n        self.assertNotEqual(df, result)", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_docstrings.py_395-445"}
{"title": "maxhumber_redframes-tests-test_docstrings.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_docstrings.py"], "line_no": 430, "start_line_no": 405, "end_line_no": 455, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "            }\n        )\n        self.assertEqual(result, expected)\n\n    def test_rename(self):\n        df = rf.DataFrame({\"foo\": [1, 2], \"bar\": [3, 4]})\n        result = df.rename({\"foo\": \"oof\", \"bar\": \"rab\"})\n        expected = rf.DataFrame({\"oof\": [1, 2], \"rab\": [3, 4]})\n        self.assertEqual(result, expected)\n\n    def test_replace(self):\n        df = rf.DataFrame({\"foo\": [1, 2, 2, 2, 1], \"bar\": [1, \"A\", \"B\", True, False]})\n        result = df.replace(\n            {\"foo\": {2: 222}, \"bar\": {False: 0, True: 1, \"A\": 2, \"B\": 3}}\n        )\n        expected = rf.DataFrame({\"foo\": [1, 222, 222, 222, 1], \"bar\": [1, 2, 3, 1, 0]})\n        self.assertEqual(result, expected)\n\n    def test_sample(self):\n        df = rf.DataFrame({\"foo\": range(10), \"bar\": range(10, 20)})\n        result1 = df.sample(1)\n        result2 = df.sample(3)\n        result3 = df.sample(0.3)\n        self.assertEqual(len(result1), 1)\n        self.assertEqual(len(result2), 3)\n        self.assertEqual(len(result3), 3)\n\n    def test_select(self):\n        df = rf.DataFrame({\"foo\": [1, 2], \"bar\": [3, 4], \"baz\": [5, 6]})\n        result1 = df.select(\"foo\")\n        result2 = df.select([\"foo\", \"baz\"])\n        expected1 = rf.DataFrame({\"foo\": [1, 2]})\n        expected2 = rf.DataFrame({\"foo\": [1, 2], \"baz\": [5, 6]})\n        self.assertEqual(result1, expected1)\n        self.assertEqual(result2, expected2)\n\n    def test_shuffle(self):\n        df = rf.DataFrame({\"foo\": range(5), \"bar\": range(5, 10)})\n        result = df.shuffle()\n        self.assertNotEqual(df, result)\n\n    def test_sort(self):\n        df = rf.DataFrame({\"foo\": [\"Z\", \"X\", \"A\", \"A\"], \"bar\": [2, -2, 4, -4]})\n        result1 = df.sort(\"bar\")\n        result2 = df.sort(\"bar\", descending=True)\n        result3 = df.sort([\"foo\", \"bar\"], descending=False)\n        expected1 = rf.DataFrame({\"foo\": [\"A\", \"X\", \"Z\", \"A\"], \"bar\": [-4, -2, 2, 4]})\n        expected2 = rf.DataFrame({\"foo\": [\"A\", \"Z\", \"X\", \"A\"], \"bar\": [4, 2, -2, -4]})\n        expected3 = rf.DataFrame({\"foo\": [\"A\", \"A\", \"X\", \"Z\"], \"bar\": [-4, 4, -2, 2]})\n        self.assertEqual(result1, expected1)", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_docstrings.py_405-455"}
{"title": "maxhumber_redframes-tests-test_docstrings.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_docstrings.py"], "line_no": 440, "start_line_no": 415, "end_line_no": 465, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "    def test_replace(self):\n        df = rf.DataFrame({\"foo\": [1, 2, 2, 2, 1], \"bar\": [1, \"A\", \"B\", True, False]})\n        result = df.replace(\n            {\"foo\": {2: 222}, \"bar\": {False: 0, True: 1, \"A\": 2, \"B\": 3}}\n        )\n        expected = rf.DataFrame({\"foo\": [1, 222, 222, 222, 1], \"bar\": [1, 2, 3, 1, 0]})\n        self.assertEqual(result, expected)\n\n    def test_sample(self):\n        df = rf.DataFrame({\"foo\": range(10), \"bar\": range(10, 20)})\n        result1 = df.sample(1)\n        result2 = df.sample(3)\n        result3 = df.sample(0.3)\n        self.assertEqual(len(result1), 1)\n        self.assertEqual(len(result2), 3)\n        self.assertEqual(len(result3), 3)\n\n    def test_select(self):\n        df = rf.DataFrame({\"foo\": [1, 2], \"bar\": [3, 4], \"baz\": [5, 6]})\n        result1 = df.select(\"foo\")\n        result2 = df.select([\"foo\", \"baz\"])\n        expected1 = rf.DataFrame({\"foo\": [1, 2]})\n        expected2 = rf.DataFrame({\"foo\": [1, 2], \"baz\": [5, 6]})\n        self.assertEqual(result1, expected1)\n        self.assertEqual(result2, expected2)\n\n    def test_shuffle(self):\n        df = rf.DataFrame({\"foo\": range(5), \"bar\": range(5, 10)})\n        result = df.shuffle()\n        self.assertNotEqual(df, result)\n\n    def test_sort(self):\n        df = rf.DataFrame({\"foo\": [\"Z\", \"X\", \"A\", \"A\"], \"bar\": [2, -2, 4, -4]})\n        result1 = df.sort(\"bar\")\n        result2 = df.sort(\"bar\", descending=True)\n        result3 = df.sort([\"foo\", \"bar\"], descending=False)\n        expected1 = rf.DataFrame({\"foo\": [\"A\", \"X\", \"Z\", \"A\"], \"bar\": [-4, -2, 2, 4]})\n        expected2 = rf.DataFrame({\"foo\": [\"A\", \"Z\", \"X\", \"A\"], \"bar\": [4, 2, -2, -4]})\n        expected3 = rf.DataFrame({\"foo\": [\"A\", \"A\", \"X\", \"Z\"], \"bar\": [-4, 4, -2, 2]})\n        self.assertEqual(result1, expected1)\n        self.assertEqual(result2, expected2)\n        self.assertEqual(result3, expected3)\n\n    def test_split(self):\n        df = rf.DataFrame({\"foo\": [\"A::1\", \"B::2\", \"C:3\"]})\n        result = df.split(\"foo\", into=[\"foo\", \"bar\"], sep=\"::\", drop=True)\n        expected = rf.DataFrame({\"foo\": [\"A\", \"B\", \"C:3\"], \"bar\": [\"1\", \"2\", None]})\n        self.assertEqual(result, expected)\n\n    def test_spread(self):", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_docstrings.py_415-465"}
{"title": "maxhumber_redframes-tests-test_docstrings.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_docstrings.py"], "line_no": 450, "start_line_no": 425, "end_line_no": 475, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        result1 = df.sample(1)\n        result2 = df.sample(3)\n        result3 = df.sample(0.3)\n        self.assertEqual(len(result1), 1)\n        self.assertEqual(len(result2), 3)\n        self.assertEqual(len(result3), 3)\n\n    def test_select(self):\n        df = rf.DataFrame({\"foo\": [1, 2], \"bar\": [3, 4], \"baz\": [5, 6]})\n        result1 = df.select(\"foo\")\n        result2 = df.select([\"foo\", \"baz\"])\n        expected1 = rf.DataFrame({\"foo\": [1, 2]})\n        expected2 = rf.DataFrame({\"foo\": [1, 2], \"baz\": [5, 6]})\n        self.assertEqual(result1, expected1)\n        self.assertEqual(result2, expected2)\n\n    def test_shuffle(self):\n        df = rf.DataFrame({\"foo\": range(5), \"bar\": range(5, 10)})\n        result = df.shuffle()\n        self.assertNotEqual(df, result)\n\n    def test_sort(self):\n        df = rf.DataFrame({\"foo\": [\"Z\", \"X\", \"A\", \"A\"], \"bar\": [2, -2, 4, -4]})\n        result1 = df.sort(\"bar\")\n        result2 = df.sort(\"bar\", descending=True)\n        result3 = df.sort([\"foo\", \"bar\"], descending=False)\n        expected1 = rf.DataFrame({\"foo\": [\"A\", \"X\", \"Z\", \"A\"], \"bar\": [-4, -2, 2, 4]})\n        expected2 = rf.DataFrame({\"foo\": [\"A\", \"Z\", \"X\", \"A\"], \"bar\": [4, 2, -2, -4]})\n        expected3 = rf.DataFrame({\"foo\": [\"A\", \"A\", \"X\", \"Z\"], \"bar\": [-4, 4, -2, 2]})\n        self.assertEqual(result1, expected1)\n        self.assertEqual(result2, expected2)\n        self.assertEqual(result3, expected3)\n\n    def test_split(self):\n        df = rf.DataFrame({\"foo\": [\"A::1\", \"B::2\", \"C:3\"]})\n        result = df.split(\"foo\", into=[\"foo\", \"bar\"], sep=\"::\", drop=True)\n        expected = rf.DataFrame({\"foo\": [\"A\", \"B\", \"C:3\"], \"bar\": [\"1\", \"2\", None]})\n        self.assertEqual(result, expected)\n\n    def test_spread(self):\n        df = rf.DataFrame(\n            {\"foo\": [\"A\", \"A\", \"A\", \"B\", \"B\", \"B\", \"B\"], \"bar\": [1, 2, 3, 4, 5, 6, 7]}\n        )\n        result = df.spread(\"foo\", using=\"bar\")\n        expected = rf.DataFrame({\"A\": [1.0, 2.0, 3.0, None], \"B\": [4.0, 5.0, 6.0, 7.0]})\n        self.assertEqual(result, expected)\n\n    def test_unpack(self):\n        df = rf.DataFrame({\"foo\": [1, 2, 3, 4], \"bar\": [\"A:B\", \"B:C:D\", \"D:E\", \"F\"]})\n        result = df.unpack(\"bar\", sep=\":\")", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_docstrings.py_425-475"}
{"title": "maxhumber_redframes-tests-test_docstrings.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_docstrings.py"], "line_no": 460, "start_line_no": 435, "end_line_no": 482, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        result2 = df.select([\"foo\", \"baz\"])\n        expected1 = rf.DataFrame({\"foo\": [1, 2]})\n        expected2 = rf.DataFrame({\"foo\": [1, 2], \"baz\": [5, 6]})\n        self.assertEqual(result1, expected1)\n        self.assertEqual(result2, expected2)\n\n    def test_shuffle(self):\n        df = rf.DataFrame({\"foo\": range(5), \"bar\": range(5, 10)})\n        result = df.shuffle()\n        self.assertNotEqual(df, result)\n\n    def test_sort(self):\n        df = rf.DataFrame({\"foo\": [\"Z\", \"X\", \"A\", \"A\"], \"bar\": [2, -2, 4, -4]})\n        result1 = df.sort(\"bar\")\n        result2 = df.sort(\"bar\", descending=True)\n        result3 = df.sort([\"foo\", \"bar\"], descending=False)\n        expected1 = rf.DataFrame({\"foo\": [\"A\", \"X\", \"Z\", \"A\"], \"bar\": [-4, -2, 2, 4]})\n        expected2 = rf.DataFrame({\"foo\": [\"A\", \"Z\", \"X\", \"A\"], \"bar\": [4, 2, -2, -4]})\n        expected3 = rf.DataFrame({\"foo\": [\"A\", \"A\", \"X\", \"Z\"], \"bar\": [-4, 4, -2, 2]})\n        self.assertEqual(result1, expected1)\n        self.assertEqual(result2, expected2)\n        self.assertEqual(result3, expected3)\n\n    def test_split(self):\n        df = rf.DataFrame({\"foo\": [\"A::1\", \"B::2\", \"C:3\"]})\n        result = df.split(\"foo\", into=[\"foo\", \"bar\"], sep=\"::\", drop=True)\n        expected = rf.DataFrame({\"foo\": [\"A\", \"B\", \"C:3\"], \"bar\": [\"1\", \"2\", None]})\n        self.assertEqual(result, expected)\n\n    def test_spread(self):\n        df = rf.DataFrame(\n            {\"foo\": [\"A\", \"A\", \"A\", \"B\", \"B\", \"B\", \"B\"], \"bar\": [1, 2, 3, 4, 5, 6, 7]}\n        )\n        result = df.spread(\"foo\", using=\"bar\")\n        expected = rf.DataFrame({\"A\": [1.0, 2.0, 3.0, None], \"B\": [4.0, 5.0, 6.0, 7.0]})\n        self.assertEqual(result, expected)\n\n    def test_unpack(self):\n        df = rf.DataFrame({\"foo\": [1, 2, 3, 4], \"bar\": [\"A:B\", \"B:C:D\", \"D:E\", \"F\"]})\n        result = df.unpack(\"bar\", sep=\":\")\n        expected = rf.DataFrame(\n            {\n                \"foo\": [1, 1, 2, 2, 2, 3, 3, 4],\n                \"bar\": [\"A\", \"B\", \"B\", \"C\", \"D\", \"D\", \"E\", \"F\"],\n            }\n        )\n        self.assertEqual(result, expected)", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_docstrings.py_435-482"}
{"title": "maxhumber_redframes-tests-test_docstrings.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_docstrings.py"], "line_no": 470, "start_line_no": 445, "end_line_no": 482, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "\n    def test_sort(self):\n        df = rf.DataFrame({\"foo\": [\"Z\", \"X\", \"A\", \"A\"], \"bar\": [2, -2, 4, -4]})\n        result1 = df.sort(\"bar\")\n        result2 = df.sort(\"bar\", descending=True)\n        result3 = df.sort([\"foo\", \"bar\"], descending=False)\n        expected1 = rf.DataFrame({\"foo\": [\"A\", \"X\", \"Z\", \"A\"], \"bar\": [-4, -2, 2, 4]})\n        expected2 = rf.DataFrame({\"foo\": [\"A\", \"Z\", \"X\", \"A\"], \"bar\": [4, 2, -2, -4]})\n        expected3 = rf.DataFrame({\"foo\": [\"A\", \"A\", \"X\", \"Z\"], \"bar\": [-4, 4, -2, 2]})\n        self.assertEqual(result1, expected1)\n        self.assertEqual(result2, expected2)\n        self.assertEqual(result3, expected3)\n\n    def test_split(self):\n        df = rf.DataFrame({\"foo\": [\"A::1\", \"B::2\", \"C:3\"]})\n        result = df.split(\"foo\", into=[\"foo\", \"bar\"], sep=\"::\", drop=True)\n        expected = rf.DataFrame({\"foo\": [\"A\", \"B\", \"C:3\"], \"bar\": [\"1\", \"2\", None]})\n        self.assertEqual(result, expected)\n\n    def test_spread(self):\n        df = rf.DataFrame(\n            {\"foo\": [\"A\", \"A\", \"A\", \"B\", \"B\", \"B\", \"B\"], \"bar\": [1, 2, 3, 4, 5, 6, 7]}\n        )\n        result = df.spread(\"foo\", using=\"bar\")\n        expected = rf.DataFrame({\"A\": [1.0, 2.0, 3.0, None], \"B\": [4.0, 5.0, 6.0, 7.0]})\n        self.assertEqual(result, expected)\n\n    def test_unpack(self):\n        df = rf.DataFrame({\"foo\": [1, 2, 3, 4], \"bar\": [\"A:B\", \"B:C:D\", \"D:E\", \"F\"]})\n        result = df.unpack(\"bar\", sep=\":\")\n        expected = rf.DataFrame(\n            {\n                \"foo\": [1, 1, 2, 2, 2, 3, 3, 4],\n                \"bar\": [\"A\", \"B\", \"B\", \"C\", \"D\", \"D\", \"E\", \"F\"],\n            }\n        )\n        self.assertEqual(result, expected)", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_docstrings.py_445-482"}
{"title": "maxhumber_redframes-tests-test_docstrings.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_docstrings.py"], "line_no": 480, "start_line_no": 455, "end_line_no": 482, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        self.assertEqual(result2, expected2)\n        self.assertEqual(result3, expected3)\n\n    def test_split(self):\n        df = rf.DataFrame({\"foo\": [\"A::1\", \"B::2\", \"C:3\"]})\n        result = df.split(\"foo\", into=[\"foo\", \"bar\"], sep=\"::\", drop=True)\n        expected = rf.DataFrame({\"foo\": [\"A\", \"B\", \"C:3\"], \"bar\": [\"1\", \"2\", None]})\n        self.assertEqual(result, expected)\n\n    def test_spread(self):\n        df = rf.DataFrame(\n            {\"foo\": [\"A\", \"A\", \"A\", \"B\", \"B\", \"B\", \"B\"], \"bar\": [1, 2, 3, 4, 5, 6, 7]}\n        )\n        result = df.spread(\"foo\", using=\"bar\")\n        expected = rf.DataFrame({\"A\": [1.0, 2.0, 3.0, None], \"B\": [4.0, 5.0, 6.0, 7.0]})\n        self.assertEqual(result, expected)\n\n    def test_unpack(self):\n        df = rf.DataFrame({\"foo\": [1, 2, 3, 4], \"bar\": [\"A:B\", \"B:C:D\", \"D:E\", \"F\"]})\n        result = df.unpack(\"bar\", sep=\":\")\n        expected = rf.DataFrame(\n            {\n                \"foo\": [1, 1, 2, 2, 2, 3, 3, 4],\n                \"bar\": [\"A\", \"B\", \"B\", \"C\", \"D\", \"D\", \"E\", \"F\"],\n            }\n        )\n        self.assertEqual(result, expected)", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_docstrings.py_455-482"}
{"title": "maxhumber_redframes-tests-test_dupe_columns.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_dupe_columns.py"], "line_no": 0, "start_line_no": 0, "end_line_no": 25, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "import unittest\n\nimport redframes as rf\n\n\nclass TestDupeColumns(unittest.TestCase):\n    def setUp(self):\n        self.df = rf.DataFrame(\n            {\n                \"foo\": range(10),\n                \"bar\": [1, 3.2, 4.5, 2, -1, 30, None, 1.1, 1.1, 9],\n                \"baz\": [\"A\", \"A\", None, \"B\", \"B\", \"A\", \"B\", \"C\", \"C\", \"A\"],\n                \"jaz\": [\n                    \"1::1\",\n                    \"2::2\",\n                    \"3:3\",\n                    \"4::4\",\n                    \"5::5\",\n                    \"6::7\",\n                    \"7::8\",\n                    \"8::9\",\n                    \"9::0\",\n                    \"0::-1\",\n                ],\n                \"raz\": [1, 2, 3, None, None, None, 9, 9, None, None],", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_dupe_columns.py_0-25"}
{"title": "maxhumber_redframes-tests-test_dupe_columns.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_dupe_columns.py"], "line_no": 10, "start_line_no": 0, "end_line_no": 35, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "import unittest\n\nimport redframes as rf\n\n\nclass TestDupeColumns(unittest.TestCase):\n    def setUp(self):\n        self.df = rf.DataFrame(\n            {\n                \"foo\": range(10),\n                \"bar\": [1, 3.2, 4.5, 2, -1, 30, None, 1.1, 1.1, 9],\n                \"baz\": [\"A\", \"A\", None, \"B\", \"B\", \"A\", \"B\", \"C\", \"C\", \"A\"],\n                \"jaz\": [\n                    \"1::1\",\n                    \"2::2\",\n                    \"3:3\",\n                    \"4::4\",\n                    \"5::5\",\n                    \"6::7\",\n                    \"7::8\",\n                    \"8::9\",\n                    \"9::0\",\n                    \"0::-1\",\n                ],\n                \"raz\": [1, 2, 3, None, None, None, 9, 9, None, None],\n            }\n        )\n\n    def test_accumulate_not_unqiue(self):\n        self.df.accumulate(\"foo\", into=\"foo\")\n        self.assertTrue(True)\n\n    def test_accumulate_overwrite_existing(self):\n        with self.assertWarnsRegex(UserWarning, \"overwriting existing column *\"):\n            self.df.accumulate(\"foo\", into=\"bar\")\n\nAST=Module(Import(alias)Import(alias)ClassDef(Attribute(Name(Load)Load)FunctionDef(arguments(arg)Assign(Attribute(Name(Load)Store)Call(Attribute(Name(Load)Load)Dict(ConstantConstantConstantConstantConstantCall(Name(Load)Constant)List(ConstantConstantConstantConstantUnaryOp(USubConstant)ConstantConstantConstantConstantConstantLoad)List(ConstantConstantConstantConstantConstantConstantConstantConstantConstantConstantLoad)List(ConstantConstantConstantConstantConstantConstantConstantConstantConstantConstantLoad)List(ConstantConstantConstantConstantConstantConstantConstantConstantConstantConstantLoad)))))FunctionDef(arguments(arg)Expr(Call(Attribute(Attribute(Name(Load)Load)Load)Constantkeyword(Constant)))Expr(Call(Attribute(Name(Load)Load)Constant)))FunctionDef(arguments(arg)With(withitem(Call(Attribute(Name(Load)Load)Name(Load)Constant))Expr(Call(Attribute(Attribute(Name(Load)Load)Load)Constantkeyword(Constant)))))))", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_dupe_columns.py_0-35"}
{"title": "maxhumber_redframes-tests-test_dupe_columns.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_dupe_columns.py"], "line_no": 20, "start_line_no": 0, "end_line_no": 45, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "import unittest\n\nimport redframes as rf\n\n\nclass TestDupeColumns(unittest.TestCase):\n    def setUp(self):\n        self.df = rf.DataFrame(\n            {\n                \"foo\": range(10),\n                \"bar\": [1, 3.2, 4.5, 2, -1, 30, None, 1.1, 1.1, 9],\n                \"baz\": [\"A\", \"A\", None, \"B\", \"B\", \"A\", \"B\", \"C\", \"C\", \"A\"],\n                \"jaz\": [\n                    \"1::1\",\n                    \"2::2\",\n                    \"3:3\",\n                    \"4::4\",\n                    \"5::5\",\n                    \"6::7\",\n                    \"7::8\",\n                    \"8::9\",\n                    \"9::0\",\n                    \"0::-1\",\n                ],\n                \"raz\": [1, 2, 3, None, None, None, 9, 9, None, None],\n            }\n        )\n\n    def test_accumulate_not_unqiue(self):\n        self.df.accumulate(\"foo\", into=\"foo\")\n        self.assertTrue(True)\n\n    def test_accumulate_overwrite_existing(self):\n        with self.assertWarnsRegex(UserWarning, \"overwriting existing column *\"):\n            self.df.accumulate(\"foo\", into=\"bar\")\n\n    def test_combine_into_overwrite(self):\n        self.df.combine([\"foo\", \"bar\"], into=\"foo\", sep=\"-\")\n        self.assertTrue(True)\n\n    def test_combine_overwrite_existing(self):\n        with self.assertWarnsRegex(UserWarning, \"overwriting existing column *\"):\n            self.df.combine([\"foo\", \"bar\"], into=\"baz\", sep=\"-\")\n\n    def test_combine_overwrite_no_drop(self):", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_dupe_columns.py_0-45"}
{"title": "maxhumber_redframes-tests-test_dupe_columns.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_dupe_columns.py"], "line_no": 30, "start_line_no": 5, "end_line_no": 55, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "class TestDupeColumns(unittest.TestCase):\n    def setUp(self):\n        self.df = rf.DataFrame(\n            {\n                \"foo\": range(10),\n                \"bar\": [1, 3.2, 4.5, 2, -1, 30, None, 1.1, 1.1, 9],\n                \"baz\": [\"A\", \"A\", None, \"B\", \"B\", \"A\", \"B\", \"C\", \"C\", \"A\"],\n                \"jaz\": [\n                    \"1::1\",\n                    \"2::2\",\n                    \"3:3\",\n                    \"4::4\",\n                    \"5::5\",\n                    \"6::7\",\n                    \"7::8\",\n                    \"8::9\",\n                    \"9::0\",\n                    \"0::-1\",\n                ],\n                \"raz\": [1, 2, 3, None, None, None, 9, 9, None, None],\n            }\n        )\n\n    def test_accumulate_not_unqiue(self):\n        self.df.accumulate(\"foo\", into=\"foo\")\n        self.assertTrue(True)\n\n    def test_accumulate_overwrite_existing(self):\n        with self.assertWarnsRegex(UserWarning, \"overwriting existing column *\"):\n            self.df.accumulate(\"foo\", into=\"bar\")\n\n    def test_combine_into_overwrite(self):\n        self.df.combine([\"foo\", \"bar\"], into=\"foo\", sep=\"-\")\n        self.assertTrue(True)\n\n    def test_combine_overwrite_existing(self):\n        with self.assertWarnsRegex(UserWarning, \"overwriting existing column *\"):\n            self.df.combine([\"foo\", \"bar\"], into=\"baz\", sep=\"-\")\n\n    def test_combine_overwrite_no_drop(self):\n        self.df.combine([\"foo\", \"bar\"], into=\"foo\", sep=\"-\", drop=False)\n        self.assertTrue(True)\n\n    def test_gather_same_column_names(self):\n        with self.assertRaisesRegex(TypeError, \"must be unique\"):\n            self.df.gather(into=(\"foo\", \"foo\"))\n\n    def test_gather_exising_column_name_for_variable(self):\n        with self.assertRaisesRegex(ValueError, \"must not be an existing column key\"):\n            self.df.gather(into=(\"foo\", \"value\"))\n\nAST=Module(ClassDef(Attribute(Name(Load)Load)FunctionDef(arguments(arg)Assign(Attribute(Name(Load)Store)Call(Attribute(Name(Load)Load)Dict(ConstantConstantConstantConstantConstantCall(Name(Load)Constant)List(ConstantConstantConstantConstantUnaryOp(USubConstant)ConstantConstantConstantConstantConstantLoad)List(ConstantConstantConstantConstantConstantConstantConstantConstantConstantConstantLoad)List(ConstantConstantConstantConstantConstantConstantConstantConstantConstantConstantLoad)List(ConstantConstantConstantConstantConstantConstantConstantConstantConstantConstantLoad)))))FunctionDef(arguments(arg)Expr(Call(Attribute(Attribute(Name(Load)Load)Load)Constantkeyword(Constant)))Expr(Call(Attribute(Name(Load)Load)Constant)))FunctionDef(arguments(arg)With(withitem(Call(Attribute(Name(Load)Load)Name(Load)Constant))Expr(Call(Attribute(Attribute(Name(Load)Load)Load)Constantkeyword(Constant)))))FunctionDef(arguments(arg)Expr(Call(Attribute(Attribute(Name(Load)Load)Load)List(ConstantConstantLoad)keyword(Constant)keyword(Constant)))Expr(Call(Attribute(Name(Load)Load)Constant)))FunctionDef(arguments(arg)With(withitem(Call(Attribute(Name(Load)Load)Name(Load)Constant))Expr(Call(Attribute(Attribute(Name(Load)Load)Load)List(ConstantConstantLoad)keyword(Constant)keyword(Constant)))))FunctionDef(arguments(arg)Expr(Call(Attribute(Attribute(Name(Load)Load)Load)List(ConstantConstantLoad)keyword(Constant)keyword(Constant)keyword(Constant)))Expr(Call(Attribute(Name(Load)Load)Constant)))FunctionDef(arguments(arg)With(withitem(Call(Attribute(Name(Load)Load)Name(Load)Constant))Expr(Call(Attribute(Attribute(Name(Load)Load)Load)keyword(Tuple(ConstantConstantLoad))))))FunctionDef(arguments(arg)With(withitem(Call(Attribute(Name(Load)Load)Name(Load)Constant))Expr(Call(Attribute(Attribute(Name(Load)Load)Load)keyword(Tuple(ConstantConstantLoad))))))))", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_dupe_columns.py_5-55"}
{"title": "maxhumber_redframes-tests-test_dupe_columns.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_dupe_columns.py"], "line_no": 40, "start_line_no": 15, "end_line_no": 65, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "                    \"3:3\",\n                    \"4::4\",\n                    \"5::5\",\n                    \"6::7\",\n                    \"7::8\",\n                    \"8::9\",\n                    \"9::0\",\n                    \"0::-1\",\n                ],\n                \"raz\": [1, 2, 3, None, None, None, 9, 9, None, None],\n            }\n        )\n\n    def test_accumulate_not_unqiue(self):\n        self.df.accumulate(\"foo\", into=\"foo\")\n        self.assertTrue(True)\n\n    def test_accumulate_overwrite_existing(self):\n        with self.assertWarnsRegex(UserWarning, \"overwriting existing column *\"):\n            self.df.accumulate(\"foo\", into=\"bar\")\n\n    def test_combine_into_overwrite(self):\n        self.df.combine([\"foo\", \"bar\"], into=\"foo\", sep=\"-\")\n        self.assertTrue(True)\n\n    def test_combine_overwrite_existing(self):\n        with self.assertWarnsRegex(UserWarning, \"overwriting existing column *\"):\n            self.df.combine([\"foo\", \"bar\"], into=\"baz\", sep=\"-\")\n\n    def test_combine_overwrite_no_drop(self):\n        self.df.combine([\"foo\", \"bar\"], into=\"foo\", sep=\"-\", drop=False)\n        self.assertTrue(True)\n\n    def test_gather_same_column_names(self):\n        with self.assertRaisesRegex(TypeError, \"must be unique\"):\n            self.df.gather(into=(\"foo\", \"foo\"))\n\n    def test_gather_exising_column_name_for_variable(self):\n        with self.assertRaisesRegex(ValueError, \"must not be an existing column key\"):\n            self.df.gather(into=(\"foo\", \"value\"))\n\n    def test_gather_exising_column_name_for_value(self):\n        with self.assertRaisesRegex(ValueError, \"must not be an existing column key\"):\n            self.df.gather(into=(\"variable\", \"foo\"))\n\n    def test_gather_exising_column_key(self):\n        with self.assertRaisesRegex(ValueError, \"must not be an existing column key\"):\n            self.df.gather([\"foo\", \"bar\"], into=(\"raz\", \"baz\"))\n\n    def test_gather_group_into_conflict(self):", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_dupe_columns.py_15-65"}
{"title": "maxhumber_redframes-tests-test_dupe_columns.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_dupe_columns.py"], "line_no": 50, "start_line_no": 25, "end_line_no": 75, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "            }\n        )\n\n    def test_accumulate_not_unqiue(self):\n        self.df.accumulate(\"foo\", into=\"foo\")\n        self.assertTrue(True)\n\n    def test_accumulate_overwrite_existing(self):\n        with self.assertWarnsRegex(UserWarning, \"overwriting existing column *\"):\n            self.df.accumulate(\"foo\", into=\"bar\")\n\n    def test_combine_into_overwrite(self):\n        self.df.combine([\"foo\", \"bar\"], into=\"foo\", sep=\"-\")\n        self.assertTrue(True)\n\n    def test_combine_overwrite_existing(self):\n        with self.assertWarnsRegex(UserWarning, \"overwriting existing column *\"):\n            self.df.combine([\"foo\", \"bar\"], into=\"baz\", sep=\"-\")\n\n    def test_combine_overwrite_no_drop(self):\n        self.df.combine([\"foo\", \"bar\"], into=\"foo\", sep=\"-\", drop=False)\n        self.assertTrue(True)\n\n    def test_gather_same_column_names(self):\n        with self.assertRaisesRegex(TypeError, \"must be unique\"):\n            self.df.gather(into=(\"foo\", \"foo\"))\n\n    def test_gather_exising_column_name_for_variable(self):\n        with self.assertRaisesRegex(ValueError, \"must not be an existing column key\"):\n            self.df.gather(into=(\"foo\", \"value\"))\n\n    def test_gather_exising_column_name_for_value(self):\n        with self.assertRaisesRegex(ValueError, \"must not be an existing column key\"):\n            self.df.gather(into=(\"variable\", \"foo\"))\n\n    def test_gather_exising_column_key(self):\n        with self.assertRaisesRegex(ValueError, \"must not be an existing column key\"):\n            self.df.gather([\"foo\", \"bar\"], into=(\"raz\", \"baz\"))\n\n    def test_gather_group_into_conflict(self):\n        with self.assertRaisesRegex(ValueError, \"must not be an existing column key\"):\n            self.df.group(\"foo\").gather(into=(\"foo\", \"bar\"))\n\n    def test_rank_into_overwrite(self):\n        self.df.rank(\"bar\", into=\"bar\", descending=True)\n        self.assertTrue(True)\n\n    def test_rank_overwrite_existing(self):\n        with self.assertWarnsRegex(UserWarning, \"overwriting existing column *\"):\n            self.df.rank(\"bar\", into=\"baz\", descending=True)", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_dupe_columns.py_25-75"}
{"title": "maxhumber_redframes-tests-test_dupe_columns.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_dupe_columns.py"], "line_no": 60, "start_line_no": 35, "end_line_no": 85, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "\n    def test_combine_into_overwrite(self):\n        self.df.combine([\"foo\", \"bar\"], into=\"foo\", sep=\"-\")\n        self.assertTrue(True)\n\n    def test_combine_overwrite_existing(self):\n        with self.assertWarnsRegex(UserWarning, \"overwriting existing column *\"):\n            self.df.combine([\"foo\", \"bar\"], into=\"baz\", sep=\"-\")\n\n    def test_combine_overwrite_no_drop(self):\n        self.df.combine([\"foo\", \"bar\"], into=\"foo\", sep=\"-\", drop=False)\n        self.assertTrue(True)\n\n    def test_gather_same_column_names(self):\n        with self.assertRaisesRegex(TypeError, \"must be unique\"):\n            self.df.gather(into=(\"foo\", \"foo\"))\n\n    def test_gather_exising_column_name_for_variable(self):\n        with self.assertRaisesRegex(ValueError, \"must not be an existing column key\"):\n            self.df.gather(into=(\"foo\", \"value\"))\n\n    def test_gather_exising_column_name_for_value(self):\n        with self.assertRaisesRegex(ValueError, \"must not be an existing column key\"):\n            self.df.gather(into=(\"variable\", \"foo\"))\n\n    def test_gather_exising_column_key(self):\n        with self.assertRaisesRegex(ValueError, \"must not be an existing column key\"):\n            self.df.gather([\"foo\", \"bar\"], into=(\"raz\", \"baz\"))\n\n    def test_gather_group_into_conflict(self):\n        with self.assertRaisesRegex(ValueError, \"must not be an existing column key\"):\n            self.df.group(\"foo\").gather(into=(\"foo\", \"bar\"))\n\n    def test_rank_into_overwrite(self):\n        self.df.rank(\"bar\", into=\"bar\", descending=True)\n        self.assertTrue(True)\n\n    def test_rank_overwrite_existing(self):\n        with self.assertWarnsRegex(UserWarning, \"overwriting existing column *\"):\n            self.df.rank(\"bar\", into=\"baz\", descending=True)\n\n    def test_rename_duplicated_dict_values(self):\n        with self.assertRaisesRegex(KeyError, \"columns must be unique\"):\n            self.df.rename({\"foo\": \"oof\", \"bar\": \"oof\"})\n\n    def test_rollup_group_existing_column(self):\n        with self.assertRaisesRegex(KeyError, \"unable to overwrite group key\"):\n            self.df.group(\"baz\").rollup({\"baz\": (\"foo\", rf.stat.max)})\n\n    def test_select_duplicate_keys(self):", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_dupe_columns.py_35-85"}
{"title": "maxhumber_redframes-tests-test_dupe_columns.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_dupe_columns.py"], "line_no": 70, "start_line_no": 45, "end_line_no": 95, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        self.df.combine([\"foo\", \"bar\"], into=\"foo\", sep=\"-\", drop=False)\n        self.assertTrue(True)\n\n    def test_gather_same_column_names(self):\n        with self.assertRaisesRegex(TypeError, \"must be unique\"):\n            self.df.gather(into=(\"foo\", \"foo\"))\n\n    def test_gather_exising_column_name_for_variable(self):\n        with self.assertRaisesRegex(ValueError, \"must not be an existing column key\"):\n            self.df.gather(into=(\"foo\", \"value\"))\n\n    def test_gather_exising_column_name_for_value(self):\n        with self.assertRaisesRegex(ValueError, \"must not be an existing column key\"):\n            self.df.gather(into=(\"variable\", \"foo\"))\n\n    def test_gather_exising_column_key(self):\n        with self.assertRaisesRegex(ValueError, \"must not be an existing column key\"):\n            self.df.gather([\"foo\", \"bar\"], into=(\"raz\", \"baz\"))\n\n    def test_gather_group_into_conflict(self):\n        with self.assertRaisesRegex(ValueError, \"must not be an existing column key\"):\n            self.df.group(\"foo\").gather(into=(\"foo\", \"bar\"))\n\n    def test_rank_into_overwrite(self):\n        self.df.rank(\"bar\", into=\"bar\", descending=True)\n        self.assertTrue(True)\n\n    def test_rank_overwrite_existing(self):\n        with self.assertWarnsRegex(UserWarning, \"overwriting existing column *\"):\n            self.df.rank(\"bar\", into=\"baz\", descending=True)\n\n    def test_rename_duplicated_dict_values(self):\n        with self.assertRaisesRegex(KeyError, \"columns must be unique\"):\n            self.df.rename({\"foo\": \"oof\", \"bar\": \"oof\"})\n\n    def test_rollup_group_existing_column(self):\n        with self.assertRaisesRegex(KeyError, \"unable to overwrite group key\"):\n            self.df.group(\"baz\").rollup({\"baz\": (\"foo\", rf.stat.max)})\n\n    def test_select_duplicate_keys(self):\n        with self.assertRaisesRegex(KeyError, \"column keys must be unique\"):\n            self.df.select([\"foo\", \"foo\"])\n\n    def test_split_overwrite_into_one(self):\n        self.df.split(\"jaz\", into=[\"jaz\", \"paz\"], sep=\"::\")\n        self.assertTrue(True)\n\n    def test_split_overwrite_into_existing(self):\n        with self.assertRaisesRegex(KeyError, \"into keys must be unique\"):\n            self.df.split(\"jaz\", into=[\"jaz\", \"foo\"], sep=\"::\")", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_dupe_columns.py_45-95"}
{"title": "maxhumber_redframes-tests-test_dupe_columns.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_dupe_columns.py"], "line_no": 80, "start_line_no": 55, "end_line_no": 103, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "\n    def test_gather_exising_column_name_for_value(self):\n        with self.assertRaisesRegex(ValueError, \"must not be an existing column key\"):\n            self.df.gather(into=(\"variable\", \"foo\"))\n\n    def test_gather_exising_column_key(self):\n        with self.assertRaisesRegex(ValueError, \"must not be an existing column key\"):\n            self.df.gather([\"foo\", \"bar\"], into=(\"raz\", \"baz\"))\n\n    def test_gather_group_into_conflict(self):\n        with self.assertRaisesRegex(ValueError, \"must not be an existing column key\"):\n            self.df.group(\"foo\").gather(into=(\"foo\", \"bar\"))\n\n    def test_rank_into_overwrite(self):\n        self.df.rank(\"bar\", into=\"bar\", descending=True)\n        self.assertTrue(True)\n\n    def test_rank_overwrite_existing(self):\n        with self.assertWarnsRegex(UserWarning, \"overwriting existing column *\"):\n            self.df.rank(\"bar\", into=\"baz\", descending=True)\n\n    def test_rename_duplicated_dict_values(self):\n        with self.assertRaisesRegex(KeyError, \"columns must be unique\"):\n            self.df.rename({\"foo\": \"oof\", \"bar\": \"oof\"})\n\n    def test_rollup_group_existing_column(self):\n        with self.assertRaisesRegex(KeyError, \"unable to overwrite group key\"):\n            self.df.group(\"baz\").rollup({\"baz\": (\"foo\", rf.stat.max)})\n\n    def test_select_duplicate_keys(self):\n        with self.assertRaisesRegex(KeyError, \"column keys must be unique\"):\n            self.df.select([\"foo\", \"foo\"])\n\n    def test_split_overwrite_into_one(self):\n        self.df.split(\"jaz\", into=[\"jaz\", \"paz\"], sep=\"::\")\n        self.assertTrue(True)\n\n    def test_split_overwrite_into_existing(self):\n        with self.assertRaisesRegex(KeyError, \"into keys must be unique\"):\n            self.df.split(\"jaz\", into=[\"jaz\", \"foo\"], sep=\"::\")\n\n    def test_split_duplicated_into_keys(self):\n        with self.assertRaisesRegex(KeyError, \"into keys must be unique\"):\n            self.df.split(\"jaz\", into=[\"paz\", \"paz\"], sep=\"::\")\n\n    def test_spread_duplicated_column_names(self):\n        with self.assertRaisesRegex(KeyError, \"column and using must be unique\"):\n            self.df.gather().spread(\"variable\", \"variable\")", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_dupe_columns.py_55-103"}
{"title": "maxhumber_redframes-tests-test_dupe_columns.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_dupe_columns.py"], "line_no": 90, "start_line_no": 65, "end_line_no": 103, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        with self.assertRaisesRegex(ValueError, \"must not be an existing column key\"):\n            self.df.group(\"foo\").gather(into=(\"foo\", \"bar\"))\n\n    def test_rank_into_overwrite(self):\n        self.df.rank(\"bar\", into=\"bar\", descending=True)\n        self.assertTrue(True)\n\n    def test_rank_overwrite_existing(self):\n        with self.assertWarnsRegex(UserWarning, \"overwriting existing column *\"):\n            self.df.rank(\"bar\", into=\"baz\", descending=True)\n\n    def test_rename_duplicated_dict_values(self):\n        with self.assertRaisesRegex(KeyError, \"columns must be unique\"):\n            self.df.rename({\"foo\": \"oof\", \"bar\": \"oof\"})\n\n    def test_rollup_group_existing_column(self):\n        with self.assertRaisesRegex(KeyError, \"unable to overwrite group key\"):\n            self.df.group(\"baz\").rollup({\"baz\": (\"foo\", rf.stat.max)})\n\n    def test_select_duplicate_keys(self):\n        with self.assertRaisesRegex(KeyError, \"column keys must be unique\"):\n            self.df.select([\"foo\", \"foo\"])\n\n    def test_split_overwrite_into_one(self):\n        self.df.split(\"jaz\", into=[\"jaz\", \"paz\"], sep=\"::\")\n        self.assertTrue(True)\n\n    def test_split_overwrite_into_existing(self):\n        with self.assertRaisesRegex(KeyError, \"into keys must be unique\"):\n            self.df.split(\"jaz\", into=[\"jaz\", \"foo\"], sep=\"::\")\n\n    def test_split_duplicated_into_keys(self):\n        with self.assertRaisesRegex(KeyError, \"into keys must be unique\"):\n            self.df.split(\"jaz\", into=[\"paz\", \"paz\"], sep=\"::\")\n\n    def test_spread_duplicated_column_names(self):\n        with self.assertRaisesRegex(KeyError, \"column and using must be unique\"):\n            self.df.gather().spread(\"variable\", \"variable\")", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_dupe_columns.py_65-103"}
{"title": "maxhumber_redframes-tests-test_dupe_columns.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_dupe_columns.py"], "line_no": 100, "start_line_no": 75, "end_line_no": 103, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "\n    def test_rename_duplicated_dict_values(self):\n        with self.assertRaisesRegex(KeyError, \"columns must be unique\"):\n            self.df.rename({\"foo\": \"oof\", \"bar\": \"oof\"})\n\n    def test_rollup_group_existing_column(self):\n        with self.assertRaisesRegex(KeyError, \"unable to overwrite group key\"):\n            self.df.group(\"baz\").rollup({\"baz\": (\"foo\", rf.stat.max)})\n\n    def test_select_duplicate_keys(self):\n        with self.assertRaisesRegex(KeyError, \"column keys must be unique\"):\n            self.df.select([\"foo\", \"foo\"])\n\n    def test_split_overwrite_into_one(self):\n        self.df.split(\"jaz\", into=[\"jaz\", \"paz\"], sep=\"::\")\n        self.assertTrue(True)\n\n    def test_split_overwrite_into_existing(self):\n        with self.assertRaisesRegex(KeyError, \"into keys must be unique\"):\n            self.df.split(\"jaz\", into=[\"jaz\", \"foo\"], sep=\"::\")\n\n    def test_split_duplicated_into_keys(self):\n        with self.assertRaisesRegex(KeyError, \"into keys must be unique\"):\n            self.df.split(\"jaz\", into=[\"paz\", \"paz\"], sep=\"::\")\n\n    def test_spread_duplicated_column_names(self):\n        with self.assertRaisesRegex(KeyError, \"column and using must be unique\"):\n            self.df.gather().spread(\"variable\", \"variable\")", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_dupe_columns.py_75-103"}
{"title": "maxhumber_redframes-tests-test_index.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_index.py"], "line_no": 0, "start_line_no": 0, "end_line_no": 25, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "import unittest\n\nimport pandas as pd\n\nimport redframes as rf\n\n\ndef index_is_okay(df: rf.DataFrame) -> bool:\n    index = df._data.index\n    is_unnamed = index.name == None\n    is_range = isinstance(index, pd.RangeIndex)\n    is_zero_start = index.start == 0\n    is_one_step = index.step == 1\n    return all([is_unnamed, is_range, is_zero_start, is_one_step])\n\n\nclass TestIndex(unittest.TestCase):\n    def setUp(self):\n        self.df = rf.DataFrame(\n            {\n                \"foo\": range(10),\n                \"bar\": [1, 3.2, 4.5, 2, -1, 30, None, 1.1, 1.1, 9],\n                \"baz\": [\"A\", \"A\", None, \"B\", \"B\", \"A\", \"B\", \"C\", \"C\", \"A\"],\n                \"jaz\": [\n                    \"1::1\",", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_index.py_0-25"}
{"title": "maxhumber_redframes-tests-test_index.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_index.py"], "line_no": 10, "start_line_no": 0, "end_line_no": 35, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "import unittest\n\nimport pandas as pd\n\nimport redframes as rf\n\n\ndef index_is_okay(df: rf.DataFrame) -> bool:\n    index = df._data.index\n    is_unnamed = index.name == None\n    is_range = isinstance(index, pd.RangeIndex)\n    is_zero_start = index.start == 0\n    is_one_step = index.step == 1\n    return all([is_unnamed, is_range, is_zero_start, is_one_step])\n\n\nclass TestIndex(unittest.TestCase):\n    def setUp(self):\n        self.df = rf.DataFrame(\n            {\n                \"foo\": range(10),\n                \"bar\": [1, 3.2, 4.5, 2, -1, 30, None, 1.1, 1.1, 9],\n                \"baz\": [\"A\", \"A\", None, \"B\", \"B\", \"A\", \"B\", \"C\", \"C\", \"A\"],\n                \"jaz\": [\n                    \"1::1\",\n                    \"2::2\",\n                    \"3:3\",\n                    \"4::4\",\n                    \"5::5\",\n                    \"6::7\",\n                    \"7::8\",\n                    \"8::9\",\n                    \"9::0\",\n                    \"0::-1\",\n                ],", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_index.py_0-35"}
{"title": "maxhumber_redframes-tests-test_index.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_index.py"], "line_no": 20, "start_line_no": 0, "end_line_no": 45, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "import unittest\n\nimport pandas as pd\n\nimport redframes as rf\n\n\ndef index_is_okay(df: rf.DataFrame) -> bool:\n    index = df._data.index\n    is_unnamed = index.name == None\n    is_range = isinstance(index, pd.RangeIndex)\n    is_zero_start = index.start == 0\n    is_one_step = index.step == 1\n    return all([is_unnamed, is_range, is_zero_start, is_one_step])\n\n\nclass TestIndex(unittest.TestCase):\n    def setUp(self):\n        self.df = rf.DataFrame(\n            {\n                \"foo\": range(10),\n                \"bar\": [1, 3.2, 4.5, 2, -1, 30, None, 1.1, 1.1, 9],\n                \"baz\": [\"A\", \"A\", None, \"B\", \"B\", \"A\", \"B\", \"C\", \"C\", \"A\"],\n                \"jaz\": [\n                    \"1::1\",\n                    \"2::2\",\n                    \"3:3\",\n                    \"4::4\",\n                    \"5::5\",\n                    \"6::7\",\n                    \"7::8\",\n                    \"8::9\",\n                    \"9::0\",\n                    \"0::-1\",\n                ],\n                \"raz\": [1, 2, 3, None, None, None, 9, 9, None, None],\n            }\n        )\n\n    def test_accumulate(self):\n        new = self.df.accumulate(\"foo\", into=\"foo\")\n        self.assertTrue(index_is_okay(new))\n\n    def test_append(self):\n        df_bottom = rf.DataFrame({\"foo\": [10]})\n\nAST=Module(Import(alias)Import(alias)Import(alias)FunctionDef(arguments(arg(Attribute(Name(Load)Load)))Assign(Name(Store)Attribute(Attribute(Name(Load)Load)Load))Assign(Name(Store)Compare(Attribute(Name(Load)Load)EqConstant))Assign(Name(Store)Call(Name(Load)Name(Load)Attribute(Name(Load)Load)))Assign(Name(Store)Compare(Attribute(Name(Load)Load)EqConstant))Assign(Name(Store)Compare(Attribute(Name(Load)Load)EqConstant))Return(Call(Name(Load)List(Name(Load)Name(Load)Name(Load)Name(Load)Load)))Name(Load))ClassDef(Attribute(Name(Load)Load)FunctionDef(arguments(arg)Assign(Attribute(Name(Load)Store)Call(Attribute(Name(Load)Load)Dict(ConstantConstantConstantConstantConstantCall(Name(Load)Constant)List(ConstantConstantConstantConstantUnaryOp(USubConstant)ConstantConstantConstantConstantConstantLoad)List(ConstantConstantConstantConstantConstantConstantConstantConstantConstantConstantLoad)List(ConstantConstantConstantConstantConstantConstantConstantConstantConstantConstantLoad)List(ConstantConstantConstantConstantConstantConstantConstantConstantConstantConstantLoad)))))FunctionDef(arguments(arg)Assign(Name(Store)Call(Attribute(Attribute(Name(Load)Load)Load)Constantkeyword(Constant)))Expr(Call(Attribute(Name(Load)Load)Call(Name(Load)Name(Load)))))FunctionDef(arguments(arg)Assign(Name(Store)Call(Attribute(Name(Load)Load)Dict(ConstantList(ConstantLoad)))))))", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_index.py_0-45"}
{"title": "maxhumber_redframes-tests-test_index.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_index.py"], "line_no": 30, "start_line_no": 5, "end_line_no": 55, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "\n\ndef index_is_okay(df: rf.DataFrame) -> bool:\n    index = df._data.index\n    is_unnamed = index.name == None\n    is_range = isinstance(index, pd.RangeIndex)\n    is_zero_start = index.start == 0\n    is_one_step = index.step == 1\n    return all([is_unnamed, is_range, is_zero_start, is_one_step])\n\n\nclass TestIndex(unittest.TestCase):\n    def setUp(self):\n        self.df = rf.DataFrame(\n            {\n                \"foo\": range(10),\n                \"bar\": [1, 3.2, 4.5, 2, -1, 30, None, 1.1, 1.1, 9],\n                \"baz\": [\"A\", \"A\", None, \"B\", \"B\", \"A\", \"B\", \"C\", \"C\", \"A\"],\n                \"jaz\": [\n                    \"1::1\",\n                    \"2::2\",\n                    \"3:3\",\n                    \"4::4\",\n                    \"5::5\",\n                    \"6::7\",\n                    \"7::8\",\n                    \"8::9\",\n                    \"9::0\",\n                    \"0::-1\",\n                ],\n                \"raz\": [1, 2, 3, None, None, None, 9, 9, None, None],\n            }\n        )\n\n    def test_accumulate(self):\n        new = self.df.accumulate(\"foo\", into=\"foo\")\n        self.assertTrue(index_is_okay(new))\n\n    def test_append(self):\n        df_bottom = rf.DataFrame({\"foo\": [10]})\n        new = self.df.append(df_bottom)\n        self.assertTrue(index_is_okay(new))\n\n    def test_combine(self):\n        new = self.df.combine([\"foo\", \"bar\"], into=\"foo\", sep=\"-\")\n        self.assertTrue(index_is_okay(new))\n\n    def test_cross(self):\n        new = self.df.cross()\n        self.assertTrue(index_is_okay(new))\n\nAST=Module(FunctionDef(arguments(arg(Attribute(Name(Load)Load)))Assign(Name(Store)Attribute(Attribute(Name(Load)Load)Load))Assign(Name(Store)Compare(Attribute(Name(Load)Load)EqConstant))Assign(Name(Store)Call(Name(Load)Name(Load)Attribute(Name(Load)Load)))Assign(Name(Store)Compare(Attribute(Name(Load)Load)EqConstant))Assign(Name(Store)Compare(Attribute(Name(Load)Load)EqConstant))Return(Call(Name(Load)List(Name(Load)Name(Load)Name(Load)Name(Load)Load)))Name(Load))ClassDef(Attribute(Name(Load)Load)FunctionDef(arguments(arg)Assign(Attribute(Name(Load)Store)Call(Attribute(Name(Load)Load)Dict(ConstantConstantConstantConstantConstantCall(Name(Load)Constant)List(ConstantConstantConstantConstantUnaryOp(USubConstant)ConstantConstantConstantConstantConstantLoad)List(ConstantConstantConstantConstantConstantConstantConstantConstantConstantConstantLoad)List(ConstantConstantConstantConstantConstantConstantConstantConstantConstantConstantLoad)List(ConstantConstantConstantConstantConstantConstantConstantConstantConstantConstantLoad)))))FunctionDef(arguments(arg)Assign(Name(Store)Call(Attribute(Attribute(Name(Load)Load)Load)Constantkeyword(Constant)))Expr(Call(Attribute(Name(Load)Load)Call(Name(Load)Name(Load)))))FunctionDef(arguments(arg)Assign(Name(Store)Call(Attribute(Name(Load)Load)Dict(ConstantList(ConstantLoad))))Assign(Name(Store)Call(Attribute(Attribute(Name(Load)Load)Load)Name(Load)))Expr(Call(Attribute(Name(Load)Load)Call(Name(Load)Name(Load)))))FunctionDef(arguments(arg)Assign(Name(Store)Call(Attribute(Attribute(Name(Load)Load)Load)List(ConstantConstantLoad)keyword(Constant)keyword(Constant)))Expr(Call(Attribute(Name(Load)Load)Call(Name(Load)Name(Load)))))FunctionDef(arguments(arg)Assign(Name(Store)Call(Attribute(Attribute(Name(Load)Load)Load)))Expr(Call(Attribute(Name(Load)Load)Call(Name(Load)Name(Load)))))))", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_index.py_5-55"}
{"title": "maxhumber_redframes-tests-test_index.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_index.py"], "line_no": 40, "start_line_no": 15, "end_line_no": 65, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "\nclass TestIndex(unittest.TestCase):\n    def setUp(self):\n        self.df = rf.DataFrame(\n            {\n                \"foo\": range(10),\n                \"bar\": [1, 3.2, 4.5, 2, -1, 30, None, 1.1, 1.1, 9],\n                \"baz\": [\"A\", \"A\", None, \"B\", \"B\", \"A\", \"B\", \"C\", \"C\", \"A\"],\n                \"jaz\": [\n                    \"1::1\",\n                    \"2::2\",\n                    \"3:3\",\n                    \"4::4\",\n                    \"5::5\",\n                    \"6::7\",\n                    \"7::8\",\n                    \"8::9\",\n                    \"9::0\",\n                    \"0::-1\",\n                ],\n                \"raz\": [1, 2, 3, None, None, None, 9, 9, None, None],\n            }\n        )\n\n    def test_accumulate(self):\n        new = self.df.accumulate(\"foo\", into=\"foo\")\n        self.assertTrue(index_is_okay(new))\n\n    def test_append(self):\n        df_bottom = rf.DataFrame({\"foo\": [10]})\n        new = self.df.append(df_bottom)\n        self.assertTrue(index_is_okay(new))\n\n    def test_combine(self):\n        new = self.df.combine([\"foo\", \"bar\"], into=\"foo\", sep=\"-\")\n        self.assertTrue(index_is_okay(new))\n\n    def test_cross(self):\n        new = self.df.cross()\n        self.assertTrue(index_is_okay(new))\n\n    def test_dedupe(self):\n        new = self.df.dedupe(\"baz\")\n        self.assertTrue(index_is_okay(new))\n\n    def test_denix(self):\n        new = self.df.denix()\n        self.assertTrue(index_is_okay(new))\n\n    def test_drop(self):", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_index.py_15-65"}
{"title": "maxhumber_redframes-tests-test_index.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_index.py"], "line_no": 50, "start_line_no": 25, "end_line_no": 75, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "                    \"2::2\",\n                    \"3:3\",\n                    \"4::4\",\n                    \"5::5\",\n                    \"6::7\",\n                    \"7::8\",\n                    \"8::9\",\n                    \"9::0\",\n                    \"0::-1\",\n                ],\n                \"raz\": [1, 2, 3, None, None, None, 9, 9, None, None],\n            }\n        )\n\n    def test_accumulate(self):\n        new = self.df.accumulate(\"foo\", into=\"foo\")\n        self.assertTrue(index_is_okay(new))\n\n    def test_append(self):\n        df_bottom = rf.DataFrame({\"foo\": [10]})\n        new = self.df.append(df_bottom)\n        self.assertTrue(index_is_okay(new))\n\n    def test_combine(self):\n        new = self.df.combine([\"foo\", \"bar\"], into=\"foo\", sep=\"-\")\n        self.assertTrue(index_is_okay(new))\n\n    def test_cross(self):\n        new = self.df.cross()\n        self.assertTrue(index_is_okay(new))\n\n    def test_dedupe(self):\n        new = self.df.dedupe(\"baz\")\n        self.assertTrue(index_is_okay(new))\n\n    def test_denix(self):\n        new = self.df.denix()\n        self.assertTrue(index_is_okay(new))\n\n    def test_drop(self):\n        new = self.df.drop(\"foo\")\n        self.assertTrue(index_is_okay(new))\n\n    def test_fill(self):\n        new = self.df.fill(\"baz\", direction=\"down\")\n        self.assertTrue(index_is_okay(new))\n\n    def test_filter(self):\n        new = self.df.filter(lambda row: row[\"bar\"] > 5)\n        self.assertTrue(index_is_okay(new))", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_index.py_25-75"}
{"title": "maxhumber_redframes-tests-test_index.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_index.py"], "line_no": 60, "start_line_no": 35, "end_line_no": 85, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "                \"raz\": [1, 2, 3, None, None, None, 9, 9, None, None],\n            }\n        )\n\n    def test_accumulate(self):\n        new = self.df.accumulate(\"foo\", into=\"foo\")\n        self.assertTrue(index_is_okay(new))\n\n    def test_append(self):\n        df_bottom = rf.DataFrame({\"foo\": [10]})\n        new = self.df.append(df_bottom)\n        self.assertTrue(index_is_okay(new))\n\n    def test_combine(self):\n        new = self.df.combine([\"foo\", \"bar\"], into=\"foo\", sep=\"-\")\n        self.assertTrue(index_is_okay(new))\n\n    def test_cross(self):\n        new = self.df.cross()\n        self.assertTrue(index_is_okay(new))\n\n    def test_dedupe(self):\n        new = self.df.dedupe(\"baz\")\n        self.assertTrue(index_is_okay(new))\n\n    def test_denix(self):\n        new = self.df.denix()\n        self.assertTrue(index_is_okay(new))\n\n    def test_drop(self):\n        new = self.df.drop(\"foo\")\n        self.assertTrue(index_is_okay(new))\n\n    def test_fill(self):\n        new = self.df.fill(\"baz\", direction=\"down\")\n        self.assertTrue(index_is_okay(new))\n\n    def test_filter(self):\n        new = self.df.filter(lambda row: row[\"bar\"] > 5)\n        self.assertTrue(index_is_okay(new))\n\n    def test_gather(self):\n        new = self.df.gather()\n        self.assertTrue(index_is_okay(new))\n\n    def test_group(self):\n        new = self.df.group(\"baz\").rollup({\"foo\": (\"foo\", rf.stat.mean)})\n        self.assertTrue(index_is_okay(new))\n\n    def test_join(self):", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_index.py_35-85"}
{"title": "maxhumber_redframes-tests-test_index.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_index.py"], "line_no": 70, "start_line_no": 45, "end_line_no": 95, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        new = self.df.append(df_bottom)\n        self.assertTrue(index_is_okay(new))\n\n    def test_combine(self):\n        new = self.df.combine([\"foo\", \"bar\"], into=\"foo\", sep=\"-\")\n        self.assertTrue(index_is_okay(new))\n\n    def test_cross(self):\n        new = self.df.cross()\n        self.assertTrue(index_is_okay(new))\n\n    def test_dedupe(self):\n        new = self.df.dedupe(\"baz\")\n        self.assertTrue(index_is_okay(new))\n\n    def test_denix(self):\n        new = self.df.denix()\n        self.assertTrue(index_is_okay(new))\n\n    def test_drop(self):\n        new = self.df.drop(\"foo\")\n        self.assertTrue(index_is_okay(new))\n\n    def test_fill(self):\n        new = self.df.fill(\"baz\", direction=\"down\")\n        self.assertTrue(index_is_okay(new))\n\n    def test_filter(self):\n        new = self.df.filter(lambda row: row[\"bar\"] > 5)\n        self.assertTrue(index_is_okay(new))\n\n    def test_gather(self):\n        new = self.df.gather()\n        self.assertTrue(index_is_okay(new))\n\n    def test_group(self):\n        new = self.df.group(\"baz\").rollup({\"foo\": (\"foo\", rf.stat.mean)})\n        self.assertTrue(index_is_okay(new))\n\n    def test_join(self):\n        df_right = rf.DataFrame({\"baz\": [\"A\", \"B\"], \"haz\": [\"Apple\", \"Banana\"]})\n        new = self.df.join(df_right, on=\"baz\")\n        self.assertTrue(index_is_okay(new))\n\n    def test_mutate(self):\n        new = self.df.mutate({\"foo\": lambda row: row[\"foo\"] * 10})\n        self.assertTrue(index_is_okay(new))\n\n    def test_pack(self):\n        new = self.df.pack(\"baz\", sep=\"|\")", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_index.py_45-95"}
{"title": "maxhumber_redframes-tests-test_index.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_index.py"], "line_no": 80, "start_line_no": 55, "end_line_no": 105, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "\n    def test_dedupe(self):\n        new = self.df.dedupe(\"baz\")\n        self.assertTrue(index_is_okay(new))\n\n    def test_denix(self):\n        new = self.df.denix()\n        self.assertTrue(index_is_okay(new))\n\n    def test_drop(self):\n        new = self.df.drop(\"foo\")\n        self.assertTrue(index_is_okay(new))\n\n    def test_fill(self):\n        new = self.df.fill(\"baz\", direction=\"down\")\n        self.assertTrue(index_is_okay(new))\n\n    def test_filter(self):\n        new = self.df.filter(lambda row: row[\"bar\"] > 5)\n        self.assertTrue(index_is_okay(new))\n\n    def test_gather(self):\n        new = self.df.gather()\n        self.assertTrue(index_is_okay(new))\n\n    def test_group(self):\n        new = self.df.group(\"baz\").rollup({\"foo\": (\"foo\", rf.stat.mean)})\n        self.assertTrue(index_is_okay(new))\n\n    def test_join(self):\n        df_right = rf.DataFrame({\"baz\": [\"A\", \"B\"], \"haz\": [\"Apple\", \"Banana\"]})\n        new = self.df.join(df_right, on=\"baz\")\n        self.assertTrue(index_is_okay(new))\n\n    def test_mutate(self):\n        new = self.df.mutate({\"foo\": lambda row: row[\"foo\"] * 10})\n        self.assertTrue(index_is_okay(new))\n\n    def test_pack(self):\n        new = self.df.pack(\"baz\", sep=\"|\")\n        self.assertTrue(index_is_okay(new))\n\n    def test_rank(self):\n        new = self.df.rank(\"bar\", into=\"bar_rank\", descending=True)\n        self.assertTrue(index_is_okay(new))\n\n    def test_rename(self):\n        new = self.df.rename({\"foo\": \"oof\"})\n        self.assertTrue(index_is_okay(new))\n", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_index.py_55-105"}
{"title": "maxhumber_redframes-tests-test_index.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_index.py"], "line_no": 90, "start_line_no": 65, "end_line_no": 115, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        new = self.df.drop(\"foo\")\n        self.assertTrue(index_is_okay(new))\n\n    def test_fill(self):\n        new = self.df.fill(\"baz\", direction=\"down\")\n        self.assertTrue(index_is_okay(new))\n\n    def test_filter(self):\n        new = self.df.filter(lambda row: row[\"bar\"] > 5)\n        self.assertTrue(index_is_okay(new))\n\n    def test_gather(self):\n        new = self.df.gather()\n        self.assertTrue(index_is_okay(new))\n\n    def test_group(self):\n        new = self.df.group(\"baz\").rollup({\"foo\": (\"foo\", rf.stat.mean)})\n        self.assertTrue(index_is_okay(new))\n\n    def test_join(self):\n        df_right = rf.DataFrame({\"baz\": [\"A\", \"B\"], \"haz\": [\"Apple\", \"Banana\"]})\n        new = self.df.join(df_right, on=\"baz\")\n        self.assertTrue(index_is_okay(new))\n\n    def test_mutate(self):\n        new = self.df.mutate({\"foo\": lambda row: row[\"foo\"] * 10})\n        self.assertTrue(index_is_okay(new))\n\n    def test_pack(self):\n        new = self.df.pack(\"baz\", sep=\"|\")\n        self.assertTrue(index_is_okay(new))\n\n    def test_rank(self):\n        new = self.df.rank(\"bar\", into=\"bar_rank\", descending=True)\n        self.assertTrue(index_is_okay(new))\n\n    def test_rename(self):\n        new = self.df.rename({\"foo\": \"oof\"})\n        self.assertTrue(index_is_okay(new))\n\n    def test_replace(self):\n        new = self.df.replace({\"baz\": {\"B\": \"Banana\"}})\n        self.assertTrue(index_is_okay(new))\n\n    def test_rollup(self):\n        new = self.df.rollup({\"bar_mean\": (\"bar\", rf.stat.mean)})\n        self.assertTrue(index_is_okay(new))\n\n    def test_sample(self):\n        new = self.df.sample(5)", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_index.py_65-115"}
{"title": "maxhumber_redframes-tests-test_index.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_index.py"], "line_no": 100, "start_line_no": 75, "end_line_no": 125, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "\n    def test_gather(self):\n        new = self.df.gather()\n        self.assertTrue(index_is_okay(new))\n\n    def test_group(self):\n        new = self.df.group(\"baz\").rollup({\"foo\": (\"foo\", rf.stat.mean)})\n        self.assertTrue(index_is_okay(new))\n\n    def test_join(self):\n        df_right = rf.DataFrame({\"baz\": [\"A\", \"B\"], \"haz\": [\"Apple\", \"Banana\"]})\n        new = self.df.join(df_right, on=\"baz\")\n        self.assertTrue(index_is_okay(new))\n\n    def test_mutate(self):\n        new = self.df.mutate({\"foo\": lambda row: row[\"foo\"] * 10})\n        self.assertTrue(index_is_okay(new))\n\n    def test_pack(self):\n        new = self.df.pack(\"baz\", sep=\"|\")\n        self.assertTrue(index_is_okay(new))\n\n    def test_rank(self):\n        new = self.df.rank(\"bar\", into=\"bar_rank\", descending=True)\n        self.assertTrue(index_is_okay(new))\n\n    def test_rename(self):\n        new = self.df.rename({\"foo\": \"oof\"})\n        self.assertTrue(index_is_okay(new))\n\n    def test_replace(self):\n        new = self.df.replace({\"baz\": {\"B\": \"Banana\"}})\n        self.assertTrue(index_is_okay(new))\n\n    def test_rollup(self):\n        new = self.df.rollup({\"bar_mean\": (\"bar\", rf.stat.mean)})\n        self.assertTrue(index_is_okay(new))\n\n    def test_sample(self):\n        new = self.df.sample(5)\n        self.assertTrue(index_is_okay(new))\n\n    def test_select(self):\n        new = self.df.select([\"foo\", \"bar\"])\n        self.assertTrue(index_is_okay(new))\n\n    def test_shuffle(self):\n        new = self.df.shuffle()\n        self.assertTrue(index_is_okay(new))\n", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_index.py_75-125"}
{"title": "maxhumber_redframes-tests-test_index.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_index.py"], "line_no": 110, "start_line_no": 85, "end_line_no": 135, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        df_right = rf.DataFrame({\"baz\": [\"A\", \"B\"], \"haz\": [\"Apple\", \"Banana\"]})\n        new = self.df.join(df_right, on=\"baz\")\n        self.assertTrue(index_is_okay(new))\n\n    def test_mutate(self):\n        new = self.df.mutate({\"foo\": lambda row: row[\"foo\"] * 10})\n        self.assertTrue(index_is_okay(new))\n\n    def test_pack(self):\n        new = self.df.pack(\"baz\", sep=\"|\")\n        self.assertTrue(index_is_okay(new))\n\n    def test_rank(self):\n        new = self.df.rank(\"bar\", into=\"bar_rank\", descending=True)\n        self.assertTrue(index_is_okay(new))\n\n    def test_rename(self):\n        new = self.df.rename({\"foo\": \"oof\"})\n        self.assertTrue(index_is_okay(new))\n\n    def test_replace(self):\n        new = self.df.replace({\"baz\": {\"B\": \"Banana\"}})\n        self.assertTrue(index_is_okay(new))\n\n    def test_rollup(self):\n        new = self.df.rollup({\"bar_mean\": (\"bar\", rf.stat.mean)})\n        self.assertTrue(index_is_okay(new))\n\n    def test_sample(self):\n        new = self.df.sample(5)\n        self.assertTrue(index_is_okay(new))\n\n    def test_select(self):\n        new = self.df.select([\"foo\", \"bar\"])\n        self.assertTrue(index_is_okay(new))\n\n    def test_shuffle(self):\n        new = self.df.shuffle()\n        self.assertTrue(index_is_okay(new))\n\n    def test_sort(self):\n        new = self.df.sort(\"bar\", descending=True)\n        self.assertTrue(index_is_okay(new))\n\n    def test_split(self):\n        new = self.df.split(\"jaz\", into=[\"jaz_1\", \"jaz_2\"], sep=\"::\")\n        self.assertTrue(index_is_okay(new))\n\n    def test_spread(self):\n        new = self.df.denix(\"baz\").select([\"baz\", \"foo\"]).spread(\"baz\", \"foo\")", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_index.py_85-135"}
{"title": "maxhumber_redframes-tests-test_index.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_index.py"], "line_no": 120, "start_line_no": 95, "end_line_no": 144, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        self.assertTrue(index_is_okay(new))\n\n    def test_rank(self):\n        new = self.df.rank(\"bar\", into=\"bar_rank\", descending=True)\n        self.assertTrue(index_is_okay(new))\n\n    def test_rename(self):\n        new = self.df.rename({\"foo\": \"oof\"})\n        self.assertTrue(index_is_okay(new))\n\n    def test_replace(self):\n        new = self.df.replace({\"baz\": {\"B\": \"Banana\"}})\n        self.assertTrue(index_is_okay(new))\n\n    def test_rollup(self):\n        new = self.df.rollup({\"bar_mean\": (\"bar\", rf.stat.mean)})\n        self.assertTrue(index_is_okay(new))\n\n    def test_sample(self):\n        new = self.df.sample(5)\n        self.assertTrue(index_is_okay(new))\n\n    def test_select(self):\n        new = self.df.select([\"foo\", \"bar\"])\n        self.assertTrue(index_is_okay(new))\n\n    def test_shuffle(self):\n        new = self.df.shuffle()\n        self.assertTrue(index_is_okay(new))\n\n    def test_sort(self):\n        new = self.df.sort(\"bar\", descending=True)\n        self.assertTrue(index_is_okay(new))\n\n    def test_split(self):\n        new = self.df.split(\"jaz\", into=[\"jaz_1\", \"jaz_2\"], sep=\"::\")\n        self.assertTrue(index_is_okay(new))\n\n    def test_spread(self):\n        new = self.df.denix(\"baz\").select([\"baz\", \"foo\"]).spread(\"baz\", \"foo\")\n        self.assertTrue(index_is_okay(new))\n\n    def test_take(self):\n        new = self.df.take(-3)\n        self.assertTrue(index_is_okay(new))\n\n    def test_unpack(self):\n        new = self.df.unpack(\"jaz\", sep=\"::\")\n        self.assertTrue(index_is_okay(new))", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_index.py_95-144"}
{"title": "maxhumber_redframes-tests-test_index.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_index.py"], "line_no": 130, "start_line_no": 105, "end_line_no": 144, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "    def test_replace(self):\n        new = self.df.replace({\"baz\": {\"B\": \"Banana\"}})\n        self.assertTrue(index_is_okay(new))\n\n    def test_rollup(self):\n        new = self.df.rollup({\"bar_mean\": (\"bar\", rf.stat.mean)})\n        self.assertTrue(index_is_okay(new))\n\n    def test_sample(self):\n        new = self.df.sample(5)\n        self.assertTrue(index_is_okay(new))\n\n    def test_select(self):\n        new = self.df.select([\"foo\", \"bar\"])\n        self.assertTrue(index_is_okay(new))\n\n    def test_shuffle(self):\n        new = self.df.shuffle()\n        self.assertTrue(index_is_okay(new))\n\n    def test_sort(self):\n        new = self.df.sort(\"bar\", descending=True)\n        self.assertTrue(index_is_okay(new))\n\n    def test_split(self):\n        new = self.df.split(\"jaz\", into=[\"jaz_1\", \"jaz_2\"], sep=\"::\")\n        self.assertTrue(index_is_okay(new))\n\n    def test_spread(self):\n        new = self.df.denix(\"baz\").select([\"baz\", \"foo\"]).spread(\"baz\", \"foo\")\n        self.assertTrue(index_is_okay(new))\n\n    def test_take(self):\n        new = self.df.take(-3)\n        self.assertTrue(index_is_okay(new))\n\n    def test_unpack(self):\n        new = self.df.unpack(\"jaz\", sep=\"::\")\n        self.assertTrue(index_is_okay(new))", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_index.py_105-144"}
{"title": "maxhumber_redframes-tests-test_index.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_index.py"], "line_no": 140, "start_line_no": 115, "end_line_no": 144, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        self.assertTrue(index_is_okay(new))\n\n    def test_select(self):\n        new = self.df.select([\"foo\", \"bar\"])\n        self.assertTrue(index_is_okay(new))\n\n    def test_shuffle(self):\n        new = self.df.shuffle()\n        self.assertTrue(index_is_okay(new))\n\n    def test_sort(self):\n        new = self.df.sort(\"bar\", descending=True)\n        self.assertTrue(index_is_okay(new))\n\n    def test_split(self):\n        new = self.df.split(\"jaz\", into=[\"jaz_1\", \"jaz_2\"], sep=\"::\")\n        self.assertTrue(index_is_okay(new))\n\n    def test_spread(self):\n        new = self.df.denix(\"baz\").select([\"baz\", \"foo\"]).spread(\"baz\", \"foo\")\n        self.assertTrue(index_is_okay(new))\n\n    def test_take(self):\n        new = self.df.take(-3)\n        self.assertTrue(index_is_okay(new))\n\n    def test_unpack(self):\n        new = self.df.unpack(\"jaz\", sep=\"::\")\n        self.assertTrue(index_is_okay(new))", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_index.py_115-144"}
{"title": "maxhumber_redframes-tests-test_interchange.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_interchange.py"], "line_no": 0, "start_line_no": 0, "end_line_no": 13, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}, {"fpath_tuple": ["maxhumber_redframes", "tests", "test_interchange.py"], "line_no": 10, "start_line_no": 0, "end_line_no": 13, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "import unittest\n\nimport pandas as pd\n\nimport redframes as rf\n\n\nclass TestInterchange(unittest.TestCase):\n    def test_wrap_no_side_effect(self):\n        rdf = rf.DataFrame({\"foo\": [1, 2], \"bar\": [3, 4]})\n        result = pd.api.interchange.from_dataframe(rdf)\n        expected = pd.DataFrame({\"foo\": [1, 2], \"bar\": [3, 4]})\n        self.assertTrue(result.equals(expected))\n\nAST=Module(Import(alias)Import(alias)Import(alias)ClassDef(Attribute(Name(Load)Load)FunctionDef(arguments(arg)Assign(Name(Store)Call(Attribute(Name(Load)Load)Dict(ConstantConstantList(ConstantConstantLoad)List(ConstantConstantLoad))))Assign(Name(Store)Call(Attribute(Attribute(Attribute(Name(Load)Load)Load)Load)Name(Load)))Assign(Name(Store)Call(Attribute(Name(Load)Load)Dict(ConstantConstantList(ConstantConstantLoad)List(ConstantConstantLoad))))Expr(Call(Attribute(Name(Load)Load)Call(Attribute(Name(Load)Load)Name(Load)))))))", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_interchange.py_0-13"}
{"title": "maxhumber_redframes-tests-test_io.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_io.py"], "line_no": 0, "start_line_no": 0, "end_line_no": 25, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "import unittest\nfrom pathlib import Path\nfrom shutil import rmtree as delete\nfrom tempfile import mkdtemp as make_temp_dir\n\nimport pandas as pd\n\nimport redframes as rf\n\n\nclass TestIO(unittest.TestCase):\n    def setUp(self):\n        self.tempdir = tempdir = make_temp_dir()\n        self.df = rf.DataFrame({\"foo\": [1, 2], \"bar\": [3, 4]})\n        self.pdf = pd.DataFrame({\"foo\": [1, 2], \"bar\": [3, 4]})\n        self.path = str(Path(tempdir) / \"example.csv\")\n\n    def tearDown(self):\n        delete(self.tempdir)\n\n    def test_load_missing_file(self):\n        with self.assertRaises(FileNotFoundError):\n            rf.load(\"test_missing_file.csv\")\n\n    def test_load_bad_format(self):", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_io.py_0-25"}
{"title": "maxhumber_redframes-tests-test_io.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_io.py"], "line_no": 10, "start_line_no": 0, "end_line_no": 35, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "import unittest\nfrom pathlib import Path\nfrom shutil import rmtree as delete\nfrom tempfile import mkdtemp as make_temp_dir\n\nimport pandas as pd\n\nimport redframes as rf\n\n\nclass TestIO(unittest.TestCase):\n    def setUp(self):\n        self.tempdir = tempdir = make_temp_dir()\n        self.df = rf.DataFrame({\"foo\": [1, 2], \"bar\": [3, 4]})\n        self.pdf = pd.DataFrame({\"foo\": [1, 2], \"bar\": [3, 4]})\n        self.path = str(Path(tempdir) / \"example.csv\")\n\n    def tearDown(self):\n        delete(self.tempdir)\n\n    def test_load_missing_file(self):\n        with self.assertRaises(FileNotFoundError):\n            rf.load(\"test_missing_file.csv\")\n\n    def test_load_bad_format(self):\n        with self.assertRaisesRegex(TypeError, \"must end in .csv\"):\n            rf.load(\"test_bad_file_format.json\")\n\n    def test_save_bad_path_format(self):\n        with self.assertRaisesRegex(TypeError, \"must end in .csv\"):\n            rf.save(self.df, \"example.json\")\n\n    def test_save_bad_type(self):\n        with self.assertRaisesRegex(TypeError, \"must be DataFrame\"):\n            rf.save(1, \"example.json\")\n\nAST=Module(Import(alias)ImportFrom(alias)ImportFrom(alias)ImportFrom(alias)Import(alias)Import(alias)ClassDef(Attribute(Name(Load)Load)FunctionDef(arguments(arg)Assign(Attribute(Name(Load)Store)Name(Store)Call(Name(Load)))Assign(Attribute(Name(Load)Store)Call(Attribute(Name(Load)Load)Dict(ConstantConstantList(ConstantConstantLoad)List(ConstantConstantLoad))))Assign(Attribute(Name(Load)Store)Call(Attribute(Name(Load)Load)Dict(ConstantConstantList(ConstantConstantLoad)List(ConstantConstantLoad))))Assign(Attribute(Name(Load)Store)Call(Name(Load)BinOp(Call(Name(Load)Name(Load))DivConstant))))FunctionDef(arguments(arg)Expr(Call(Name(Load)Attribute(Name(Load)Load))))FunctionDef(arguments(arg)With(withitem(Call(Attribute(Name(Load)Load)Name(Load)))Expr(Call(Attribute(Name(Load)Load)Constant))))FunctionDef(arguments(arg)With(withitem(Call(Attribute(Name(Load)Load)Name(Load)Constant))Expr(Call(Attribute(Name(Load)Load)Constant))))FunctionDef(arguments(arg)With(withitem(Call(Attribute(Name(Load)Load)Name(Load)Constant))Expr(Call(Attribute(Name(Load)Load)Attribute(Name(Load)Load)Constant))))FunctionDef(arguments(arg)With(withitem(Call(Attribute(Name(Load)Load)Name(Load)Constant))Expr(Call(Attribute(Name(Load)Load)ConstantConstant))))))", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_io.py_0-35"}
{"title": "maxhumber_redframes-tests-test_io.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_io.py"], "line_no": 20, "start_line_no": 0, "end_line_no": 45, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "import unittest\nfrom pathlib import Path\nfrom shutil import rmtree as delete\nfrom tempfile import mkdtemp as make_temp_dir\n\nimport pandas as pd\n\nimport redframes as rf\n\n\nclass TestIO(unittest.TestCase):\n    def setUp(self):\n        self.tempdir = tempdir = make_temp_dir()\n        self.df = rf.DataFrame({\"foo\": [1, 2], \"bar\": [3, 4]})\n        self.pdf = pd.DataFrame({\"foo\": [1, 2], \"bar\": [3, 4]})\n        self.path = str(Path(tempdir) / \"example.csv\")\n\n    def tearDown(self):\n        delete(self.tempdir)\n\n    def test_load_missing_file(self):\n        with self.assertRaises(FileNotFoundError):\n            rf.load(\"test_missing_file.csv\")\n\n    def test_load_bad_format(self):\n        with self.assertRaisesRegex(TypeError, \"must end in .csv\"):\n            rf.load(\"test_bad_file_format.json\")\n\n    def test_save_bad_path_format(self):\n        with self.assertRaisesRegex(TypeError, \"must end in .csv\"):\n            rf.save(self.df, \"example.json\")\n\n    def test_save_bad_type(self):\n        with self.assertRaisesRegex(TypeError, \"must be DataFrame\"):\n            rf.save(1, \"example.json\")\n\n    def test_unwrap_bad_type(self):\n        with self.assertRaisesRegex(TypeError, \"must be DataFrame\"):\n            rf.unwrap(1)\n\n    def test_wrap_bad_type(self):\n        with self.assertRaisesRegex(TypeError, \"must be DataFrame\"):\n            rf.wrap(1)\n\n    def test_unwrap_wrong_direction(self):", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_io.py_0-45"}
{"title": "maxhumber_redframes-tests-test_io.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_io.py"], "line_no": 30, "start_line_no": 5, "end_line_no": 55, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "import pandas as pd\n\nimport redframes as rf\n\n\nclass TestIO(unittest.TestCase):\n    def setUp(self):\n        self.tempdir = tempdir = make_temp_dir()\n        self.df = rf.DataFrame({\"foo\": [1, 2], \"bar\": [3, 4]})\n        self.pdf = pd.DataFrame({\"foo\": [1, 2], \"bar\": [3, 4]})\n        self.path = str(Path(tempdir) / \"example.csv\")\n\n    def tearDown(self):\n        delete(self.tempdir)\n\n    def test_load_missing_file(self):\n        with self.assertRaises(FileNotFoundError):\n            rf.load(\"test_missing_file.csv\")\n\n    def test_load_bad_format(self):\n        with self.assertRaisesRegex(TypeError, \"must end in .csv\"):\n            rf.load(\"test_bad_file_format.json\")\n\n    def test_save_bad_path_format(self):\n        with self.assertRaisesRegex(TypeError, \"must end in .csv\"):\n            rf.save(self.df, \"example.json\")\n\n    def test_save_bad_type(self):\n        with self.assertRaisesRegex(TypeError, \"must be DataFrame\"):\n            rf.save(1, \"example.json\")\n\n    def test_unwrap_bad_type(self):\n        with self.assertRaisesRegex(TypeError, \"must be DataFrame\"):\n            rf.unwrap(1)\n\n    def test_wrap_bad_type(self):\n        with self.assertRaisesRegex(TypeError, \"must be DataFrame\"):\n            rf.wrap(1)\n\n    def test_unwrap_wrong_direction(self):\n        with self.assertRaisesRegex(TypeError, \"must be DataFrame\"):\n            rf.unwrap(self.pdf)\n\n    def test_wrap_wrong_direction(self):\n        with self.assertRaisesRegex(TypeError, \"must be DataFrame\"):\n            rf.wrap(self.df)\n\n    def test_unwrap_no_side_effect(self):\n        pdf = rf.unwrap(self.df)\n        pdf.columns = [\"oof\", \"rab\"]\n\nAST=Module(Import(alias)Import(alias)ClassDef(Attribute(Name(Load)Load)FunctionDef(arguments(arg)Assign(Attribute(Name(Load)Store)Name(Store)Call(Name(Load)))Assign(Attribute(Name(Load)Store)Call(Attribute(Name(Load)Load)Dict(ConstantConstantList(ConstantConstantLoad)List(ConstantConstantLoad))))Assign(Attribute(Name(Load)Store)Call(Attribute(Name(Load)Load)Dict(ConstantConstantList(ConstantConstantLoad)List(ConstantConstantLoad))))Assign(Attribute(Name(Load)Store)Call(Name(Load)BinOp(Call(Name(Load)Name(Load))DivConstant))))FunctionDef(arguments(arg)Expr(Call(Name(Load)Attribute(Name(Load)Load))))FunctionDef(arguments(arg)With(withitem(Call(Attribute(Name(Load)Load)Name(Load)))Expr(Call(Attribute(Name(Load)Load)Constant))))FunctionDef(arguments(arg)With(withitem(Call(Attribute(Name(Load)Load)Name(Load)Constant))Expr(Call(Attribute(Name(Load)Load)Constant))))FunctionDef(arguments(arg)With(withitem(Call(Attribute(Name(Load)Load)Name(Load)Constant))Expr(Call(Attribute(Name(Load)Load)Attribute(Name(Load)Load)Constant))))FunctionDef(arguments(arg)With(withitem(Call(Attribute(Name(Load)Load)Name(Load)Constant))Expr(Call(Attribute(Name(Load)Load)ConstantConstant))))FunctionDef(arguments(arg)With(withitem(Call(Attribute(Name(Load)Load)Name(Load)Constant))Expr(Call(Attribute(Name(Load)Load)Constant))))FunctionDef(arguments(arg)With(withitem(Call(Attribute(Name(Load)Load)Name(Load)Constant))Expr(Call(Attribute(Name(Load)Load)Constant))))FunctionDef(arguments(arg)With(withitem(Call(Attribute(Name(Load)Load)Name(Load)Constant))Expr(Call(Attribute(Name(Load)Load)Attribute(Name(Load)Load)))))FunctionDef(arguments(arg)With(withitem(Call(Attribute(Name(Load)Load)Name(Load)Constant))Expr(Call(Attribute(Name(Load)Load)Attribute(Name(Load)Load)))))FunctionDef(arguments(arg)Assign(Name(Store)Call(Attribute(Name(Load)Load)Attribute(Name(Load)Load)))Assign(Attribute(Name(Load)Store)List(ConstantConstantLoad)))))", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_io.py_5-55"}
{"title": "maxhumber_redframes-tests-test_io.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_io.py"], "line_no": 40, "start_line_no": 15, "end_line_no": 65, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        self.path = str(Path(tempdir) / \"example.csv\")\n\n    def tearDown(self):\n        delete(self.tempdir)\n\n    def test_load_missing_file(self):\n        with self.assertRaises(FileNotFoundError):\n            rf.load(\"test_missing_file.csv\")\n\n    def test_load_bad_format(self):\n        with self.assertRaisesRegex(TypeError, \"must end in .csv\"):\n            rf.load(\"test_bad_file_format.json\")\n\n    def test_save_bad_path_format(self):\n        with self.assertRaisesRegex(TypeError, \"must end in .csv\"):\n            rf.save(self.df, \"example.json\")\n\n    def test_save_bad_type(self):\n        with self.assertRaisesRegex(TypeError, \"must be DataFrame\"):\n            rf.save(1, \"example.json\")\n\n    def test_unwrap_bad_type(self):\n        with self.assertRaisesRegex(TypeError, \"must be DataFrame\"):\n            rf.unwrap(1)\n\n    def test_wrap_bad_type(self):\n        with self.assertRaisesRegex(TypeError, \"must be DataFrame\"):\n            rf.wrap(1)\n\n    def test_unwrap_wrong_direction(self):\n        with self.assertRaisesRegex(TypeError, \"must be DataFrame\"):\n            rf.unwrap(self.pdf)\n\n    def test_wrap_wrong_direction(self):\n        with self.assertRaisesRegex(TypeError, \"must be DataFrame\"):\n            rf.wrap(self.df)\n\n    def test_unwrap_no_side_effect(self):\n        pdf = rf.unwrap(self.df)\n        pdf.columns = [\"oof\", \"rab\"]\n        expected = rf.DataFrame({\"foo\": [1, 2], \"bar\": [3, 4]})\n        self.assertEqual(self.df, expected)\n\n    def test_wrap_no_side_effect(self):\n        df = rf.wrap(self.pdf)\n        df = df.rename({\"foo\": \"oof\"})\n        expected = pd.DataFrame({\"foo\": [1, 2], \"bar\": [3, 4]})\n        self.assertTrue(self.pdf.equals(expected))\n\n    def test_round_trip_save_load(self):", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_io.py_15-65"}
{"title": "maxhumber_redframes-tests-test_io.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_io.py"], "line_no": 50, "start_line_no": 25, "end_line_no": 75, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        with self.assertRaisesRegex(TypeError, \"must end in .csv\"):\n            rf.load(\"test_bad_file_format.json\")\n\n    def test_save_bad_path_format(self):\n        with self.assertRaisesRegex(TypeError, \"must end in .csv\"):\n            rf.save(self.df, \"example.json\")\n\n    def test_save_bad_type(self):\n        with self.assertRaisesRegex(TypeError, \"must be DataFrame\"):\n            rf.save(1, \"example.json\")\n\n    def test_unwrap_bad_type(self):\n        with self.assertRaisesRegex(TypeError, \"must be DataFrame\"):\n            rf.unwrap(1)\n\n    def test_wrap_bad_type(self):\n        with self.assertRaisesRegex(TypeError, \"must be DataFrame\"):\n            rf.wrap(1)\n\n    def test_unwrap_wrong_direction(self):\n        with self.assertRaisesRegex(TypeError, \"must be DataFrame\"):\n            rf.unwrap(self.pdf)\n\n    def test_wrap_wrong_direction(self):\n        with self.assertRaisesRegex(TypeError, \"must be DataFrame\"):\n            rf.wrap(self.df)\n\n    def test_unwrap_no_side_effect(self):\n        pdf = rf.unwrap(self.df)\n        pdf.columns = [\"oof\", \"rab\"]\n        expected = rf.DataFrame({\"foo\": [1, 2], \"bar\": [3, 4]})\n        self.assertEqual(self.df, expected)\n\n    def test_wrap_no_side_effect(self):\n        df = rf.wrap(self.pdf)\n        df = df.rename({\"foo\": \"oof\"})\n        expected = pd.DataFrame({\"foo\": [1, 2], \"bar\": [3, 4]})\n        self.assertTrue(self.pdf.equals(expected))\n\n    def test_round_trip_save_load(self):\n        rf.save(self.df, self.path)\n        result = rf.load(self.path)\n        expected = rf.DataFrame({\"foo\": [1, 2], \"bar\": [3, 4]})\n        self.assertEqual(result, expected)\n\n    def test_round_trip_unwrap_wrap(self):\n        pdf = rf.unwrap(self.df)\n        result = rf.wrap(pdf)\n        expected = rf.DataFrame({\"foo\": [1, 2], \"bar\": [3, 4]})\n        self.assertEqual(result, expected)", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_io.py_25-75"}
{"title": "maxhumber_redframes-tests-test_io.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_io.py"], "line_no": 60, "start_line_no": 35, "end_line_no": 75, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "\n    def test_unwrap_bad_type(self):\n        with self.assertRaisesRegex(TypeError, \"must be DataFrame\"):\n            rf.unwrap(1)\n\n    def test_wrap_bad_type(self):\n        with self.assertRaisesRegex(TypeError, \"must be DataFrame\"):\n            rf.wrap(1)\n\n    def test_unwrap_wrong_direction(self):\n        with self.assertRaisesRegex(TypeError, \"must be DataFrame\"):\n            rf.unwrap(self.pdf)\n\n    def test_wrap_wrong_direction(self):\n        with self.assertRaisesRegex(TypeError, \"must be DataFrame\"):\n            rf.wrap(self.df)\n\n    def test_unwrap_no_side_effect(self):\n        pdf = rf.unwrap(self.df)\n        pdf.columns = [\"oof\", \"rab\"]\n        expected = rf.DataFrame({\"foo\": [1, 2], \"bar\": [3, 4]})\n        self.assertEqual(self.df, expected)\n\n    def test_wrap_no_side_effect(self):\n        df = rf.wrap(self.pdf)\n        df = df.rename({\"foo\": \"oof\"})\n        expected = pd.DataFrame({\"foo\": [1, 2], \"bar\": [3, 4]})\n        self.assertTrue(self.pdf.equals(expected))\n\n    def test_round_trip_save_load(self):\n        rf.save(self.df, self.path)\n        result = rf.load(self.path)\n        expected = rf.DataFrame({\"foo\": [1, 2], \"bar\": [3, 4]})\n        self.assertEqual(result, expected)\n\n    def test_round_trip_unwrap_wrap(self):\n        pdf = rf.unwrap(self.df)\n        result = rf.wrap(pdf)\n        expected = rf.DataFrame({\"foo\": [1, 2], \"bar\": [3, 4]})\n        self.assertEqual(result, expected)", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_io.py_35-75"}
{"title": "maxhumber_redframes-tests-test_io.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_io.py"], "line_no": 70, "start_line_no": 45, "end_line_no": 75, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        with self.assertRaisesRegex(TypeError, \"must be DataFrame\"):\n            rf.unwrap(self.pdf)\n\n    def test_wrap_wrong_direction(self):\n        with self.assertRaisesRegex(TypeError, \"must be DataFrame\"):\n            rf.wrap(self.df)\n\n    def test_unwrap_no_side_effect(self):\n        pdf = rf.unwrap(self.df)\n        pdf.columns = [\"oof\", \"rab\"]\n        expected = rf.DataFrame({\"foo\": [1, 2], \"bar\": [3, 4]})\n        self.assertEqual(self.df, expected)\n\n    def test_wrap_no_side_effect(self):\n        df = rf.wrap(self.pdf)\n        df = df.rename({\"foo\": \"oof\"})\n        expected = pd.DataFrame({\"foo\": [1, 2], \"bar\": [3, 4]})\n        self.assertTrue(self.pdf.equals(expected))\n\n    def test_round_trip_save_load(self):\n        rf.save(self.df, self.path)\n        result = rf.load(self.path)\n        expected = rf.DataFrame({\"foo\": [1, 2], \"bar\": [3, 4]})\n        self.assertEqual(result, expected)\n\n    def test_round_trip_unwrap_wrap(self):\n        pdf = rf.unwrap(self.df)\n        result = rf.wrap(pdf)\n        expected = rf.DataFrame({\"foo\": [1, 2], \"bar\": [3, 4]})\n        self.assertEqual(result, expected)", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_io.py_45-75"}
{"title": "maxhumber_redframes-tests-test_ladybugs.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_ladybugs.py"], "line_no": 0, "start_line_no": 0, "end_line_no": 25, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "import unittest\n\nimport pandas as pd\n\nimport redframes as rf\n\n\nclass TestLadyBugs(unittest.TestCase):\n    def test_gather_spread_string_values(self):\n        df = rf.DataFrame(\n            {\"foo\": [\"A\", \"B\", \"C\"], \"bar\": [\"D\", \"E\", \"F\"], \"baz\": [\"G\", \"H\", \"I\"]}\n        )\n        result = df.gather().spread(\"variable\", \"value\")\n        expected = rf.DataFrame(\n            {\"bar\": [\"D\", \"E\", \"F\"], \"baz\": [\"G\", \"H\", \"I\"], \"foo\": [\"A\", \"B\", \"C\"]}\n        )\n        self.assertEqual(result, expected)\n\n    def test_types_mixed_column(self):\n        df = rf.DataFrame({\"foo\": [1, None, 2.0, \"3\"]})\n        result = df.types\n        expected = {\"foo\": object}\n        self.assertEqual(result, expected)\n\n    def test_comine_overwrite_and_drop_other(self):", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_ladybugs.py_0-25"}
{"title": "maxhumber_redframes-tests-test_ladybugs.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_ladybugs.py"], "line_no": 10, "start_line_no": 0, "end_line_no": 35, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "import unittest\n\nimport pandas as pd\n\nimport redframes as rf\n\n\nclass TestLadyBugs(unittest.TestCase):\n    def test_gather_spread_string_values(self):\n        df = rf.DataFrame(\n            {\"foo\": [\"A\", \"B\", \"C\"], \"bar\": [\"D\", \"E\", \"F\"], \"baz\": [\"G\", \"H\", \"I\"]}\n        )\n        result = df.gather().spread(\"variable\", \"value\")\n        expected = rf.DataFrame(\n            {\"bar\": [\"D\", \"E\", \"F\"], \"baz\": [\"G\", \"H\", \"I\"], \"foo\": [\"A\", \"B\", \"C\"]}\n        )\n        self.assertEqual(result, expected)\n\n    def test_types_mixed_column(self):\n        df = rf.DataFrame({\"foo\": [1, None, 2.0, \"3\"]})\n        result = df.types\n        expected = {\"foo\": object}\n        self.assertEqual(result, expected)\n\n    def test_comine_overwrite_and_drop_other(self):\n        df = rf.DataFrame({\"foo\": [1, 2, 3], \"bar\": [1, 2, 3]})\n        result = df.combine([\"foo\", \"bar\"], into=\"foo\", sep=\"-\", drop=True)\n        expected = rf.DataFrame({\"foo\": [\"1-1\", \"2-2\", \"3-3\"]})\n        self.assertEqual(result, expected)\n\n    def test_sample_float_1_point_0(self):\n        df = rf.DataFrame({\"foo\": range(100)})\n        with self.assertRaisesRegex(ValueError, \"must be int if > 1\"):\n            df.sample(1.0)\n\n\nAST=Module(Import(alias)Import(alias)Import(alias)ClassDef(Attribute(Name(Load)Load)FunctionDef(arguments(arg)Assign(Name(Store)Call(Attribute(Name(Load)Load)Dict(ConstantConstantConstantList(ConstantConstantConstantLoad)List(ConstantConstantConstantLoad)List(ConstantConstantConstantLoad))))Assign(Name(Store)Call(Attribute(Call(Attribute(Name(Load)Load))Load)ConstantConstant))Assign(Name(Store)Call(Attribute(Name(Load)Load)Dict(ConstantConstantConstantList(ConstantConstantConstantLoad)List(ConstantConstantConstantLoad)List(ConstantConstantConstantLoad))))Expr(Call(Attribute(Name(Load)Load)Name(Load)Name(Load))))FunctionDef(arguments(arg)Assign(Name(Store)Call(Attribute(Name(Load)Load)Dict(ConstantList(ConstantConstantConstantConstantLoad))))Assign(Name(Store)Attribute(Name(Load)Load))Assign(Name(Store)Dict(ConstantName(Load)))Expr(Call(Attribute(Name(Load)Load)Name(Load)Name(Load))))FunctionDef(arguments(arg)Assign(Name(Store)Call(Attribute(Name(Load)Load)Dict(ConstantConstantList(ConstantConstantConstantLoad)List(ConstantConstantConstantLoad))))Assign(Name(Store)Call(Attribute(Name(Load)Load)List(ConstantConstantLoad)keyword(Constant)keyword(Constant)keyword(Constant)))Assign(Name(Store)Call(Attribute(Name(Load)Load)Dict(ConstantList(ConstantConstantConstantLoad))))Expr(Call(Attribute(Name(Load)Load)Name(Load)Name(Load))))FunctionDef(arguments(arg)Assign(Name(Store)Call(Attribute(Name(Load)Load)Dict(ConstantCall(Name(Load)Constant))))With(withitem(Call(Attribute(Name(Load)Load)Name(Load)Constant))Expr(Call(Attribute(Name(Load)Load)Constant))))))", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_ladybugs.py_0-35"}
{"title": "maxhumber_redframes-tests-test_ladybugs.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_ladybugs.py"], "line_no": 20, "start_line_no": 0, "end_line_no": 45, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "import unittest\n\nimport pandas as pd\n\nimport redframes as rf\n\n\nclass TestLadyBugs(unittest.TestCase):\n    def test_gather_spread_string_values(self):\n        df = rf.DataFrame(\n            {\"foo\": [\"A\", \"B\", \"C\"], \"bar\": [\"D\", \"E\", \"F\"], \"baz\": [\"G\", \"H\", \"I\"]}\n        )\n        result = df.gather().spread(\"variable\", \"value\")\n        expected = rf.DataFrame(\n            {\"bar\": [\"D\", \"E\", \"F\"], \"baz\": [\"G\", \"H\", \"I\"], \"foo\": [\"A\", \"B\", \"C\"]}\n        )\n        self.assertEqual(result, expected)\n\n    def test_types_mixed_column(self):\n        df = rf.DataFrame({\"foo\": [1, None, 2.0, \"3\"]})\n        result = df.types\n        expected = {\"foo\": object}\n        self.assertEqual(result, expected)\n\n    def test_comine_overwrite_and_drop_other(self):\n        df = rf.DataFrame({\"foo\": [1, 2, 3], \"bar\": [1, 2, 3]})\n        result = df.combine([\"foo\", \"bar\"], into=\"foo\", sep=\"-\", drop=True)\n        expected = rf.DataFrame({\"foo\": [\"1-1\", \"2-2\", \"3-3\"]})\n        self.assertEqual(result, expected)\n\n    def test_sample_float_1_point_0(self):\n        df = rf.DataFrame({\"foo\": range(100)})\n        with self.assertRaisesRegex(ValueError, \"must be int if > 1\"):\n            df.sample(1.0)\n\n    def test_sample_negative_1(self):\n        df = rf.DataFrame({\"foo\": range(100)})\n        with self.assertRaisesRegex(ValueError, \"must be > 0\"):\n            df.sample(-1)\n\n    def test_io_wrap_multi_columns(self):\n        columns = pd.MultiIndex.from_arrays(\n            [[\"route\", \"action\", \"action\"], [\"type\", \"source\", \"destination\"]]\n        )\n        pdf = pd.DataFrame([[1, 2, 3]], columns=columns)\n\nAST=Module(Import(alias)Import(alias)Import(alias)ClassDef(Attribute(Name(Load)Load)FunctionDef(arguments(arg)Assign(Name(Store)Call(Attribute(Name(Load)Load)Dict(ConstantConstantConstantList(ConstantConstantConstantLoad)List(ConstantConstantConstantLoad)List(ConstantConstantConstantLoad))))Assign(Name(Store)Call(Attribute(Call(Attribute(Name(Load)Load))Load)ConstantConstant))Assign(Name(Store)Call(Attribute(Name(Load)Load)Dict(ConstantConstantConstantList(ConstantConstantConstantLoad)List(ConstantConstantConstantLoad)List(ConstantConstantConstantLoad))))Expr(Call(Attribute(Name(Load)Load)Name(Load)Name(Load))))FunctionDef(arguments(arg)Assign(Name(Store)Call(Attribute(Name(Load)Load)Dict(ConstantList(ConstantConstantConstantConstantLoad))))Assign(Name(Store)Attribute(Name(Load)Load))Assign(Name(Store)Dict(ConstantName(Load)))Expr(Call(Attribute(Name(Load)Load)Name(Load)Name(Load))))FunctionDef(arguments(arg)Assign(Name(Store)Call(Attribute(Name(Load)Load)Dict(ConstantConstantList(ConstantConstantConstantLoad)List(ConstantConstantConstantLoad))))Assign(Name(Store)Call(Attribute(Name(Load)Load)List(ConstantConstantLoad)keyword(Constant)keyword(Constant)keyword(Constant)))Assign(Name(Store)Call(Attribute(Name(Load)Load)Dict(ConstantList(ConstantConstantConstantLoad))))Expr(Call(Attribute(Name(Load)Load)Name(Load)Name(Load))))FunctionDef(arguments(arg)Assign(Name(Store)Call(Attribute(Name(Load)Load)Dict(ConstantCall(Name(Load)Constant))))With(withitem(Call(Attribute(Name(Load)Load)Name(Load)Constant))Expr(Call(Attribute(Name(Load)Load)Constant))))FunctionDef(arguments(arg)Assign(Name(Store)Call(Attribute(Name(Load)Load)Dict(ConstantCall(Name(Load)Constant))))With(withitem(Call(Attribute(Name(Load)Load)Name(Load)Constant))Expr(Call(Attribute(Name(Load)Load)UnaryOp(USubConstant)))))FunctionDef(arguments(arg)Assign(Name(Store)Call(Attribute(Attribute(Name(Load)Load)Load)List(List(ConstantConstantConstantLoad)List(ConstantConstantConstantLoad)Load)))Assign(Name(Store)Call(Attribute(Name(Load)Load)List(List(ConstantConstantConstantLoad)Load)keyword(Name(Load)))))))", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_ladybugs.py_0-45"}
{"title": "maxhumber_redframes-tests-test_ladybugs.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_ladybugs.py"], "line_no": 30, "start_line_no": 5, "end_line_no": 55, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "\n\nclass TestLadyBugs(unittest.TestCase):\n    def test_gather_spread_string_values(self):\n        df = rf.DataFrame(\n            {\"foo\": [\"A\", \"B\", \"C\"], \"bar\": [\"D\", \"E\", \"F\"], \"baz\": [\"G\", \"H\", \"I\"]}\n        )\n        result = df.gather().spread(\"variable\", \"value\")\n        expected = rf.DataFrame(\n            {\"bar\": [\"D\", \"E\", \"F\"], \"baz\": [\"G\", \"H\", \"I\"], \"foo\": [\"A\", \"B\", \"C\"]}\n        )\n        self.assertEqual(result, expected)\n\n    def test_types_mixed_column(self):\n        df = rf.DataFrame({\"foo\": [1, None, 2.0, \"3\"]})\n        result = df.types\n        expected = {\"foo\": object}\n        self.assertEqual(result, expected)\n\n    def test_comine_overwrite_and_drop_other(self):\n        df = rf.DataFrame({\"foo\": [1, 2, 3], \"bar\": [1, 2, 3]})\n        result = df.combine([\"foo\", \"bar\"], into=\"foo\", sep=\"-\", drop=True)\n        expected = rf.DataFrame({\"foo\": [\"1-1\", \"2-2\", \"3-3\"]})\n        self.assertEqual(result, expected)\n\n    def test_sample_float_1_point_0(self):\n        df = rf.DataFrame({\"foo\": range(100)})\n        with self.assertRaisesRegex(ValueError, \"must be int if > 1\"):\n            df.sample(1.0)\n\n    def test_sample_negative_1(self):\n        df = rf.DataFrame({\"foo\": range(100)})\n        with self.assertRaisesRegex(ValueError, \"must be > 0\"):\n            df.sample(-1)\n\n    def test_io_wrap_multi_columns(self):\n        columns = pd.MultiIndex.from_arrays(\n            [[\"route\", \"action\", \"action\"], [\"type\", \"source\", \"destination\"]]\n        )\n        pdf = pd.DataFrame([[1, 2, 3]], columns=columns)\n        with self.assertRaisesRegex(KeyError, \"must be flat\"):\n            rf.wrap(pdf)\n\n    def test_group_gather_beside_conflict(self):\n        df = rf.DataFrame(\n            {\n                \"foo\": [1, 1, 1, 2, 2, 1, 3, 3],\n                \"bar\": range(8),\n                \"baz\": range(8),\n                \"jaz\": range(8),", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_ladybugs.py_5-55"}
{"title": "maxhumber_redframes-tests-test_ladybugs.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_ladybugs.py"], "line_no": 40, "start_line_no": 15, "end_line_no": 65, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        )\n        self.assertEqual(result, expected)\n\n    def test_types_mixed_column(self):\n        df = rf.DataFrame({\"foo\": [1, None, 2.0, \"3\"]})\n        result = df.types\n        expected = {\"foo\": object}\n        self.assertEqual(result, expected)\n\n    def test_comine_overwrite_and_drop_other(self):\n        df = rf.DataFrame({\"foo\": [1, 2, 3], \"bar\": [1, 2, 3]})\n        result = df.combine([\"foo\", \"bar\"], into=\"foo\", sep=\"-\", drop=True)\n        expected = rf.DataFrame({\"foo\": [\"1-1\", \"2-2\", \"3-3\"]})\n        self.assertEqual(result, expected)\n\n    def test_sample_float_1_point_0(self):\n        df = rf.DataFrame({\"foo\": range(100)})\n        with self.assertRaisesRegex(ValueError, \"must be int if > 1\"):\n            df.sample(1.0)\n\n    def test_sample_negative_1(self):\n        df = rf.DataFrame({\"foo\": range(100)})\n        with self.assertRaisesRegex(ValueError, \"must be > 0\"):\n            df.sample(-1)\n\n    def test_io_wrap_multi_columns(self):\n        columns = pd.MultiIndex.from_arrays(\n            [[\"route\", \"action\", \"action\"], [\"type\", \"source\", \"destination\"]]\n        )\n        pdf = pd.DataFrame([[1, 2, 3]], columns=columns)\n        with self.assertRaisesRegex(KeyError, \"must be flat\"):\n            rf.wrap(pdf)\n\n    def test_group_gather_beside_conflict(self):\n        df = rf.DataFrame(\n            {\n                \"foo\": [1, 1, 1, 2, 2, 1, 3, 3],\n                \"bar\": range(8),\n                \"baz\": range(8),\n                \"jaz\": range(8),\n            }\n        )\n        with self.assertRaisesRegex(ValueError, \"beside is incompatible*\"):\n            df.group(\"foo\").gather(beside=\"bar\")\n\n    def test_group_gather_columns_conflict(self):\n        df = rf.DataFrame(\n            {\n                \"foo\": [1, 1, 1, 2, 2, 1, 3, 3],\n                \"bar\": range(8),", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_ladybugs.py_15-65"}
{"title": "maxhumber_redframes-tests-test_ladybugs.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_ladybugs.py"], "line_no": 50, "start_line_no": 25, "end_line_no": 71, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        df = rf.DataFrame({\"foo\": [1, 2, 3], \"bar\": [1, 2, 3]})\n        result = df.combine([\"foo\", \"bar\"], into=\"foo\", sep=\"-\", drop=True)\n        expected = rf.DataFrame({\"foo\": [\"1-1\", \"2-2\", \"3-3\"]})\n        self.assertEqual(result, expected)\n\n    def test_sample_float_1_point_0(self):\n        df = rf.DataFrame({\"foo\": range(100)})\n        with self.assertRaisesRegex(ValueError, \"must be int if > 1\"):\n            df.sample(1.0)\n\n    def test_sample_negative_1(self):\n        df = rf.DataFrame({\"foo\": range(100)})\n        with self.assertRaisesRegex(ValueError, \"must be > 0\"):\n            df.sample(-1)\n\n    def test_io_wrap_multi_columns(self):\n        columns = pd.MultiIndex.from_arrays(\n            [[\"route\", \"action\", \"action\"], [\"type\", \"source\", \"destination\"]]\n        )\n        pdf = pd.DataFrame([[1, 2, 3]], columns=columns)\n        with self.assertRaisesRegex(KeyError, \"must be flat\"):\n            rf.wrap(pdf)\n\n    def test_group_gather_beside_conflict(self):\n        df = rf.DataFrame(\n            {\n                \"foo\": [1, 1, 1, 2, 2, 1, 3, 3],\n                \"bar\": range(8),\n                \"baz\": range(8),\n                \"jaz\": range(8),\n            }\n        )\n        with self.assertRaisesRegex(ValueError, \"beside is incompatible*\"):\n            df.group(\"foo\").gather(beside=\"bar\")\n\n    def test_group_gather_columns_conflict(self):\n        df = rf.DataFrame(\n            {\n                \"foo\": [1, 1, 1, 2, 2, 1, 3, 3],\n                \"bar\": range(8),\n                \"baz\": range(8),\n                \"jaz\": range(8),\n            }\n        )\n        with self.assertRaisesRegex(ValueError, \"columns is incompatible*\"):\n            df.group(\"foo\").gather(columns=[\"foo\", \"bar\"])", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_ladybugs.py_25-71"}
{"title": "maxhumber_redframes-tests-test_ladybugs.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_ladybugs.py"], "line_no": 60, "start_line_no": 35, "end_line_no": 71, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "    def test_sample_negative_1(self):\n        df = rf.DataFrame({\"foo\": range(100)})\n        with self.assertRaisesRegex(ValueError, \"must be > 0\"):\n            df.sample(-1)\n\n    def test_io_wrap_multi_columns(self):\n        columns = pd.MultiIndex.from_arrays(\n            [[\"route\", \"action\", \"action\"], [\"type\", \"source\", \"destination\"]]\n        )\n        pdf = pd.DataFrame([[1, 2, 3]], columns=columns)\n        with self.assertRaisesRegex(KeyError, \"must be flat\"):\n            rf.wrap(pdf)\n\n    def test_group_gather_beside_conflict(self):\n        df = rf.DataFrame(\n            {\n                \"foo\": [1, 1, 1, 2, 2, 1, 3, 3],\n                \"bar\": range(8),\n                \"baz\": range(8),\n                \"jaz\": range(8),\n            }\n        )\n        with self.assertRaisesRegex(ValueError, \"beside is incompatible*\"):\n            df.group(\"foo\").gather(beside=\"bar\")\n\n    def test_group_gather_columns_conflict(self):\n        df = rf.DataFrame(\n            {\n                \"foo\": [1, 1, 1, 2, 2, 1, 3, 3],\n                \"bar\": range(8),\n                \"baz\": range(8),\n                \"jaz\": range(8),\n            }\n        )\n        with self.assertRaisesRegex(ValueError, \"columns is incompatible*\"):\n            df.group(\"foo\").gather(columns=[\"foo\", \"bar\"])", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_ladybugs.py_35-71"}
{"title": "maxhumber_redframes-tests-test_ladybugs.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_ladybugs.py"], "line_no": 70, "start_line_no": 45, "end_line_no": 71, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        with self.assertRaisesRegex(KeyError, \"must be flat\"):\n            rf.wrap(pdf)\n\n    def test_group_gather_beside_conflict(self):\n        df = rf.DataFrame(\n            {\n                \"foo\": [1, 1, 1, 2, 2, 1, 3, 3],\n                \"bar\": range(8),\n                \"baz\": range(8),\n                \"jaz\": range(8),\n            }\n        )\n        with self.assertRaisesRegex(ValueError, \"beside is incompatible*\"):\n            df.group(\"foo\").gather(beside=\"bar\")\n\n    def test_group_gather_columns_conflict(self):\n        df = rf.DataFrame(\n            {\n                \"foo\": [1, 1, 1, 2, 2, 1, 3, 3],\n                \"bar\": range(8),\n                \"baz\": range(8),\n                \"jaz\": range(8),\n            }\n        )\n        with self.assertRaisesRegex(ValueError, \"columns is incompatible*\"):\n            df.group(\"foo\").gather(columns=[\"foo\", \"bar\"])", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_ladybugs.py_45-71"}
{"title": "maxhumber_redframes-tests-test_readme.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_readme.py"], "line_no": 0, "start_line_no": 0, "end_line_no": 25, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "import unittest\nfrom pathlib import Path\nfrom shutil import rmtree as delete\nfrom tempfile import mkdtemp as make_temp_dir\n\n\nclass TestReadme(unittest.TestCase):\n    def setUp(self):\n        self.tempdir = tempdir = make_temp_dir()\n        self.path = str(Path(tempdir) / \"bears.csv\")\n\n    def tearDown(self):\n        delete(self.tempdir)\n\n    def test_quick_start(self):\n        import redframes as rf\n\n        df = rf.DataFrame(\n            {\n                \"bear\": [\n                    \"Brown bear\",\n                    \"Polar bear\",\n                    \"Asian black bear\",\n                    \"American black bear\",\n                    \"Sun bear\",", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_readme.py_0-25"}
{"title": "maxhumber_redframes-tests-test_readme.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_readme.py"], "line_no": 10, "start_line_no": 0, "end_line_no": 35, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "import unittest\nfrom pathlib import Path\nfrom shutil import rmtree as delete\nfrom tempfile import mkdtemp as make_temp_dir\n\n\nclass TestReadme(unittest.TestCase):\n    def setUp(self):\n        self.tempdir = tempdir = make_temp_dir()\n        self.path = str(Path(tempdir) / \"bears.csv\")\n\n    def tearDown(self):\n        delete(self.tempdir)\n\n    def test_quick_start(self):\n        import redframes as rf\n\n        df = rf.DataFrame(\n            {\n                \"bear\": [\n                    \"Brown bear\",\n                    \"Polar bear\",\n                    \"Asian black bear\",\n                    \"American black bear\",\n                    \"Sun bear\",\n                    \"Sloth bear\",\n                    \"Spectacled bear\",\n                    \"Giant panda\",\n                ],\n                \"genus\": [\n                    \"Ursus\",\n                    \"Ursus\",\n                    \"Ursus\",\n                    \"Ursus\",\n                    \"Helarctos\",", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_readme.py_0-35"}
{"title": "maxhumber_redframes-tests-test_readme.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_readme.py"], "line_no": 20, "start_line_no": 0, "end_line_no": 45, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "import unittest\nfrom pathlib import Path\nfrom shutil import rmtree as delete\nfrom tempfile import mkdtemp as make_temp_dir\n\n\nclass TestReadme(unittest.TestCase):\n    def setUp(self):\n        self.tempdir = tempdir = make_temp_dir()\n        self.path = str(Path(tempdir) / \"bears.csv\")\n\n    def tearDown(self):\n        delete(self.tempdir)\n\n    def test_quick_start(self):\n        import redframes as rf\n\n        df = rf.DataFrame(\n            {\n                \"bear\": [\n                    \"Brown bear\",\n                    \"Polar bear\",\n                    \"Asian black bear\",\n                    \"American black bear\",\n                    \"Sun bear\",\n                    \"Sloth bear\",\n                    \"Spectacled bear\",\n                    \"Giant panda\",\n                ],\n                \"genus\": [\n                    \"Ursus\",\n                    \"Ursus\",\n                    \"Ursus\",\n                    \"Ursus\",\n                    \"Helarctos\",\n                    \"Melursus\",\n                    \"Tremarctos\",\n                    \"Ailuropoda\",\n                ],\n                \"weight (male, lbs)\": [\n                    \"300-860\",\n                    \"880-1320\",\n                    \"220-440\",\n                    \"125-500\",\n                    \"60-150\",", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_readme.py_0-45"}
{"title": "maxhumber_redframes-tests-test_readme.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_readme.py"], "line_no": 30, "start_line_no": 5, "end_line_no": 55, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "\nclass TestReadme(unittest.TestCase):\n    def setUp(self):\n        self.tempdir = tempdir = make_temp_dir()\n        self.path = str(Path(tempdir) / \"bears.csv\")\n\n    def tearDown(self):\n        delete(self.tempdir)\n\n    def test_quick_start(self):\n        import redframes as rf\n\n        df = rf.DataFrame(\n            {\n                \"bear\": [\n                    \"Brown bear\",\n                    \"Polar bear\",\n                    \"Asian black bear\",\n                    \"American black bear\",\n                    \"Sun bear\",\n                    \"Sloth bear\",\n                    \"Spectacled bear\",\n                    \"Giant panda\",\n                ],\n                \"genus\": [\n                    \"Ursus\",\n                    \"Ursus\",\n                    \"Ursus\",\n                    \"Ursus\",\n                    \"Helarctos\",\n                    \"Melursus\",\n                    \"Tremarctos\",\n                    \"Ailuropoda\",\n                ],\n                \"weight (male, lbs)\": [\n                    \"300-860\",\n                    \"880-1320\",\n                    \"220-440\",\n                    \"125-500\",\n                    \"60-150\",\n                    \"175-310\",\n                    \"220-340\",\n                    \"190-275\",\n                ],\n                \"weight (female, lbs)\": [\n                    \"205-455\",\n                    \"330-550\",\n                    \"110-275\",\n                    \"90-300\",\n                    \"45-90\",", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_readme.py_5-55"}
{"title": "maxhumber_redframes-tests-test_readme.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_readme.py"], "line_no": 40, "start_line_no": 15, "end_line_no": 65, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        import redframes as rf\n\n        df = rf.DataFrame(\n            {\n                \"bear\": [\n                    \"Brown bear\",\n                    \"Polar bear\",\n                    \"Asian black bear\",\n                    \"American black bear\",\n                    \"Sun bear\",\n                    \"Sloth bear\",\n                    \"Spectacled bear\",\n                    \"Giant panda\",\n                ],\n                \"genus\": [\n                    \"Ursus\",\n                    \"Ursus\",\n                    \"Ursus\",\n                    \"Ursus\",\n                    \"Helarctos\",\n                    \"Melursus\",\n                    \"Tremarctos\",\n                    \"Ailuropoda\",\n                ],\n                \"weight (male, lbs)\": [\n                    \"300-860\",\n                    \"880-1320\",\n                    \"220-440\",\n                    \"125-500\",\n                    \"60-150\",\n                    \"175-310\",\n                    \"220-340\",\n                    \"190-275\",\n                ],\n                \"weight (female, lbs)\": [\n                    \"205-455\",\n                    \"330-550\",\n                    \"110-275\",\n                    \"90-300\",\n                    \"45-90\",\n                    \"120-210\",\n                    \"140-180\",\n                    \"155-220\",\n                ],\n            }\n        )\n\n        # | bear                | genus      | weight (male, lbs)   | weight (female, lbs)   |\n        # |:--------------------|:-----------|:---------------------|:-----------------------|\n        # | Brown bear          | Ursus      | 300-860              | 205-455                |", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_readme.py_15-65"}
{"title": "maxhumber_redframes-tests-test_readme.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_readme.py"], "line_no": 50, "start_line_no": 25, "end_line_no": 75, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "                    \"Sloth bear\",\n                    \"Spectacled bear\",\n                    \"Giant panda\",\n                ],\n                \"genus\": [\n                    \"Ursus\",\n                    \"Ursus\",\n                    \"Ursus\",\n                    \"Ursus\",\n                    \"Helarctos\",\n                    \"Melursus\",\n                    \"Tremarctos\",\n                    \"Ailuropoda\",\n                ],\n                \"weight (male, lbs)\": [\n                    \"300-860\",\n                    \"880-1320\",\n                    \"220-440\",\n                    \"125-500\",\n                    \"60-150\",\n                    \"175-310\",\n                    \"220-340\",\n                    \"190-275\",\n                ],\n                \"weight (female, lbs)\": [\n                    \"205-455\",\n                    \"330-550\",\n                    \"110-275\",\n                    \"90-300\",\n                    \"45-90\",\n                    \"120-210\",\n                    \"140-180\",\n                    \"155-220\",\n                ],\n            }\n        )\n\n        # | bear                | genus      | weight (male, lbs)   | weight (female, lbs)   |\n        # |:--------------------|:-----------|:---------------------|:-----------------------|\n        # | Brown bear          | Ursus      | 300-860              | 205-455                |\n        # | Polar bear          | Ursus      | 880-1320             | 330-550                |\n        # | Asian black bear    | Ursus      | 220-440              | 110-275                |\n        # | American black bear | Ursus      | 125-500              | 90-300                 |\n        # | Sun bear            | Helarctos  | 60-150               | 45-90                  |\n        # | Sloth bear          | Melursus   | 175-310              | 120-210                |\n        # | Spectacled bear     | Tremarctos | 220-340              | 140-180                |\n        # | Giant panda         | Ailuropoda | 190-275              | 155-220                |\n\n        (\n            df.rename({\"weight (male, lbs)\": \"male\", \"weight (female, lbs)\": \"female\"})", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_readme.py_25-75"}
{"title": "maxhumber_redframes-tests-test_readme.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_readme.py"], "line_no": 60, "start_line_no": 35, "end_line_no": 85, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "                    \"Melursus\",\n                    \"Tremarctos\",\n                    \"Ailuropoda\",\n                ],\n                \"weight (male, lbs)\": [\n                    \"300-860\",\n                    \"880-1320\",\n                    \"220-440\",\n                    \"125-500\",\n                    \"60-150\",\n                    \"175-310\",\n                    \"220-340\",\n                    \"190-275\",\n                ],\n                \"weight (female, lbs)\": [\n                    \"205-455\",\n                    \"330-550\",\n                    \"110-275\",\n                    \"90-300\",\n                    \"45-90\",\n                    \"120-210\",\n                    \"140-180\",\n                    \"155-220\",\n                ],\n            }\n        )\n\n        # | bear                | genus      | weight (male, lbs)   | weight (female, lbs)   |\n        # |:--------------------|:-----------|:---------------------|:-----------------------|\n        # | Brown bear          | Ursus      | 300-860              | 205-455                |\n        # | Polar bear          | Ursus      | 880-1320             | 330-550                |\n        # | Asian black bear    | Ursus      | 220-440              | 110-275                |\n        # | American black bear | Ursus      | 125-500              | 90-300                 |\n        # | Sun bear            | Helarctos  | 60-150               | 45-90                  |\n        # | Sloth bear          | Melursus   | 175-310              | 120-210                |\n        # | Spectacled bear     | Tremarctos | 220-340              | 140-180                |\n        # | Giant panda         | Ailuropoda | 190-275              | 155-220                |\n\n        (\n            df.rename({\"weight (male, lbs)\": \"male\", \"weight (female, lbs)\": \"female\"})\n            .gather([\"male\", \"female\"], into=(\"sex\", \"weight\"))\n            .split(\"weight\", into=[\"min\", \"max\"], sep=\"-\")\n            .gather([\"min\", \"max\"], into=(\"stat\", \"weight\"))\n            .mutate({\"weight\": lambda row: float(row[\"weight\"])})\n            .group([\"genus\", \"sex\"])\n            .rollup({\"weight\": (\"weight\", rf.stat.mean)})\n            .spread(\"sex\", using=\"weight\")\n            .mutate({\"dimorphism\": lambda row: round(row[\"male\"] / row[\"female\"], 2)})\n            .drop([\"male\", \"female\"])\n            .sort(\"dimorphism\", descending=True)", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_readme.py_35-85"}
{"title": "maxhumber_redframes-tests-test_readme.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_readme.py"], "line_no": 70, "start_line_no": 45, "end_line_no": 95, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "                    \"175-310\",\n                    \"220-340\",\n                    \"190-275\",\n                ],\n                \"weight (female, lbs)\": [\n                    \"205-455\",\n                    \"330-550\",\n                    \"110-275\",\n                    \"90-300\",\n                    \"45-90\",\n                    \"120-210\",\n                    \"140-180\",\n                    \"155-220\",\n                ],\n            }\n        )\n\n        # | bear                | genus      | weight (male, lbs)   | weight (female, lbs)   |\n        # |:--------------------|:-----------|:---------------------|:-----------------------|\n        # | Brown bear          | Ursus      | 300-860              | 205-455                |\n        # | Polar bear          | Ursus      | 880-1320             | 330-550                |\n        # | Asian black bear    | Ursus      | 220-440              | 110-275                |\n        # | American black bear | Ursus      | 125-500              | 90-300                 |\n        # | Sun bear            | Helarctos  | 60-150               | 45-90                  |\n        # | Sloth bear          | Melursus   | 175-310              | 120-210                |\n        # | Spectacled bear     | Tremarctos | 220-340              | 140-180                |\n        # | Giant panda         | Ailuropoda | 190-275              | 155-220                |\n\n        (\n            df.rename({\"weight (male, lbs)\": \"male\", \"weight (female, lbs)\": \"female\"})\n            .gather([\"male\", \"female\"], into=(\"sex\", \"weight\"))\n            .split(\"weight\", into=[\"min\", \"max\"], sep=\"-\")\n            .gather([\"min\", \"max\"], into=(\"stat\", \"weight\"))\n            .mutate({\"weight\": lambda row: float(row[\"weight\"])})\n            .group([\"genus\", \"sex\"])\n            .rollup({\"weight\": (\"weight\", rf.stat.mean)})\n            .spread(\"sex\", using=\"weight\")\n            .mutate({\"dimorphism\": lambda row: round(row[\"male\"] / row[\"female\"], 2)})\n            .drop([\"male\", \"female\"])\n            .sort(\"dimorphism\", descending=True)\n        )\n\n        # | genus      |   dimorphism |\n        # |:-----------|-------------:|\n        # | Ursus      |         2.01 |\n        # | Tremarctos |         1.75 |\n        # | Helarctos  |         1.56 |\n        # | Melursus   |         1.47 |\n        # | Ailuropoda |         1.24 |\n", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_readme.py_45-95"}
{"title": "maxhumber_redframes-tests-test_readme.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_readme.py"], "line_no": 80, "start_line_no": 55, "end_line_no": 105, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "                    \"120-210\",\n                    \"140-180\",\n                    \"155-220\",\n                ],\n            }\n        )\n\n        # | bear                | genus      | weight (male, lbs)   | weight (female, lbs)   |\n        # |:--------------------|:-----------|:---------------------|:-----------------------|\n        # | Brown bear          | Ursus      | 300-860              | 205-455                |\n        # | Polar bear          | Ursus      | 880-1320             | 330-550                |\n        # | Asian black bear    | Ursus      | 220-440              | 110-275                |\n        # | American black bear | Ursus      | 125-500              | 90-300                 |\n        # | Sun bear            | Helarctos  | 60-150               | 45-90                  |\n        # | Sloth bear          | Melursus   | 175-310              | 120-210                |\n        # | Spectacled bear     | Tremarctos | 220-340              | 140-180                |\n        # | Giant panda         | Ailuropoda | 190-275              | 155-220                |\n\n        (\n            df.rename({\"weight (male, lbs)\": \"male\", \"weight (female, lbs)\": \"female\"})\n            .gather([\"male\", \"female\"], into=(\"sex\", \"weight\"))\n            .split(\"weight\", into=[\"min\", \"max\"], sep=\"-\")\n            .gather([\"min\", \"max\"], into=(\"stat\", \"weight\"))\n            .mutate({\"weight\": lambda row: float(row[\"weight\"])})\n            .group([\"genus\", \"sex\"])\n            .rollup({\"weight\": (\"weight\", rf.stat.mean)})\n            .spread(\"sex\", using=\"weight\")\n            .mutate({\"dimorphism\": lambda row: round(row[\"male\"] / row[\"female\"], 2)})\n            .drop([\"male\", \"female\"])\n            .sort(\"dimorphism\", descending=True)\n        )\n\n        # | genus      |   dimorphism |\n        # |:-----------|-------------:|\n        # | Ursus      |         2.01 |\n        # | Tremarctos |         1.75 |\n        # | Helarctos  |         1.56 |\n        # | Melursus   |         1.47 |\n        # | Ailuropoda |         1.24 |\n\n        self.assertTrue(True)\n\n    def test_pandas_comparison(self):\n        import pandas as pd\n\n        df = pd.DataFrame(\n            {\n                \"bear\": [\n                    \"Brown bear\",\n                    \"Polar bear\",", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_readme.py_55-105"}
{"title": "maxhumber_redframes-tests-test_readme.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_readme.py"], "line_no": 90, "start_line_no": 65, "end_line_no": 115, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        # | Polar bear          | Ursus      | 880-1320             | 330-550                |\n        # | Asian black bear    | Ursus      | 220-440              | 110-275                |\n        # | American black bear | Ursus      | 125-500              | 90-300                 |\n        # | Sun bear            | Helarctos  | 60-150               | 45-90                  |\n        # | Sloth bear          | Melursus   | 175-310              | 120-210                |\n        # | Spectacled bear     | Tremarctos | 220-340              | 140-180                |\n        # | Giant panda         | Ailuropoda | 190-275              | 155-220                |\n\n        (\n            df.rename({\"weight (male, lbs)\": \"male\", \"weight (female, lbs)\": \"female\"})\n            .gather([\"male\", \"female\"], into=(\"sex\", \"weight\"))\n            .split(\"weight\", into=[\"min\", \"max\"], sep=\"-\")\n            .gather([\"min\", \"max\"], into=(\"stat\", \"weight\"))\n            .mutate({\"weight\": lambda row: float(row[\"weight\"])})\n            .group([\"genus\", \"sex\"])\n            .rollup({\"weight\": (\"weight\", rf.stat.mean)})\n            .spread(\"sex\", using=\"weight\")\n            .mutate({\"dimorphism\": lambda row: round(row[\"male\"] / row[\"female\"], 2)})\n            .drop([\"male\", \"female\"])\n            .sort(\"dimorphism\", descending=True)\n        )\n\n        # | genus      |   dimorphism |\n        # |:-----------|-------------:|\n        # | Ursus      |         2.01 |\n        # | Tremarctos |         1.75 |\n        # | Helarctos  |         1.56 |\n        # | Melursus   |         1.47 |\n        # | Ailuropoda |         1.24 |\n\n        self.assertTrue(True)\n\n    def test_pandas_comparison(self):\n        import pandas as pd\n\n        df = pd.DataFrame(\n            {\n                \"bear\": [\n                    \"Brown bear\",\n                    \"Polar bear\",\n                    \"Asian black bear\",\n                    \"American black bear\",\n                    \"Sun bear\",\n                    \"Sloth bear\",\n                    \"Spectacled bear\",\n                    \"Giant panda\",\n                ],\n                \"genus\": [\n                    \"Ursus\",\n                    \"Ursus\",", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_readme.py_65-115"}
{"title": "maxhumber_redframes-tests-test_readme.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_readme.py"], "line_no": 100, "start_line_no": 75, "end_line_no": 125, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "            .gather([\"male\", \"female\"], into=(\"sex\", \"weight\"))\n            .split(\"weight\", into=[\"min\", \"max\"], sep=\"-\")\n            .gather([\"min\", \"max\"], into=(\"stat\", \"weight\"))\n            .mutate({\"weight\": lambda row: float(row[\"weight\"])})\n            .group([\"genus\", \"sex\"])\n            .rollup({\"weight\": (\"weight\", rf.stat.mean)})\n            .spread(\"sex\", using=\"weight\")\n            .mutate({\"dimorphism\": lambda row: round(row[\"male\"] / row[\"female\"], 2)})\n            .drop([\"male\", \"female\"])\n            .sort(\"dimorphism\", descending=True)\n        )\n\n        # | genus      |   dimorphism |\n        # |:-----------|-------------:|\n        # | Ursus      |         2.01 |\n        # | Tremarctos |         1.75 |\n        # | Helarctos  |         1.56 |\n        # | Melursus   |         1.47 |\n        # | Ailuropoda |         1.24 |\n\n        self.assertTrue(True)\n\n    def test_pandas_comparison(self):\n        import pandas as pd\n\n        df = pd.DataFrame(\n            {\n                \"bear\": [\n                    \"Brown bear\",\n                    \"Polar bear\",\n                    \"Asian black bear\",\n                    \"American black bear\",\n                    \"Sun bear\",\n                    \"Sloth bear\",\n                    \"Spectacled bear\",\n                    \"Giant panda\",\n                ],\n                \"genus\": [\n                    \"Ursus\",\n                    \"Ursus\",\n                    \"Ursus\",\n                    \"Ursus\",\n                    \"Helarctos\",\n                    \"Melursus\",\n                    \"Tremarctos\",\n                    \"Ailuropoda\",\n                ],\n                \"weight (male, lbs)\": [\n                    \"300-860\",\n                    \"880-1320\",", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_readme.py_75-125"}
{"title": "maxhumber_redframes-tests-test_readme.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_readme.py"], "line_no": 110, "start_line_no": 85, "end_line_no": 135, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        )\n\n        # | genus      |   dimorphism |\n        # |:-----------|-------------:|\n        # | Ursus      |         2.01 |\n        # | Tremarctos |         1.75 |\n        # | Helarctos  |         1.56 |\n        # | Melursus   |         1.47 |\n        # | Ailuropoda |         1.24 |\n\n        self.assertTrue(True)\n\n    def test_pandas_comparison(self):\n        import pandas as pd\n\n        df = pd.DataFrame(\n            {\n                \"bear\": [\n                    \"Brown bear\",\n                    \"Polar bear\",\n                    \"Asian black bear\",\n                    \"American black bear\",\n                    \"Sun bear\",\n                    \"Sloth bear\",\n                    \"Spectacled bear\",\n                    \"Giant panda\",\n                ],\n                \"genus\": [\n                    \"Ursus\",\n                    \"Ursus\",\n                    \"Ursus\",\n                    \"Ursus\",\n                    \"Helarctos\",\n                    \"Melursus\",\n                    \"Tremarctos\",\n                    \"Ailuropoda\",\n                ],\n                \"weight (male, lbs)\": [\n                    \"300-860\",\n                    \"880-1320\",\n                    \"220-440\",\n                    \"125-500\",\n                    \"60-150\",\n                    \"175-310\",\n                    \"220-340\",\n                    \"190-275\",\n                ],\n                \"weight (female, lbs)\": [\n                    \"205-455\",\n                    \"330-550\",", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_readme.py_85-135"}
{"title": "maxhumber_redframes-tests-test_readme.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_readme.py"], "line_no": 120, "start_line_no": 95, "end_line_no": 145, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        self.assertTrue(True)\n\n    def test_pandas_comparison(self):\n        import pandas as pd\n\n        df = pd.DataFrame(\n            {\n                \"bear\": [\n                    \"Brown bear\",\n                    \"Polar bear\",\n                    \"Asian black bear\",\n                    \"American black bear\",\n                    \"Sun bear\",\n                    \"Sloth bear\",\n                    \"Spectacled bear\",\n                    \"Giant panda\",\n                ],\n                \"genus\": [\n                    \"Ursus\",\n                    \"Ursus\",\n                    \"Ursus\",\n                    \"Ursus\",\n                    \"Helarctos\",\n                    \"Melursus\",\n                    \"Tremarctos\",\n                    \"Ailuropoda\",\n                ],\n                \"weight (male, lbs)\": [\n                    \"300-860\",\n                    \"880-1320\",\n                    \"220-440\",\n                    \"125-500\",\n                    \"60-150\",\n                    \"175-310\",\n                    \"220-340\",\n                    \"190-275\",\n                ],\n                \"weight (female, lbs)\": [\n                    \"205-455\",\n                    \"330-550\",\n                    \"110-275\",\n                    \"90-300\",\n                    \"45-90\",\n                    \"120-210\",\n                    \"140-180\",\n                    \"155-220\",\n                ],\n            }\n        )\n", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_readme.py_95-145"}
{"title": "maxhumber_redframes-tests-test_readme.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_readme.py"], "line_no": 130, "start_line_no": 105, "end_line_no": 155, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "                    \"Asian black bear\",\n                    \"American black bear\",\n                    \"Sun bear\",\n                    \"Sloth bear\",\n                    \"Spectacled bear\",\n                    \"Giant panda\",\n                ],\n                \"genus\": [\n                    \"Ursus\",\n                    \"Ursus\",\n                    \"Ursus\",\n                    \"Ursus\",\n                    \"Helarctos\",\n                    \"Melursus\",\n                    \"Tremarctos\",\n                    \"Ailuropoda\",\n                ],\n                \"weight (male, lbs)\": [\n                    \"300-860\",\n                    \"880-1320\",\n                    \"220-440\",\n                    \"125-500\",\n                    \"60-150\",\n                    \"175-310\",\n                    \"220-340\",\n                    \"190-275\",\n                ],\n                \"weight (female, lbs)\": [\n                    \"205-455\",\n                    \"330-550\",\n                    \"110-275\",\n                    \"90-300\",\n                    \"45-90\",\n                    \"120-210\",\n                    \"140-180\",\n                    \"155-220\",\n                ],\n            }\n        )\n\n        df = df.rename(\n            columns={\"weight (male, lbs)\": \"male\", \"weight (female, lbs)\": \"female\"}\n        )\n        df = pd.melt(\n            df,\n            id_vars=[\"bear\", \"genus\"],\n            value_vars=[\"male\", \"female\"],\n            var_name=\"sex\",\n            value_name=\"weight\",\n        )", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_readme.py_105-155"}
{"title": "maxhumber_redframes-tests-test_readme.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_readme.py"], "line_no": 140, "start_line_no": 115, "end_line_no": 165, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "                    \"Ursus\",\n                    \"Ursus\",\n                    \"Helarctos\",\n                    \"Melursus\",\n                    \"Tremarctos\",\n                    \"Ailuropoda\",\n                ],\n                \"weight (male, lbs)\": [\n                    \"300-860\",\n                    \"880-1320\",\n                    \"220-440\",\n                    \"125-500\",\n                    \"60-150\",\n                    \"175-310\",\n                    \"220-340\",\n                    \"190-275\",\n                ],\n                \"weight (female, lbs)\": [\n                    \"205-455\",\n                    \"330-550\",\n                    \"110-275\",\n                    \"90-300\",\n                    \"45-90\",\n                    \"120-210\",\n                    \"140-180\",\n                    \"155-220\",\n                ],\n            }\n        )\n\n        df = df.rename(\n            columns={\"weight (male, lbs)\": \"male\", \"weight (female, lbs)\": \"female\"}\n        )\n        df = pd.melt(\n            df,\n            id_vars=[\"bear\", \"genus\"],\n            value_vars=[\"male\", \"female\"],\n            var_name=\"sex\",\n            value_name=\"weight\",\n        )\n        df[[\"min\", \"max\"]] = df[\"weight\"].str.split(\"-\", expand=True)\n        df = df.drop(\"weight\", axis=1)\n        df = pd.melt(\n            df,\n            id_vars=[\"bear\", \"genus\", \"sex\"],\n            value_vars=[\"min\", \"max\"],\n            var_name=\"stat\",\n            value_name=\"weight\",\n        )\n        df[\"weight\"] = df[\"weight\"].astype(\"float\")", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_readme.py_115-165"}
{"title": "maxhumber_redframes-tests-test_readme.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_readme.py"], "line_no": 150, "start_line_no": 125, "end_line_no": 175, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "                    \"220-440\",\n                    \"125-500\",\n                    \"60-150\",\n                    \"175-310\",\n                    \"220-340\",\n                    \"190-275\",\n                ],\n                \"weight (female, lbs)\": [\n                    \"205-455\",\n                    \"330-550\",\n                    \"110-275\",\n                    \"90-300\",\n                    \"45-90\",\n                    \"120-210\",\n                    \"140-180\",\n                    \"155-220\",\n                ],\n            }\n        )\n\n        df = df.rename(\n            columns={\"weight (male, lbs)\": \"male\", \"weight (female, lbs)\": \"female\"}\n        )\n        df = pd.melt(\n            df,\n            id_vars=[\"bear\", \"genus\"],\n            value_vars=[\"male\", \"female\"],\n            var_name=\"sex\",\n            value_name=\"weight\",\n        )\n        df[[\"min\", \"max\"]] = df[\"weight\"].str.split(\"-\", expand=True)\n        df = df.drop(\"weight\", axis=1)\n        df = pd.melt(\n            df,\n            id_vars=[\"bear\", \"genus\", \"sex\"],\n            value_vars=[\"min\", \"max\"],\n            var_name=\"stat\",\n            value_name=\"weight\",\n        )\n        df[\"weight\"] = df[\"weight\"].astype(\"float\")\n        df = df.groupby([\"genus\", \"sex\"])[\"weight\"].mean()\n        df = df.reset_index()\n        df = pd.pivot_table(df, index=[\"genus\"], columns=[\"sex\"], values=\"weight\")\n        df = df.reset_index()\n        df = df.rename_axis(None, axis=1)\n        df[\"dimorphism\"] = round(df[\"male\"] / df[\"female\"], 2)\n        df = df.drop([\"female\", \"male\"], axis=1)\n        df = df.sort_values(\"dimorphism\", ascending=False)\n        df = df.reset_index(drop=True)\n", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_readme.py_125-175"}
{"title": "maxhumber_redframes-tests-test_readme.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_readme.py"], "line_no": 160, "start_line_no": 135, "end_line_no": 185, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "                    \"110-275\",\n                    \"90-300\",\n                    \"45-90\",\n                    \"120-210\",\n                    \"140-180\",\n                    \"155-220\",\n                ],\n            }\n        )\n\n        df = df.rename(\n            columns={\"weight (male, lbs)\": \"male\", \"weight (female, lbs)\": \"female\"}\n        )\n        df = pd.melt(\n            df,\n            id_vars=[\"bear\", \"genus\"],\n            value_vars=[\"male\", \"female\"],\n            var_name=\"sex\",\n            value_name=\"weight\",\n        )\n        df[[\"min\", \"max\"]] = df[\"weight\"].str.split(\"-\", expand=True)\n        df = df.drop(\"weight\", axis=1)\n        df = pd.melt(\n            df,\n            id_vars=[\"bear\", \"genus\", \"sex\"],\n            value_vars=[\"min\", \"max\"],\n            var_name=\"stat\",\n            value_name=\"weight\",\n        )\n        df[\"weight\"] = df[\"weight\"].astype(\"float\")\n        df = df.groupby([\"genus\", \"sex\"])[\"weight\"].mean()\n        df = df.reset_index()\n        df = pd.pivot_table(df, index=[\"genus\"], columns=[\"sex\"], values=\"weight\")\n        df = df.reset_index()\n        df = df.rename_axis(None, axis=1)\n        df[\"dimorphism\"] = round(df[\"male\"] / df[\"female\"], 2)\n        df = df.drop([\"female\", \"male\"], axis=1)\n        df = df.sort_values(\"dimorphism\", ascending=False)\n        df = df.reset_index(drop=True)\n\n        self.assertTrue(True)\n\n    def test_io(self):\n        import redframes as rf\n\n        df = rf.DataFrame({\"foo\": [1, 2], \"bar\": [\"A\", \"B\"]})\n\n        # save .csv\n        rf.save(df, self.path)\n", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_readme.py_135-185"}
{"title": "maxhumber_redframes-tests-test_readme.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_readme.py"], "line_no": 170, "start_line_no": 145, "end_line_no": 195, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        df = df.rename(\n            columns={\"weight (male, lbs)\": \"male\", \"weight (female, lbs)\": \"female\"}\n        )\n        df = pd.melt(\n            df,\n            id_vars=[\"bear\", \"genus\"],\n            value_vars=[\"male\", \"female\"],\n            var_name=\"sex\",\n            value_name=\"weight\",\n        )\n        df[[\"min\", \"max\"]] = df[\"weight\"].str.split(\"-\", expand=True)\n        df = df.drop(\"weight\", axis=1)\n        df = pd.melt(\n            df,\n            id_vars=[\"bear\", \"genus\", \"sex\"],\n            value_vars=[\"min\", \"max\"],\n            var_name=\"stat\",\n            value_name=\"weight\",\n        )\n        df[\"weight\"] = df[\"weight\"].astype(\"float\")\n        df = df.groupby([\"genus\", \"sex\"])[\"weight\"].mean()\n        df = df.reset_index()\n        df = pd.pivot_table(df, index=[\"genus\"], columns=[\"sex\"], values=\"weight\")\n        df = df.reset_index()\n        df = df.rename_axis(None, axis=1)\n        df[\"dimorphism\"] = round(df[\"male\"] / df[\"female\"], 2)\n        df = df.drop([\"female\", \"male\"], axis=1)\n        df = df.sort_values(\"dimorphism\", ascending=False)\n        df = df.reset_index(drop=True)\n\n        self.assertTrue(True)\n\n    def test_io(self):\n        import redframes as rf\n\n        df = rf.DataFrame({\"foo\": [1, 2], \"bar\": [\"A\", \"B\"]})\n\n        # save .csv\n        rf.save(df, self.path)\n\n        # load .csv\n        df = rf.load(self.path)\n\n        # convert redframes \u2192 pandas\n        pandas_df = rf.unwrap(df)\n\n        # convert pandas \u2192 redframes\n        df = rf.wrap(pandas_df)\n\n        self.assertTrue(True)", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_readme.py_145-195"}
{"title": "maxhumber_redframes-tests-test_readme.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_readme.py"], "line_no": 180, "start_line_no": 155, "end_line_no": 205, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        df[[\"min\", \"max\"]] = df[\"weight\"].str.split(\"-\", expand=True)\n        df = df.drop(\"weight\", axis=1)\n        df = pd.melt(\n            df,\n            id_vars=[\"bear\", \"genus\", \"sex\"],\n            value_vars=[\"min\", \"max\"],\n            var_name=\"stat\",\n            value_name=\"weight\",\n        )\n        df[\"weight\"] = df[\"weight\"].astype(\"float\")\n        df = df.groupby([\"genus\", \"sex\"])[\"weight\"].mean()\n        df = df.reset_index()\n        df = pd.pivot_table(df, index=[\"genus\"], columns=[\"sex\"], values=\"weight\")\n        df = df.reset_index()\n        df = df.rename_axis(None, axis=1)\n        df[\"dimorphism\"] = round(df[\"male\"] / df[\"female\"], 2)\n        df = df.drop([\"female\", \"male\"], axis=1)\n        df = df.sort_values(\"dimorphism\", ascending=False)\n        df = df.reset_index(drop=True)\n\n        self.assertTrue(True)\n\n    def test_io(self):\n        import redframes as rf\n\n        df = rf.DataFrame({\"foo\": [1, 2], \"bar\": [\"A\", \"B\"]})\n\n        # save .csv\n        rf.save(df, self.path)\n\n        # load .csv\n        df = rf.load(self.path)\n\n        # convert redframes \u2192 pandas\n        pandas_df = rf.unwrap(df)\n\n        # convert pandas \u2192 redframes\n        df = rf.wrap(pandas_df)\n\n        self.assertTrue(True)\n\n    def test_properties(self):\n        import redframes as rf\n\n        df = rf.DataFrame({\"genus\": [1]})\n\n        df[\"genus\"]\n        # ['Ursus', 'Ursus', 'Ursus', 'Ursus', 'Helarctos', 'Melursus', 'Tremarctos', 'Ailuropoda']\n\n        df.columns", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_readme.py_155-205"}
{"title": "maxhumber_redframes-tests-test_readme.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_readme.py"], "line_no": 190, "start_line_no": 165, "end_line_no": 215, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        df = df.groupby([\"genus\", \"sex\"])[\"weight\"].mean()\n        df = df.reset_index()\n        df = pd.pivot_table(df, index=[\"genus\"], columns=[\"sex\"], values=\"weight\")\n        df = df.reset_index()\n        df = df.rename_axis(None, axis=1)\n        df[\"dimorphism\"] = round(df[\"male\"] / df[\"female\"], 2)\n        df = df.drop([\"female\", \"male\"], axis=1)\n        df = df.sort_values(\"dimorphism\", ascending=False)\n        df = df.reset_index(drop=True)\n\n        self.assertTrue(True)\n\n    def test_io(self):\n        import redframes as rf\n\n        df = rf.DataFrame({\"foo\": [1, 2], \"bar\": [\"A\", \"B\"]})\n\n        # save .csv\n        rf.save(df, self.path)\n\n        # load .csv\n        df = rf.load(self.path)\n\n        # convert redframes \u2192 pandas\n        pandas_df = rf.unwrap(df)\n\n        # convert pandas \u2192 redframes\n        df = rf.wrap(pandas_df)\n\n        self.assertTrue(True)\n\n    def test_properties(self):\n        import redframes as rf\n\n        df = rf.DataFrame({\"genus\": [1]})\n\n        df[\"genus\"]\n        # ['Ursus', 'Ursus', 'Ursus', 'Ursus', 'Helarctos', 'Melursus', 'Tremarctos', 'Ailuropoda']\n\n        df.columns\n        # ['bear', 'genus', 'weight (male, lbs)', 'weight (female, lbs)']\n\n        df.dimensions\n        # {'rows': 8, 'columns': 4}\n\n        df.empty\n        # False\n\n        df.memory\n        # '2 KB'", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_readme.py_165-215"}
{"title": "maxhumber_redframes-tests-test_readme.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_readme.py"], "line_no": 200, "start_line_no": 175, "end_line_no": 225, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        self.assertTrue(True)\n\n    def test_io(self):\n        import redframes as rf\n\n        df = rf.DataFrame({\"foo\": [1, 2], \"bar\": [\"A\", \"B\"]})\n\n        # save .csv\n        rf.save(df, self.path)\n\n        # load .csv\n        df = rf.load(self.path)\n\n        # convert redframes \u2192 pandas\n        pandas_df = rf.unwrap(df)\n\n        # convert pandas \u2192 redframes\n        df = rf.wrap(pandas_df)\n\n        self.assertTrue(True)\n\n    def test_properties(self):\n        import redframes as rf\n\n        df = rf.DataFrame({\"genus\": [1]})\n\n        df[\"genus\"]\n        # ['Ursus', 'Ursus', 'Ursus', 'Ursus', 'Helarctos', 'Melursus', 'Tremarctos', 'Ailuropoda']\n\n        df.columns\n        # ['bear', 'genus', 'weight (male, lbs)', 'weight (female, lbs)']\n\n        df.dimensions\n        # {'rows': 8, 'columns': 4}\n\n        df.empty\n        # False\n\n        df.memory\n        # '2 KB'\n\n        df.types\n        # {'bear': object, 'genus': object, 'weight (male, lbs)': object, 'weight (female, lbs)': object}\n\n        self.assertTrue(True)\n\n    def test_matplotlib(self):\n        import matplotlib.pyplot as plt\n\n        import redframes as rf", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_readme.py_175-225"}
{"title": "maxhumber_redframes-tests-test_readme.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_readme.py"], "line_no": 210, "start_line_no": 185, "end_line_no": 235, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        # load .csv\n        df = rf.load(self.path)\n\n        # convert redframes \u2192 pandas\n        pandas_df = rf.unwrap(df)\n\n        # convert pandas \u2192 redframes\n        df = rf.wrap(pandas_df)\n\n        self.assertTrue(True)\n\n    def test_properties(self):\n        import redframes as rf\n\n        df = rf.DataFrame({\"genus\": [1]})\n\n        df[\"genus\"]\n        # ['Ursus', 'Ursus', 'Ursus', 'Ursus', 'Helarctos', 'Melursus', 'Tremarctos', 'Ailuropoda']\n\n        df.columns\n        # ['bear', 'genus', 'weight (male, lbs)', 'weight (female, lbs)']\n\n        df.dimensions\n        # {'rows': 8, 'columns': 4}\n\n        df.empty\n        # False\n\n        df.memory\n        # '2 KB'\n\n        df.types\n        # {'bear': object, 'genus': object, 'weight (male, lbs)': object, 'weight (female, lbs)': object}\n\n        self.assertTrue(True)\n\n    def test_matplotlib(self):\n        import matplotlib.pyplot as plt\n\n        import redframes as rf\n\n        football = rf.DataFrame(\n            {\n                \"position\": [\"TE\", \"K\", \"RB\", \"WR\", \"QB\"],\n                \"avp\": [116.98, 131.15, 180, 222.22, 272.91],\n            }\n        )\n\n        df = football.mutate(\n            {\"color\": lambda row: row[\"position\"] in [\"WR\", \"RB\"]}", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_readme.py_185-235"}
{"title": "maxhumber_redframes-tests-test_readme.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_readme.py"], "line_no": 220, "start_line_no": 195, "end_line_no": 245, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "\n    def test_properties(self):\n        import redframes as rf\n\n        df = rf.DataFrame({\"genus\": [1]})\n\n        df[\"genus\"]\n        # ['Ursus', 'Ursus', 'Ursus', 'Ursus', 'Helarctos', 'Melursus', 'Tremarctos', 'Ailuropoda']\n\n        df.columns\n        # ['bear', 'genus', 'weight (male, lbs)', 'weight (female, lbs)']\n\n        df.dimensions\n        # {'rows': 8, 'columns': 4}\n\n        df.empty\n        # False\n\n        df.memory\n        # '2 KB'\n\n        df.types\n        # {'bear': object, 'genus': object, 'weight (male, lbs)': object, 'weight (female, lbs)': object}\n\n        self.assertTrue(True)\n\n    def test_matplotlib(self):\n        import matplotlib.pyplot as plt\n\n        import redframes as rf\n\n        football = rf.DataFrame(\n            {\n                \"position\": [\"TE\", \"K\", \"RB\", \"WR\", \"QB\"],\n                \"avp\": [116.98, 131.15, 180, 222.22, 272.91],\n            }\n        )\n\n        df = football.mutate(\n            {\"color\": lambda row: row[\"position\"] in [\"WR\", \"RB\"]}\n        ).replace({\"color\": {False: \"orange\", True: \"red\"}})\n\n        plt.barh(df[\"position\"], df[\"avp\"], color=df[\"color\"])\n\n        self.assertTrue(True)\n\n    def test_sklearn(self):\n        from sklearn.linear_model import LinearRegression\n        from sklearn.model_selection import train_test_split\n", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_readme.py_195-245"}
{"title": "maxhumber_redframes-tests-test_readme.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_readme.py"], "line_no": 230, "start_line_no": 205, "end_line_no": 255, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        # ['bear', 'genus', 'weight (male, lbs)', 'weight (female, lbs)']\n\n        df.dimensions\n        # {'rows': 8, 'columns': 4}\n\n        df.empty\n        # False\n\n        df.memory\n        # '2 KB'\n\n        df.types\n        # {'bear': object, 'genus': object, 'weight (male, lbs)': object, 'weight (female, lbs)': object}\n\n        self.assertTrue(True)\n\n    def test_matplotlib(self):\n        import matplotlib.pyplot as plt\n\n        import redframes as rf\n\n        football = rf.DataFrame(\n            {\n                \"position\": [\"TE\", \"K\", \"RB\", \"WR\", \"QB\"],\n                \"avp\": [116.98, 131.15, 180, 222.22, 272.91],\n            }\n        )\n\n        df = football.mutate(\n            {\"color\": lambda row: row[\"position\"] in [\"WR\", \"RB\"]}\n        ).replace({\"color\": {False: \"orange\", True: \"red\"}})\n\n        plt.barh(df[\"position\"], df[\"avp\"], color=df[\"color\"])\n\n        self.assertTrue(True)\n\n    def test_sklearn(self):\n        from sklearn.linear_model import LinearRegression\n        from sklearn.model_selection import train_test_split\n\n        import redframes as rf\n\n        df = rf.DataFrame(\n            {\n                \"touchdowns\": [15, 19, 5, 7, 9, 10, 12, 22, 16, 10],\n                \"age\": [21, 22, 21, 24, 26, 28, 30, 35, 28, 21],\n                \"mvp\": [1, 1, 0, 0, 0, 0, 0, 1, 0, 0],\n            }\n        )\n", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_readme.py_205-255"}
{"title": "maxhumber_redframes-tests-test_readme.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_readme.py"], "line_no": 240, "start_line_no": 215, "end_line_no": 265, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "\n        df.types\n        # {'bear': object, 'genus': object, 'weight (male, lbs)': object, 'weight (female, lbs)': object}\n\n        self.assertTrue(True)\n\n    def test_matplotlib(self):\n        import matplotlib.pyplot as plt\n\n        import redframes as rf\n\n        football = rf.DataFrame(\n            {\n                \"position\": [\"TE\", \"K\", \"RB\", \"WR\", \"QB\"],\n                \"avp\": [116.98, 131.15, 180, 222.22, 272.91],\n            }\n        )\n\n        df = football.mutate(\n            {\"color\": lambda row: row[\"position\"] in [\"WR\", \"RB\"]}\n        ).replace({\"color\": {False: \"orange\", True: \"red\"}})\n\n        plt.barh(df[\"position\"], df[\"avp\"], color=df[\"color\"])\n\n        self.assertTrue(True)\n\n    def test_sklearn(self):\n        from sklearn.linear_model import LinearRegression\n        from sklearn.model_selection import train_test_split\n\n        import redframes as rf\n\n        df = rf.DataFrame(\n            {\n                \"touchdowns\": [15, 19, 5, 7, 9, 10, 12, 22, 16, 10],\n                \"age\": [21, 22, 21, 24, 26, 28, 30, 35, 28, 21],\n                \"mvp\": [1, 1, 0, 0, 0, 0, 0, 1, 0, 0],\n            }\n        )\n\n        target = \"touchdowns\"\n        y = df[target]\n        X = df.drop(target)\n        X_train, X_test, y_train, y_test = train_test_split(\n            X, y, test_size=0.3, random_state=1\n        )\n\n        model = LinearRegression()\n        model.fit(X_train, y_train)\n        model.score(X_test, y_test)", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_readme.py_215-265"}
{"title": "maxhumber_redframes-tests-test_readme.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_readme.py"], "line_no": 250, "start_line_no": 225, "end_line_no": 275, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "\n        football = rf.DataFrame(\n            {\n                \"position\": [\"TE\", \"K\", \"RB\", \"WR\", \"QB\"],\n                \"avp\": [116.98, 131.15, 180, 222.22, 272.91],\n            }\n        )\n\n        df = football.mutate(\n            {\"color\": lambda row: row[\"position\"] in [\"WR\", \"RB\"]}\n        ).replace({\"color\": {False: \"orange\", True: \"red\"}})\n\n        plt.barh(df[\"position\"], df[\"avp\"], color=df[\"color\"])\n\n        self.assertTrue(True)\n\n    def test_sklearn(self):\n        from sklearn.linear_model import LinearRegression\n        from sklearn.model_selection import train_test_split\n\n        import redframes as rf\n\n        df = rf.DataFrame(\n            {\n                \"touchdowns\": [15, 19, 5, 7, 9, 10, 12, 22, 16, 10],\n                \"age\": [21, 22, 21, 24, 26, 28, 30, 35, 28, 21],\n                \"mvp\": [1, 1, 0, 0, 0, 0, 0, 1, 0, 0],\n            }\n        )\n\n        target = \"touchdowns\"\n        y = df[target]\n        X = df.drop(target)\n        X_train, X_test, y_train, y_test = train_test_split(\n            X, y, test_size=0.3, random_state=1\n        )\n\n        model = LinearRegression()\n        model.fit(X_train, y_train)\n        model.score(X_test, y_test)\n        # 0.5083194901655527\n\n        # print(X_train.take(1))\n        # rf.DataFrame({'age': [21], 'mvp': [0]})\n\n        X_new = rf.DataFrame({\"age\": [22], \"mvp\": [1]})\n        model.predict(X_new)\n        # array([19.])\n\n        self.assertTrue(True)", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_readme.py_225-275"}
{"title": "maxhumber_redframes-tests-test_readme.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_readme.py"], "line_no": 260, "start_line_no": 235, "end_line_no": 275, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        ).replace({\"color\": {False: \"orange\", True: \"red\"}})\n\n        plt.barh(df[\"position\"], df[\"avp\"], color=df[\"color\"])\n\n        self.assertTrue(True)\n\n    def test_sklearn(self):\n        from sklearn.linear_model import LinearRegression\n        from sklearn.model_selection import train_test_split\n\n        import redframes as rf\n\n        df = rf.DataFrame(\n            {\n                \"touchdowns\": [15, 19, 5, 7, 9, 10, 12, 22, 16, 10],\n                \"age\": [21, 22, 21, 24, 26, 28, 30, 35, 28, 21],\n                \"mvp\": [1, 1, 0, 0, 0, 0, 0, 1, 0, 0],\n            }\n        )\n\n        target = \"touchdowns\"\n        y = df[target]\n        X = df.drop(target)\n        X_train, X_test, y_train, y_test = train_test_split(\n            X, y, test_size=0.3, random_state=1\n        )\n\n        model = LinearRegression()\n        model.fit(X_train, y_train)\n        model.score(X_test, y_test)\n        # 0.5083194901655527\n\n        # print(X_train.take(1))\n        # rf.DataFrame({'age': [21], 'mvp': [0]})\n\n        X_new = rf.DataFrame({\"age\": [22], \"mvp\": [1]})\n        model.predict(X_new)\n        # array([19.])\n\n        self.assertTrue(True)", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_readme.py_235-275"}
{"title": "maxhumber_redframes-tests-test_readme.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_readme.py"], "line_no": 270, "start_line_no": 245, "end_line_no": 275, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        import redframes as rf\n\n        df = rf.DataFrame(\n            {\n                \"touchdowns\": [15, 19, 5, 7, 9, 10, 12, 22, 16, 10],\n                \"age\": [21, 22, 21, 24, 26, 28, 30, 35, 28, 21],\n                \"mvp\": [1, 1, 0, 0, 0, 0, 0, 1, 0, 0],\n            }\n        )\n\n        target = \"touchdowns\"\n        y = df[target]\n        X = df.drop(target)\n        X_train, X_test, y_train, y_test = train_test_split(\n            X, y, test_size=0.3, random_state=1\n        )\n\n        model = LinearRegression()\n        model.fit(X_train, y_train)\n        model.score(X_test, y_test)\n        # 0.5083194901655527\n\n        # print(X_train.take(1))\n        # rf.DataFrame({'age': [21], 'mvp': [0]})\n\n        X_new = rf.DataFrame({\"age\": [22], \"mvp\": [1]})\n        model.predict(X_new)\n        # array([19.])\n\n        self.assertTrue(True)", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_readme.py_245-275"}
{"title": "maxhumber_redframes-tests-test_side_effects.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_side_effects.py"], "line_no": 0, "start_line_no": 0, "end_line_no": 25, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "import unittest\n\nimport redframes as rf\n\n\nclass TestSideEffects(unittest.TestCase):\n    def setUp(self):\n        self.df = rf.DataFrame(\n            {\n                \"foo\": range(10),\n                \"bar\": [1, 3.2, 4.5, 2, -1, 30, None, 1.1, 1.1, 9],\n                \"baz\": [\"A\", \"A\", None, \"B\", \"B\", \"A\", \"B\", \"C\", \"C\", \"A\"],\n                \"jaz\": [\n                    \"1::1\",\n                    \"2::2\",\n                    \"3:3\",\n                    \"4::4\",\n                    \"5::5\",\n                    \"6::7\",\n                    \"7::8\",\n                    \"8::9\",\n                    \"9::0\",\n                    \"0::-1\",\n                ],\n                \"raz\": [1, 2, 3, None, None, None, 9, 9, None, None],", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_side_effects.py_0-25"}
{"title": "maxhumber_redframes-tests-test_side_effects.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_side_effects.py"], "line_no": 10, "start_line_no": 0, "end_line_no": 35, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "import unittest\n\nimport redframes as rf\n\n\nclass TestSideEffects(unittest.TestCase):\n    def setUp(self):\n        self.df = rf.DataFrame(\n            {\n                \"foo\": range(10),\n                \"bar\": [1, 3.2, 4.5, 2, -1, 30, None, 1.1, 1.1, 9],\n                \"baz\": [\"A\", \"A\", None, \"B\", \"B\", \"A\", \"B\", \"C\", \"C\", \"A\"],\n                \"jaz\": [\n                    \"1::1\",\n                    \"2::2\",\n                    \"3:3\",\n                    \"4::4\",\n                    \"5::5\",\n                    \"6::7\",\n                    \"7::8\",\n                    \"8::9\",\n                    \"9::0\",\n                    \"0::-1\",\n                ],\n                \"raz\": [1, 2, 3, None, None, None, 9, 9, None, None],\n            }\n        )\n        self.expected = rf.DataFrame(\n            {\n                \"foo\": range(10),\n                \"bar\": [1, 3.2, 4.5, 2, -1, 30, None, 1.1, 1.1, 9],\n                \"baz\": [\"A\", \"A\", None, \"B\", \"B\", \"A\", \"B\", \"C\", \"C\", \"A\"],\n                \"jaz\": [\n                    \"1::1\",\n                    \"2::2\",", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_side_effects.py_0-35"}
{"title": "maxhumber_redframes-tests-test_side_effects.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_side_effects.py"], "line_no": 20, "start_line_no": 0, "end_line_no": 45, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "import unittest\n\nimport redframes as rf\n\n\nclass TestSideEffects(unittest.TestCase):\n    def setUp(self):\n        self.df = rf.DataFrame(\n            {\n                \"foo\": range(10),\n                \"bar\": [1, 3.2, 4.5, 2, -1, 30, None, 1.1, 1.1, 9],\n                \"baz\": [\"A\", \"A\", None, \"B\", \"B\", \"A\", \"B\", \"C\", \"C\", \"A\"],\n                \"jaz\": [\n                    \"1::1\",\n                    \"2::2\",\n                    \"3:3\",\n                    \"4::4\",\n                    \"5::5\",\n                    \"6::7\",\n                    \"7::8\",\n                    \"8::9\",\n                    \"9::0\",\n                    \"0::-1\",\n                ],\n                \"raz\": [1, 2, 3, None, None, None, 9, 9, None, None],\n            }\n        )\n        self.expected = rf.DataFrame(\n            {\n                \"foo\": range(10),\n                \"bar\": [1, 3.2, 4.5, 2, -1, 30, None, 1.1, 1.1, 9],\n                \"baz\": [\"A\", \"A\", None, \"B\", \"B\", \"A\", \"B\", \"C\", \"C\", \"A\"],\n                \"jaz\": [\n                    \"1::1\",\n                    \"2::2\",\n                    \"3:3\",\n                    \"4::4\",\n                    \"5::5\",\n                    \"6::7\",\n                    \"7::8\",\n                    \"8::9\",\n                    \"9::0\",\n                    \"0::-1\",\n                ],\n                \"raz\": [1, 2, 3, None, None, None, 9, 9, None, None],", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_side_effects.py_0-45"}
{"title": "maxhumber_redframes-tests-test_side_effects.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_side_effects.py"], "line_no": 30, "start_line_no": 5, "end_line_no": 55, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "class TestSideEffects(unittest.TestCase):\n    def setUp(self):\n        self.df = rf.DataFrame(\n            {\n                \"foo\": range(10),\n                \"bar\": [1, 3.2, 4.5, 2, -1, 30, None, 1.1, 1.1, 9],\n                \"baz\": [\"A\", \"A\", None, \"B\", \"B\", \"A\", \"B\", \"C\", \"C\", \"A\"],\n                \"jaz\": [\n                    \"1::1\",\n                    \"2::2\",\n                    \"3:3\",\n                    \"4::4\",\n                    \"5::5\",\n                    \"6::7\",\n                    \"7::8\",\n                    \"8::9\",\n                    \"9::0\",\n                    \"0::-1\",\n                ],\n                \"raz\": [1, 2, 3, None, None, None, 9, 9, None, None],\n            }\n        )\n        self.expected = rf.DataFrame(\n            {\n                \"foo\": range(10),\n                \"bar\": [1, 3.2, 4.5, 2, -1, 30, None, 1.1, 1.1, 9],\n                \"baz\": [\"A\", \"A\", None, \"B\", \"B\", \"A\", \"B\", \"C\", \"C\", \"A\"],\n                \"jaz\": [\n                    \"1::1\",\n                    \"2::2\",\n                    \"3:3\",\n                    \"4::4\",\n                    \"5::5\",\n                    \"6::7\",\n                    \"7::8\",\n                    \"8::9\",\n                    \"9::0\",\n                    \"0::-1\",\n                ],\n                \"raz\": [1, 2, 3, None, None, None, 9, 9, None, None],\n            }\n        )\n\n    def test_accumulate(self):\n        _ = self.df.accumulate(\"foo\", into=\"foo\")\n        self.assertEqual(self.df, self.expected)\n\n    def test_append(self):\n        df_bottom = rf.DataFrame({\"foo\": [10]})\n        df_bottom_expected = rf.DataFrame({\"foo\": [10]})\n\nAST=Module(ClassDef(Attribute(Name(Load)Load)FunctionDef(arguments(arg)Assign(Attribute(Name(Load)Store)Call(Attribute(Name(Load)Load)Dict(ConstantConstantConstantConstantConstantCall(Name(Load)Constant)List(ConstantConstantConstantConstantUnaryOp(USubConstant)ConstantConstantConstantConstantConstantLoad)List(ConstantConstantConstantConstantConstantConstantConstantConstantConstantConstantLoad)List(ConstantConstantConstantConstantConstantConstantConstantConstantConstantConstantLoad)List(ConstantConstantConstantConstantConstantConstantConstantConstantConstantConstantLoad))))Assign(Attribute(Name(Load)Store)Call(Attribute(Name(Load)Load)Dict(ConstantConstantConstantConstantConstantCall(Name(Load)Constant)List(ConstantConstantConstantConstantUnaryOp(USubConstant)ConstantConstantConstantConstantConstantLoad)List(ConstantConstantConstantConstantConstantConstantConstantConstantConstantConstantLoad)List(ConstantConstantConstantConstantConstantConstantConstantConstantConstantConstantLoad)List(ConstantConstantConstantConstantConstantConstantConstantConstantConstantConstantLoad)))))FunctionDef(arguments(arg)Assign(Name(Store)Call(Attribute(Attribute(Name(Load)Load)Load)Constantkeyword(Constant)))Expr(Call(Attribute(Name(Load)Load)Attribute(Name(Load)Load)Attribute(Name(Load)Load))))FunctionDef(arguments(arg)Assign(Name(Store)Call(Attribute(Name(Load)Load)Dict(ConstantList(ConstantLoad))))Assign(Name(Store)Call(Attribute(Name(Load)Load)Dict(ConstantList(ConstantLoad)))))))", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_side_effects.py_5-55"}
{"title": "maxhumber_redframes-tests-test_side_effects.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_side_effects.py"], "line_no": 40, "start_line_no": 15, "end_line_no": 65, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "                    \"3:3\",\n                    \"4::4\",\n                    \"5::5\",\n                    \"6::7\",\n                    \"7::8\",\n                    \"8::9\",\n                    \"9::0\",\n                    \"0::-1\",\n                ],\n                \"raz\": [1, 2, 3, None, None, None, 9, 9, None, None],\n            }\n        )\n        self.expected = rf.DataFrame(\n            {\n                \"foo\": range(10),\n                \"bar\": [1, 3.2, 4.5, 2, -1, 30, None, 1.1, 1.1, 9],\n                \"baz\": [\"A\", \"A\", None, \"B\", \"B\", \"A\", \"B\", \"C\", \"C\", \"A\"],\n                \"jaz\": [\n                    \"1::1\",\n                    \"2::2\",\n                    \"3:3\",\n                    \"4::4\",\n                    \"5::5\",\n                    \"6::7\",\n                    \"7::8\",\n                    \"8::9\",\n                    \"9::0\",\n                    \"0::-1\",\n                ],\n                \"raz\": [1, 2, 3, None, None, None, 9, 9, None, None],\n            }\n        )\n\n    def test_accumulate(self):\n        _ = self.df.accumulate(\"foo\", into=\"foo\")\n        self.assertEqual(self.df, self.expected)\n\n    def test_append(self):\n        df_bottom = rf.DataFrame({\"foo\": [10]})\n        df_bottom_expected = rf.DataFrame({\"foo\": [10]})\n        _ = self.df.append(df_bottom)\n        self.assertEqual(self.df, self.expected)\n        self.assertEqual(df_bottom, df_bottom_expected)\n\n    def test_combine(self):\n        _ = self.df.combine([\"foo\", \"bar\"], into=\"foo\", sep=\"-\")\n        self.assertEqual(self.df, self.expected)\n\n    def test_cross(self):\n        _ = self.df.cross(postfix=(\"_a\", \"_b\"))", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_side_effects.py_15-65"}
{"title": "maxhumber_redframes-tests-test_side_effects.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_side_effects.py"], "line_no": 50, "start_line_no": 25, "end_line_no": 75, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "            }\n        )\n        self.expected = rf.DataFrame(\n            {\n                \"foo\": range(10),\n                \"bar\": [1, 3.2, 4.5, 2, -1, 30, None, 1.1, 1.1, 9],\n                \"baz\": [\"A\", \"A\", None, \"B\", \"B\", \"A\", \"B\", \"C\", \"C\", \"A\"],\n                \"jaz\": [\n                    \"1::1\",\n                    \"2::2\",\n                    \"3:3\",\n                    \"4::4\",\n                    \"5::5\",\n                    \"6::7\",\n                    \"7::8\",\n                    \"8::9\",\n                    \"9::0\",\n                    \"0::-1\",\n                ],\n                \"raz\": [1, 2, 3, None, None, None, 9, 9, None, None],\n            }\n        )\n\n    def test_accumulate(self):\n        _ = self.df.accumulate(\"foo\", into=\"foo\")\n        self.assertEqual(self.df, self.expected)\n\n    def test_append(self):\n        df_bottom = rf.DataFrame({\"foo\": [10]})\n        df_bottom_expected = rf.DataFrame({\"foo\": [10]})\n        _ = self.df.append(df_bottom)\n        self.assertEqual(self.df, self.expected)\n        self.assertEqual(df_bottom, df_bottom_expected)\n\n    def test_combine(self):\n        _ = self.df.combine([\"foo\", \"bar\"], into=\"foo\", sep=\"-\")\n        self.assertEqual(self.df, self.expected)\n\n    def test_cross(self):\n        _ = self.df.cross(postfix=(\"_a\", \"_b\"))\n        self.assertEqual(self.df, self.expected)\n\n    def test_dedupe(self):\n        _ = self.df.dedupe(\"baz\")\n        self.assertEqual(self.df, self.expected)\n\n    def test_denix(self):\n        _ = self.df.denix()\n        self.assertEqual(self.df, self.expected)\n", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_side_effects.py_25-75"}
{"title": "maxhumber_redframes-tests-test_side_effects.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_side_effects.py"], "line_no": 60, "start_line_no": 35, "end_line_no": 85, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "                    \"3:3\",\n                    \"4::4\",\n                    \"5::5\",\n                    \"6::7\",\n                    \"7::8\",\n                    \"8::9\",\n                    \"9::0\",\n                    \"0::-1\",\n                ],\n                \"raz\": [1, 2, 3, None, None, None, 9, 9, None, None],\n            }\n        )\n\n    def test_accumulate(self):\n        _ = self.df.accumulate(\"foo\", into=\"foo\")\n        self.assertEqual(self.df, self.expected)\n\n    def test_append(self):\n        df_bottom = rf.DataFrame({\"foo\": [10]})\n        df_bottom_expected = rf.DataFrame({\"foo\": [10]})\n        _ = self.df.append(df_bottom)\n        self.assertEqual(self.df, self.expected)\n        self.assertEqual(df_bottom, df_bottom_expected)\n\n    def test_combine(self):\n        _ = self.df.combine([\"foo\", \"bar\"], into=\"foo\", sep=\"-\")\n        self.assertEqual(self.df, self.expected)\n\n    def test_cross(self):\n        _ = self.df.cross(postfix=(\"_a\", \"_b\"))\n        self.assertEqual(self.df, self.expected)\n\n    def test_dedupe(self):\n        _ = self.df.dedupe(\"baz\")\n        self.assertEqual(self.df, self.expected)\n\n    def test_denix(self):\n        _ = self.df.denix()\n        self.assertEqual(self.df, self.expected)\n\n    def test_drop(self):\n        _ = self.df.drop(\"foo\")\n        self.assertEqual(self.df, self.expected)\n\n    def test_fill(self):\n        _ = self.df.fill(\"baz\", direction=\"down\")\n        self.assertEqual(self.df, self.expected)\n\n    def test_filter(self):\n        _ = self.df.filter(lambda row: row[\"bar\"] > 5)", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_side_effects.py_35-85"}
{"title": "maxhumber_redframes-tests-test_side_effects.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_side_effects.py"], "line_no": 70, "start_line_no": 45, "end_line_no": 95, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "            }\n        )\n\n    def test_accumulate(self):\n        _ = self.df.accumulate(\"foo\", into=\"foo\")\n        self.assertEqual(self.df, self.expected)\n\n    def test_append(self):\n        df_bottom = rf.DataFrame({\"foo\": [10]})\n        df_bottom_expected = rf.DataFrame({\"foo\": [10]})\n        _ = self.df.append(df_bottom)\n        self.assertEqual(self.df, self.expected)\n        self.assertEqual(df_bottom, df_bottom_expected)\n\n    def test_combine(self):\n        _ = self.df.combine([\"foo\", \"bar\"], into=\"foo\", sep=\"-\")\n        self.assertEqual(self.df, self.expected)\n\n    def test_cross(self):\n        _ = self.df.cross(postfix=(\"_a\", \"_b\"))\n        self.assertEqual(self.df, self.expected)\n\n    def test_dedupe(self):\n        _ = self.df.dedupe(\"baz\")\n        self.assertEqual(self.df, self.expected)\n\n    def test_denix(self):\n        _ = self.df.denix()\n        self.assertEqual(self.df, self.expected)\n\n    def test_drop(self):\n        _ = self.df.drop(\"foo\")\n        self.assertEqual(self.df, self.expected)\n\n    def test_fill(self):\n        _ = self.df.fill(\"baz\", direction=\"down\")\n        self.assertEqual(self.df, self.expected)\n\n    def test_filter(self):\n        _ = self.df.filter(lambda row: row[\"bar\"] > 5)\n        self.assertEqual(self.df, self.expected)\n\n    def test_gather(self):\n        _ = self.df.gather()\n        self.assertEqual(self.df, self.expected)\n\n    def test_group(self):\n        _ = self.df.group(\"baz\").rollup({\"foo\": (\"foo\", rf.stat.mean)})\n        self.assertEqual(self.df, self.expected)\n", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_side_effects.py_45-95"}
{"title": "maxhumber_redframes-tests-test_side_effects.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_side_effects.py"], "line_no": 80, "start_line_no": 55, "end_line_no": 105, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        _ = self.df.append(df_bottom)\n        self.assertEqual(self.df, self.expected)\n        self.assertEqual(df_bottom, df_bottom_expected)\n\n    def test_combine(self):\n        _ = self.df.combine([\"foo\", \"bar\"], into=\"foo\", sep=\"-\")\n        self.assertEqual(self.df, self.expected)\n\n    def test_cross(self):\n        _ = self.df.cross(postfix=(\"_a\", \"_b\"))\n        self.assertEqual(self.df, self.expected)\n\n    def test_dedupe(self):\n        _ = self.df.dedupe(\"baz\")\n        self.assertEqual(self.df, self.expected)\n\n    def test_denix(self):\n        _ = self.df.denix()\n        self.assertEqual(self.df, self.expected)\n\n    def test_drop(self):\n        _ = self.df.drop(\"foo\")\n        self.assertEqual(self.df, self.expected)\n\n    def test_fill(self):\n        _ = self.df.fill(\"baz\", direction=\"down\")\n        self.assertEqual(self.df, self.expected)\n\n    def test_filter(self):\n        _ = self.df.filter(lambda row: row[\"bar\"] > 5)\n        self.assertEqual(self.df, self.expected)\n\n    def test_gather(self):\n        _ = self.df.gather()\n        self.assertEqual(self.df, self.expected)\n\n    def test_group(self):\n        _ = self.df.group(\"baz\").rollup({\"foo\": (\"foo\", rf.stat.mean)})\n        self.assertEqual(self.df, self.expected)\n\n    def test_join(self):\n        df_right = rf.DataFrame({\"baz\": [\"A\", \"B\"], \"haz\": [\"Apple\", \"Banana\"]})\n        df_right_expected = rf.DataFrame(\n            {\"baz\": [\"A\", \"B\"], \"haz\": [\"Apple\", \"Banana\"]}\n        )\n        _ = self.df.join(df_right, on=\"baz\")\n        self.assertEqual(self.df, self.expected)\n        self.assertEqual(df_right, df_right_expected)\n\n    def test_mutate(self):", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_side_effects.py_55-105"}
{"title": "maxhumber_redframes-tests-test_side_effects.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_side_effects.py"], "line_no": 90, "start_line_no": 65, "end_line_no": 115, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        self.assertEqual(self.df, self.expected)\n\n    def test_dedupe(self):\n        _ = self.df.dedupe(\"baz\")\n        self.assertEqual(self.df, self.expected)\n\n    def test_denix(self):\n        _ = self.df.denix()\n        self.assertEqual(self.df, self.expected)\n\n    def test_drop(self):\n        _ = self.df.drop(\"foo\")\n        self.assertEqual(self.df, self.expected)\n\n    def test_fill(self):\n        _ = self.df.fill(\"baz\", direction=\"down\")\n        self.assertEqual(self.df, self.expected)\n\n    def test_filter(self):\n        _ = self.df.filter(lambda row: row[\"bar\"] > 5)\n        self.assertEqual(self.df, self.expected)\n\n    def test_gather(self):\n        _ = self.df.gather()\n        self.assertEqual(self.df, self.expected)\n\n    def test_group(self):\n        _ = self.df.group(\"baz\").rollup({\"foo\": (\"foo\", rf.stat.mean)})\n        self.assertEqual(self.df, self.expected)\n\n    def test_join(self):\n        df_right = rf.DataFrame({\"baz\": [\"A\", \"B\"], \"haz\": [\"Apple\", \"Banana\"]})\n        df_right_expected = rf.DataFrame(\n            {\"baz\": [\"A\", \"B\"], \"haz\": [\"Apple\", \"Banana\"]}\n        )\n        _ = self.df.join(df_right, on=\"baz\")\n        self.assertEqual(self.df, self.expected)\n        self.assertEqual(df_right, df_right_expected)\n\n    def test_mutate(self):\n        _ = self.df.mutate({\"foo\": lambda row: row[\"foo\"] * 10})\n        self.assertEqual(self.df, self.expected)\n\n    def test_pack(self):\n        _ = self.df.pack(\"baz\", sep=\"|\")\n        self.assertEqual(self.df, self.expected)\n\n    def test_rank(self):\n        _ = self.df.rank(\"bar\", into=\"bar_rank\", descending=True)\n        self.assertEqual(self.df, self.expected)", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_side_effects.py_65-115"}
{"title": "maxhumber_redframes-tests-test_side_effects.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_side_effects.py"], "line_no": 100, "start_line_no": 75, "end_line_no": 125, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "    def test_drop(self):\n        _ = self.df.drop(\"foo\")\n        self.assertEqual(self.df, self.expected)\n\n    def test_fill(self):\n        _ = self.df.fill(\"baz\", direction=\"down\")\n        self.assertEqual(self.df, self.expected)\n\n    def test_filter(self):\n        _ = self.df.filter(lambda row: row[\"bar\"] > 5)\n        self.assertEqual(self.df, self.expected)\n\n    def test_gather(self):\n        _ = self.df.gather()\n        self.assertEqual(self.df, self.expected)\n\n    def test_group(self):\n        _ = self.df.group(\"baz\").rollup({\"foo\": (\"foo\", rf.stat.mean)})\n        self.assertEqual(self.df, self.expected)\n\n    def test_join(self):\n        df_right = rf.DataFrame({\"baz\": [\"A\", \"B\"], \"haz\": [\"Apple\", \"Banana\"]})\n        df_right_expected = rf.DataFrame(\n            {\"baz\": [\"A\", \"B\"], \"haz\": [\"Apple\", \"Banana\"]}\n        )\n        _ = self.df.join(df_right, on=\"baz\")\n        self.assertEqual(self.df, self.expected)\n        self.assertEqual(df_right, df_right_expected)\n\n    def test_mutate(self):\n        _ = self.df.mutate({\"foo\": lambda row: row[\"foo\"] * 10})\n        self.assertEqual(self.df, self.expected)\n\n    def test_pack(self):\n        _ = self.df.pack(\"baz\", sep=\"|\")\n        self.assertEqual(self.df, self.expected)\n\n    def test_rank(self):\n        _ = self.df.rank(\"bar\", into=\"bar_rank\", descending=True)\n        self.assertEqual(self.df, self.expected)\n\n    def test_rename(self):\n        _ = self.df.rename({\"foo\": \"oof\"})\n        self.assertEqual(self.df, self.expected)\n\n    def test_replace(self):\n        _ = self.df.replace({\"baz\": {\"B\": \"Banana\"}})\n        self.assertEqual(self.df, self.expected)\n\n    def test_rollup(self):", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_side_effects.py_75-125"}
{"title": "maxhumber_redframes-tests-test_side_effects.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_side_effects.py"], "line_no": 110, "start_line_no": 85, "end_line_no": 135, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        self.assertEqual(self.df, self.expected)\n\n    def test_gather(self):\n        _ = self.df.gather()\n        self.assertEqual(self.df, self.expected)\n\n    def test_group(self):\n        _ = self.df.group(\"baz\").rollup({\"foo\": (\"foo\", rf.stat.mean)})\n        self.assertEqual(self.df, self.expected)\n\n    def test_join(self):\n        df_right = rf.DataFrame({\"baz\": [\"A\", \"B\"], \"haz\": [\"Apple\", \"Banana\"]})\n        df_right_expected = rf.DataFrame(\n            {\"baz\": [\"A\", \"B\"], \"haz\": [\"Apple\", \"Banana\"]}\n        )\n        _ = self.df.join(df_right, on=\"baz\")\n        self.assertEqual(self.df, self.expected)\n        self.assertEqual(df_right, df_right_expected)\n\n    def test_mutate(self):\n        _ = self.df.mutate({\"foo\": lambda row: row[\"foo\"] * 10})\n        self.assertEqual(self.df, self.expected)\n\n    def test_pack(self):\n        _ = self.df.pack(\"baz\", sep=\"|\")\n        self.assertEqual(self.df, self.expected)\n\n    def test_rank(self):\n        _ = self.df.rank(\"bar\", into=\"bar_rank\", descending=True)\n        self.assertEqual(self.df, self.expected)\n\n    def test_rename(self):\n        _ = self.df.rename({\"foo\": \"oof\"})\n        self.assertEqual(self.df, self.expected)\n\n    def test_replace(self):\n        _ = self.df.replace({\"baz\": {\"B\": \"Banana\"}})\n        self.assertEqual(self.df, self.expected)\n\n    def test_rollup(self):\n        _ = self.df.rollup({\"bar_mean\": (\"bar\", rf.stat.mean)})\n        self.assertEqual(self.df, self.expected)\n\n    def test_sample(self):\n        _ = self.df.sample(5)\n        self.assertEqual(self.df, self.expected)\n\n    def test_select(self):\n        _ = self.df.select([\"foo\", \"bar\"])\n        self.assertEqual(self.df, self.expected)", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_side_effects.py_85-135"}
{"title": "maxhumber_redframes-tests-test_side_effects.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_side_effects.py"], "line_no": 120, "start_line_no": 95, "end_line_no": 145, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "    def test_join(self):\n        df_right = rf.DataFrame({\"baz\": [\"A\", \"B\"], \"haz\": [\"Apple\", \"Banana\"]})\n        df_right_expected = rf.DataFrame(\n            {\"baz\": [\"A\", \"B\"], \"haz\": [\"Apple\", \"Banana\"]}\n        )\n        _ = self.df.join(df_right, on=\"baz\")\n        self.assertEqual(self.df, self.expected)\n        self.assertEqual(df_right, df_right_expected)\n\n    def test_mutate(self):\n        _ = self.df.mutate({\"foo\": lambda row: row[\"foo\"] * 10})\n        self.assertEqual(self.df, self.expected)\n\n    def test_pack(self):\n        _ = self.df.pack(\"baz\", sep=\"|\")\n        self.assertEqual(self.df, self.expected)\n\n    def test_rank(self):\n        _ = self.df.rank(\"bar\", into=\"bar_rank\", descending=True)\n        self.assertEqual(self.df, self.expected)\n\n    def test_rename(self):\n        _ = self.df.rename({\"foo\": \"oof\"})\n        self.assertEqual(self.df, self.expected)\n\n    def test_replace(self):\n        _ = self.df.replace({\"baz\": {\"B\": \"Banana\"}})\n        self.assertEqual(self.df, self.expected)\n\n    def test_rollup(self):\n        _ = self.df.rollup({\"bar_mean\": (\"bar\", rf.stat.mean)})\n        self.assertEqual(self.df, self.expected)\n\n    def test_sample(self):\n        _ = self.df.sample(5)\n        self.assertEqual(self.df, self.expected)\n\n    def test_select(self):\n        _ = self.df.select([\"foo\", \"bar\"])\n        self.assertEqual(self.df, self.expected)\n\n    def test_shuffle(self):\n        _ = self.df.shuffle()\n        self.assertEqual(self.df, self.expected)\n\n    def test_sort(self):\n        _ = self.df.sort(\"bar\", descending=True)\n        self.assertEqual(self.df, self.expected)\n\n    def test_split(self):", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_side_effects.py_95-145"}
{"title": "maxhumber_redframes-tests-test_side_effects.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_side_effects.py"], "line_no": 130, "start_line_no": 105, "end_line_no": 155, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        _ = self.df.mutate({\"foo\": lambda row: row[\"foo\"] * 10})\n        self.assertEqual(self.df, self.expected)\n\n    def test_pack(self):\n        _ = self.df.pack(\"baz\", sep=\"|\")\n        self.assertEqual(self.df, self.expected)\n\n    def test_rank(self):\n        _ = self.df.rank(\"bar\", into=\"bar_rank\", descending=True)\n        self.assertEqual(self.df, self.expected)\n\n    def test_rename(self):\n        _ = self.df.rename({\"foo\": \"oof\"})\n        self.assertEqual(self.df, self.expected)\n\n    def test_replace(self):\n        _ = self.df.replace({\"baz\": {\"B\": \"Banana\"}})\n        self.assertEqual(self.df, self.expected)\n\n    def test_rollup(self):\n        _ = self.df.rollup({\"bar_mean\": (\"bar\", rf.stat.mean)})\n        self.assertEqual(self.df, self.expected)\n\n    def test_sample(self):\n        _ = self.df.sample(5)\n        self.assertEqual(self.df, self.expected)\n\n    def test_select(self):\n        _ = self.df.select([\"foo\", \"bar\"])\n        self.assertEqual(self.df, self.expected)\n\n    def test_shuffle(self):\n        _ = self.df.shuffle()\n        self.assertEqual(self.df, self.expected)\n\n    def test_sort(self):\n        _ = self.df.sort(\"bar\", descending=True)\n        self.assertEqual(self.df, self.expected)\n\n    def test_split(self):\n        _ = self.df.split(\"jaz\", into=[\"jaz_1\", \"jaz_2\"], sep=\"::\")\n        self.assertEqual(self.df, self.expected)\n\n    def test_spread(self):\n        _ = self.df.denix(\"baz\").select([\"baz\", \"foo\"]).spread(\"baz\", \"foo\")\n        self.assertEqual(self.df, self.expected)\n\n    def test_take(self):\n        _ = self.df.take(-3)\n        self.assertEqual(self.df, self.expected)", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_side_effects.py_105-155"}
{"title": "maxhumber_redframes-tests-test_side_effects.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_side_effects.py"], "line_no": 140, "start_line_no": 115, "end_line_no": 159, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "\n    def test_rename(self):\n        _ = self.df.rename({\"foo\": \"oof\"})\n        self.assertEqual(self.df, self.expected)\n\n    def test_replace(self):\n        _ = self.df.replace({\"baz\": {\"B\": \"Banana\"}})\n        self.assertEqual(self.df, self.expected)\n\n    def test_rollup(self):\n        _ = self.df.rollup({\"bar_mean\": (\"bar\", rf.stat.mean)})\n        self.assertEqual(self.df, self.expected)\n\n    def test_sample(self):\n        _ = self.df.sample(5)\n        self.assertEqual(self.df, self.expected)\n\n    def test_select(self):\n        _ = self.df.select([\"foo\", \"bar\"])\n        self.assertEqual(self.df, self.expected)\n\n    def test_shuffle(self):\n        _ = self.df.shuffle()\n        self.assertEqual(self.df, self.expected)\n\n    def test_sort(self):\n        _ = self.df.sort(\"bar\", descending=True)\n        self.assertEqual(self.df, self.expected)\n\n    def test_split(self):\n        _ = self.df.split(\"jaz\", into=[\"jaz_1\", \"jaz_2\"], sep=\"::\")\n        self.assertEqual(self.df, self.expected)\n\n    def test_spread(self):\n        _ = self.df.denix(\"baz\").select([\"baz\", \"foo\"]).spread(\"baz\", \"foo\")\n        self.assertEqual(self.df, self.expected)\n\n    def test_take(self):\n        _ = self.df.take(-3)\n        self.assertEqual(self.df, self.expected)\n\n    def test_take(self):\n        _ = self.df.unpack(\"jaz\", sep=\"::\")\n        self.assertEqual(self.df, self.expected)", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_side_effects.py_115-159"}
{"title": "maxhumber_redframes-tests-test_side_effects.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_side_effects.py"], "line_no": 150, "start_line_no": 125, "end_line_no": 159, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        _ = self.df.rollup({\"bar_mean\": (\"bar\", rf.stat.mean)})\n        self.assertEqual(self.df, self.expected)\n\n    def test_sample(self):\n        _ = self.df.sample(5)\n        self.assertEqual(self.df, self.expected)\n\n    def test_select(self):\n        _ = self.df.select([\"foo\", \"bar\"])\n        self.assertEqual(self.df, self.expected)\n\n    def test_shuffle(self):\n        _ = self.df.shuffle()\n        self.assertEqual(self.df, self.expected)\n\n    def test_sort(self):\n        _ = self.df.sort(\"bar\", descending=True)\n        self.assertEqual(self.df, self.expected)\n\n    def test_split(self):\n        _ = self.df.split(\"jaz\", into=[\"jaz_1\", \"jaz_2\"], sep=\"::\")\n        self.assertEqual(self.df, self.expected)\n\n    def test_spread(self):\n        _ = self.df.denix(\"baz\").select([\"baz\", \"foo\"]).spread(\"baz\", \"foo\")\n        self.assertEqual(self.df, self.expected)\n\n    def test_take(self):\n        _ = self.df.take(-3)\n        self.assertEqual(self.df, self.expected)\n\n    def test_take(self):\n        _ = self.df.unpack(\"jaz\", sep=\"::\")\n        self.assertEqual(self.df, self.expected)", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_side_effects.py_125-159"}
{"title": "maxhumber_redframes-tests-test_type_hints.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_type_hints.py"], "line_no": 0, "start_line_no": 0, "end_line_no": 25, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "import unittest\n\nimport redframes as rf\n\n\nclass TestTypeHints(unittest.TestCase):\n    def setUp(self):\n        self.df = rf.DataFrame(\n            {\n                \"foo\": range(10),\n                \"bar\": [1, 3.2, 4.5, 2, -1, 30, None, 1.1, 1.1, 9],\n                \"baz\": [\"A\", \"A\", None, \"B\", \"B\", \"A\", \"B\", \"C\", \"C\", \"A\"],\n                \"jaz\": [\n                    \"1::1\",\n                    \"2::2\",\n                    \"3:3\",\n                    \"4::4\",\n                    \"5::5\",\n                    \"6::7\",\n                    \"7::8\",\n                    \"8::9\",\n                    \"9::0\",\n                    \"0::-1\",\n                ],\n                \"raz\": [1, 2, 3, None, None, None, 9, 9, None, None],", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_type_hints.py_0-25"}
{"title": "maxhumber_redframes-tests-test_type_hints.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_type_hints.py"], "line_no": 10, "start_line_no": 0, "end_line_no": 35, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "import unittest\n\nimport redframes as rf\n\n\nclass TestTypeHints(unittest.TestCase):\n    def setUp(self):\n        self.df = rf.DataFrame(\n            {\n                \"foo\": range(10),\n                \"bar\": [1, 3.2, 4.5, 2, -1, 30, None, 1.1, 1.1, 9],\n                \"baz\": [\"A\", \"A\", None, \"B\", \"B\", \"A\", \"B\", \"C\", \"C\", \"A\"],\n                \"jaz\": [\n                    \"1::1\",\n                    \"2::2\",\n                    \"3:3\",\n                    \"4::4\",\n                    \"5::5\",\n                    \"6::7\",\n                    \"7::8\",\n                    \"8::9\",\n                    \"9::0\",\n                    \"0::-1\",\n                ],\n                \"raz\": [1, 2, 3, None, None, None, 9, 9, None, None],\n            }\n        )\n\n    def test_io_load_bad_path(self):\n        with self.assertRaisesRegex(TypeError, \"must be str\"):\n            rf.load(1)\n\n    def test_io_load_bad_file_type(self):\n        with self.assertRaisesRegex(TypeError, \"must end in .csv\"):\n            rf.load(\"example.json\")\n\nAST=Module(Import(alias)Import(alias)ClassDef(Attribute(Name(Load)Load)FunctionDef(arguments(arg)Assign(Attribute(Name(Load)Store)Call(Attribute(Name(Load)Load)Dict(ConstantConstantConstantConstantConstantCall(Name(Load)Constant)List(ConstantConstantConstantConstantUnaryOp(USubConstant)ConstantConstantConstantConstantConstantLoad)List(ConstantConstantConstantConstantConstantConstantConstantConstantConstantConstantLoad)List(ConstantConstantConstantConstantConstantConstantConstantConstantConstantConstantLoad)List(ConstantConstantConstantConstantConstantConstantConstantConstantConstantConstantLoad)))))FunctionDef(arguments(arg)With(withitem(Call(Attribute(Name(Load)Load)Name(Load)Constant))Expr(Call(Attribute(Name(Load)Load)Constant))))FunctionDef(arguments(arg)With(withitem(Call(Attribute(Name(Load)Load)Name(Load)Constant))Expr(Call(Attribute(Name(Load)Load)Constant))))))", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_type_hints.py_0-35"}
{"title": "maxhumber_redframes-tests-test_type_hints.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_type_hints.py"], "line_no": 20, "start_line_no": 0, "end_line_no": 45, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "import unittest\n\nimport redframes as rf\n\n\nclass TestTypeHints(unittest.TestCase):\n    def setUp(self):\n        self.df = rf.DataFrame(\n            {\n                \"foo\": range(10),\n                \"bar\": [1, 3.2, 4.5, 2, -1, 30, None, 1.1, 1.1, 9],\n                \"baz\": [\"A\", \"A\", None, \"B\", \"B\", \"A\", \"B\", \"C\", \"C\", \"A\"],\n                \"jaz\": [\n                    \"1::1\",\n                    \"2::2\",\n                    \"3:3\",\n                    \"4::4\",\n                    \"5::5\",\n                    \"6::7\",\n                    \"7::8\",\n                    \"8::9\",\n                    \"9::0\",\n                    \"0::-1\",\n                ],\n                \"raz\": [1, 2, 3, None, None, None, 9, 9, None, None],\n            }\n        )\n\n    def test_io_load_bad_path(self):\n        with self.assertRaisesRegex(TypeError, \"must be str\"):\n            rf.load(1)\n\n    def test_io_load_bad_file_type(self):\n        with self.assertRaisesRegex(TypeError, \"must end in .csv\"):\n            rf.load(\"example.json\")\n\n    def test_io_save_bad_object(self):\n        with self.assertRaisesRegex(TypeError, \"must be DataFrame\"):\n            rf.save(1, \"example.csv\")\n\n    def test_io_save_bad_path(self):\n        with self.assertRaisesRegex(TypeError, \"must be str\"):\n            rf.save(self.df, 1)\n\n    def test_io_save_bad_format(self):", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_type_hints.py_0-45"}
{"title": "maxhumber_redframes-tests-test_type_hints.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_type_hints.py"], "line_no": 30, "start_line_no": 5, "end_line_no": 55, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "class TestTypeHints(unittest.TestCase):\n    def setUp(self):\n        self.df = rf.DataFrame(\n            {\n                \"foo\": range(10),\n                \"bar\": [1, 3.2, 4.5, 2, -1, 30, None, 1.1, 1.1, 9],\n                \"baz\": [\"A\", \"A\", None, \"B\", \"B\", \"A\", \"B\", \"C\", \"C\", \"A\"],\n                \"jaz\": [\n                    \"1::1\",\n                    \"2::2\",\n                    \"3:3\",\n                    \"4::4\",\n                    \"5::5\",\n                    \"6::7\",\n                    \"7::8\",\n                    \"8::9\",\n                    \"9::0\",\n                    \"0::-1\",\n                ],\n                \"raz\": [1, 2, 3, None, None, None, 9, 9, None, None],\n            }\n        )\n\n    def test_io_load_bad_path(self):\n        with self.assertRaisesRegex(TypeError, \"must be str\"):\n            rf.load(1)\n\n    def test_io_load_bad_file_type(self):\n        with self.assertRaisesRegex(TypeError, \"must end in .csv\"):\n            rf.load(\"example.json\")\n\n    def test_io_save_bad_object(self):\n        with self.assertRaisesRegex(TypeError, \"must be DataFrame\"):\n            rf.save(1, \"example.csv\")\n\n    def test_io_save_bad_path(self):\n        with self.assertRaisesRegex(TypeError, \"must be str\"):\n            rf.save(self.df, 1)\n\n    def test_io_save_bad_format(self):\n        with self.assertRaisesRegex(TypeError, \"must end in .csv\"):\n            rf.save(self.df, \"example.json\")\n\n    def test_io_unwrap_bad_object(self):\n        with self.assertRaisesRegex(TypeError, \"must be DataFrame\"):\n            rf.unwrap(1)\n\n    def test_io_wrap_bad_object(self):\n        with self.assertRaisesRegex(TypeError, \"must be DataFrame\"):\n            rf.unwrap(1)\n\nAST=Module(ClassDef(Attribute(Name(Load)Load)FunctionDef(arguments(arg)Assign(Attribute(Name(Load)Store)Call(Attribute(Name(Load)Load)Dict(ConstantConstantConstantConstantConstantCall(Name(Load)Constant)List(ConstantConstantConstantConstantUnaryOp(USubConstant)ConstantConstantConstantConstantConstantLoad)List(ConstantConstantConstantConstantConstantConstantConstantConstantConstantConstantLoad)List(ConstantConstantConstantConstantConstantConstantConstantConstantConstantConstantLoad)List(ConstantConstantConstantConstantConstantConstantConstantConstantConstantConstantLoad)))))FunctionDef(arguments(arg)With(withitem(Call(Attribute(Name(Load)Load)Name(Load)Constant))Expr(Call(Attribute(Name(Load)Load)Constant))))FunctionDef(arguments(arg)With(withitem(Call(Attribute(Name(Load)Load)Name(Load)Constant))Expr(Call(Attribute(Name(Load)Load)Constant))))FunctionDef(arguments(arg)With(withitem(Call(Attribute(Name(Load)Load)Name(Load)Constant))Expr(Call(Attribute(Name(Load)Load)ConstantConstant))))FunctionDef(arguments(arg)With(withitem(Call(Attribute(Name(Load)Load)Name(Load)Constant))Expr(Call(Attribute(Name(Load)Load)Attribute(Name(Load)Load)Constant))))FunctionDef(arguments(arg)With(withitem(Call(Attribute(Name(Load)Load)Name(Load)Constant))Expr(Call(Attribute(Name(Load)Load)Attribute(Name(Load)Load)Constant))))FunctionDef(arguments(arg)With(withitem(Call(Attribute(Name(Load)Load)Name(Load)Constant))Expr(Call(Attribute(Name(Load)Load)Constant))))FunctionDef(arguments(arg)With(withitem(Call(Attribute(Name(Load)Load)Name(Load)Constant))Expr(Call(Attribute(Name(Load)Load)Constant))))))", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_type_hints.py_5-55"}
{"title": "maxhumber_redframes-tests-test_type_hints.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_type_hints.py"], "line_no": 40, "start_line_no": 15, "end_line_no": 65, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "                    \"3:3\",\n                    \"4::4\",\n                    \"5::5\",\n                    \"6::7\",\n                    \"7::8\",\n                    \"8::9\",\n                    \"9::0\",\n                    \"0::-1\",\n                ],\n                \"raz\": [1, 2, 3, None, None, None, 9, 9, None, None],\n            }\n        )\n\n    def test_io_load_bad_path(self):\n        with self.assertRaisesRegex(TypeError, \"must be str\"):\n            rf.load(1)\n\n    def test_io_load_bad_file_type(self):\n        with self.assertRaisesRegex(TypeError, \"must end in .csv\"):\n            rf.load(\"example.json\")\n\n    def test_io_save_bad_object(self):\n        with self.assertRaisesRegex(TypeError, \"must be DataFrame\"):\n            rf.save(1, \"example.csv\")\n\n    def test_io_save_bad_path(self):\n        with self.assertRaisesRegex(TypeError, \"must be str\"):\n            rf.save(self.df, 1)\n\n    def test_io_save_bad_format(self):\n        with self.assertRaisesRegex(TypeError, \"must end in .csv\"):\n            rf.save(self.df, \"example.json\")\n\n    def test_io_unwrap_bad_object(self):\n        with self.assertRaisesRegex(TypeError, \"must be DataFrame\"):\n            rf.unwrap(1)\n\n    def test_io_wrap_bad_object(self):\n        with self.assertRaisesRegex(TypeError, \"must be DataFrame\"):\n            rf.unwrap(1)\n\n    def test_take_bad_rows(self):\n        with self.assertRaisesRegex(TypeError, \"must be int\"):\n            self.df.take(\"A\")\n\n    def test_accumulate_bad_column(self):\n        with self.assertRaisesRegex(TypeError, \"must be str\"):\n            self.df.accumulate(1, \"foo\")\n\n    def test_accumulate_bad_into_column(self):", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_type_hints.py_15-65"}
{"title": "maxhumber_redframes-tests-test_type_hints.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_type_hints.py"], "line_no": 50, "start_line_no": 25, "end_line_no": 75, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "            }\n        )\n\n    def test_io_load_bad_path(self):\n        with self.assertRaisesRegex(TypeError, \"must be str\"):\n            rf.load(1)\n\n    def test_io_load_bad_file_type(self):\n        with self.assertRaisesRegex(TypeError, \"must end in .csv\"):\n            rf.load(\"example.json\")\n\n    def test_io_save_bad_object(self):\n        with self.assertRaisesRegex(TypeError, \"must be DataFrame\"):\n            rf.save(1, \"example.csv\")\n\n    def test_io_save_bad_path(self):\n        with self.assertRaisesRegex(TypeError, \"must be str\"):\n            rf.save(self.df, 1)\n\n    def test_io_save_bad_format(self):\n        with self.assertRaisesRegex(TypeError, \"must end in .csv\"):\n            rf.save(self.df, \"example.json\")\n\n    def test_io_unwrap_bad_object(self):\n        with self.assertRaisesRegex(TypeError, \"must be DataFrame\"):\n            rf.unwrap(1)\n\n    def test_io_wrap_bad_object(self):\n        with self.assertRaisesRegex(TypeError, \"must be DataFrame\"):\n            rf.unwrap(1)\n\n    def test_take_bad_rows(self):\n        with self.assertRaisesRegex(TypeError, \"must be int\"):\n            self.df.take(\"A\")\n\n    def test_accumulate_bad_column(self):\n        with self.assertRaisesRegex(TypeError, \"must be str\"):\n            self.df.accumulate(1, \"foo\")\n\n    def test_accumulate_bad_into_column(self):\n        with self.assertRaisesRegex(TypeError, \"must be str\"):\n            self.df.accumulate(\"foo\", 1)\n\n    def test_rank_bad_column(self):\n        with self.assertRaisesRegex(TypeError, \"must be str\"):\n            self.df.rank(1, \"bar2\")\n\n    def test_rank_bad_into_column(self):\n        with self.assertRaisesRegex(TypeError, \"must be str\"):\n            self.df.rank(\"bar\", 1)", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_type_hints.py_25-75"}
{"title": "maxhumber_redframes-tests-test_type_hints.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_type_hints.py"], "line_no": 60, "start_line_no": 35, "end_line_no": 85, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "\n    def test_io_save_bad_object(self):\n        with self.assertRaisesRegex(TypeError, \"must be DataFrame\"):\n            rf.save(1, \"example.csv\")\n\n    def test_io_save_bad_path(self):\n        with self.assertRaisesRegex(TypeError, \"must be str\"):\n            rf.save(self.df, 1)\n\n    def test_io_save_bad_format(self):\n        with self.assertRaisesRegex(TypeError, \"must end in .csv\"):\n            rf.save(self.df, \"example.json\")\n\n    def test_io_unwrap_bad_object(self):\n        with self.assertRaisesRegex(TypeError, \"must be DataFrame\"):\n            rf.unwrap(1)\n\n    def test_io_wrap_bad_object(self):\n        with self.assertRaisesRegex(TypeError, \"must be DataFrame\"):\n            rf.unwrap(1)\n\n    def test_take_bad_rows(self):\n        with self.assertRaisesRegex(TypeError, \"must be int\"):\n            self.df.take(\"A\")\n\n    def test_accumulate_bad_column(self):\n        with self.assertRaisesRegex(TypeError, \"must be str\"):\n            self.df.accumulate(1, \"foo\")\n\n    def test_accumulate_bad_into_column(self):\n        with self.assertRaisesRegex(TypeError, \"must be str\"):\n            self.df.accumulate(\"foo\", 1)\n\n    def test_rank_bad_column(self):\n        with self.assertRaisesRegex(TypeError, \"must be str\"):\n            self.df.rank(1, \"bar2\")\n\n    def test_rank_bad_into_column(self):\n        with self.assertRaisesRegex(TypeError, \"must be str\"):\n            self.df.rank(\"bar\", 1)\n\n    def test_rank_bad_descending_argument(self):\n        with self.assertRaisesRegex(TypeError, \"must be bool\"):\n            self.df.rank(\"bar\", \"bar\", descending=\"bar\")\n\n    def test_rollup_bad_over(self):\n        with self.assertRaisesRegex(TypeError, \"must be dict\"):\n            self.df.rollup(1)\n\n    def test_rollup_bad_over_values(self):", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_type_hints.py_35-85"}
{"title": "maxhumber_redframes-tests-test_type_hints.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_type_hints.py"], "line_no": 70, "start_line_no": 45, "end_line_no": 95, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        with self.assertRaisesRegex(TypeError, \"must end in .csv\"):\n            rf.save(self.df, \"example.json\")\n\n    def test_io_unwrap_bad_object(self):\n        with self.assertRaisesRegex(TypeError, \"must be DataFrame\"):\n            rf.unwrap(1)\n\n    def test_io_wrap_bad_object(self):\n        with self.assertRaisesRegex(TypeError, \"must be DataFrame\"):\n            rf.unwrap(1)\n\n    def test_take_bad_rows(self):\n        with self.assertRaisesRegex(TypeError, \"must be int\"):\n            self.df.take(\"A\")\n\n    def test_accumulate_bad_column(self):\n        with self.assertRaisesRegex(TypeError, \"must be str\"):\n            self.df.accumulate(1, \"foo\")\n\n    def test_accumulate_bad_into_column(self):\n        with self.assertRaisesRegex(TypeError, \"must be str\"):\n            self.df.accumulate(\"foo\", 1)\n\n    def test_rank_bad_column(self):\n        with self.assertRaisesRegex(TypeError, \"must be str\"):\n            self.df.rank(1, \"bar2\")\n\n    def test_rank_bad_into_column(self):\n        with self.assertRaisesRegex(TypeError, \"must be str\"):\n            self.df.rank(\"bar\", 1)\n\n    def test_rank_bad_descending_argument(self):\n        with self.assertRaisesRegex(TypeError, \"must be bool\"):\n            self.df.rank(\"bar\", \"bar\", descending=\"bar\")\n\n    def test_rollup_bad_over(self):\n        with self.assertRaisesRegex(TypeError, \"must be dict\"):\n            self.df.rollup(1)\n\n    def test_rollup_bad_over_values(self):\n        with self.assertRaises(TypeError):\n            self.df.rollup({\"bar_mean\": 1})\n\n    def test_init_bad_data(self):\n        with self.assertRaisesRegex(TypeError, \"must be dict | None\"):\n            rf.DataFrame(1)\n\n    def test_eq_bad_rhs_object(self):\n        self.assertFalse(self.df == 1)\n", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_type_hints.py_45-95"}
{"title": "maxhumber_redframes-tests-test_type_hints.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_type_hints.py"], "line_no": 80, "start_line_no": 55, "end_line_no": 105, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "\n    def test_take_bad_rows(self):\n        with self.assertRaisesRegex(TypeError, \"must be int\"):\n            self.df.take(\"A\")\n\n    def test_accumulate_bad_column(self):\n        with self.assertRaisesRegex(TypeError, \"must be str\"):\n            self.df.accumulate(1, \"foo\")\n\n    def test_accumulate_bad_into_column(self):\n        with self.assertRaisesRegex(TypeError, \"must be str\"):\n            self.df.accumulate(\"foo\", 1)\n\n    def test_rank_bad_column(self):\n        with self.assertRaisesRegex(TypeError, \"must be str\"):\n            self.df.rank(1, \"bar2\")\n\n    def test_rank_bad_into_column(self):\n        with self.assertRaisesRegex(TypeError, \"must be str\"):\n            self.df.rank(\"bar\", 1)\n\n    def test_rank_bad_descending_argument(self):\n        with self.assertRaisesRegex(TypeError, \"must be bool\"):\n            self.df.rank(\"bar\", \"bar\", descending=\"bar\")\n\n    def test_rollup_bad_over(self):\n        with self.assertRaisesRegex(TypeError, \"must be dict\"):\n            self.df.rollup(1)\n\n    def test_rollup_bad_over_values(self):\n        with self.assertRaises(TypeError):\n            self.df.rollup({\"bar_mean\": 1})\n\n    def test_init_bad_data(self):\n        with self.assertRaisesRegex(TypeError, \"must be dict | None\"):\n            rf.DataFrame(1)\n\n    def test_eq_bad_rhs_object(self):\n        self.assertFalse(self.df == 1)\n\n    def test_getitem_bad_key(self):\n        pass\n\n    def test_append_bad_other(self):\n        with self.assertRaisesRegex(TypeError, \"must be DataFrame\"):\n            self.df.append(1)\n\n    def test_combine_bad_columns(self):\n        with self.assertRaisesRegex(TypeError, \"must be list\"):\n            self.df.combine(1, \"foo\", sep=\"-\")", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_type_hints.py_55-105"}
{"title": "maxhumber_redframes-tests-test_type_hints.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_type_hints.py"], "line_no": 90, "start_line_no": 65, "end_line_no": 115, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        with self.assertRaisesRegex(TypeError, \"must be str\"):\n            self.df.accumulate(\"foo\", 1)\n\n    def test_rank_bad_column(self):\n        with self.assertRaisesRegex(TypeError, \"must be str\"):\n            self.df.rank(1, \"bar2\")\n\n    def test_rank_bad_into_column(self):\n        with self.assertRaisesRegex(TypeError, \"must be str\"):\n            self.df.rank(\"bar\", 1)\n\n    def test_rank_bad_descending_argument(self):\n        with self.assertRaisesRegex(TypeError, \"must be bool\"):\n            self.df.rank(\"bar\", \"bar\", descending=\"bar\")\n\n    def test_rollup_bad_over(self):\n        with self.assertRaisesRegex(TypeError, \"must be dict\"):\n            self.df.rollup(1)\n\n    def test_rollup_bad_over_values(self):\n        with self.assertRaises(TypeError):\n            self.df.rollup({\"bar_mean\": 1})\n\n    def test_init_bad_data(self):\n        with self.assertRaisesRegex(TypeError, \"must be dict | None\"):\n            rf.DataFrame(1)\n\n    def test_eq_bad_rhs_object(self):\n        self.assertFalse(self.df == 1)\n\n    def test_getitem_bad_key(self):\n        pass\n\n    def test_append_bad_other(self):\n        with self.assertRaisesRegex(TypeError, \"must be DataFrame\"):\n            self.df.append(1)\n\n    def test_combine_bad_columns(self):\n        with self.assertRaisesRegex(TypeError, \"must be list\"):\n            self.df.combine(1, \"foo\", sep=\"-\")\n\n    def test_combine_bad_into_column(self):\n        with self.assertRaisesRegex(TypeError, \"must be str\"):\n            self.df.combine([\"foo\", \"bar\"], 1, sep=\"-\")\n\n    def test_combine_bad_sep_argument(self):\n        with self.assertRaisesRegex(TypeError, \"must be str\"):\n            self.df.combine([\"foo\", \"bar\"], \"foo\", sep=1)\n\n    def test_combine_bad_drop_argument(self):", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_type_hints.py_65-115"}
{"title": "maxhumber_redframes-tests-test_type_hints.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_type_hints.py"], "line_no": 100, "start_line_no": 75, "end_line_no": 125, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "\n    def test_rank_bad_descending_argument(self):\n        with self.assertRaisesRegex(TypeError, \"must be bool\"):\n            self.df.rank(\"bar\", \"bar\", descending=\"bar\")\n\n    def test_rollup_bad_over(self):\n        with self.assertRaisesRegex(TypeError, \"must be dict\"):\n            self.df.rollup(1)\n\n    def test_rollup_bad_over_values(self):\n        with self.assertRaises(TypeError):\n            self.df.rollup({\"bar_mean\": 1})\n\n    def test_init_bad_data(self):\n        with self.assertRaisesRegex(TypeError, \"must be dict | None\"):\n            rf.DataFrame(1)\n\n    def test_eq_bad_rhs_object(self):\n        self.assertFalse(self.df == 1)\n\n    def test_getitem_bad_key(self):\n        pass\n\n    def test_append_bad_other(self):\n        with self.assertRaisesRegex(TypeError, \"must be DataFrame\"):\n            self.df.append(1)\n\n    def test_combine_bad_columns(self):\n        with self.assertRaisesRegex(TypeError, \"must be list\"):\n            self.df.combine(1, \"foo\", sep=\"-\")\n\n    def test_combine_bad_into_column(self):\n        with self.assertRaisesRegex(TypeError, \"must be str\"):\n            self.df.combine([\"foo\", \"bar\"], 1, sep=\"-\")\n\n    def test_combine_bad_sep_argument(self):\n        with self.assertRaisesRegex(TypeError, \"must be str\"):\n            self.df.combine([\"foo\", \"bar\"], \"foo\", sep=1)\n\n    def test_combine_bad_drop_argument(self):\n        with self.assertRaisesRegex(TypeError, \"must be bool\"):\n            self.df.combine([\"foo\", \"bar\"], \"foo\", sep=\":::\", drop=\"A\")\n\n    def test_dedupe_bad_columns(self):\n        with self.assertRaisesRegex(TypeError, \"must be list | str | None\"):\n            self.df.dedupe(1)\n\n    def test_denix_bad_columns(self):\n        with self.assertRaisesRegex(TypeError, \"must be list | str | None\"):\n            self.df.denix(1)", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_type_hints.py_75-125"}
{"title": "maxhumber_redframes-tests-test_type_hints.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_type_hints.py"], "line_no": 110, "start_line_no": 85, "end_line_no": 135, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        with self.assertRaises(TypeError):\n            self.df.rollup({\"bar_mean\": 1})\n\n    def test_init_bad_data(self):\n        with self.assertRaisesRegex(TypeError, \"must be dict | None\"):\n            rf.DataFrame(1)\n\n    def test_eq_bad_rhs_object(self):\n        self.assertFalse(self.df == 1)\n\n    def test_getitem_bad_key(self):\n        pass\n\n    def test_append_bad_other(self):\n        with self.assertRaisesRegex(TypeError, \"must be DataFrame\"):\n            self.df.append(1)\n\n    def test_combine_bad_columns(self):\n        with self.assertRaisesRegex(TypeError, \"must be list\"):\n            self.df.combine(1, \"foo\", sep=\"-\")\n\n    def test_combine_bad_into_column(self):\n        with self.assertRaisesRegex(TypeError, \"must be str\"):\n            self.df.combine([\"foo\", \"bar\"], 1, sep=\"-\")\n\n    def test_combine_bad_sep_argument(self):\n        with self.assertRaisesRegex(TypeError, \"must be str\"):\n            self.df.combine([\"foo\", \"bar\"], \"foo\", sep=1)\n\n    def test_combine_bad_drop_argument(self):\n        with self.assertRaisesRegex(TypeError, \"must be bool\"):\n            self.df.combine([\"foo\", \"bar\"], \"foo\", sep=\":::\", drop=\"A\")\n\n    def test_dedupe_bad_columns(self):\n        with self.assertRaisesRegex(TypeError, \"must be list | str | None\"):\n            self.df.dedupe(1)\n\n    def test_denix_bad_columns(self):\n        with self.assertRaisesRegex(TypeError, \"must be list | str | None\"):\n            self.df.denix(1)\n\n    def test_drop_bad_columns(self):\n        with self.assertRaisesRegex(TypeError, \"must be list | str | None\"):\n            self.df.drop(1)\n\n    def test_fill_bad_columns(self):\n        with self.assertRaisesRegex(TypeError, \"must be list | str | None\"):\n            self.df.fill(1)\n\n    def test_fill_bad_direction(self):", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_type_hints.py_85-135"}
{"title": "maxhumber_redframes-tests-test_type_hints.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_type_hints.py"], "line_no": 120, "start_line_no": 95, "end_line_no": 145, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "    def test_getitem_bad_key(self):\n        pass\n\n    def test_append_bad_other(self):\n        with self.assertRaisesRegex(TypeError, \"must be DataFrame\"):\n            self.df.append(1)\n\n    def test_combine_bad_columns(self):\n        with self.assertRaisesRegex(TypeError, \"must be list\"):\n            self.df.combine(1, \"foo\", sep=\"-\")\n\n    def test_combine_bad_into_column(self):\n        with self.assertRaisesRegex(TypeError, \"must be str\"):\n            self.df.combine([\"foo\", \"bar\"], 1, sep=\"-\")\n\n    def test_combine_bad_sep_argument(self):\n        with self.assertRaisesRegex(TypeError, \"must be str\"):\n            self.df.combine([\"foo\", \"bar\"], \"foo\", sep=1)\n\n    def test_combine_bad_drop_argument(self):\n        with self.assertRaisesRegex(TypeError, \"must be bool\"):\n            self.df.combine([\"foo\", \"bar\"], \"foo\", sep=\":::\", drop=\"A\")\n\n    def test_dedupe_bad_columns(self):\n        with self.assertRaisesRegex(TypeError, \"must be list | str | None\"):\n            self.df.dedupe(1)\n\n    def test_denix_bad_columns(self):\n        with self.assertRaisesRegex(TypeError, \"must be list | str | None\"):\n            self.df.denix(1)\n\n    def test_drop_bad_columns(self):\n        with self.assertRaisesRegex(TypeError, \"must be list | str | None\"):\n            self.df.drop(1)\n\n    def test_fill_bad_columns(self):\n        with self.assertRaisesRegex(TypeError, \"must be list | str | None\"):\n            self.df.fill(1)\n\n    def test_fill_bad_direction(self):\n        with self.assertRaisesRegex(ValueError, \"must be one of {'down', 'up'}\"):\n            self.df.fill(\"bar\", direction=\"sideways\")\n\n    def test_fill_bad_constant_and_direction(self):\n        with self.assertRaisesRegex(\n            ValueError, \"either direction OR constant must not be None\"\n        ):\n            self.df.fill(\"bar\")\n\n    def test_fill_bad_no_constant_nor_direction(self):", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_type_hints.py_95-145"}
{"title": "maxhumber_redframes-tests-test_type_hints.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_type_hints.py"], "line_no": 130, "start_line_no": 105, "end_line_no": 155, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "\n    def test_combine_bad_into_column(self):\n        with self.assertRaisesRegex(TypeError, \"must be str\"):\n            self.df.combine([\"foo\", \"bar\"], 1, sep=\"-\")\n\n    def test_combine_bad_sep_argument(self):\n        with self.assertRaisesRegex(TypeError, \"must be str\"):\n            self.df.combine([\"foo\", \"bar\"], \"foo\", sep=1)\n\n    def test_combine_bad_drop_argument(self):\n        with self.assertRaisesRegex(TypeError, \"must be bool\"):\n            self.df.combine([\"foo\", \"bar\"], \"foo\", sep=\":::\", drop=\"A\")\n\n    def test_dedupe_bad_columns(self):\n        with self.assertRaisesRegex(TypeError, \"must be list | str | None\"):\n            self.df.dedupe(1)\n\n    def test_denix_bad_columns(self):\n        with self.assertRaisesRegex(TypeError, \"must be list | str | None\"):\n            self.df.denix(1)\n\n    def test_drop_bad_columns(self):\n        with self.assertRaisesRegex(TypeError, \"must be list | str | None\"):\n            self.df.drop(1)\n\n    def test_fill_bad_columns(self):\n        with self.assertRaisesRegex(TypeError, \"must be list | str | None\"):\n            self.df.fill(1)\n\n    def test_fill_bad_direction(self):\n        with self.assertRaisesRegex(ValueError, \"must be one of {'down', 'up'}\"):\n            self.df.fill(\"bar\", direction=\"sideways\")\n\n    def test_fill_bad_constant_and_direction(self):\n        with self.assertRaisesRegex(\n            ValueError, \"either direction OR constant must not be None\"\n        ):\n            self.df.fill(\"bar\")\n\n    def test_fill_bad_no_constant_nor_direction(self):\n        with self.assertRaisesRegex(\n            ValueError, \"either direction OR constant must be None\"\n        ):\n            self.df.fill(\"bar\", direction=\"down\", constant=\"X\")\n\n    def test_filter_bad_func(self):\n        with self.assertRaisesRegex(TypeError, \"must be Func\"):\n            self.df.filter(1)\n\n    def test_gather_bad_columns(self):", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_type_hints.py_105-155"}
{"title": "maxhumber_redframes-tests-test_type_hints.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_type_hints.py"], "line_no": 140, "start_line_no": 115, "end_line_no": 165, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        with self.assertRaisesRegex(TypeError, \"must be bool\"):\n            self.df.combine([\"foo\", \"bar\"], \"foo\", sep=\":::\", drop=\"A\")\n\n    def test_dedupe_bad_columns(self):\n        with self.assertRaisesRegex(TypeError, \"must be list | str | None\"):\n            self.df.dedupe(1)\n\n    def test_denix_bad_columns(self):\n        with self.assertRaisesRegex(TypeError, \"must be list | str | None\"):\n            self.df.denix(1)\n\n    def test_drop_bad_columns(self):\n        with self.assertRaisesRegex(TypeError, \"must be list | str | None\"):\n            self.df.drop(1)\n\n    def test_fill_bad_columns(self):\n        with self.assertRaisesRegex(TypeError, \"must be list | str | None\"):\n            self.df.fill(1)\n\n    def test_fill_bad_direction(self):\n        with self.assertRaisesRegex(ValueError, \"must be one of {'down', 'up'}\"):\n            self.df.fill(\"bar\", direction=\"sideways\")\n\n    def test_fill_bad_constant_and_direction(self):\n        with self.assertRaisesRegex(\n            ValueError, \"either direction OR constant must not be None\"\n        ):\n            self.df.fill(\"bar\")\n\n    def test_fill_bad_no_constant_nor_direction(self):\n        with self.assertRaisesRegex(\n            ValueError, \"either direction OR constant must be None\"\n        ):\n            self.df.fill(\"bar\", direction=\"down\", constant=\"X\")\n\n    def test_filter_bad_func(self):\n        with self.assertRaisesRegex(TypeError, \"must be Func\"):\n            self.df.filter(1)\n\n    def test_gather_bad_columns(self):\n        with self.assertRaisesRegex(TypeError, \"must be list | None\"):\n            self.df.gather(1)\n\n    def test_gather_bad_beside(self):\n        with self.assertRaisesRegex(TypeError, \"must be str | list | None\"):\n            self.df.gather(beside=1)\n\n    def test_gather_bad_into_column(self):\n        with self.assertRaisesRegex(TypeError, \"must be tuple\"):\n            self.df.gather([\"foo\", \"bar\"], into=1)", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_type_hints.py_115-165"}
{"title": "maxhumber_redframes-tests-test_type_hints.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_type_hints.py"], "line_no": 150, "start_line_no": 125, "end_line_no": 175, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "\n    def test_drop_bad_columns(self):\n        with self.assertRaisesRegex(TypeError, \"must be list | str | None\"):\n            self.df.drop(1)\n\n    def test_fill_bad_columns(self):\n        with self.assertRaisesRegex(TypeError, \"must be list | str | None\"):\n            self.df.fill(1)\n\n    def test_fill_bad_direction(self):\n        with self.assertRaisesRegex(ValueError, \"must be one of {'down', 'up'}\"):\n            self.df.fill(\"bar\", direction=\"sideways\")\n\n    def test_fill_bad_constant_and_direction(self):\n        with self.assertRaisesRegex(\n            ValueError, \"either direction OR constant must not be None\"\n        ):\n            self.df.fill(\"bar\")\n\n    def test_fill_bad_no_constant_nor_direction(self):\n        with self.assertRaisesRegex(\n            ValueError, \"either direction OR constant must be None\"\n        ):\n            self.df.fill(\"bar\", direction=\"down\", constant=\"X\")\n\n    def test_filter_bad_func(self):\n        with self.assertRaisesRegex(TypeError, \"must be Func\"):\n            self.df.filter(1)\n\n    def test_gather_bad_columns(self):\n        with self.assertRaisesRegex(TypeError, \"must be list | None\"):\n            self.df.gather(1)\n\n    def test_gather_bad_beside(self):\n        with self.assertRaisesRegex(TypeError, \"must be str | list | None\"):\n            self.df.gather(beside=1)\n\n    def test_gather_bad_into_column(self):\n        with self.assertRaisesRegex(TypeError, \"must be tuple\"):\n            self.df.gather([\"foo\", \"bar\"], into=1)\n\n    def test_gather_bad_into_tuple(self):\n        with self.assertRaisesRegex(TypeError, \"must be tuple*\"):\n            self.df.gather(into=(\"one\", \"two\", \"three\"))\n\n    def test_gather_bad_both_not_none(self):\n        with self.assertRaisesRegex(ValueError, \"columns OR beside must be None\"):\n            self.df.gather(columns=[\"foo\", \"bar\"], beside=[\"baz\"])\n\n    def test_group_bad_by_columns(self):", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_type_hints.py_125-175"}
{"title": "maxhumber_redframes-tests-test_type_hints.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_type_hints.py"], "line_no": 160, "start_line_no": 135, "end_line_no": 185, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        with self.assertRaisesRegex(ValueError, \"must be one of {'down', 'up'}\"):\n            self.df.fill(\"bar\", direction=\"sideways\")\n\n    def test_fill_bad_constant_and_direction(self):\n        with self.assertRaisesRegex(\n            ValueError, \"either direction OR constant must not be None\"\n        ):\n            self.df.fill(\"bar\")\n\n    def test_fill_bad_no_constant_nor_direction(self):\n        with self.assertRaisesRegex(\n            ValueError, \"either direction OR constant must be None\"\n        ):\n            self.df.fill(\"bar\", direction=\"down\", constant=\"X\")\n\n    def test_filter_bad_func(self):\n        with self.assertRaisesRegex(TypeError, \"must be Func\"):\n            self.df.filter(1)\n\n    def test_gather_bad_columns(self):\n        with self.assertRaisesRegex(TypeError, \"must be list | None\"):\n            self.df.gather(1)\n\n    def test_gather_bad_beside(self):\n        with self.assertRaisesRegex(TypeError, \"must be str | list | None\"):\n            self.df.gather(beside=1)\n\n    def test_gather_bad_into_column(self):\n        with self.assertRaisesRegex(TypeError, \"must be tuple\"):\n            self.df.gather([\"foo\", \"bar\"], into=1)\n\n    def test_gather_bad_into_tuple(self):\n        with self.assertRaisesRegex(TypeError, \"must be tuple*\"):\n            self.df.gather(into=(\"one\", \"two\", \"three\"))\n\n    def test_gather_bad_both_not_none(self):\n        with self.assertRaisesRegex(ValueError, \"columns OR beside must be None\"):\n            self.df.gather(columns=[\"foo\", \"bar\"], beside=[\"baz\"])\n\n    def test_group_bad_by_columns(self):\n        with self.assertRaisesRegex(TypeError, \"must be list | str\"):\n            self.df.group(1)\n\n    def test_join_bad_rhs_object(self):\n        with self.assertRaisesRegex(TypeError, \"must be DataFrame\"):\n            self.df.join(1, on=\"baz\")\n\n    def test_join_bad_on_type(self):\n        rhs = rf.DataFrame()\n        with self.assertRaisesRegex(TypeError, \"must be list | str\"):", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_type_hints.py_135-185"}
{"title": "maxhumber_redframes-tests-test_type_hints.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_type_hints.py"], "line_no": 170, "start_line_no": 145, "end_line_no": 195, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        with self.assertRaisesRegex(\n            ValueError, \"either direction OR constant must be None\"\n        ):\n            self.df.fill(\"bar\", direction=\"down\", constant=\"X\")\n\n    def test_filter_bad_func(self):\n        with self.assertRaisesRegex(TypeError, \"must be Func\"):\n            self.df.filter(1)\n\n    def test_gather_bad_columns(self):\n        with self.assertRaisesRegex(TypeError, \"must be list | None\"):\n            self.df.gather(1)\n\n    def test_gather_bad_beside(self):\n        with self.assertRaisesRegex(TypeError, \"must be str | list | None\"):\n            self.df.gather(beside=1)\n\n    def test_gather_bad_into_column(self):\n        with self.assertRaisesRegex(TypeError, \"must be tuple\"):\n            self.df.gather([\"foo\", \"bar\"], into=1)\n\n    def test_gather_bad_into_tuple(self):\n        with self.assertRaisesRegex(TypeError, \"must be tuple*\"):\n            self.df.gather(into=(\"one\", \"two\", \"three\"))\n\n    def test_gather_bad_both_not_none(self):\n        with self.assertRaisesRegex(ValueError, \"columns OR beside must be None\"):\n            self.df.gather(columns=[\"foo\", \"bar\"], beside=[\"baz\"])\n\n    def test_group_bad_by_columns(self):\n        with self.assertRaisesRegex(TypeError, \"must be list | str\"):\n            self.df.group(1)\n\n    def test_join_bad_rhs_object(self):\n        with self.assertRaisesRegex(TypeError, \"must be DataFrame\"):\n            self.df.join(1, on=\"baz\")\n\n    def test_join_bad_on_type(self):\n        rhs = rf.DataFrame()\n        with self.assertRaisesRegex(TypeError, \"must be list | str\"):\n            self.df.join(rhs, on=1)\n\n    def test_join_bad_how_argument(self):\n        rhs = rf.DataFrame()\n        message = (\n            \"on argument is invalid, must be one of {'left', 'right', 'inner', 'full'}\"\n        )\n        with self.assertRaisesRegex(ValueError, message):\n            self.df.join(rhs, on=\"baz\", how=\"inside\")\n", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_type_hints.py_145-195"}
{"title": "maxhumber_redframes-tests-test_type_hints.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_type_hints.py"], "line_no": 180, "start_line_no": 155, "end_line_no": 205, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        with self.assertRaisesRegex(TypeError, \"must be list | None\"):\n            self.df.gather(1)\n\n    def test_gather_bad_beside(self):\n        with self.assertRaisesRegex(TypeError, \"must be str | list | None\"):\n            self.df.gather(beside=1)\n\n    def test_gather_bad_into_column(self):\n        with self.assertRaisesRegex(TypeError, \"must be tuple\"):\n            self.df.gather([\"foo\", \"bar\"], into=1)\n\n    def test_gather_bad_into_tuple(self):\n        with self.assertRaisesRegex(TypeError, \"must be tuple*\"):\n            self.df.gather(into=(\"one\", \"two\", \"three\"))\n\n    def test_gather_bad_both_not_none(self):\n        with self.assertRaisesRegex(ValueError, \"columns OR beside must be None\"):\n            self.df.gather(columns=[\"foo\", \"bar\"], beside=[\"baz\"])\n\n    def test_group_bad_by_columns(self):\n        with self.assertRaisesRegex(TypeError, \"must be list | str\"):\n            self.df.group(1)\n\n    def test_join_bad_rhs_object(self):\n        with self.assertRaisesRegex(TypeError, \"must be DataFrame\"):\n            self.df.join(1, on=\"baz\")\n\n    def test_join_bad_on_type(self):\n        rhs = rf.DataFrame()\n        with self.assertRaisesRegex(TypeError, \"must be list | str\"):\n            self.df.join(rhs, on=1)\n\n    def test_join_bad_how_argument(self):\n        rhs = rf.DataFrame()\n        message = (\n            \"on argument is invalid, must be one of {'left', 'right', 'inner', 'full'}\"\n        )\n        with self.assertRaisesRegex(ValueError, message):\n            self.df.join(rhs, on=\"baz\", how=\"inside\")\n\n    def test_mutate_bad_over(self):\n        with self.assertRaisesRegex(TypeError, \"must be dict\"):\n            self.df.mutate(1)\n\n    def test_pack_bad_column(self):\n        with self.assertRaisesRegex(TypeError, \"must be str\"):\n            self.df.pack(1, sep=\"|\")\n\n    def test_pack_bad_sep(self):\n        with self.assertRaisesRegex(TypeError, \"must be str\"):", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_type_hints.py_155-205"}
{"title": "maxhumber_redframes-tests-test_type_hints.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_type_hints.py"], "line_no": 190, "start_line_no": 165, "end_line_no": 215, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "\n    def test_gather_bad_into_tuple(self):\n        with self.assertRaisesRegex(TypeError, \"must be tuple*\"):\n            self.df.gather(into=(\"one\", \"two\", \"three\"))\n\n    def test_gather_bad_both_not_none(self):\n        with self.assertRaisesRegex(ValueError, \"columns OR beside must be None\"):\n            self.df.gather(columns=[\"foo\", \"bar\"], beside=[\"baz\"])\n\n    def test_group_bad_by_columns(self):\n        with self.assertRaisesRegex(TypeError, \"must be list | str\"):\n            self.df.group(1)\n\n    def test_join_bad_rhs_object(self):\n        with self.assertRaisesRegex(TypeError, \"must be DataFrame\"):\n            self.df.join(1, on=\"baz\")\n\n    def test_join_bad_on_type(self):\n        rhs = rf.DataFrame()\n        with self.assertRaisesRegex(TypeError, \"must be list | str\"):\n            self.df.join(rhs, on=1)\n\n    def test_join_bad_how_argument(self):\n        rhs = rf.DataFrame()\n        message = (\n            \"on argument is invalid, must be one of {'left', 'right', 'inner', 'full'}\"\n        )\n        with self.assertRaisesRegex(ValueError, message):\n            self.df.join(rhs, on=\"baz\", how=\"inside\")\n\n    def test_mutate_bad_over(self):\n        with self.assertRaisesRegex(TypeError, \"must be dict\"):\n            self.df.mutate(1)\n\n    def test_pack_bad_column(self):\n        with self.assertRaisesRegex(TypeError, \"must be str\"):\n            self.df.pack(1, sep=\"|\")\n\n    def test_pack_bad_sep(self):\n        with self.assertRaisesRegex(TypeError, \"must be str\"):\n            self.df.pack(\"baz\", sep=1)\n\n    def test_rename_bad_columns(self):\n        with self.assertRaisesRegex(TypeError, \"must be dict\"):\n            self.df.rename(1)\n\n    def test_rename_bad_columns_values(self):\n        with self.assertRaisesRegex(TypeError, \"must be str\"):\n            self.df.rename({\"foo\": 1})\n", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_type_hints.py_165-215"}
{"title": "maxhumber_redframes-tests-test_type_hints.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_type_hints.py"], "line_no": 200, "start_line_no": 175, "end_line_no": 225, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        with self.assertRaisesRegex(TypeError, \"must be list | str\"):\n            self.df.group(1)\n\n    def test_join_bad_rhs_object(self):\n        with self.assertRaisesRegex(TypeError, \"must be DataFrame\"):\n            self.df.join(1, on=\"baz\")\n\n    def test_join_bad_on_type(self):\n        rhs = rf.DataFrame()\n        with self.assertRaisesRegex(TypeError, \"must be list | str\"):\n            self.df.join(rhs, on=1)\n\n    def test_join_bad_how_argument(self):\n        rhs = rf.DataFrame()\n        message = (\n            \"on argument is invalid, must be one of {'left', 'right', 'inner', 'full'}\"\n        )\n        with self.assertRaisesRegex(ValueError, message):\n            self.df.join(rhs, on=\"baz\", how=\"inside\")\n\n    def test_mutate_bad_over(self):\n        with self.assertRaisesRegex(TypeError, \"must be dict\"):\n            self.df.mutate(1)\n\n    def test_pack_bad_column(self):\n        with self.assertRaisesRegex(TypeError, \"must be str\"):\n            self.df.pack(1, sep=\"|\")\n\n    def test_pack_bad_sep(self):\n        with self.assertRaisesRegex(TypeError, \"must be str\"):\n            self.df.pack(\"baz\", sep=1)\n\n    def test_rename_bad_columns(self):\n        with self.assertRaisesRegex(TypeError, \"must be dict\"):\n            self.df.rename(1)\n\n    def test_rename_bad_columns_values(self):\n        with self.assertRaisesRegex(TypeError, \"must be str\"):\n            self.df.rename({\"foo\": 1})\n\n    def test_replace_bad_over(self):\n        with self.assertRaisesRegex(TypeError, \"must be dict\"):\n            self.df.replace(1)\n\n    def test_sample_bad_rows(self):\n        with self.assertRaisesRegex(TypeError, \"must be int | float\"):\n            self.df.sample(\"A\")\n\n    def test_select_bad_columns(self):\n        with self.assertRaisesRegex(TypeError, \"must be list | str\"):", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_type_hints.py_175-225"}
{"title": "maxhumber_redframes-tests-test_type_hints.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_type_hints.py"], "line_no": 210, "start_line_no": 185, "end_line_no": 235, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "            self.df.join(rhs, on=1)\n\n    def test_join_bad_how_argument(self):\n        rhs = rf.DataFrame()\n        message = (\n            \"on argument is invalid, must be one of {'left', 'right', 'inner', 'full'}\"\n        )\n        with self.assertRaisesRegex(ValueError, message):\n            self.df.join(rhs, on=\"baz\", how=\"inside\")\n\n    def test_mutate_bad_over(self):\n        with self.assertRaisesRegex(TypeError, \"must be dict\"):\n            self.df.mutate(1)\n\n    def test_pack_bad_column(self):\n        with self.assertRaisesRegex(TypeError, \"must be str\"):\n            self.df.pack(1, sep=\"|\")\n\n    def test_pack_bad_sep(self):\n        with self.assertRaisesRegex(TypeError, \"must be str\"):\n            self.df.pack(\"baz\", sep=1)\n\n    def test_rename_bad_columns(self):\n        with self.assertRaisesRegex(TypeError, \"must be dict\"):\n            self.df.rename(1)\n\n    def test_rename_bad_columns_values(self):\n        with self.assertRaisesRegex(TypeError, \"must be str\"):\n            self.df.rename({\"foo\": 1})\n\n    def test_replace_bad_over(self):\n        with self.assertRaisesRegex(TypeError, \"must be dict\"):\n            self.df.replace(1)\n\n    def test_sample_bad_rows(self):\n        with self.assertRaisesRegex(TypeError, \"must be int | float\"):\n            self.df.sample(\"A\")\n\n    def test_select_bad_columns(self):\n        with self.assertRaisesRegex(TypeError, \"must be list | str\"):\n            self.df.select(1)\n\n    def test_shuffle(self):\n        pass\n\n    def test_sort_bad_columns(self):\n        with self.assertRaisesRegex(TypeError, \"must be list | str\"):\n            self.df.sort(1)\n\n    def test_sort_bad_descending_argument(self):", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_type_hints.py_185-235"}
{"title": "maxhumber_redframes-tests-test_type_hints.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_type_hints.py"], "line_no": 220, "start_line_no": 195, "end_line_no": 245, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "    def test_mutate_bad_over(self):\n        with self.assertRaisesRegex(TypeError, \"must be dict\"):\n            self.df.mutate(1)\n\n    def test_pack_bad_column(self):\n        with self.assertRaisesRegex(TypeError, \"must be str\"):\n            self.df.pack(1, sep=\"|\")\n\n    def test_pack_bad_sep(self):\n        with self.assertRaisesRegex(TypeError, \"must be str\"):\n            self.df.pack(\"baz\", sep=1)\n\n    def test_rename_bad_columns(self):\n        with self.assertRaisesRegex(TypeError, \"must be dict\"):\n            self.df.rename(1)\n\n    def test_rename_bad_columns_values(self):\n        with self.assertRaisesRegex(TypeError, \"must be str\"):\n            self.df.rename({\"foo\": 1})\n\n    def test_replace_bad_over(self):\n        with self.assertRaisesRegex(TypeError, \"must be dict\"):\n            self.df.replace(1)\n\n    def test_sample_bad_rows(self):\n        with self.assertRaisesRegex(TypeError, \"must be int | float\"):\n            self.df.sample(\"A\")\n\n    def test_select_bad_columns(self):\n        with self.assertRaisesRegex(TypeError, \"must be list | str\"):\n            self.df.select(1)\n\n    def test_shuffle(self):\n        pass\n\n    def test_sort_bad_columns(self):\n        with self.assertRaisesRegex(TypeError, \"must be list | str\"):\n            self.df.sort(1)\n\n    def test_sort_bad_descending_argument(self):\n        with self.assertRaisesRegex(TypeError, \"must be bool\"):\n            self.df.sort(\"bar\", descending=\"A\")\n\n    def test_split_bad_column(self):\n        with self.assertRaisesRegex(TypeError, \"must be str\"):\n            self.df.split(1, into=[\"jaz1\", \"jaz2\"], sep=\"::\")\n\n    def test_split_bad_into_column(self):\n        with self.assertRaisesRegex(TypeError, \"must be list\"):\n            self.df.split(\"jaz\", into=1, sep=\"::\")", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_type_hints.py_195-245"}
{"title": "maxhumber_redframes-tests-test_type_hints.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_type_hints.py"], "line_no": 230, "start_line_no": 205, "end_line_no": 255, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "            self.df.pack(\"baz\", sep=1)\n\n    def test_rename_bad_columns(self):\n        with self.assertRaisesRegex(TypeError, \"must be dict\"):\n            self.df.rename(1)\n\n    def test_rename_bad_columns_values(self):\n        with self.assertRaisesRegex(TypeError, \"must be str\"):\n            self.df.rename({\"foo\": 1})\n\n    def test_replace_bad_over(self):\n        with self.assertRaisesRegex(TypeError, \"must be dict\"):\n            self.df.replace(1)\n\n    def test_sample_bad_rows(self):\n        with self.assertRaisesRegex(TypeError, \"must be int | float\"):\n            self.df.sample(\"A\")\n\n    def test_select_bad_columns(self):\n        with self.assertRaisesRegex(TypeError, \"must be list | str\"):\n            self.df.select(1)\n\n    def test_shuffle(self):\n        pass\n\n    def test_sort_bad_columns(self):\n        with self.assertRaisesRegex(TypeError, \"must be list | str\"):\n            self.df.sort(1)\n\n    def test_sort_bad_descending_argument(self):\n        with self.assertRaisesRegex(TypeError, \"must be bool\"):\n            self.df.sort(\"bar\", descending=\"A\")\n\n    def test_split_bad_column(self):\n        with self.assertRaisesRegex(TypeError, \"must be str\"):\n            self.df.split(1, into=[\"jaz1\", \"jaz2\"], sep=\"::\")\n\n    def test_split_bad_into_column(self):\n        with self.assertRaisesRegex(TypeError, \"must be list\"):\n            self.df.split(\"jaz\", into=1, sep=\"::\")\n\n    def test_split_bad_sep_argument(self):\n        with self.assertRaisesRegex(TypeError, \"must be str\"):\n            self.df.split(\"jaz\", into=[\"jaz1\", \"jaz2\"], sep=1)\n\n    def test_split_bad_drop_argument(self):\n        with self.assertRaisesRegex(TypeError, \"must be bool\"):\n            self.df.split(\"jaz\", into=[\"jaz1\", \"jaz2\"], sep=\"::\", drop=\"A\")\n\n    def test_spread_bad_column(self):", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_type_hints.py_205-255"}
{"title": "maxhumber_redframes-tests-test_type_hints.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_type_hints.py"], "line_no": 240, "start_line_no": 215, "end_line_no": 265, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "    def test_replace_bad_over(self):\n        with self.assertRaisesRegex(TypeError, \"must be dict\"):\n            self.df.replace(1)\n\n    def test_sample_bad_rows(self):\n        with self.assertRaisesRegex(TypeError, \"must be int | float\"):\n            self.df.sample(\"A\")\n\n    def test_select_bad_columns(self):\n        with self.assertRaisesRegex(TypeError, \"must be list | str\"):\n            self.df.select(1)\n\n    def test_shuffle(self):\n        pass\n\n    def test_sort_bad_columns(self):\n        with self.assertRaisesRegex(TypeError, \"must be list | str\"):\n            self.df.sort(1)\n\n    def test_sort_bad_descending_argument(self):\n        with self.assertRaisesRegex(TypeError, \"must be bool\"):\n            self.df.sort(\"bar\", descending=\"A\")\n\n    def test_split_bad_column(self):\n        with self.assertRaisesRegex(TypeError, \"must be str\"):\n            self.df.split(1, into=[\"jaz1\", \"jaz2\"], sep=\"::\")\n\n    def test_split_bad_into_column(self):\n        with self.assertRaisesRegex(TypeError, \"must be list\"):\n            self.df.split(\"jaz\", into=1, sep=\"::\")\n\n    def test_split_bad_sep_argument(self):\n        with self.assertRaisesRegex(TypeError, \"must be str\"):\n            self.df.split(\"jaz\", into=[\"jaz1\", \"jaz2\"], sep=1)\n\n    def test_split_bad_drop_argument(self):\n        with self.assertRaisesRegex(TypeError, \"must be bool\"):\n            self.df.split(\"jaz\", into=[\"jaz1\", \"jaz2\"], sep=\"::\", drop=\"A\")\n\n    def test_spread_bad_column(self):\n        with self.assertRaisesRegex(TypeError, \"must be str\"):\n            self.df.spread(1, using=\"bar\")\n\n    def test_spread_bad_using_column(self):\n        with self.assertRaisesRegex(TypeError, \"must be str\"):\n            self.df.spread(\"foo\", using=1)\n\n    def test_unpack_bad_column(self):\n        with self.assertRaisesRegex(TypeError, \"must be str\"):\n            self.df.unpack(1, sep=\"|\")", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_type_hints.py_215-265"}
{"title": "maxhumber_redframes-tests-test_type_hints.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_type_hints.py"], "line_no": 250, "start_line_no": 225, "end_line_no": 269, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "            self.df.select(1)\n\n    def test_shuffle(self):\n        pass\n\n    def test_sort_bad_columns(self):\n        with self.assertRaisesRegex(TypeError, \"must be list | str\"):\n            self.df.sort(1)\n\n    def test_sort_bad_descending_argument(self):\n        with self.assertRaisesRegex(TypeError, \"must be bool\"):\n            self.df.sort(\"bar\", descending=\"A\")\n\n    def test_split_bad_column(self):\n        with self.assertRaisesRegex(TypeError, \"must be str\"):\n            self.df.split(1, into=[\"jaz1\", \"jaz2\"], sep=\"::\")\n\n    def test_split_bad_into_column(self):\n        with self.assertRaisesRegex(TypeError, \"must be list\"):\n            self.df.split(\"jaz\", into=1, sep=\"::\")\n\n    def test_split_bad_sep_argument(self):\n        with self.assertRaisesRegex(TypeError, \"must be str\"):\n            self.df.split(\"jaz\", into=[\"jaz1\", \"jaz2\"], sep=1)\n\n    def test_split_bad_drop_argument(self):\n        with self.assertRaisesRegex(TypeError, \"must be bool\"):\n            self.df.split(\"jaz\", into=[\"jaz1\", \"jaz2\"], sep=\"::\", drop=\"A\")\n\n    def test_spread_bad_column(self):\n        with self.assertRaisesRegex(TypeError, \"must be str\"):\n            self.df.spread(1, using=\"bar\")\n\n    def test_spread_bad_using_column(self):\n        with self.assertRaisesRegex(TypeError, \"must be str\"):\n            self.df.spread(\"foo\", using=1)\n\n    def test_unpack_bad_column(self):\n        with self.assertRaisesRegex(TypeError, \"must be str\"):\n            self.df.unpack(1, sep=\"|\")\n\n    def test_unpack_bad_sep(self):\n        with self.assertRaisesRegex(TypeError, \"must be str\"):\n            self.df.unpack(\"jaz\", sep=1)", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_type_hints.py_225-269"}
{"title": "maxhumber_redframes-tests-test_type_hints.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_type_hints.py"], "line_no": 260, "start_line_no": 235, "end_line_no": 269, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        with self.assertRaisesRegex(TypeError, \"must be bool\"):\n            self.df.sort(\"bar\", descending=\"A\")\n\n    def test_split_bad_column(self):\n        with self.assertRaisesRegex(TypeError, \"must be str\"):\n            self.df.split(1, into=[\"jaz1\", \"jaz2\"], sep=\"::\")\n\n    def test_split_bad_into_column(self):\n        with self.assertRaisesRegex(TypeError, \"must be list\"):\n            self.df.split(\"jaz\", into=1, sep=\"::\")\n\n    def test_split_bad_sep_argument(self):\n        with self.assertRaisesRegex(TypeError, \"must be str\"):\n            self.df.split(\"jaz\", into=[\"jaz1\", \"jaz2\"], sep=1)\n\n    def test_split_bad_drop_argument(self):\n        with self.assertRaisesRegex(TypeError, \"must be bool\"):\n            self.df.split(\"jaz\", into=[\"jaz1\", \"jaz2\"], sep=\"::\", drop=\"A\")\n\n    def test_spread_bad_column(self):\n        with self.assertRaisesRegex(TypeError, \"must be str\"):\n            self.df.spread(1, using=\"bar\")\n\n    def test_spread_bad_using_column(self):\n        with self.assertRaisesRegex(TypeError, \"must be str\"):\n            self.df.spread(\"foo\", using=1)\n\n    def test_unpack_bad_column(self):\n        with self.assertRaisesRegex(TypeError, \"must be str\"):\n            self.df.unpack(1, sep=\"|\")\n\n    def test_unpack_bad_sep(self):\n        with self.assertRaisesRegex(TypeError, \"must be str\"):\n            self.df.unpack(\"jaz\", sep=1)", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_type_hints.py_235-269"}
