{"title": "maxhumber_redframes-setup.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "setup.py"], "line_no": 0, "start_line_no": 0, "end_line_no": 25, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "from setuptools import find_packages, setup\n\nexec(open(\"redframes/version.py\").read())\n\nwith open(\"README.md\", \"r\", encoding=\"utf-8\") as f:\n    long_description = f.read()\n\nsetup(\n    name=\"redframes\",\n    version=__version__,  # type: ignore\n    url=\"https://github.com/maxhumber/redframes\",\n    description=\"General Purpose Data Manipulation Library\",\n    long_description=long_description,\n    long_description_content_type=\"text/markdown\",\n    author=\"Max Humber\",\n    author_email=\"max.humber@gmail.com\",\n    license=\"BSD 2\",\n    packages=find_packages(),\n    python_requires=\">=3.9\",\n    install_requires=[\"pandas>=1.5,<2.0\", \"scikit-learn==1.2.2\"],\n    extras_require={\n        \"test\": [\n            \"matplotlib\",\n            \"scikit-learn\",\n            \"protobuf==3.20.3\",", "id": "maxhumber_redframes_maxhumber_redframes-setup.py_0-25"}
{"title": "maxhumber_redframes-setup.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "setup.py"], "line_no": 10, "start_line_no": 0, "end_line_no": 35, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "from setuptools import find_packages, setup\n\nexec(open(\"redframes/version.py\").read())\n\nwith open(\"README.md\", \"r\", encoding=\"utf-8\") as f:\n    long_description = f.read()\n\nsetup(\n    name=\"redframes\",\n    version=__version__,  # type: ignore\n    url=\"https://github.com/maxhumber/redframes\",\n    description=\"General Purpose Data Manipulation Library\",\n    long_description=long_description,\n    long_description_content_type=\"text/markdown\",\n    author=\"Max Humber\",\n    author_email=\"max.humber@gmail.com\",\n    license=\"BSD 2\",\n    packages=find_packages(),\n    python_requires=\">=3.9\",\n    install_requires=[\"pandas>=1.5,<2.0\", \"scikit-learn==1.2.2\"],\n    extras_require={\n        \"test\": [\n            \"matplotlib\",\n            \"scikit-learn\",\n            \"protobuf==3.20.3\",\n        ],\n        \"dev\": [\n            \"black\",\n            \"ipykernel\",\n            \"isort\",\n            \"lxml\",\n            \"matplotlib\",\n            \"mypy\",\n            \"pandas-stubs\",\n            \"pyright\",", "id": "maxhumber_redframes_maxhumber_redframes-setup.py_0-35"}
{"title": "maxhumber_redframes-setup.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "setup.py"], "line_no": 20, "start_line_no": 0, "end_line_no": 45, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "from setuptools import find_packages, setup\n\nexec(open(\"redframes/version.py\").read())\n\nwith open(\"README.md\", \"r\", encoding=\"utf-8\") as f:\n    long_description = f.read()\n\nsetup(\n    name=\"redframes\",\n    version=__version__,  # type: ignore\n    url=\"https://github.com/maxhumber/redframes\",\n    description=\"General Purpose Data Manipulation Library\",\n    long_description=long_description,\n    long_description_content_type=\"text/markdown\",\n    author=\"Max Humber\",\n    author_email=\"max.humber@gmail.com\",\n    license=\"BSD 2\",\n    packages=find_packages(),\n    python_requires=\">=3.9\",\n    install_requires=[\"pandas>=1.5,<2.0\", \"scikit-learn==1.2.2\"],\n    extras_require={\n        \"test\": [\n            \"matplotlib\",\n            \"scikit-learn\",\n            \"protobuf==3.20.3\",\n        ],\n        \"dev\": [\n            \"black\",\n            \"ipykernel\",\n            \"isort\",\n            \"lxml\",\n            \"matplotlib\",\n            \"mypy\",\n            \"pandas-stubs\",\n            \"pyright\",\n            \"scikit-learn\",\n            \"tabulate\",\n        ],\n    },\n    classifiers=[\n        \"Intended Audience :: Developers\",\n        \"Programming Language :: Python :: 3.9\",\n        \"Programming Language :: Python :: 3.10\",\n        \"Programming Language :: Python :: 3.11\",\n    ],", "id": "maxhumber_redframes_maxhumber_redframes-setup.py_0-45"}
{"title": "maxhumber_redframes-setup.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "setup.py"], "line_no": 30, "start_line_no": 5, "end_line_no": 46, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "    long_description = f.read()\n\nsetup(\n    name=\"redframes\",\n    version=__version__,  # type: ignore\n    url=\"https://github.com/maxhumber/redframes\",\n    description=\"General Purpose Data Manipulation Library\",\n    long_description=long_description,\n    long_description_content_type=\"text/markdown\",\n    author=\"Max Humber\",\n    author_email=\"max.humber@gmail.com\",\n    license=\"BSD 2\",\n    packages=find_packages(),\n    python_requires=\">=3.9\",\n    install_requires=[\"pandas>=1.5,<2.0\", \"scikit-learn==1.2.2\"],\n    extras_require={\n        \"test\": [\n            \"matplotlib\",\n            \"scikit-learn\",\n            \"protobuf==3.20.3\",\n        ],\n        \"dev\": [\n            \"black\",\n            \"ipykernel\",\n            \"isort\",\n            \"lxml\",\n            \"matplotlib\",\n            \"mypy\",\n            \"pandas-stubs\",\n            \"pyright\",\n            \"scikit-learn\",\n            \"tabulate\",\n        ],\n    },\n    classifiers=[\n        \"Intended Audience :: Developers\",\n        \"Programming Language :: Python :: 3.9\",\n        \"Programming Language :: Python :: 3.10\",\n        \"Programming Language :: Python :: 3.11\",\n    ],\n)", "id": "maxhumber_redframes_maxhumber_redframes-setup.py_5-46"}
{"title": "maxhumber_redframes-setup.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "setup.py"], "line_no": 40, "start_line_no": 15, "end_line_no": 46, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "    author_email=\"max.humber@gmail.com\",\n    license=\"BSD 2\",\n    packages=find_packages(),\n    python_requires=\">=3.9\",\n    install_requires=[\"pandas>=1.5,<2.0\", \"scikit-learn==1.2.2\"],\n    extras_require={\n        \"test\": [\n            \"matplotlib\",\n            \"scikit-learn\",\n            \"protobuf==3.20.3\",\n        ],\n        \"dev\": [\n            \"black\",\n            \"ipykernel\",\n            \"isort\",\n            \"lxml\",\n            \"matplotlib\",\n            \"mypy\",\n            \"pandas-stubs\",\n            \"pyright\",\n            \"scikit-learn\",\n            \"tabulate\",\n        ],\n    },\n    classifiers=[\n        \"Intended Audience :: Developers\",\n        \"Programming Language :: Python :: 3.9\",\n        \"Programming Language :: Python :: 3.10\",\n        \"Programming Language :: Python :: 3.11\",\n    ],\n)", "id": "maxhumber_redframes_maxhumber_redframes-setup.py_15-46"}
{"title": "maxhumber_redframes-redframes-checks.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "checks.py"], "line_no": 0, "start_line_no": 0, "end_line_no": 25, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "from __future__ import annotations\n\nfrom .types import (\n    Any,\n    Columns,\n    LazyColumns,\n    PandasDataFrame,\n    PandasIndex,\n    PandasRangeIndex,\n)\n\n\ndef _check_type(argument: Any, against: type | set[type | None]) -> None:\n    if isinstance(against, set):\n        if len(against) == 0:\n            against = {against}  # type: ignore\n    if not isinstance(against, set):\n        against = {against}\n    optional = None in against\n    just_types = against.difference({None})\n    checks = [isinstance(argument, t) for t in just_types]  # type: ignore\n    if optional:\n        checks += [argument == None]\n    if not any(checks):\n        str_types = \" | \".join([t.__name__ for t in just_types])  # type: ignore", "id": "maxhumber_redframes_maxhumber_redframes-redframes-checks.py_0-25"}
{"title": "maxhumber_redframes-redframes-checks.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "checks.py"], "line_no": 10, "start_line_no": 0, "end_line_no": 35, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "from __future__ import annotations\n\nfrom .types import (\n    Any,\n    Columns,\n    LazyColumns,\n    PandasDataFrame,\n    PandasIndex,\n    PandasRangeIndex,\n)\n\n\ndef _check_type(argument: Any, against: type | set[type | None]) -> None:\n    if isinstance(against, set):\n        if len(against) == 0:\n            against = {against}  # type: ignore\n    if not isinstance(against, set):\n        against = {against}\n    optional = None in against\n    just_types = against.difference({None})\n    checks = [isinstance(argument, t) for t in just_types]  # type: ignore\n    if optional:\n        checks += [argument == None]\n    if not any(checks):\n        str_types = \" | \".join([t.__name__ for t in just_types])  # type: ignore\n        if optional:\n            str_types += \" | None\"\n        raise TypeError(f\"must be {str_types}\")\n\n\ndef _check_values(values: Any, type: type) -> None:\n    if not all(isinstance(value, type) for value in values):\n        raise TypeError(f\"must be {type.__name__}\")\n\n", "id": "maxhumber_redframes_maxhumber_redframes-redframes-checks.py_0-35"}
{"title": "maxhumber_redframes-redframes-checks.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "checks.py"], "line_no": 20, "start_line_no": 0, "end_line_no": 45, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "from __future__ import annotations\n\nfrom .types import (\n    Any,\n    Columns,\n    LazyColumns,\n    PandasDataFrame,\n    PandasIndex,\n    PandasRangeIndex,\n)\n\n\ndef _check_type(argument: Any, against: type | set[type | None]) -> None:\n    if isinstance(against, set):\n        if len(against) == 0:\n            against = {against}  # type: ignore\n    if not isinstance(against, set):\n        against = {against}\n    optional = None in against\n    just_types = against.difference({None})\n    checks = [isinstance(argument, t) for t in just_types]  # type: ignore\n    if optional:\n        checks += [argument == None]\n    if not any(checks):\n        str_types = \" | \".join([t.__name__ for t in just_types])  # type: ignore\n        if optional:\n            str_types += \" | None\"\n        raise TypeError(f\"must be {str_types}\")\n\n\ndef _check_values(values: Any, type: type) -> None:\n    if not all(isinstance(value, type) for value in values):\n        raise TypeError(f\"must be {type.__name__}\")\n\n\ndef _check_keys(columns: LazyColumns | None, against: Columns | PandasIndex) -> None:\n    if isinstance(columns, str):\n        columns = [columns]\n    columns = [] if (columns == None) else columns\n    bad_keys = set(columns).difference(against)  # type: ignore\n    if bad_keys:\n        if len(bad_keys) == 1:\n            raise KeyError(f\"invalid key {bad_keys}\")\n        else:\n            raise KeyError(f\"invalid keys {bad_keys}\")", "id": "maxhumber_redframes_maxhumber_redframes-redframes-checks.py_0-45"}
{"title": "maxhumber_redframes-redframes-checks.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "checks.py"], "line_no": 30, "start_line_no": 5, "end_line_no": 55, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "    LazyColumns,\n    PandasDataFrame,\n    PandasIndex,\n    PandasRangeIndex,\n)\n\n\ndef _check_type(argument: Any, against: type | set[type | None]) -> None:\n    if isinstance(against, set):\n        if len(against) == 0:\n            against = {against}  # type: ignore\n    if not isinstance(against, set):\n        against = {against}\n    optional = None in against\n    just_types = against.difference({None})\n    checks = [isinstance(argument, t) for t in just_types]  # type: ignore\n    if optional:\n        checks += [argument == None]\n    if not any(checks):\n        str_types = \" | \".join([t.__name__ for t in just_types])  # type: ignore\n        if optional:\n            str_types += \" | None\"\n        raise TypeError(f\"must be {str_types}\")\n\n\ndef _check_values(values: Any, type: type) -> None:\n    if not all(isinstance(value, type) for value in values):\n        raise TypeError(f\"must be {type.__name__}\")\n\n\ndef _check_keys(columns: LazyColumns | None, against: Columns | PandasIndex) -> None:\n    if isinstance(columns, str):\n        columns = [columns]\n    columns = [] if (columns == None) else columns\n    bad_keys = set(columns).difference(against)  # type: ignore\n    if bad_keys:\n        if len(bad_keys) == 1:\n            raise KeyError(f\"invalid key {bad_keys}\")\n        else:\n            raise KeyError(f\"invalid keys {bad_keys}\")\n\n\ndef _check_index(df: PandasDataFrame) -> None:\n    if not (df.index.name == None):\n        raise IndexError(\"must be unnamed\")\n    if not isinstance(df.index, PandasRangeIndex):\n        raise IndexError(\"must be range\")\n    if not (df.index.start == 0):\n        raise IndexError(\"must start at 0\")\n    if not (df.index.step == 1):", "id": "maxhumber_redframes_maxhumber_redframes-redframes-checks.py_5-55"}
{"title": "maxhumber_redframes-redframes-checks.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "checks.py"], "line_no": 40, "start_line_no": 15, "end_line_no": 65, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "            against = {against}  # type: ignore\n    if not isinstance(against, set):\n        against = {against}\n    optional = None in against\n    just_types = against.difference({None})\n    checks = [isinstance(argument, t) for t in just_types]  # type: ignore\n    if optional:\n        checks += [argument == None]\n    if not any(checks):\n        str_types = \" | \".join([t.__name__ for t in just_types])  # type: ignore\n        if optional:\n            str_types += \" | None\"\n        raise TypeError(f\"must be {str_types}\")\n\n\ndef _check_values(values: Any, type: type) -> None:\n    if not all(isinstance(value, type) for value in values):\n        raise TypeError(f\"must be {type.__name__}\")\n\n\ndef _check_keys(columns: LazyColumns | None, against: Columns | PandasIndex) -> None:\n    if isinstance(columns, str):\n        columns = [columns]\n    columns = [] if (columns == None) else columns\n    bad_keys = set(columns).difference(against)  # type: ignore\n    if bad_keys:\n        if len(bad_keys) == 1:\n            raise KeyError(f\"invalid key {bad_keys}\")\n        else:\n            raise KeyError(f\"invalid keys {bad_keys}\")\n\n\ndef _check_index(df: PandasDataFrame) -> None:\n    if not (df.index.name == None):\n        raise IndexError(\"must be unnamed\")\n    if not isinstance(df.index, PandasRangeIndex):\n        raise IndexError(\"must be range\")\n    if not (df.index.start == 0):\n        raise IndexError(\"must start at 0\")\n    if not (df.index.step == 1):\n        raise IndexError(\"must step by 1\")\n\n\ndef _check_columns(df: PandasDataFrame) -> None:\n    if type(df.columns) != PandasIndex:\n        raise KeyError(\"must be flat\")\n    if df.columns.has_duplicates:\n        raise KeyError(\"must not contain duplicate keys\")\n\n", "id": "maxhumber_redframes_maxhumber_redframes-redframes-checks.py_15-65"}
{"title": "maxhumber_redframes-redframes-checks.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "checks.py"], "line_no": 50, "start_line_no": 25, "end_line_no": 68, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        if optional:\n            str_types += \" | None\"\n        raise TypeError(f\"must be {str_types}\")\n\n\ndef _check_values(values: Any, type: type) -> None:\n    if not all(isinstance(value, type) for value in values):\n        raise TypeError(f\"must be {type.__name__}\")\n\n\ndef _check_keys(columns: LazyColumns | None, against: Columns | PandasIndex) -> None:\n    if isinstance(columns, str):\n        columns = [columns]\n    columns = [] if (columns == None) else columns\n    bad_keys = set(columns).difference(against)  # type: ignore\n    if bad_keys:\n        if len(bad_keys) == 1:\n            raise KeyError(f\"invalid key {bad_keys}\")\n        else:\n            raise KeyError(f\"invalid keys {bad_keys}\")\n\n\ndef _check_index(df: PandasDataFrame) -> None:\n    if not (df.index.name == None):\n        raise IndexError(\"must be unnamed\")\n    if not isinstance(df.index, PandasRangeIndex):\n        raise IndexError(\"must be range\")\n    if not (df.index.start == 0):\n        raise IndexError(\"must start at 0\")\n    if not (df.index.step == 1):\n        raise IndexError(\"must step by 1\")\n\n\ndef _check_columns(df: PandasDataFrame) -> None:\n    if type(df.columns) != PandasIndex:\n        raise KeyError(\"must be flat\")\n    if df.columns.has_duplicates:\n        raise KeyError(\"must not contain duplicate keys\")\n\n\ndef _check_file(path: str) -> None:\n    if not path.endswith(\".csv\"):\n        raise TypeError(\"must end in .csv\")", "id": "maxhumber_redframes_maxhumber_redframes-redframes-checks.py_25-68"}
{"title": "maxhumber_redframes-redframes-checks.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "checks.py"], "line_no": 60, "start_line_no": 35, "end_line_no": 68, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "def _check_keys(columns: LazyColumns | None, against: Columns | PandasIndex) -> None:\n    if isinstance(columns, str):\n        columns = [columns]\n    columns = [] if (columns == None) else columns\n    bad_keys = set(columns).difference(against)  # type: ignore\n    if bad_keys:\n        if len(bad_keys) == 1:\n            raise KeyError(f\"invalid key {bad_keys}\")\n        else:\n            raise KeyError(f\"invalid keys {bad_keys}\")\n\n\ndef _check_index(df: PandasDataFrame) -> None:\n    if not (df.index.name == None):\n        raise IndexError(\"must be unnamed\")\n    if not isinstance(df.index, PandasRangeIndex):\n        raise IndexError(\"must be range\")\n    if not (df.index.start == 0):\n        raise IndexError(\"must start at 0\")\n    if not (df.index.step == 1):\n        raise IndexError(\"must step by 1\")\n\n\ndef _check_columns(df: PandasDataFrame) -> None:\n    if type(df.columns) != PandasIndex:\n        raise KeyError(\"must be flat\")\n    if df.columns.has_duplicates:\n        raise KeyError(\"must not contain duplicate keys\")\n\n\ndef _check_file(path: str) -> None:\n    if not path.endswith(\".csv\"):\n        raise TypeError(\"must end in .csv\")", "id": "maxhumber_redframes_maxhumber_redframes-redframes-checks.py_35-68"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 0, "start_line_no": 0, "end_line_no": 25, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "from __future__ import annotations\n\nimport pprint\nimport warnings\n\nfrom .checks import _check_type\nfrom .types import (\n    Any,\n    Column,\n    Columns,\n    DateTime,\n    Direction,\n    Func,\n    Join,\n    LazyColumns,\n    NewColumn,\n    NewValue,\n    NumpyArray,\n    NumpyType,\n    OldColumn,\n    OldValue,\n    PandasDataFrame,\n    PandasGroupedFrame,\n    Value,\n    Values,", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_0-25"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 10, "start_line_no": 0, "end_line_no": 35, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "from __future__ import annotations\n\nimport pprint\nimport warnings\n\nfrom .checks import _check_type\nfrom .types import (\n    Any,\n    Column,\n    Columns,\n    DateTime,\n    Direction,\n    Func,\n    Join,\n    LazyColumns,\n    NewColumn,\n    NewValue,\n    NumpyArray,\n    NumpyType,\n    OldColumn,\n    OldValue,\n    PandasDataFrame,\n    PandasGroupedFrame,\n    Value,\n    Values,\n)\nfrom .verbs import (\n    accumulate,\n    append,\n    combine,\n    cross,\n    dedupe,\n    denix,\n    drop,\n    fill,", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_0-35"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 20, "start_line_no": 0, "end_line_no": 45, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "from __future__ import annotations\n\nimport pprint\nimport warnings\n\nfrom .checks import _check_type\nfrom .types import (\n    Any,\n    Column,\n    Columns,\n    DateTime,\n    Direction,\n    Func,\n    Join,\n    LazyColumns,\n    NewColumn,\n    NewValue,\n    NumpyArray,\n    NumpyType,\n    OldColumn,\n    OldValue,\n    PandasDataFrame,\n    PandasGroupedFrame,\n    Value,\n    Values,\n)\nfrom .verbs import (\n    accumulate,\n    append,\n    combine,\n    cross,\n    dedupe,\n    denix,\n    drop,\n    fill,\n    filter,\n    gather,\n    group,\n    join,\n    mutate,\n    pack,\n    rank,\n    rename,\n    replace,\n    rollup,", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_0-45"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 30, "start_line_no": 5, "end_line_no": 55, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "from .checks import _check_type\nfrom .types import (\n    Any,\n    Column,\n    Columns,\n    DateTime,\n    Direction,\n    Func,\n    Join,\n    LazyColumns,\n    NewColumn,\n    NewValue,\n    NumpyArray,\n    NumpyType,\n    OldColumn,\n    OldValue,\n    PandasDataFrame,\n    PandasGroupedFrame,\n    Value,\n    Values,\n)\nfrom .verbs import (\n    accumulate,\n    append,\n    combine,\n    cross,\n    dedupe,\n    denix,\n    drop,\n    fill,\n    filter,\n    gather,\n    group,\n    join,\n    mutate,\n    pack,\n    rank,\n    rename,\n    replace,\n    rollup,\n    sample,\n    select,\n    shuffle,\n    sort,\n    split,\n    spread,\n    take,\n    unpack,\n)\n", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_5-55"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 40, "start_line_no": 15, "end_line_no": 65, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "    NewColumn,\n    NewValue,\n    NumpyArray,\n    NumpyType,\n    OldColumn,\n    OldValue,\n    PandasDataFrame,\n    PandasGroupedFrame,\n    Value,\n    Values,\n)\nfrom .verbs import (\n    accumulate,\n    append,\n    combine,\n    cross,\n    dedupe,\n    denix,\n    drop,\n    fill,\n    filter,\n    gather,\n    group,\n    join,\n    mutate,\n    pack,\n    rank,\n    rename,\n    replace,\n    rollup,\n    sample,\n    select,\n    shuffle,\n    sort,\n    split,\n    spread,\n    take,\n    unpack,\n)\n\n\ndef _wrap(data: PandasDataFrame) -> DataFrame:\n    \"\"\"Unsafe version of redframes.io.wrap()\"\"\"\n    df = DataFrame()\n    df._data = data\n    return df\n\n\nclass _TakeMixin:\n    def __init__(self, data: PandasDataFrame | PandasGroupedFrame) -> None:", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_15-65"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 50, "start_line_no": 25, "end_line_no": 75, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": ")\nfrom .verbs import (\n    accumulate,\n    append,\n    combine,\n    cross,\n    dedupe,\n    denix,\n    drop,\n    fill,\n    filter,\n    gather,\n    group,\n    join,\n    mutate,\n    pack,\n    rank,\n    rename,\n    replace,\n    rollup,\n    sample,\n    select,\n    shuffle,\n    sort,\n    split,\n    spread,\n    take,\n    unpack,\n)\n\n\ndef _wrap(data: PandasDataFrame) -> DataFrame:\n    \"\"\"Unsafe version of redframes.io.wrap()\"\"\"\n    df = DataFrame()\n    df._data = data\n    return df\n\n\nclass _TakeMixin:\n    def __init__(self, data: PandasDataFrame | PandasGroupedFrame) -> None:\n        self._data = data\n\n    def take(self, rows: int, **kwargs) -> DataFrame:\n        \"\"\"Take any number of rows (from the top/bottom)\n\n        Examples:\n\n        ```python\n        df = rf.DataFrame({\"foo\": range(10)})\n        ```", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_25-75"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 60, "start_line_no": 35, "end_line_no": 85, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "    filter,\n    gather,\n    group,\n    join,\n    mutate,\n    pack,\n    rank,\n    rename,\n    replace,\n    rollup,\n    sample,\n    select,\n    shuffle,\n    sort,\n    split,\n    spread,\n    take,\n    unpack,\n)\n\n\ndef _wrap(data: PandasDataFrame) -> DataFrame:\n    \"\"\"Unsafe version of redframes.io.wrap()\"\"\"\n    df = DataFrame()\n    df._data = data\n    return df\n\n\nclass _TakeMixin:\n    def __init__(self, data: PandasDataFrame | PandasGroupedFrame) -> None:\n        self._data = data\n\n    def take(self, rows: int, **kwargs) -> DataFrame:\n        \"\"\"Take any number of rows (from the top/bottom)\n\n        Examples:\n\n        ```python\n        df = rf.DataFrame({\"foo\": range(10)})\n        ```\n        |   foo |\n        |------:|\n        |     0 |\n        |     1 |\n        |     2 |\n        |     3 |\n        |     4 |\n        |     5 |\n        |     6 |\n        |     7 |", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_35-85"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 70, "start_line_no": 45, "end_line_no": 95, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "    sample,\n    select,\n    shuffle,\n    sort,\n    split,\n    spread,\n    take,\n    unpack,\n)\n\n\ndef _wrap(data: PandasDataFrame) -> DataFrame:\n    \"\"\"Unsafe version of redframes.io.wrap()\"\"\"\n    df = DataFrame()\n    df._data = data\n    return df\n\n\nclass _TakeMixin:\n    def __init__(self, data: PandasDataFrame | PandasGroupedFrame) -> None:\n        self._data = data\n\n    def take(self, rows: int, **kwargs) -> DataFrame:\n        \"\"\"Take any number of rows (from the top/bottom)\n\n        Examples:\n\n        ```python\n        df = rf.DataFrame({\"foo\": range(10)})\n        ```\n        |   foo |\n        |------:|\n        |     0 |\n        |     1 |\n        |     2 |\n        |     3 |\n        |     4 |\n        |     5 |\n        |     6 |\n        |     7 |\n        |     8 |\n        |     9 |\n\n        From \"head\":\n\n        ```python\n        df.take(1)\n        ```\n        |   foo |\n        |------:|", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_45-95"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 80, "start_line_no": 55, "end_line_no": 105, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "\ndef _wrap(data: PandasDataFrame) -> DataFrame:\n    \"\"\"Unsafe version of redframes.io.wrap()\"\"\"\n    df = DataFrame()\n    df._data = data\n    return df\n\n\nclass _TakeMixin:\n    def __init__(self, data: PandasDataFrame | PandasGroupedFrame) -> None:\n        self._data = data\n\n    def take(self, rows: int, **kwargs) -> DataFrame:\n        \"\"\"Take any number of rows (from the top/bottom)\n\n        Examples:\n\n        ```python\n        df = rf.DataFrame({\"foo\": range(10)})\n        ```\n        |   foo |\n        |------:|\n        |     0 |\n        |     1 |\n        |     2 |\n        |     3 |\n        |     4 |\n        |     5 |\n        |     6 |\n        |     7 |\n        |     8 |\n        |     9 |\n\n        From \"head\":\n\n        ```python\n        df.take(1)\n        ```\n        |   foo |\n        |------:|\n        |     0 |\n\n        From \"tail\":\n\n        ```python\n        df.take(-2)\n        ```\n        |   foo |\n        |------:|\n        |     8 |", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_55-105"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 90, "start_line_no": 65, "end_line_no": 115, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        self._data = data\n\n    def take(self, rows: int, **kwargs) -> DataFrame:\n        \"\"\"Take any number of rows (from the top/bottom)\n\n        Examples:\n\n        ```python\n        df = rf.DataFrame({\"foo\": range(10)})\n        ```\n        |   foo |\n        |------:|\n        |     0 |\n        |     1 |\n        |     2 |\n        |     3 |\n        |     4 |\n        |     5 |\n        |     6 |\n        |     7 |\n        |     8 |\n        |     9 |\n\n        From \"head\":\n\n        ```python\n        df.take(1)\n        ```\n        |   foo |\n        |------:|\n        |     0 |\n\n        From \"tail\":\n\n        ```python\n        df.take(-2)\n        ```\n        |   foo |\n        |------:|\n        |     8 |\n        |     9 |\n        \"\"\"\n        return _wrap(take(self._data, rows, **kwargs))\n\n\nclass _InterchangeMixin(_TakeMixin):\n    def __init__(self, data: PandasDataFrame) -> None:\n        self._data = data\n\n    def __array__(self) -> NumpyArray:", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_65-115"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 100, "start_line_no": 75, "end_line_no": 125, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        |   foo |\n        |------:|\n        |     0 |\n        |     1 |\n        |     2 |\n        |     3 |\n        |     4 |\n        |     5 |\n        |     6 |\n        |     7 |\n        |     8 |\n        |     9 |\n\n        From \"head\":\n\n        ```python\n        df.take(1)\n        ```\n        |   foo |\n        |------:|\n        |     0 |\n\n        From \"tail\":\n\n        ```python\n        df.take(-2)\n        ```\n        |   foo |\n        |------:|\n        |     8 |\n        |     9 |\n        \"\"\"\n        return _wrap(take(self._data, rows, **kwargs))\n\n\nclass _InterchangeMixin(_TakeMixin):\n    def __init__(self, data: PandasDataFrame) -> None:\n        self._data = data\n\n    def __array__(self) -> NumpyArray:\n        return self._data.__array__()\n\n    def __dataframe__(self, nan_as_null=False, allow_copy=True) -> \"PandasDataFrameXchg\":  # type: ignore\n        return self._data.__dataframe__(nan_as_null, allow_copy)\n\n    def __len__(self) -> int:\n        return self._data.__len__()\n\n    @property\n    def iloc(self):", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_75-125"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 110, "start_line_no": 85, "end_line_no": 135, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        |     8 |\n        |     9 |\n\n        From \"head\":\n\n        ```python\n        df.take(1)\n        ```\n        |   foo |\n        |------:|\n        |     0 |\n\n        From \"tail\":\n\n        ```python\n        df.take(-2)\n        ```\n        |   foo |\n        |------:|\n        |     8 |\n        |     9 |\n        \"\"\"\n        return _wrap(take(self._data, rows, **kwargs))\n\n\nclass _InterchangeMixin(_TakeMixin):\n    def __init__(self, data: PandasDataFrame) -> None:\n        self._data = data\n\n    def __array__(self) -> NumpyArray:\n        return self._data.__array__()\n\n    def __dataframe__(self, nan_as_null=False, allow_copy=True) -> \"PandasDataFrameXchg\":  # type: ignore\n        return self._data.__dataframe__(nan_as_null, allow_copy)\n\n    def __len__(self) -> int:\n        return self._data.__len__()\n\n    @property\n    def iloc(self):\n        return self._data.iloc\n\n\nclass _CommonMixin(_TakeMixin):\n    def __init__(self, data: PandasDataFrame | PandasGroupedFrame) -> None:\n        self._data = data\n\n    def accumulate(self, column: Column, into: Column) -> DataFrame:\n        \"\"\"Run a cumulative sum over a column\n", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_85-135"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 120, "start_line_no": 95, "end_line_no": 145, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        |     0 |\n\n        From \"tail\":\n\n        ```python\n        df.take(-2)\n        ```\n        |   foo |\n        |------:|\n        |     8 |\n        |     9 |\n        \"\"\"\n        return _wrap(take(self._data, rows, **kwargs))\n\n\nclass _InterchangeMixin(_TakeMixin):\n    def __init__(self, data: PandasDataFrame) -> None:\n        self._data = data\n\n    def __array__(self) -> NumpyArray:\n        return self._data.__array__()\n\n    def __dataframe__(self, nan_as_null=False, allow_copy=True) -> \"PandasDataFrameXchg\":  # type: ignore\n        return self._data.__dataframe__(nan_as_null, allow_copy)\n\n    def __len__(self) -> int:\n        return self._data.__len__()\n\n    @property\n    def iloc(self):\n        return self._data.iloc\n\n\nclass _CommonMixin(_TakeMixin):\n    def __init__(self, data: PandasDataFrame | PandasGroupedFrame) -> None:\n        self._data = data\n\n    def accumulate(self, column: Column, into: Column) -> DataFrame:\n        \"\"\"Run a cumulative sum over a column\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [1, 2, 3, 4]})\n        ```\n        |   foo |\n        |------:|\n        |     1 |\n        |     2 |\n        |     3 |", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_95-145"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 130, "start_line_no": 105, "end_line_no": 155, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        |     9 |\n        \"\"\"\n        return _wrap(take(self._data, rows, **kwargs))\n\n\nclass _InterchangeMixin(_TakeMixin):\n    def __init__(self, data: PandasDataFrame) -> None:\n        self._data = data\n\n    def __array__(self) -> NumpyArray:\n        return self._data.__array__()\n\n    def __dataframe__(self, nan_as_null=False, allow_copy=True) -> \"PandasDataFrameXchg\":  # type: ignore\n        return self._data.__dataframe__(nan_as_null, allow_copy)\n\n    def __len__(self) -> int:\n        return self._data.__len__()\n\n    @property\n    def iloc(self):\n        return self._data.iloc\n\n\nclass _CommonMixin(_TakeMixin):\n    def __init__(self, data: PandasDataFrame | PandasGroupedFrame) -> None:\n        self._data = data\n\n    def accumulate(self, column: Column, into: Column) -> DataFrame:\n        \"\"\"Run a cumulative sum over a column\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [1, 2, 3, 4]})\n        ```\n        |   foo |\n        |------:|\n        |     1 |\n        |     2 |\n        |     3 |\n        |     4 |\n\n        ```python\n        df.accumulate(\"foo\", into=\"cumsum\")\n        ```\n        |   foo |   cumsum |\n        |------:|---------:|\n        |     1 |        1 |\n        |     2 |        3 |\n        |     3 |        6 |", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_105-155"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 140, "start_line_no": 115, "end_line_no": 165, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        return self._data.__array__()\n\n    def __dataframe__(self, nan_as_null=False, allow_copy=True) -> \"PandasDataFrameXchg\":  # type: ignore\n        return self._data.__dataframe__(nan_as_null, allow_copy)\n\n    def __len__(self) -> int:\n        return self._data.__len__()\n\n    @property\n    def iloc(self):\n        return self._data.iloc\n\n\nclass _CommonMixin(_TakeMixin):\n    def __init__(self, data: PandasDataFrame | PandasGroupedFrame) -> None:\n        self._data = data\n\n    def accumulate(self, column: Column, into: Column) -> DataFrame:\n        \"\"\"Run a cumulative sum over a column\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [1, 2, 3, 4]})\n        ```\n        |   foo |\n        |------:|\n        |     1 |\n        |     2 |\n        |     3 |\n        |     4 |\n\n        ```python\n        df.accumulate(\"foo\", into=\"cumsum\")\n        ```\n        |   foo |   cumsum |\n        |------:|---------:|\n        |     1 |        1 |\n        |     2 |        3 |\n        |     3 |        6 |\n        |     4 |       10 |\n        \"\"\"\n        return _wrap(accumulate(self._data, column, into))\n\n    def gather(\n        self,\n        columns: Columns | None = None,\n        beside: LazyColumns | None = None,\n        into: tuple[Column, Column] = (\"variable\", \"value\"),\n    ):", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_115-165"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 150, "start_line_no": 125, "end_line_no": 175, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        return self._data.iloc\n\n\nclass _CommonMixin(_TakeMixin):\n    def __init__(self, data: PandasDataFrame | PandasGroupedFrame) -> None:\n        self._data = data\n\n    def accumulate(self, column: Column, into: Column) -> DataFrame:\n        \"\"\"Run a cumulative sum over a column\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [1, 2, 3, 4]})\n        ```\n        |   foo |\n        |------:|\n        |     1 |\n        |     2 |\n        |     3 |\n        |     4 |\n\n        ```python\n        df.accumulate(\"foo\", into=\"cumsum\")\n        ```\n        |   foo |   cumsum |\n        |------:|---------:|\n        |     1 |        1 |\n        |     2 |        3 |\n        |     3 |        6 |\n        |     4 |       10 |\n        \"\"\"\n        return _wrap(accumulate(self._data, column, into))\n\n    def gather(\n        self,\n        columns: Columns | None = None,\n        beside: LazyColumns | None = None,\n        into: tuple[Column, Column] = (\"variable\", \"value\"),\n    ):\n        \"\"\"Gather columns into rows (opposite of spread)\n\n        Examples:\n\n        ```python\n        df = rf.DataFrame({\n            \"foo\": [1, 2, 1, 2],\n            \"bar\": [\"A\", \"B\", \"C\", \"D\"],\n            \"baz\": [\"!\", \"@\", \"#\", \"$\"],\n            \"jaz\": range(4)", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_125-175"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 160, "start_line_no": 135, "end_line_no": 185, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [1, 2, 3, 4]})\n        ```\n        |   foo |\n        |------:|\n        |     1 |\n        |     2 |\n        |     3 |\n        |     4 |\n\n        ```python\n        df.accumulate(\"foo\", into=\"cumsum\")\n        ```\n        |   foo |   cumsum |\n        |------:|---------:|\n        |     1 |        1 |\n        |     2 |        3 |\n        |     3 |        6 |\n        |     4 |       10 |\n        \"\"\"\n        return _wrap(accumulate(self._data, column, into))\n\n    def gather(\n        self,\n        columns: Columns | None = None,\n        beside: LazyColumns | None = None,\n        into: tuple[Column, Column] = (\"variable\", \"value\"),\n    ):\n        \"\"\"Gather columns into rows (opposite of spread)\n\n        Examples:\n\n        ```python\n        df = rf.DataFrame({\n            \"foo\": [1, 2, 1, 2],\n            \"bar\": [\"A\", \"B\", \"C\", \"D\"],\n            \"baz\": [\"!\", \"@\", \"#\", \"$\"],\n            \"jaz\": range(4)\n        })\n        ```\n        |   foo | bar   | baz   |   jaz |\n        |------:|:------|:------|------:|\n        |     1 | A     | !     |     0 |\n        |     2 | B     | @     |     1 |\n        |     1 | C     | #     |     2 |\n        |     2 | D     | $     |     3 |\n\n        All columns:", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_135-185"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 170, "start_line_no": 145, "end_line_no": 195, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        |     4 |\n\n        ```python\n        df.accumulate(\"foo\", into=\"cumsum\")\n        ```\n        |   foo |   cumsum |\n        |------:|---------:|\n        |     1 |        1 |\n        |     2 |        3 |\n        |     3 |        6 |\n        |     4 |       10 |\n        \"\"\"\n        return _wrap(accumulate(self._data, column, into))\n\n    def gather(\n        self,\n        columns: Columns | None = None,\n        beside: LazyColumns | None = None,\n        into: tuple[Column, Column] = (\"variable\", \"value\"),\n    ):\n        \"\"\"Gather columns into rows (opposite of spread)\n\n        Examples:\n\n        ```python\n        df = rf.DataFrame({\n            \"foo\": [1, 2, 1, 2],\n            \"bar\": [\"A\", \"B\", \"C\", \"D\"],\n            \"baz\": [\"!\", \"@\", \"#\", \"$\"],\n            \"jaz\": range(4)\n        })\n        ```\n        |   foo | bar   | baz   |   jaz |\n        |------:|:------|:------|------:|\n        |     1 | A     | !     |     0 |\n        |     2 | B     | @     |     1 |\n        |     1 | C     | #     |     2 |\n        |     2 | D     | $     |     3 |\n\n        All columns:\n\n        ```python\n        df.gather()\n        ```\n        | variable   | value   |\n        |:-----------|:--------|\n        | foo        | 1       |\n        | foo        | 2       |\n        | foo        | 1       |\n        | foo        | 2       |", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_145-195"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 180, "start_line_no": 155, "end_line_no": 205, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        |     4 |       10 |\n        \"\"\"\n        return _wrap(accumulate(self._data, column, into))\n\n    def gather(\n        self,\n        columns: Columns | None = None,\n        beside: LazyColumns | None = None,\n        into: tuple[Column, Column] = (\"variable\", \"value\"),\n    ):\n        \"\"\"Gather columns into rows (opposite of spread)\n\n        Examples:\n\n        ```python\n        df = rf.DataFrame({\n            \"foo\": [1, 2, 1, 2],\n            \"bar\": [\"A\", \"B\", \"C\", \"D\"],\n            \"baz\": [\"!\", \"@\", \"#\", \"$\"],\n            \"jaz\": range(4)\n        })\n        ```\n        |   foo | bar   | baz   |   jaz |\n        |------:|:------|:------|------:|\n        |     1 | A     | !     |     0 |\n        |     2 | B     | @     |     1 |\n        |     1 | C     | #     |     2 |\n        |     2 | D     | $     |     3 |\n\n        All columns:\n\n        ```python\n        df.gather()\n        ```\n        | variable   | value   |\n        |:-----------|:--------|\n        | foo        | 1       |\n        | foo        | 2       |\n        | foo        | 1       |\n        | foo        | 2       |\n        | bar        | A       |\n        | bar        | B       |\n        | bar        | C       |\n        | bar        | D       |\n        | baz        | !       |\n        | baz        | @       |\n        | baz        | #       |\n        | baz        | $       |\n        | jaz        | 0       |\n        | jaz        | 1       |", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_155-205"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 190, "start_line_no": 165, "end_line_no": 215, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        \"\"\"Gather columns into rows (opposite of spread)\n\n        Examples:\n\n        ```python\n        df = rf.DataFrame({\n            \"foo\": [1, 2, 1, 2],\n            \"bar\": [\"A\", \"B\", \"C\", \"D\"],\n            \"baz\": [\"!\", \"@\", \"#\", \"$\"],\n            \"jaz\": range(4)\n        })\n        ```\n        |   foo | bar   | baz   |   jaz |\n        |------:|:------|:------|------:|\n        |     1 | A     | !     |     0 |\n        |     2 | B     | @     |     1 |\n        |     1 | C     | #     |     2 |\n        |     2 | D     | $     |     3 |\n\n        All columns:\n\n        ```python\n        df.gather()\n        ```\n        | variable   | value   |\n        |:-----------|:--------|\n        | foo        | 1       |\n        | foo        | 2       |\n        | foo        | 1       |\n        | foo        | 2       |\n        | bar        | A       |\n        | bar        | B       |\n        | bar        | C       |\n        | bar        | D       |\n        | baz        | !       |\n        | baz        | @       |\n        | baz        | #       |\n        | baz        | $       |\n        | jaz        | 0       |\n        | jaz        | 1       |\n        | jaz        | 2       |\n        | jaz        | 3       |\n\n        Multiple columns:\n\n        ```python\n        df.gather([\"foo\", \"bar\"], into=(\"var\", \"val\"))\n        ```\n        | baz   |   jaz | var   | val   |\n        |:------|------:|:------|:------|", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_165-215"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 200, "start_line_no": 175, "end_line_no": 225, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        })\n        ```\n        |   foo | bar   | baz   |   jaz |\n        |------:|:------|:------|------:|\n        |     1 | A     | !     |     0 |\n        |     2 | B     | @     |     1 |\n        |     1 | C     | #     |     2 |\n        |     2 | D     | $     |     3 |\n\n        All columns:\n\n        ```python\n        df.gather()\n        ```\n        | variable   | value   |\n        |:-----------|:--------|\n        | foo        | 1       |\n        | foo        | 2       |\n        | foo        | 1       |\n        | foo        | 2       |\n        | bar        | A       |\n        | bar        | B       |\n        | bar        | C       |\n        | bar        | D       |\n        | baz        | !       |\n        | baz        | @       |\n        | baz        | #       |\n        | baz        | $       |\n        | jaz        | 0       |\n        | jaz        | 1       |\n        | jaz        | 2       |\n        | jaz        | 3       |\n\n        Multiple columns:\n\n        ```python\n        df.gather([\"foo\", \"bar\"], into=(\"var\", \"val\"))\n        ```\n        | baz   |   jaz | var   | val   |\n        |:------|------:|:------|:------|\n        | !     |     0 | foo   | 1     |\n        | @     |     1 | foo   | 2     |\n        | #     |     2 | foo   | 1     |\n        | $     |     3 | foo   | 2     |\n        | !     |     0 | bar   | A     |\n        | @     |     1 | bar   | B     |\n        | #     |     2 | bar   | C     |\n        | $     |     3 | bar   | D     |\n\n        All columns beside:", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_175-225"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 210, "start_line_no": 185, "end_line_no": 235, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "\n        ```python\n        df.gather()\n        ```\n        | variable   | value   |\n        |:-----------|:--------|\n        | foo        | 1       |\n        | foo        | 2       |\n        | foo        | 1       |\n        | foo        | 2       |\n        | bar        | A       |\n        | bar        | B       |\n        | bar        | C       |\n        | bar        | D       |\n        | baz        | !       |\n        | baz        | @       |\n        | baz        | #       |\n        | baz        | $       |\n        | jaz        | 0       |\n        | jaz        | 1       |\n        | jaz        | 2       |\n        | jaz        | 3       |\n\n        Multiple columns:\n\n        ```python\n        df.gather([\"foo\", \"bar\"], into=(\"var\", \"val\"))\n        ```\n        | baz   |   jaz | var   | val   |\n        |:------|------:|:------|:------|\n        | !     |     0 | foo   | 1     |\n        | @     |     1 | foo   | 2     |\n        | #     |     2 | foo   | 1     |\n        | $     |     3 | foo   | 2     |\n        | !     |     0 | bar   | A     |\n        | @     |     1 | bar   | B     |\n        | #     |     2 | bar   | C     |\n        | $     |     3 | bar   | D     |\n\n        All columns beside:\n\n        ```python\n        df.group([\"foo\", \"bar\"]).gather(into=(\"variable\", \"value\"))\n        ```\n        |   foo | bar   | variable   | value   |\n        |------:|:------|:-----------|:--------|\n        |     1 | A     | baz        | !       |\n        |     2 | B     | baz        | @       |\n        |     1 | C     | baz        | #       |\n        |     2 | D     | baz        | $       |", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_185-235"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 220, "start_line_no": 195, "end_line_no": 245, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        | bar        | A       |\n        | bar        | B       |\n        | bar        | C       |\n        | bar        | D       |\n        | baz        | !       |\n        | baz        | @       |\n        | baz        | #       |\n        | baz        | $       |\n        | jaz        | 0       |\n        | jaz        | 1       |\n        | jaz        | 2       |\n        | jaz        | 3       |\n\n        Multiple columns:\n\n        ```python\n        df.gather([\"foo\", \"bar\"], into=(\"var\", \"val\"))\n        ```\n        | baz   |   jaz | var   | val   |\n        |:------|------:|:------|:------|\n        | !     |     0 | foo   | 1     |\n        | @     |     1 | foo   | 2     |\n        | #     |     2 | foo   | 1     |\n        | $     |     3 | foo   | 2     |\n        | !     |     0 | bar   | A     |\n        | @     |     1 | bar   | B     |\n        | #     |     2 | bar   | C     |\n        | $     |     3 | bar   | D     |\n\n        All columns beside:\n\n        ```python\n        df.group([\"foo\", \"bar\"]).gather(into=(\"variable\", \"value\"))\n        ```\n        |   foo | bar   | variable   | value   |\n        |------:|:------|:-----------|:--------|\n        |     1 | A     | baz        | !       |\n        |     2 | B     | baz        | @       |\n        |     1 | C     | baz        | #       |\n        |     2 | D     | baz        | $       |\n        |     1 | A     | jaz        | 0       |\n        |     2 | B     | jaz        | 1       |\n        |     1 | C     | jaz        | 2       |\n        |     2 | D     | jaz        | 3       |\n        \"\"\"\n        return _wrap(gather(self._data, columns, beside, into))\n\n    def pack(self, column: Column, sep: str) -> DataFrame:\n        \"\"\"Collate and concatenate row values for a target column (opposite of unpack)\n", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_195-245"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 230, "start_line_no": 205, "end_line_no": 255, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        | jaz        | 2       |\n        | jaz        | 3       |\n\n        Multiple columns:\n\n        ```python\n        df.gather([\"foo\", \"bar\"], into=(\"var\", \"val\"))\n        ```\n        | baz   |   jaz | var   | val   |\n        |:------|------:|:------|:------|\n        | !     |     0 | foo   | 1     |\n        | @     |     1 | foo   | 2     |\n        | #     |     2 | foo   | 1     |\n        | $     |     3 | foo   | 2     |\n        | !     |     0 | bar   | A     |\n        | @     |     1 | bar   | B     |\n        | #     |     2 | bar   | C     |\n        | $     |     3 | bar   | D     |\n\n        All columns beside:\n\n        ```python\n        df.group([\"foo\", \"bar\"]).gather(into=(\"variable\", \"value\"))\n        ```\n        |   foo | bar   | variable   | value   |\n        |------:|:------|:-----------|:--------|\n        |     1 | A     | baz        | !       |\n        |     2 | B     | baz        | @       |\n        |     1 | C     | baz        | #       |\n        |     2 | D     | baz        | $       |\n        |     1 | A     | jaz        | 0       |\n        |     2 | B     | jaz        | 1       |\n        |     1 | C     | jaz        | 2       |\n        |     2 | D     | jaz        | 3       |\n        \"\"\"\n        return _wrap(gather(self._data, columns, beside, into))\n\n    def pack(self, column: Column, sep: str) -> DataFrame:\n        \"\"\"Collate and concatenate row values for a target column (opposite of unpack)\n\n        Examples:\n\n        ```python\n        df = rf.DataFrame({\n            \"foo\": [\"A\", \"A\", \"B\", \"A\", \"B\", \"C\"],\n            \"bar\": [1, 2, 3, 4, 5, 6]\n        })\n        ```\n        | foo   |   bar |\n        |:------|------:|", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_205-255"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 240, "start_line_no": 215, "end_line_no": 265, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        | !     |     0 | foo   | 1     |\n        | @     |     1 | foo   | 2     |\n        | #     |     2 | foo   | 1     |\n        | $     |     3 | foo   | 2     |\n        | !     |     0 | bar   | A     |\n        | @     |     1 | bar   | B     |\n        | #     |     2 | bar   | C     |\n        | $     |     3 | bar   | D     |\n\n        All columns beside:\n\n        ```python\n        df.group([\"foo\", \"bar\"]).gather(into=(\"variable\", \"value\"))\n        ```\n        |   foo | bar   | variable   | value   |\n        |------:|:------|:-----------|:--------|\n        |     1 | A     | baz        | !       |\n        |     2 | B     | baz        | @       |\n        |     1 | C     | baz        | #       |\n        |     2 | D     | baz        | $       |\n        |     1 | A     | jaz        | 0       |\n        |     2 | B     | jaz        | 1       |\n        |     1 | C     | jaz        | 2       |\n        |     2 | D     | jaz        | 3       |\n        \"\"\"\n        return _wrap(gather(self._data, columns, beside, into))\n\n    def pack(self, column: Column, sep: str) -> DataFrame:\n        \"\"\"Collate and concatenate row values for a target column (opposite of unpack)\n\n        Examples:\n\n        ```python\n        df = rf.DataFrame({\n            \"foo\": [\"A\", \"A\", \"B\", \"A\", \"B\", \"C\"],\n            \"bar\": [1, 2, 3, 4, 5, 6]\n        })\n        ```\n        | foo   |   bar |\n        |:------|------:|\n        | A     |     1 |\n        | A     |     2 |\n        | B     |     3 |\n        | A     |     4 |\n        | B     |     5 |\n        | C     |     6 |\n\n        Pack all rows:\n\n        ```python", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_215-265"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 250, "start_line_no": 225, "end_line_no": 275, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "\n        ```python\n        df.group([\"foo\", \"bar\"]).gather(into=(\"variable\", \"value\"))\n        ```\n        |   foo | bar   | variable   | value   |\n        |------:|:------|:-----------|:--------|\n        |     1 | A     | baz        | !       |\n        |     2 | B     | baz        | @       |\n        |     1 | C     | baz        | #       |\n        |     2 | D     | baz        | $       |\n        |     1 | A     | jaz        | 0       |\n        |     2 | B     | jaz        | 1       |\n        |     1 | C     | jaz        | 2       |\n        |     2 | D     | jaz        | 3       |\n        \"\"\"\n        return _wrap(gather(self._data, columns, beside, into))\n\n    def pack(self, column: Column, sep: str) -> DataFrame:\n        \"\"\"Collate and concatenate row values for a target column (opposite of unpack)\n\n        Examples:\n\n        ```python\n        df = rf.DataFrame({\n            \"foo\": [\"A\", \"A\", \"B\", \"A\", \"B\", \"C\"],\n            \"bar\": [1, 2, 3, 4, 5, 6]\n        })\n        ```\n        | foo   |   bar |\n        |:------|------:|\n        | A     |     1 |\n        | A     |     2 |\n        | B     |     3 |\n        | A     |     4 |\n        | B     |     5 |\n        | C     |     6 |\n\n        Pack all rows:\n\n        ```python\n        df.pack(\"foo\", sep=\"+\")\n        ```\n        | foo         |\n        |:------------|\n        | A+A+B+A+B+C |\n\n        Pack rows by Group:\n\n        ```python\n        df.group(\"foo\").pack(\"bar\", sep=\"|\")", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_225-275"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 260, "start_line_no": 235, "end_line_no": 285, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        |     1 | A     | jaz        | 0       |\n        |     2 | B     | jaz        | 1       |\n        |     1 | C     | jaz        | 2       |\n        |     2 | D     | jaz        | 3       |\n        \"\"\"\n        return _wrap(gather(self._data, columns, beside, into))\n\n    def pack(self, column: Column, sep: str) -> DataFrame:\n        \"\"\"Collate and concatenate row values for a target column (opposite of unpack)\n\n        Examples:\n\n        ```python\n        df = rf.DataFrame({\n            \"foo\": [\"A\", \"A\", \"B\", \"A\", \"B\", \"C\"],\n            \"bar\": [1, 2, 3, 4, 5, 6]\n        })\n        ```\n        | foo   |   bar |\n        |:------|------:|\n        | A     |     1 |\n        | A     |     2 |\n        | B     |     3 |\n        | A     |     4 |\n        | B     |     5 |\n        | C     |     6 |\n\n        Pack all rows:\n\n        ```python\n        df.pack(\"foo\", sep=\"+\")\n        ```\n        | foo         |\n        |:------------|\n        | A+A+B+A+B+C |\n\n        Pack rows by Group:\n\n        ```python\n        df.group(\"foo\").pack(\"bar\", sep=\"|\")\n        ```\n        | foo   | bar   |\n        |:------|:------|\n        | A     | 1|2|4 |\n        | B     | 3|5   |\n        | C     | 6     |\n        \"\"\"\n        return _wrap(pack(self._data, column, sep))\n\n    def rank(", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_235-285"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 270, "start_line_no": 245, "end_line_no": 295, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        Examples:\n\n        ```python\n        df = rf.DataFrame({\n            \"foo\": [\"A\", \"A\", \"B\", \"A\", \"B\", \"C\"],\n            \"bar\": [1, 2, 3, 4, 5, 6]\n        })\n        ```\n        | foo   |   bar |\n        |:------|------:|\n        | A     |     1 |\n        | A     |     2 |\n        | B     |     3 |\n        | A     |     4 |\n        | B     |     5 |\n        | C     |     6 |\n\n        Pack all rows:\n\n        ```python\n        df.pack(\"foo\", sep=\"+\")\n        ```\n        | foo         |\n        |:------------|\n        | A+A+B+A+B+C |\n\n        Pack rows by Group:\n\n        ```python\n        df.group(\"foo\").pack(\"bar\", sep=\"|\")\n        ```\n        | foo   | bar   |\n        |:------|:------|\n        | A     | 1|2|4 |\n        | B     | 3|5   |\n        | C     | 6     |\n        \"\"\"\n        return _wrap(pack(self._data, column, sep))\n\n    def rank(\n        self,\n        column: Column,\n        into: Column,\n        descending: bool = False,\n    ) -> DataFrame:\n        \"\"\"Rank order values in a column\n\n        Example:\n\n        ```python", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_245-295"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 280, "start_line_no": 255, "end_line_no": 305, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        | A     |     1 |\n        | A     |     2 |\n        | B     |     3 |\n        | A     |     4 |\n        | B     |     5 |\n        | C     |     6 |\n\n        Pack all rows:\n\n        ```python\n        df.pack(\"foo\", sep=\"+\")\n        ```\n        | foo         |\n        |:------------|\n        | A+A+B+A+B+C |\n\n        Pack rows by Group:\n\n        ```python\n        df.group(\"foo\").pack(\"bar\", sep=\"|\")\n        ```\n        | foo   | bar   |\n        |:------|:------|\n        | A     | 1|2|4 |\n        | B     | 3|5   |\n        | C     | 6     |\n        \"\"\"\n        return _wrap(pack(self._data, column, sep))\n\n    def rank(\n        self,\n        column: Column,\n        into: Column,\n        descending: bool = False,\n    ) -> DataFrame:\n        \"\"\"Rank order values in a column\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [2, 3, 3, 99, 1000, 1, -6, 4]})\n        ```\n        |   foo |\n        |------:|\n        |     2 |\n        |     3 |\n        |     3 |\n        |    99 |\n        |  1000 |\n        |     1 |", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_255-305"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 290, "start_line_no": 265, "end_line_no": 315, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        df.pack(\"foo\", sep=\"+\")\n        ```\n        | foo         |\n        |:------------|\n        | A+A+B+A+B+C |\n\n        Pack rows by Group:\n\n        ```python\n        df.group(\"foo\").pack(\"bar\", sep=\"|\")\n        ```\n        | foo   | bar   |\n        |:------|:------|\n        | A     | 1|2|4 |\n        | B     | 3|5   |\n        | C     | 6     |\n        \"\"\"\n        return _wrap(pack(self._data, column, sep))\n\n    def rank(\n        self,\n        column: Column,\n        into: Column,\n        descending: bool = False,\n    ) -> DataFrame:\n        \"\"\"Rank order values in a column\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [2, 3, 3, 99, 1000, 1, -6, 4]})\n        ```\n        |   foo |\n        |------:|\n        |     2 |\n        |     3 |\n        |     3 |\n        |    99 |\n        |  1000 |\n        |     1 |\n        |    -6 |\n        |     4 |\n\n        ```python\n        df.rank(\"foo\", into=\"rank\", descending=True)\n        ```\n        |   foo |   rank |\n        |------:|-------:|\n        |     2 |      5 |\n        |     3 |      4 |", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_265-315"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 300, "start_line_no": 275, "end_line_no": 325, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        ```\n        | foo   | bar   |\n        |:------|:------|\n        | A     | 1|2|4 |\n        | B     | 3|5   |\n        | C     | 6     |\n        \"\"\"\n        return _wrap(pack(self._data, column, sep))\n\n    def rank(\n        self,\n        column: Column,\n        into: Column,\n        descending: bool = False,\n    ) -> DataFrame:\n        \"\"\"Rank order values in a column\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [2, 3, 3, 99, 1000, 1, -6, 4]})\n        ```\n        |   foo |\n        |------:|\n        |     2 |\n        |     3 |\n        |     3 |\n        |    99 |\n        |  1000 |\n        |     1 |\n        |    -6 |\n        |     4 |\n\n        ```python\n        df.rank(\"foo\", into=\"rank\", descending=True)\n        ```\n        |   foo |   rank |\n        |------:|-------:|\n        |     2 |      5 |\n        |     3 |      4 |\n        |     3 |      4 |\n        |    99 |      2 |\n        |  1000 |      1 |\n        |     1 |      6 |\n        |    -6 |      7 |\n        |     4 |      3 |\n        \"\"\"\n        return _wrap(rank(self._data, column, into, descending))\n\n    def rollup(self, over: dict[Column, tuple[Column, Func]]) -> DataFrame:", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_275-325"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 310, "start_line_no": 285, "end_line_no": 335, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        self,\n        column: Column,\n        into: Column,\n        descending: bool = False,\n    ) -> DataFrame:\n        \"\"\"Rank order values in a column\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [2, 3, 3, 99, 1000, 1, -6, 4]})\n        ```\n        |   foo |\n        |------:|\n        |     2 |\n        |     3 |\n        |     3 |\n        |    99 |\n        |  1000 |\n        |     1 |\n        |    -6 |\n        |     4 |\n\n        ```python\n        df.rank(\"foo\", into=\"rank\", descending=True)\n        ```\n        |   foo |   rank |\n        |------:|-------:|\n        |     2 |      5 |\n        |     3 |      4 |\n        |     3 |      4 |\n        |    99 |      2 |\n        |  1000 |      1 |\n        |     1 |      6 |\n        |    -6 |      7 |\n        |     4 |      3 |\n        \"\"\"\n        return _wrap(rank(self._data, column, into, descending))\n\n    def rollup(self, over: dict[Column, tuple[Column, Func]]) -> DataFrame:\n        \"\"\"Apply summary functions and/or statistics to target columns\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [1, 2, 3, 4, 5], \"bar\": [99, 100, 1, -5, 2]})\n        ```\n        |   foo |   bar |\n        |------:|------:|\n        |     1 |    99 |", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_285-335"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 320, "start_line_no": 295, "end_line_no": 345, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        df = rf.DataFrame({\"foo\": [2, 3, 3, 99, 1000, 1, -6, 4]})\n        ```\n        |   foo |\n        |------:|\n        |     2 |\n        |     3 |\n        |     3 |\n        |    99 |\n        |  1000 |\n        |     1 |\n        |    -6 |\n        |     4 |\n\n        ```python\n        df.rank(\"foo\", into=\"rank\", descending=True)\n        ```\n        |   foo |   rank |\n        |------:|-------:|\n        |     2 |      5 |\n        |     3 |      4 |\n        |     3 |      4 |\n        |    99 |      2 |\n        |  1000 |      1 |\n        |     1 |      6 |\n        |    -6 |      7 |\n        |     4 |      3 |\n        \"\"\"\n        return _wrap(rank(self._data, column, into, descending))\n\n    def rollup(self, over: dict[Column, tuple[Column, Func]]) -> DataFrame:\n        \"\"\"Apply summary functions and/or statistics to target columns\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [1, 2, 3, 4, 5], \"bar\": [99, 100, 1, -5, 2]})\n        ```\n        |   foo |   bar |\n        |------:|------:|\n        |     1 |    99 |\n        |     2 |   100 |\n        |     3 |     1 |\n        |     4 |    -5 |\n        |     5 |     2 |\n\n        ```python\n        df.rollup({\n            \"fcount\": (\"foo\", rf.stat.count),\n            \"fmean\": (\"foo\", rf.stat.mean),\n            \"fsum\": (\"foo\", rf.stat.sum),", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_295-345"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 330, "start_line_no": 305, "end_line_no": 355, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        |    -6 |\n        |     4 |\n\n        ```python\n        df.rank(\"foo\", into=\"rank\", descending=True)\n        ```\n        |   foo |   rank |\n        |------:|-------:|\n        |     2 |      5 |\n        |     3 |      4 |\n        |     3 |      4 |\n        |    99 |      2 |\n        |  1000 |      1 |\n        |     1 |      6 |\n        |    -6 |      7 |\n        |     4 |      3 |\n        \"\"\"\n        return _wrap(rank(self._data, column, into, descending))\n\n    def rollup(self, over: dict[Column, tuple[Column, Func]]) -> DataFrame:\n        \"\"\"Apply summary functions and/or statistics to target columns\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [1, 2, 3, 4, 5], \"bar\": [99, 100, 1, -5, 2]})\n        ```\n        |   foo |   bar |\n        |------:|------:|\n        |     1 |    99 |\n        |     2 |   100 |\n        |     3 |     1 |\n        |     4 |    -5 |\n        |     5 |     2 |\n\n        ```python\n        df.rollup({\n            \"fcount\": (\"foo\", rf.stat.count),\n            \"fmean\": (\"foo\", rf.stat.mean),\n            \"fsum\": (\"foo\", rf.stat.sum),\n            \"fmax\": (\"foo\", rf.stat.max),\n            \"bmedian\": (\"bar\", rf.stat.median),\n            \"bmin\": (\"bar\", rf.stat.min),\n            \"bstd\": (\"bar\", rf.stat.std)\n        })\n        ```\n        |   fcount |   fmean |   fsum |   fmax |   bmedian |   bmin |   bstd |\n        |---------:|--------:|-------:|-------:|----------:|-------:|-------:|\n        |        5 |       3 |     15 |      5 |         2 |     -5 |  54.93 |\n        \"\"\"", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_305-355"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 340, "start_line_no": 315, "end_line_no": 365, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        |     3 |      4 |\n        |    99 |      2 |\n        |  1000 |      1 |\n        |     1 |      6 |\n        |    -6 |      7 |\n        |     4 |      3 |\n        \"\"\"\n        return _wrap(rank(self._data, column, into, descending))\n\n    def rollup(self, over: dict[Column, tuple[Column, Func]]) -> DataFrame:\n        \"\"\"Apply summary functions and/or statistics to target columns\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [1, 2, 3, 4, 5], \"bar\": [99, 100, 1, -5, 2]})\n        ```\n        |   foo |   bar |\n        |------:|------:|\n        |     1 |    99 |\n        |     2 |   100 |\n        |     3 |     1 |\n        |     4 |    -5 |\n        |     5 |     2 |\n\n        ```python\n        df.rollup({\n            \"fcount\": (\"foo\", rf.stat.count),\n            \"fmean\": (\"foo\", rf.stat.mean),\n            \"fsum\": (\"foo\", rf.stat.sum),\n            \"fmax\": (\"foo\", rf.stat.max),\n            \"bmedian\": (\"bar\", rf.stat.median),\n            \"bmin\": (\"bar\", rf.stat.min),\n            \"bstd\": (\"bar\", rf.stat.std)\n        })\n        ```\n        |   fcount |   fmean |   fsum |   fmax |   bmedian |   bmin |   bstd |\n        |---------:|--------:|-------:|-------:|----------:|-------:|-------:|\n        |        5 |       3 |     15 |      5 |         2 |     -5 |  54.93 |\n        \"\"\"\n        return _wrap(rollup(self._data, over))\n\n    def summarize(self, over: dict[Column, tuple[Column, Func]]) -> DataFrame:\n        message = \"Marked for removal, please use `rollup` instead\"\n        warnings.warn(message, FutureWarning)\n        return self.rollup(over)\n\n\nclass GroupedFrame(_CommonMixin):\n    \"\"\"GroupedFrame compatible with: `accumulate`, `gather`, `pack`, `rank`, `rollup`, `take`\"\"\"", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_315-365"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 350, "start_line_no": 325, "end_line_no": 375, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        \"\"\"Apply summary functions and/or statistics to target columns\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [1, 2, 3, 4, 5], \"bar\": [99, 100, 1, -5, 2]})\n        ```\n        |   foo |   bar |\n        |------:|------:|\n        |     1 |    99 |\n        |     2 |   100 |\n        |     3 |     1 |\n        |     4 |    -5 |\n        |     5 |     2 |\n\n        ```python\n        df.rollup({\n            \"fcount\": (\"foo\", rf.stat.count),\n            \"fmean\": (\"foo\", rf.stat.mean),\n            \"fsum\": (\"foo\", rf.stat.sum),\n            \"fmax\": (\"foo\", rf.stat.max),\n            \"bmedian\": (\"bar\", rf.stat.median),\n            \"bmin\": (\"bar\", rf.stat.min),\n            \"bstd\": (\"bar\", rf.stat.std)\n        })\n        ```\n        |   fcount |   fmean |   fsum |   fmax |   bmedian |   bmin |   bstd |\n        |---------:|--------:|-------:|-------:|----------:|-------:|-------:|\n        |        5 |       3 |     15 |      5 |         2 |     -5 |  54.93 |\n        \"\"\"\n        return _wrap(rollup(self._data, over))\n\n    def summarize(self, over: dict[Column, tuple[Column, Func]]) -> DataFrame:\n        message = \"Marked for removal, please use `rollup` instead\"\n        warnings.warn(message, FutureWarning)\n        return self.rollup(over)\n\n\nclass GroupedFrame(_CommonMixin):\n    \"\"\"GroupedFrame compatible with: `accumulate`, `gather`, `pack`, `rank`, `rollup`, `take`\"\"\"\n\n    def __repr__(self) -> str:\n        return self._data.obj.__repr__()  # type: ignore\n\n    def _repr_html_(self) -> str:\n        return self._data.obj.to_html(index=True)  # type: ignore\n\n\nclass DataFrame(_CommonMixin, _InterchangeMixin):\n    def __init__(self, data: dict[Column, Values] | None = None) -> None:", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_325-375"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 360, "start_line_no": 335, "end_line_no": 385, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        |     2 |   100 |\n        |     3 |     1 |\n        |     4 |    -5 |\n        |     5 |     2 |\n\n        ```python\n        df.rollup({\n            \"fcount\": (\"foo\", rf.stat.count),\n            \"fmean\": (\"foo\", rf.stat.mean),\n            \"fsum\": (\"foo\", rf.stat.sum),\n            \"fmax\": (\"foo\", rf.stat.max),\n            \"bmedian\": (\"bar\", rf.stat.median),\n            \"bmin\": (\"bar\", rf.stat.min),\n            \"bstd\": (\"bar\", rf.stat.std)\n        })\n        ```\n        |   fcount |   fmean |   fsum |   fmax |   bmedian |   bmin |   bstd |\n        |---------:|--------:|-------:|-------:|----------:|-------:|-------:|\n        |        5 |       3 |     15 |      5 |         2 |     -5 |  54.93 |\n        \"\"\"\n        return _wrap(rollup(self._data, over))\n\n    def summarize(self, over: dict[Column, tuple[Column, Func]]) -> DataFrame:\n        message = \"Marked for removal, please use `rollup` instead\"\n        warnings.warn(message, FutureWarning)\n        return self.rollup(over)\n\n\nclass GroupedFrame(_CommonMixin):\n    \"\"\"GroupedFrame compatible with: `accumulate`, `gather`, `pack`, `rank`, `rollup`, `take`\"\"\"\n\n    def __repr__(self) -> str:\n        return self._data.obj.__repr__()  # type: ignore\n\n    def _repr_html_(self) -> str:\n        return self._data.obj.to_html(index=True)  # type: ignore\n\n\nclass DataFrame(_CommonMixin, _InterchangeMixin):\n    def __init__(self, data: dict[Column, Values] | None = None) -> None:\n        \"\"\"Initialize a DataFrame with a standard dictionary\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [1, 2], \"bar\": [\"A\", \"B\"]})\n        ```\n        |   foo | bar   |\n        |------:|:------|\n        |     1 | A     |", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_335-385"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 370, "start_line_no": 345, "end_line_no": 395, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "            \"fmax\": (\"foo\", rf.stat.max),\n            \"bmedian\": (\"bar\", rf.stat.median),\n            \"bmin\": (\"bar\", rf.stat.min),\n            \"bstd\": (\"bar\", rf.stat.std)\n        })\n        ```\n        |   fcount |   fmean |   fsum |   fmax |   bmedian |   bmin |   bstd |\n        |---------:|--------:|-------:|-------:|----------:|-------:|-------:|\n        |        5 |       3 |     15 |      5 |         2 |     -5 |  54.93 |\n        \"\"\"\n        return _wrap(rollup(self._data, over))\n\n    def summarize(self, over: dict[Column, tuple[Column, Func]]) -> DataFrame:\n        message = \"Marked for removal, please use `rollup` instead\"\n        warnings.warn(message, FutureWarning)\n        return self.rollup(over)\n\n\nclass GroupedFrame(_CommonMixin):\n    \"\"\"GroupedFrame compatible with: `accumulate`, `gather`, `pack`, `rank`, `rollup`, `take`\"\"\"\n\n    def __repr__(self) -> str:\n        return self._data.obj.__repr__()  # type: ignore\n\n    def _repr_html_(self) -> str:\n        return self._data.obj.to_html(index=True)  # type: ignore\n\n\nclass DataFrame(_CommonMixin, _InterchangeMixin):\n    def __init__(self, data: dict[Column, Values] | None = None) -> None:\n        \"\"\"Initialize a DataFrame with a standard dictionary\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [1, 2], \"bar\": [\"A\", \"B\"]})\n        ```\n        |   foo | bar   |\n        |------:|:------|\n        |     1 | A     |\n        |     2 | B     |\n        \"\"\"\n        _check_type(data, {dict, None})\n        if not data:\n            self._data = PandasDataFrame()\n        if isinstance(data, dict):\n            self._data = PandasDataFrame(data)\n\n    def __eq__(self, rhs: Any) -> bool:\n        \"\"\"Check if two DataFrames are equal to each other", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_345-395"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 380, "start_line_no": 355, "end_line_no": 405, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        return _wrap(rollup(self._data, over))\n\n    def summarize(self, over: dict[Column, tuple[Column, Func]]) -> DataFrame:\n        message = \"Marked for removal, please use `rollup` instead\"\n        warnings.warn(message, FutureWarning)\n        return self.rollup(over)\n\n\nclass GroupedFrame(_CommonMixin):\n    \"\"\"GroupedFrame compatible with: `accumulate`, `gather`, `pack`, `rank`, `rollup`, `take`\"\"\"\n\n    def __repr__(self) -> str:\n        return self._data.obj.__repr__()  # type: ignore\n\n    def _repr_html_(self) -> str:\n        return self._data.obj.to_html(index=True)  # type: ignore\n\n\nclass DataFrame(_CommonMixin, _InterchangeMixin):\n    def __init__(self, data: dict[Column, Values] | None = None) -> None:\n        \"\"\"Initialize a DataFrame with a standard dictionary\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [1, 2], \"bar\": [\"A\", \"B\"]})\n        ```\n        |   foo | bar   |\n        |------:|:------|\n        |     1 | A     |\n        |     2 | B     |\n        \"\"\"\n        _check_type(data, {dict, None})\n        if not data:\n            self._data = PandasDataFrame()\n        if isinstance(data, dict):\n            self._data = PandasDataFrame(data)\n\n    def __eq__(self, rhs: Any) -> bool:\n        \"\"\"Check if two DataFrames are equal to each other\n\n        Example:\n\n        ```python\n        adf = rf.DataFrame({\"foo\": [1]})\n        bdf = rf.DataFrame({\"bar\": [1]})\n        cdf = rf.DataFrame({\"foo\": [1]})\n        print(adf == bdf)\n        print(adf == cdf)\n        # False", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_355-405"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 390, "start_line_no": 365, "end_line_no": 415, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "\n    def __repr__(self) -> str:\n        return self._data.obj.__repr__()  # type: ignore\n\n    def _repr_html_(self) -> str:\n        return self._data.obj.to_html(index=True)  # type: ignore\n\n\nclass DataFrame(_CommonMixin, _InterchangeMixin):\n    def __init__(self, data: dict[Column, Values] | None = None) -> None:\n        \"\"\"Initialize a DataFrame with a standard dictionary\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [1, 2], \"bar\": [\"A\", \"B\"]})\n        ```\n        |   foo | bar   |\n        |------:|:------|\n        |     1 | A     |\n        |     2 | B     |\n        \"\"\"\n        _check_type(data, {dict, None})\n        if not data:\n            self._data = PandasDataFrame()\n        if isinstance(data, dict):\n            self._data = PandasDataFrame(data)\n\n    def __eq__(self, rhs: Any) -> bool:\n        \"\"\"Check if two DataFrames are equal to each other\n\n        Example:\n\n        ```python\n        adf = rf.DataFrame({\"foo\": [1]})\n        bdf = rf.DataFrame({\"bar\": [1]})\n        cdf = rf.DataFrame({\"foo\": [1]})\n        print(adf == bdf)\n        print(adf == cdf)\n        # False\n        # True\n        ```\n        \"\"\"\n        if not isinstance(rhs, DataFrame):\n            return False\n        return self._data.equals(rhs._data)\n\n    def __getitem__(self, key: Column) -> Values:\n        \"\"\"Retrive values (as a python list) from a specified column\n", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_365-415"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 400, "start_line_no": 375, "end_line_no": 425, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        \"\"\"Initialize a DataFrame with a standard dictionary\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [1, 2], \"bar\": [\"A\", \"B\"]})\n        ```\n        |   foo | bar   |\n        |------:|:------|\n        |     1 | A     |\n        |     2 | B     |\n        \"\"\"\n        _check_type(data, {dict, None})\n        if not data:\n            self._data = PandasDataFrame()\n        if isinstance(data, dict):\n            self._data = PandasDataFrame(data)\n\n    def __eq__(self, rhs: Any) -> bool:\n        \"\"\"Check if two DataFrames are equal to each other\n\n        Example:\n\n        ```python\n        adf = rf.DataFrame({\"foo\": [1]})\n        bdf = rf.DataFrame({\"bar\": [1]})\n        cdf = rf.DataFrame({\"foo\": [1]})\n        print(adf == bdf)\n        print(adf == cdf)\n        # False\n        # True\n        ```\n        \"\"\"\n        if not isinstance(rhs, DataFrame):\n            return False\n        return self._data.equals(rhs._data)\n\n    def __getitem__(self, key: Column) -> Values:\n        \"\"\"Retrive values (as a python list) from a specified column\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [1, 2], \"bar\": [\"A\", \"B\"]})\n        df[\"foo\"]\n        # [1, 2]\n        ```\n        \"\"\"\n        return list(self._data[key])\n", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_375-425"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 410, "start_line_no": 385, "end_line_no": 435, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        |     2 | B     |\n        \"\"\"\n        _check_type(data, {dict, None})\n        if not data:\n            self._data = PandasDataFrame()\n        if isinstance(data, dict):\n            self._data = PandasDataFrame(data)\n\n    def __eq__(self, rhs: Any) -> bool:\n        \"\"\"Check if two DataFrames are equal to each other\n\n        Example:\n\n        ```python\n        adf = rf.DataFrame({\"foo\": [1]})\n        bdf = rf.DataFrame({\"bar\": [1]})\n        cdf = rf.DataFrame({\"foo\": [1]})\n        print(adf == bdf)\n        print(adf == cdf)\n        # False\n        # True\n        ```\n        \"\"\"\n        if not isinstance(rhs, DataFrame):\n            return False\n        return self._data.equals(rhs._data)\n\n    def __getitem__(self, key: Column) -> Values:\n        \"\"\"Retrive values (as a python list) from a specified column\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [1, 2], \"bar\": [\"A\", \"B\"]})\n        df[\"foo\"]\n        # [1, 2]\n        ```\n        \"\"\"\n        return list(self._data[key])\n\n    def __repr__(self) -> str:\n        return self._data.__repr__()\n\n    def _repr_html_(self) -> str:\n        return self._data.to_html(index=True)\n\n    def __str__(self) -> str:\n        \"\"\"Return string constructor (for copy-and-pasting)\n\n        Example:", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_385-435"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 420, "start_line_no": 395, "end_line_no": 445, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "\n        Example:\n\n        ```python\n        adf = rf.DataFrame({\"foo\": [1]})\n        bdf = rf.DataFrame({\"bar\": [1]})\n        cdf = rf.DataFrame({\"foo\": [1]})\n        print(adf == bdf)\n        print(adf == cdf)\n        # False\n        # True\n        ```\n        \"\"\"\n        if not isinstance(rhs, DataFrame):\n            return False\n        return self._data.equals(rhs._data)\n\n    def __getitem__(self, key: Column) -> Values:\n        \"\"\"Retrive values (as a python list) from a specified column\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [1, 2], \"bar\": [\"A\", \"B\"]})\n        df[\"foo\"]\n        # [1, 2]\n        ```\n        \"\"\"\n        return list(self._data[key])\n\n    def __repr__(self) -> str:\n        return self._data.__repr__()\n\n    def _repr_html_(self) -> str:\n        return self._data.to_html(index=True)\n\n    def __str__(self) -> str:\n        \"\"\"Return string constructor (for copy-and-pasting)\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [1, 2], \"bar\": [\"A\", \"B\"]})\n        str(df)\n        # \"rf.DataFrame({'foo': [1, 2], 'bar': ['A', 'B']})\"\n        ```\n        \"\"\"\n        data = self._data.to_dict(orient=\"list\")\n        string = pprint.pformat(data, indent=4, sort_dicts=False, compact=True)\n        if \"\\n\" in string:", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_395-445"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 430, "start_line_no": 405, "end_line_no": 455, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        # True\n        ```\n        \"\"\"\n        if not isinstance(rhs, DataFrame):\n            return False\n        return self._data.equals(rhs._data)\n\n    def __getitem__(self, key: Column) -> Values:\n        \"\"\"Retrive values (as a python list) from a specified column\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [1, 2], \"bar\": [\"A\", \"B\"]})\n        df[\"foo\"]\n        # [1, 2]\n        ```\n        \"\"\"\n        return list(self._data[key])\n\n    def __repr__(self) -> str:\n        return self._data.__repr__()\n\n    def _repr_html_(self) -> str:\n        return self._data.to_html(index=True)\n\n    def __str__(self) -> str:\n        \"\"\"Return string constructor (for copy-and-pasting)\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [1, 2], \"bar\": [\"A\", \"B\"]})\n        str(df)\n        # \"rf.DataFrame({'foo': [1, 2], 'bar': ['A', 'B']})\"\n        ```\n        \"\"\"\n        data = self._data.to_dict(orient=\"list\")\n        string = pprint.pformat(data, indent=4, sort_dicts=False, compact=True)\n        if \"\\n\" in string:\n            string = \" \" + string[1:-1]\n            string = f\"rf.DataFrame({{\\n{string}\\n}})\"\n        else:\n            string = f\"rf.DataFrame({string})\"\n        return string\n\n    @property\n    def columns(self) -> Columns:\n        \"\"\"Inspect column keys (names)\n", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_405-455"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 440, "start_line_no": 415, "end_line_no": 465, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [1, 2], \"bar\": [\"A\", \"B\"]})\n        df[\"foo\"]\n        # [1, 2]\n        ```\n        \"\"\"\n        return list(self._data[key])\n\n    def __repr__(self) -> str:\n        return self._data.__repr__()\n\n    def _repr_html_(self) -> str:\n        return self._data.to_html(index=True)\n\n    def __str__(self) -> str:\n        \"\"\"Return string constructor (for copy-and-pasting)\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [1, 2], \"bar\": [\"A\", \"B\"]})\n        str(df)\n        # \"rf.DataFrame({'foo': [1, 2], 'bar': ['A', 'B']})\"\n        ```\n        \"\"\"\n        data = self._data.to_dict(orient=\"list\")\n        string = pprint.pformat(data, indent=4, sort_dicts=False, compact=True)\n        if \"\\n\" in string:\n            string = \" \" + string[1:-1]\n            string = f\"rf.DataFrame({{\\n{string}\\n}})\"\n        else:\n            string = f\"rf.DataFrame({string})\"\n        return string\n\n    @property\n    def columns(self) -> Columns:\n        \"\"\"Inspect column keys (names)\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [1, 2], \"bar\": [\"A\", \"B\"], \"baz\": [True, False]})\n        df.columns\n        # ['foo', 'bar', 'baz']\n        ```\n        \"\"\"\n        return list(self._data.columns)\n", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_415-465"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 450, "start_line_no": 425, "end_line_no": 475, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "    def __repr__(self) -> str:\n        return self._data.__repr__()\n\n    def _repr_html_(self) -> str:\n        return self._data.to_html(index=True)\n\n    def __str__(self) -> str:\n        \"\"\"Return string constructor (for copy-and-pasting)\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [1, 2], \"bar\": [\"A\", \"B\"]})\n        str(df)\n        # \"rf.DataFrame({'foo': [1, 2], 'bar': ['A', 'B']})\"\n        ```\n        \"\"\"\n        data = self._data.to_dict(orient=\"list\")\n        string = pprint.pformat(data, indent=4, sort_dicts=False, compact=True)\n        if \"\\n\" in string:\n            string = \" \" + string[1:-1]\n            string = f\"rf.DataFrame({{\\n{string}\\n}})\"\n        else:\n            string = f\"rf.DataFrame({string})\"\n        return string\n\n    @property\n    def columns(self) -> Columns:\n        \"\"\"Inspect column keys (names)\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [1, 2], \"bar\": [\"A\", \"B\"], \"baz\": [True, False]})\n        df.columns\n        # ['foo', 'bar', 'baz']\n        ```\n        \"\"\"\n        return list(self._data.columns)\n\n    @property\n    def dimensions(self) -> dict[str, int]:\n        \"\"\"Inspect DataFrame shape\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": range(10), \"bar\": range(10, 20)})\n        df.dimensions\n        # {'rows': 10, 'columns': 2}", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_425-475"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 460, "start_line_no": 435, "end_line_no": 485, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "\n        ```python\n        df = rf.DataFrame({\"foo\": [1, 2], \"bar\": [\"A\", \"B\"]})\n        str(df)\n        # \"rf.DataFrame({'foo': [1, 2], 'bar': ['A', 'B']})\"\n        ```\n        \"\"\"\n        data = self._data.to_dict(orient=\"list\")\n        string = pprint.pformat(data, indent=4, sort_dicts=False, compact=True)\n        if \"\\n\" in string:\n            string = \" \" + string[1:-1]\n            string = f\"rf.DataFrame({{\\n{string}\\n}})\"\n        else:\n            string = f\"rf.DataFrame({string})\"\n        return string\n\n    @property\n    def columns(self) -> Columns:\n        \"\"\"Inspect column keys (names)\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [1, 2], \"bar\": [\"A\", \"B\"], \"baz\": [True, False]})\n        df.columns\n        # ['foo', 'bar', 'baz']\n        ```\n        \"\"\"\n        return list(self._data.columns)\n\n    @property\n    def dimensions(self) -> dict[str, int]:\n        \"\"\"Inspect DataFrame shape\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": range(10), \"bar\": range(10, 20)})\n        df.dimensions\n        # {'rows': 10, 'columns': 2}\n        ```\n        \"\"\"\n        return dict(zip([\"rows\", \"columns\"], self._data.shape))\n\n    @property\n    def empty(self) -> bool:\n        \"\"\"Inspect if DataFrame is \"empty\"\n\n        Example:\n", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_435-485"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 470, "start_line_no": 445, "end_line_no": 495, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "            string = \" \" + string[1:-1]\n            string = f\"rf.DataFrame({{\\n{string}\\n}})\"\n        else:\n            string = f\"rf.DataFrame({string})\"\n        return string\n\n    @property\n    def columns(self) -> Columns:\n        \"\"\"Inspect column keys (names)\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [1, 2], \"bar\": [\"A\", \"B\"], \"baz\": [True, False]})\n        df.columns\n        # ['foo', 'bar', 'baz']\n        ```\n        \"\"\"\n        return list(self._data.columns)\n\n    @property\n    def dimensions(self) -> dict[str, int]:\n        \"\"\"Inspect DataFrame shape\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": range(10), \"bar\": range(10, 20)})\n        df.dimensions\n        # {'rows': 10, 'columns': 2}\n        ```\n        \"\"\"\n        return dict(zip([\"rows\", \"columns\"], self._data.shape))\n\n    @property\n    def empty(self) -> bool:\n        \"\"\"Inspect if DataFrame is \"empty\"\n\n        Example:\n\n        ```python\n        df = rf.DataFrame()\n        df.empty\n        # True\n        ```\n        \"\"\"\n        return self._data.empty\n\n    @property\n    def memory(self) -> str:", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_445-495"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 480, "start_line_no": 455, "end_line_no": 505, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [1, 2], \"bar\": [\"A\", \"B\"], \"baz\": [True, False]})\n        df.columns\n        # ['foo', 'bar', 'baz']\n        ```\n        \"\"\"\n        return list(self._data.columns)\n\n    @property\n    def dimensions(self) -> dict[str, int]:\n        \"\"\"Inspect DataFrame shape\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": range(10), \"bar\": range(10, 20)})\n        df.dimensions\n        # {'rows': 10, 'columns': 2}\n        ```\n        \"\"\"\n        return dict(zip([\"rows\", \"columns\"], self._data.shape))\n\n    @property\n    def empty(self) -> bool:\n        \"\"\"Inspect if DataFrame is \"empty\"\n\n        Example:\n\n        ```python\n        df = rf.DataFrame()\n        df.empty\n        # True\n        ```\n        \"\"\"\n        return self._data.empty\n\n    @property\n    def memory(self) -> str:\n        \"\"\"Interrogate DataFrame (deep) memory usage\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [1, 2, 3], \"bar\": [\"A\", \"B\", \"C\"]})\n        df.memory\n        # '326B'\n        ```\n        \"\"\"", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_455-505"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 490, "start_line_no": 465, "end_line_no": 515, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "    @property\n    def dimensions(self) -> dict[str, int]:\n        \"\"\"Inspect DataFrame shape\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": range(10), \"bar\": range(10, 20)})\n        df.dimensions\n        # {'rows': 10, 'columns': 2}\n        ```\n        \"\"\"\n        return dict(zip([\"rows\", \"columns\"], self._data.shape))\n\n    @property\n    def empty(self) -> bool:\n        \"\"\"Inspect if DataFrame is \"empty\"\n\n        Example:\n\n        ```python\n        df = rf.DataFrame()\n        df.empty\n        # True\n        ```\n        \"\"\"\n        return self._data.empty\n\n    @property\n    def memory(self) -> str:\n        \"\"\"Interrogate DataFrame (deep) memory usage\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [1, 2, 3], \"bar\": [\"A\", \"B\", \"C\"]})\n        df.memory\n        # '326B'\n        ```\n        \"\"\"\n        size = self._data.memory_usage(deep=True).sum()\n        power_labels = {40: \"TB\", 30: \"GB\", 20: \"MB\", 10: \"KB\"}\n        for power, label in power_labels.items():\n            if size >= (2**power):\n                approx_size = size // 2**power\n                return f\"{approx_size} {label}\"\n        return f\"{size} B\"\n\n    @property\n    def types(self) -> dict[Column, type]:", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_465-515"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 500, "start_line_no": 475, "end_line_no": 525, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        ```\n        \"\"\"\n        return dict(zip([\"rows\", \"columns\"], self._data.shape))\n\n    @property\n    def empty(self) -> bool:\n        \"\"\"Inspect if DataFrame is \"empty\"\n\n        Example:\n\n        ```python\n        df = rf.DataFrame()\n        df.empty\n        # True\n        ```\n        \"\"\"\n        return self._data.empty\n\n    @property\n    def memory(self) -> str:\n        \"\"\"Interrogate DataFrame (deep) memory usage\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [1, 2, 3], \"bar\": [\"A\", \"B\", \"C\"]})\n        df.memory\n        # '326B'\n        ```\n        \"\"\"\n        size = self._data.memory_usage(deep=True).sum()\n        power_labels = {40: \"TB\", 30: \"GB\", 20: \"MB\", 10: \"KB\"}\n        for power, label in power_labels.items():\n            if size >= (2**power):\n                approx_size = size // 2**power\n                return f\"{approx_size} {label}\"\n        return f\"{size} B\"\n\n    @property\n    def types(self) -> dict[Column, type]:\n        \"\"\"Inspect column types\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [1, 2], \"bar\": [\"A\", \"B\"], \"baz\": [True, False]})\n        df.types\n        # {'foo': int, 'bar': object, 'baz': bool}\n        ```\n        \"\"\"", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_475-525"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 510, "start_line_no": 485, "end_line_no": 535, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        ```python\n        df = rf.DataFrame()\n        df.empty\n        # True\n        ```\n        \"\"\"\n        return self._data.empty\n\n    @property\n    def memory(self) -> str:\n        \"\"\"Interrogate DataFrame (deep) memory usage\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [1, 2, 3], \"bar\": [\"A\", \"B\", \"C\"]})\n        df.memory\n        # '326B'\n        ```\n        \"\"\"\n        size = self._data.memory_usage(deep=True).sum()\n        power_labels = {40: \"TB\", 30: \"GB\", 20: \"MB\", 10: \"KB\"}\n        for power, label in power_labels.items():\n            if size >= (2**power):\n                approx_size = size // 2**power\n                return f\"{approx_size} {label}\"\n        return f\"{size} B\"\n\n    @property\n    def types(self) -> dict[Column, type]:\n        \"\"\"Inspect column types\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [1, 2], \"bar\": [\"A\", \"B\"], \"baz\": [True, False]})\n        df.types\n        # {'foo': int, 'bar': object, 'baz': bool}\n        ```\n        \"\"\"\n        numpy_types = {\n            NumpyType(\"O\"): object,\n            NumpyType(\"int64\"): int,\n            NumpyType(\"float64\"): float,\n            NumpyType(\"bool\"): bool,\n            NumpyType(\"datetime64\"): DateTime,\n        }\n        raw_types = dict(self._data.dtypes)\n        clean_types = {}\n        for column in self.columns:", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_485-535"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 520, "start_line_no": 495, "end_line_no": 545, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        \"\"\"Interrogate DataFrame (deep) memory usage\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [1, 2, 3], \"bar\": [\"A\", \"B\", \"C\"]})\n        df.memory\n        # '326B'\n        ```\n        \"\"\"\n        size = self._data.memory_usage(deep=True).sum()\n        power_labels = {40: \"TB\", 30: \"GB\", 20: \"MB\", 10: \"KB\"}\n        for power, label in power_labels.items():\n            if size >= (2**power):\n                approx_size = size // 2**power\n                return f\"{approx_size} {label}\"\n        return f\"{size} B\"\n\n    @property\n    def types(self) -> dict[Column, type]:\n        \"\"\"Inspect column types\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [1, 2], \"bar\": [\"A\", \"B\"], \"baz\": [True, False]})\n        df.types\n        # {'foo': int, 'bar': object, 'baz': bool}\n        ```\n        \"\"\"\n        numpy_types = {\n            NumpyType(\"O\"): object,\n            NumpyType(\"int64\"): int,\n            NumpyType(\"float64\"): float,\n            NumpyType(\"bool\"): bool,\n            NumpyType(\"datetime64\"): DateTime,\n        }\n        raw_types = dict(self._data.dtypes)\n        clean_types = {}\n        for column in self.columns:\n            current = raw_types[column]\n            clean = numpy_types.get(current, current)  # type: ignore\n            clean_types[column] = clean\n        return clean_types\n\n    def append(self, other: DataFrame) -> DataFrame:\n        \"\"\"Append rows from another DataFrame\n\n        Example:\n", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_495-545"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 530, "start_line_no": 505, "end_line_no": 555, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        size = self._data.memory_usage(deep=True).sum()\n        power_labels = {40: \"TB\", 30: \"GB\", 20: \"MB\", 10: \"KB\"}\n        for power, label in power_labels.items():\n            if size >= (2**power):\n                approx_size = size // 2**power\n                return f\"{approx_size} {label}\"\n        return f\"{size} B\"\n\n    @property\n    def types(self) -> dict[Column, type]:\n        \"\"\"Inspect column types\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [1, 2], \"bar\": [\"A\", \"B\"], \"baz\": [True, False]})\n        df.types\n        # {'foo': int, 'bar': object, 'baz': bool}\n        ```\n        \"\"\"\n        numpy_types = {\n            NumpyType(\"O\"): object,\n            NumpyType(\"int64\"): int,\n            NumpyType(\"float64\"): float,\n            NumpyType(\"bool\"): bool,\n            NumpyType(\"datetime64\"): DateTime,\n        }\n        raw_types = dict(self._data.dtypes)\n        clean_types = {}\n        for column in self.columns:\n            current = raw_types[column]\n            clean = numpy_types.get(current, current)  # type: ignore\n            clean_types[column] = clean\n        return clean_types\n\n    def append(self, other: DataFrame) -> DataFrame:\n        \"\"\"Append rows from another DataFrame\n\n        Example:\n\n        ```python\n        df1 = rf.DataFrame({\"foo\": [1, 2], \"bar\": [\"A\", \"B\"]})\n        ```\n        |   foo | bar   |\n        |------:|:------|\n        |     1 | A     |\n        |     2 | B     |\n\n        ```python\n        df2 = rf.DataFrame({\"bar\": [\"C\", \"D\"], \"foo\": [3, 4], \"baz\": [\"$\", \"@\"]})", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_505-555"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 540, "start_line_no": 515, "end_line_no": 565, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        \"\"\"Inspect column types\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [1, 2], \"bar\": [\"A\", \"B\"], \"baz\": [True, False]})\n        df.types\n        # {'foo': int, 'bar': object, 'baz': bool}\n        ```\n        \"\"\"\n        numpy_types = {\n            NumpyType(\"O\"): object,\n            NumpyType(\"int64\"): int,\n            NumpyType(\"float64\"): float,\n            NumpyType(\"bool\"): bool,\n            NumpyType(\"datetime64\"): DateTime,\n        }\n        raw_types = dict(self._data.dtypes)\n        clean_types = {}\n        for column in self.columns:\n            current = raw_types[column]\n            clean = numpy_types.get(current, current)  # type: ignore\n            clean_types[column] = clean\n        return clean_types\n\n    def append(self, other: DataFrame) -> DataFrame:\n        \"\"\"Append rows from another DataFrame\n\n        Example:\n\n        ```python\n        df1 = rf.DataFrame({\"foo\": [1, 2], \"bar\": [\"A\", \"B\"]})\n        ```\n        |   foo | bar   |\n        |------:|:------|\n        |     1 | A     |\n        |     2 | B     |\n\n        ```python\n        df2 = rf.DataFrame({\"bar\": [\"C\", \"D\"], \"foo\": [3, 4], \"baz\": [\"$\", \"@\"]})\n        ```\n        | bar   |   foo | baz   |\n        |:------|------:|:------|\n        | C     |     3 | $     |\n        | D     |     4 | @     |\n\n        ```python\n        df1.append(df2)\n        ```\n        |   foo | bar   | baz   |", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_515-565"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 550, "start_line_no": 525, "end_line_no": 575, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        numpy_types = {\n            NumpyType(\"O\"): object,\n            NumpyType(\"int64\"): int,\n            NumpyType(\"float64\"): float,\n            NumpyType(\"bool\"): bool,\n            NumpyType(\"datetime64\"): DateTime,\n        }\n        raw_types = dict(self._data.dtypes)\n        clean_types = {}\n        for column in self.columns:\n            current = raw_types[column]\n            clean = numpy_types.get(current, current)  # type: ignore\n            clean_types[column] = clean\n        return clean_types\n\n    def append(self, other: DataFrame) -> DataFrame:\n        \"\"\"Append rows from another DataFrame\n\n        Example:\n\n        ```python\n        df1 = rf.DataFrame({\"foo\": [1, 2], \"bar\": [\"A\", \"B\"]})\n        ```\n        |   foo | bar   |\n        |------:|:------|\n        |     1 | A     |\n        |     2 | B     |\n\n        ```python\n        df2 = rf.DataFrame({\"bar\": [\"C\", \"D\"], \"foo\": [3, 4], \"baz\": [\"$\", \"@\"]})\n        ```\n        | bar   |   foo | baz   |\n        |:------|------:|:------|\n        | C     |     3 | $     |\n        | D     |     4 | @     |\n\n        ```python\n        df1.append(df2)\n        ```\n        |   foo | bar   | baz   |\n        |------:|:------|:------|\n        |     1 | A     | nan   |\n        |     2 | B     | nan   |\n        |     3 | C     | $     |\n        |     4 | D     | @     |\n        \"\"\"\n        _check_type(other, DataFrame)\n        return _wrap(append(self._data, other._data))\n\n    def combine(", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_525-575"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 560, "start_line_no": 535, "end_line_no": 585, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "            current = raw_types[column]\n            clean = numpy_types.get(current, current)  # type: ignore\n            clean_types[column] = clean\n        return clean_types\n\n    def append(self, other: DataFrame) -> DataFrame:\n        \"\"\"Append rows from another DataFrame\n\n        Example:\n\n        ```python\n        df1 = rf.DataFrame({\"foo\": [1, 2], \"bar\": [\"A\", \"B\"]})\n        ```\n        |   foo | bar   |\n        |------:|:------|\n        |     1 | A     |\n        |     2 | B     |\n\n        ```python\n        df2 = rf.DataFrame({\"bar\": [\"C\", \"D\"], \"foo\": [3, 4], \"baz\": [\"$\", \"@\"]})\n        ```\n        | bar   |   foo | baz   |\n        |:------|------:|:------|\n        | C     |     3 | $     |\n        | D     |     4 | @     |\n\n        ```python\n        df1.append(df2)\n        ```\n        |   foo | bar   | baz   |\n        |------:|:------|:------|\n        |     1 | A     | nan   |\n        |     2 | B     | nan   |\n        |     3 | C     | $     |\n        |     4 | D     | @     |\n        \"\"\"\n        _check_type(other, DataFrame)\n        return _wrap(append(self._data, other._data))\n\n    def combine(\n        self, columns: Columns, into: Column, sep: str, drop: bool = True\n    ) -> DataFrame:\n        \"\"\"Combine multiple columns into a single column (opposite of `split`)\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [1, 2], \"bar\": [\"A\", \"B\"]})\n        ```\n        |   foo | bar   |", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_535-585"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 570, "start_line_no": 545, "end_line_no": 595, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        ```python\n        df1 = rf.DataFrame({\"foo\": [1, 2], \"bar\": [\"A\", \"B\"]})\n        ```\n        |   foo | bar   |\n        |------:|:------|\n        |     1 | A     |\n        |     2 | B     |\n\n        ```python\n        df2 = rf.DataFrame({\"bar\": [\"C\", \"D\"], \"foo\": [3, 4], \"baz\": [\"$\", \"@\"]})\n        ```\n        | bar   |   foo | baz   |\n        |:------|------:|:------|\n        | C     |     3 | $     |\n        | D     |     4 | @     |\n\n        ```python\n        df1.append(df2)\n        ```\n        |   foo | bar   | baz   |\n        |------:|:------|:------|\n        |     1 | A     | nan   |\n        |     2 | B     | nan   |\n        |     3 | C     | $     |\n        |     4 | D     | @     |\n        \"\"\"\n        _check_type(other, DataFrame)\n        return _wrap(append(self._data, other._data))\n\n    def combine(\n        self, columns: Columns, into: Column, sep: str, drop: bool = True\n    ) -> DataFrame:\n        \"\"\"Combine multiple columns into a single column (opposite of `split`)\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [1, 2], \"bar\": [\"A\", \"B\"]})\n        ```\n        |   foo | bar   |\n        |------:|:------|\n        |     1 | A     |\n        |     2 | B     |\n\n        ```python\n        df.combine([\"bar\", \"foo\"], into=\"baz\", sep=\"::\", drop=True)\n        ```\n        | baz   |\n        |:------|\n        | A::1  |", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_545-595"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 580, "start_line_no": 555, "end_line_no": 605, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        ```\n        | bar   |   foo | baz   |\n        |:------|------:|:------|\n        | C     |     3 | $     |\n        | D     |     4 | @     |\n\n        ```python\n        df1.append(df2)\n        ```\n        |   foo | bar   | baz   |\n        |------:|:------|:------|\n        |     1 | A     | nan   |\n        |     2 | B     | nan   |\n        |     3 | C     | $     |\n        |     4 | D     | @     |\n        \"\"\"\n        _check_type(other, DataFrame)\n        return _wrap(append(self._data, other._data))\n\n    def combine(\n        self, columns: Columns, into: Column, sep: str, drop: bool = True\n    ) -> DataFrame:\n        \"\"\"Combine multiple columns into a single column (opposite of `split`)\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [1, 2], \"bar\": [\"A\", \"B\"]})\n        ```\n        |   foo | bar   |\n        |------:|:------|\n        |     1 | A     |\n        |     2 | B     |\n\n        ```python\n        df.combine([\"bar\", \"foo\"], into=\"baz\", sep=\"::\", drop=True)\n        ```\n        | baz   |\n        |:------|\n        | A::1  |\n        | B::2  |\n        \"\"\"\n        return _wrap(combine(self._data, columns, into, sep, drop))\n\n    def cross(\n        self, rhs: DataFrame | None = None, postfix: tuple[str, str] = (\"_lhs\", \"_rhs\")\n    ) -> DataFrame:\n        \"\"\"Cross join columns from another DataFrame\n\n        Examples:", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_555-605"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 590, "start_line_no": 565, "end_line_no": 615, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        |------:|:------|:------|\n        |     1 | A     | nan   |\n        |     2 | B     | nan   |\n        |     3 | C     | $     |\n        |     4 | D     | @     |\n        \"\"\"\n        _check_type(other, DataFrame)\n        return _wrap(append(self._data, other._data))\n\n    def combine(\n        self, columns: Columns, into: Column, sep: str, drop: bool = True\n    ) -> DataFrame:\n        \"\"\"Combine multiple columns into a single column (opposite of `split`)\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [1, 2], \"bar\": [\"A\", \"B\"]})\n        ```\n        |   foo | bar   |\n        |------:|:------|\n        |     1 | A     |\n        |     2 | B     |\n\n        ```python\n        df.combine([\"bar\", \"foo\"], into=\"baz\", sep=\"::\", drop=True)\n        ```\n        | baz   |\n        |:------|\n        | A::1  |\n        | B::2  |\n        \"\"\"\n        return _wrap(combine(self._data, columns, into, sep, drop))\n\n    def cross(\n        self, rhs: DataFrame | None = None, postfix: tuple[str, str] = (\"_lhs\", \"_rhs\")\n    ) -> DataFrame:\n        \"\"\"Cross join columns from another DataFrame\n\n        Examples:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [\"a\", \"b\", \"c\"], \"bar\": [1, 2, 3]})\n        ```\n        | foo   |   bar |\n        |:------|------:|\n        | a     |     1 |\n        | b     |     2 |\n        | c     |     3 |\n", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_565-615"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 600, "start_line_no": 575, "end_line_no": 625, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        self, columns: Columns, into: Column, sep: str, drop: bool = True\n    ) -> DataFrame:\n        \"\"\"Combine multiple columns into a single column (opposite of `split`)\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [1, 2], \"bar\": [\"A\", \"B\"]})\n        ```\n        |   foo | bar   |\n        |------:|:------|\n        |     1 | A     |\n        |     2 | B     |\n\n        ```python\n        df.combine([\"bar\", \"foo\"], into=\"baz\", sep=\"::\", drop=True)\n        ```\n        | baz   |\n        |:------|\n        | A::1  |\n        | B::2  |\n        \"\"\"\n        return _wrap(combine(self._data, columns, into, sep, drop))\n\n    def cross(\n        self, rhs: DataFrame | None = None, postfix: tuple[str, str] = (\"_lhs\", \"_rhs\")\n    ) -> DataFrame:\n        \"\"\"Cross join columns from another DataFrame\n\n        Examples:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [\"a\", \"b\", \"c\"], \"bar\": [1, 2, 3]})\n        ```\n        | foo   |   bar |\n        |:------|------:|\n        | a     |     1 |\n        | b     |     2 |\n        | c     |     3 |\n\n        Self:\n\n        ```python\n        df.cross()\n        ```\n\n        | foo_lhs   |   bar_lhs | foo_rhs   |   bar_rhs |\n        |:----------|----------:|:----------|----------:|\n        | a         |         1 | a         |         1 |\n        | a         |         1 | b         |         2 |", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_575-625"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 610, "start_line_no": 585, "end_line_no": 635, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        |------:|:------|\n        |     1 | A     |\n        |     2 | B     |\n\n        ```python\n        df.combine([\"bar\", \"foo\"], into=\"baz\", sep=\"::\", drop=True)\n        ```\n        | baz   |\n        |:------|\n        | A::1  |\n        | B::2  |\n        \"\"\"\n        return _wrap(combine(self._data, columns, into, sep, drop))\n\n    def cross(\n        self, rhs: DataFrame | None = None, postfix: tuple[str, str] = (\"_lhs\", \"_rhs\")\n    ) -> DataFrame:\n        \"\"\"Cross join columns from another DataFrame\n\n        Examples:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [\"a\", \"b\", \"c\"], \"bar\": [1, 2, 3]})\n        ```\n        | foo   |   bar |\n        |:------|------:|\n        | a     |     1 |\n        | b     |     2 |\n        | c     |     3 |\n\n        Self:\n\n        ```python\n        df.cross()\n        ```\n\n        | foo_lhs   |   bar_lhs | foo_rhs   |   bar_rhs |\n        |:----------|----------:|:----------|----------:|\n        | a         |         1 | a         |         1 |\n        | a         |         1 | b         |         2 |\n        | a         |         1 | c         |         3 |\n        | b         |         2 | a         |         1 |\n        | b         |         2 | b         |         2 |\n        | b         |         2 | c         |         3 |\n        | c         |         3 | a         |         1 |\n        | c         |         3 | b         |         2 |\n        | c         |         3 | c         |         3 |\n\n        Two DataFrames:\n", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_585-635"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 620, "start_line_no": 595, "end_line_no": 645, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        | B::2  |\n        \"\"\"\n        return _wrap(combine(self._data, columns, into, sep, drop))\n\n    def cross(\n        self, rhs: DataFrame | None = None, postfix: tuple[str, str] = (\"_lhs\", \"_rhs\")\n    ) -> DataFrame:\n        \"\"\"Cross join columns from another DataFrame\n\n        Examples:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [\"a\", \"b\", \"c\"], \"bar\": [1, 2, 3]})\n        ```\n        | foo   |   bar |\n        |:------|------:|\n        | a     |     1 |\n        | b     |     2 |\n        | c     |     3 |\n\n        Self:\n\n        ```python\n        df.cross()\n        ```\n\n        | foo_lhs   |   bar_lhs | foo_rhs   |   bar_rhs |\n        |:----------|----------:|:----------|----------:|\n        | a         |         1 | a         |         1 |\n        | a         |         1 | b         |         2 |\n        | a         |         1 | c         |         3 |\n        | b         |         2 | a         |         1 |\n        | b         |         2 | b         |         2 |\n        | b         |         2 | c         |         3 |\n        | c         |         3 | a         |         1 |\n        | c         |         3 | b         |         2 |\n        | c         |         3 | c         |         3 |\n\n        Two DataFrames:\n\n        ```python\n        dfa = rf.DataFrame({\"foo\": [1, 2, 3]})\n        dfb = rf.DataFrame({\"bar\": [1, 2, 3]})\n        dfa.cross(dfb, postfix=(\"_a\", \"_b\"))\n        ```\n\n        |   foo |   bar |\n        |------:|------:|\n        |     1 |     1 |\n        |     1 |     2 |", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_595-645"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 630, "start_line_no": 605, "end_line_no": 655, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "\n        ```python\n        df = rf.DataFrame({\"foo\": [\"a\", \"b\", \"c\"], \"bar\": [1, 2, 3]})\n        ```\n        | foo   |   bar |\n        |:------|------:|\n        | a     |     1 |\n        | b     |     2 |\n        | c     |     3 |\n\n        Self:\n\n        ```python\n        df.cross()\n        ```\n\n        | foo_lhs   |   bar_lhs | foo_rhs   |   bar_rhs |\n        |:----------|----------:|:----------|----------:|\n        | a         |         1 | a         |         1 |\n        | a         |         1 | b         |         2 |\n        | a         |         1 | c         |         3 |\n        | b         |         2 | a         |         1 |\n        | b         |         2 | b         |         2 |\n        | b         |         2 | c         |         3 |\n        | c         |         3 | a         |         1 |\n        | c         |         3 | b         |         2 |\n        | c         |         3 | c         |         3 |\n\n        Two DataFrames:\n\n        ```python\n        dfa = rf.DataFrame({\"foo\": [1, 2, 3]})\n        dfb = rf.DataFrame({\"bar\": [1, 2, 3]})\n        dfa.cross(dfb, postfix=(\"_a\", \"_b\"))\n        ```\n\n        |   foo |   bar |\n        |------:|------:|\n        |     1 |     1 |\n        |     1 |     2 |\n        |     1 |     3 |\n        |     2 |     1 |\n        |     2 |     2 |\n        |     2 |     3 |\n        |     3 |     1 |\n        |     3 |     2 |\n        |     3 |     3 |\n        \"\"\"\n        rhs = self if (rhs == None) else rhs\n        _check_type(rhs, DataFrame)", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_605-655"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 640, "start_line_no": 615, "end_line_no": 665, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        Self:\n\n        ```python\n        df.cross()\n        ```\n\n        | foo_lhs   |   bar_lhs | foo_rhs   |   bar_rhs |\n        |:----------|----------:|:----------|----------:|\n        | a         |         1 | a         |         1 |\n        | a         |         1 | b         |         2 |\n        | a         |         1 | c         |         3 |\n        | b         |         2 | a         |         1 |\n        | b         |         2 | b         |         2 |\n        | b         |         2 | c         |         3 |\n        | c         |         3 | a         |         1 |\n        | c         |         3 | b         |         2 |\n        | c         |         3 | c         |         3 |\n\n        Two DataFrames:\n\n        ```python\n        dfa = rf.DataFrame({\"foo\": [1, 2, 3]})\n        dfb = rf.DataFrame({\"bar\": [1, 2, 3]})\n        dfa.cross(dfb, postfix=(\"_a\", \"_b\"))\n        ```\n\n        |   foo |   bar |\n        |------:|------:|\n        |     1 |     1 |\n        |     1 |     2 |\n        |     1 |     3 |\n        |     2 |     1 |\n        |     2 |     2 |\n        |     2 |     3 |\n        |     3 |     1 |\n        |     3 |     2 |\n        |     3 |     3 |\n        \"\"\"\n        rhs = self if (rhs == None) else rhs\n        _check_type(rhs, DataFrame)\n        return _wrap(cross(self._data, rhs._data, postfix))  # type: ignore\n\n    def dedupe(self, columns: LazyColumns | None = None) -> DataFrame:\n        \"\"\"Remove duplicate rows\n\n        Examples:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [1, 1, 2, 2], \"bar\": [\"A\", \"A\", \"B\", \"A\"]})\n        ```", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_615-665"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 650, "start_line_no": 625, "end_line_no": 675, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        | a         |         1 | c         |         3 |\n        | b         |         2 | a         |         1 |\n        | b         |         2 | b         |         2 |\n        | b         |         2 | c         |         3 |\n        | c         |         3 | a         |         1 |\n        | c         |         3 | b         |         2 |\n        | c         |         3 | c         |         3 |\n\n        Two DataFrames:\n\n        ```python\n        dfa = rf.DataFrame({\"foo\": [1, 2, 3]})\n        dfb = rf.DataFrame({\"bar\": [1, 2, 3]})\n        dfa.cross(dfb, postfix=(\"_a\", \"_b\"))\n        ```\n\n        |   foo |   bar |\n        |------:|------:|\n        |     1 |     1 |\n        |     1 |     2 |\n        |     1 |     3 |\n        |     2 |     1 |\n        |     2 |     2 |\n        |     2 |     3 |\n        |     3 |     1 |\n        |     3 |     2 |\n        |     3 |     3 |\n        \"\"\"\n        rhs = self if (rhs == None) else rhs\n        _check_type(rhs, DataFrame)\n        return _wrap(cross(self._data, rhs._data, postfix))  # type: ignore\n\n    def dedupe(self, columns: LazyColumns | None = None) -> DataFrame:\n        \"\"\"Remove duplicate rows\n\n        Examples:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [1, 1, 2, 2], \"bar\": [\"A\", \"A\", \"B\", \"A\"]})\n        ```\n        |   foo | bar   |\n        |------:|:------|\n        |     1 | A     |\n        |     1 | A     |\n        |     2 | B     |\n        |     2 | A     |\n\n        All columns:\n\n        ```python", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_625-675"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 660, "start_line_no": 635, "end_line_no": 685, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        ```python\n        dfa = rf.DataFrame({\"foo\": [1, 2, 3]})\n        dfb = rf.DataFrame({\"bar\": [1, 2, 3]})\n        dfa.cross(dfb, postfix=(\"_a\", \"_b\"))\n        ```\n\n        |   foo |   bar |\n        |------:|------:|\n        |     1 |     1 |\n        |     1 |     2 |\n        |     1 |     3 |\n        |     2 |     1 |\n        |     2 |     2 |\n        |     2 |     3 |\n        |     3 |     1 |\n        |     3 |     2 |\n        |     3 |     3 |\n        \"\"\"\n        rhs = self if (rhs == None) else rhs\n        _check_type(rhs, DataFrame)\n        return _wrap(cross(self._data, rhs._data, postfix))  # type: ignore\n\n    def dedupe(self, columns: LazyColumns | None = None) -> DataFrame:\n        \"\"\"Remove duplicate rows\n\n        Examples:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [1, 1, 2, 2], \"bar\": [\"A\", \"A\", \"B\", \"A\"]})\n        ```\n        |   foo | bar   |\n        |------:|:------|\n        |     1 | A     |\n        |     1 | A     |\n        |     2 | B     |\n        |     2 | A     |\n\n        All columns:\n\n        ```python\n        df.dedupe()\n        ```\n        |   foo | bar   |\n        |------:|:------|\n        |     1 | A     |\n        |     2 | B     |\n        |     2 | A     |\n\n        Single column:\n", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_635-685"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 670, "start_line_no": 645, "end_line_no": 695, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        |     1 |     3 |\n        |     2 |     1 |\n        |     2 |     2 |\n        |     2 |     3 |\n        |     3 |     1 |\n        |     3 |     2 |\n        |     3 |     3 |\n        \"\"\"\n        rhs = self if (rhs == None) else rhs\n        _check_type(rhs, DataFrame)\n        return _wrap(cross(self._data, rhs._data, postfix))  # type: ignore\n\n    def dedupe(self, columns: LazyColumns | None = None) -> DataFrame:\n        \"\"\"Remove duplicate rows\n\n        Examples:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [1, 1, 2, 2], \"bar\": [\"A\", \"A\", \"B\", \"A\"]})\n        ```\n        |   foo | bar   |\n        |------:|:------|\n        |     1 | A     |\n        |     1 | A     |\n        |     2 | B     |\n        |     2 | A     |\n\n        All columns:\n\n        ```python\n        df.dedupe()\n        ```\n        |   foo | bar   |\n        |------:|:------|\n        |     1 | A     |\n        |     2 | B     |\n        |     2 | A     |\n\n        Single column:\n\n        ```python\n        df.dedupe(\"foo\")\n        ```\n        |   foo | bar   |\n        |------:|:------|\n        |     1 | A     |\n        |     2 | B     |\n\n        Multiple columns:\n", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_645-695"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 680, "start_line_no": 655, "end_line_no": 705, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        return _wrap(cross(self._data, rhs._data, postfix))  # type: ignore\n\n    def dedupe(self, columns: LazyColumns | None = None) -> DataFrame:\n        \"\"\"Remove duplicate rows\n\n        Examples:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [1, 1, 2, 2], \"bar\": [\"A\", \"A\", \"B\", \"A\"]})\n        ```\n        |   foo | bar   |\n        |------:|:------|\n        |     1 | A     |\n        |     1 | A     |\n        |     2 | B     |\n        |     2 | A     |\n\n        All columns:\n\n        ```python\n        df.dedupe()\n        ```\n        |   foo | bar   |\n        |------:|:------|\n        |     1 | A     |\n        |     2 | B     |\n        |     2 | A     |\n\n        Single column:\n\n        ```python\n        df.dedupe(\"foo\")\n        ```\n        |   foo | bar   |\n        |------:|:------|\n        |     1 | A     |\n        |     2 | B     |\n\n        Multiple columns:\n\n        ```python\n        df.dedupe([\"foo\", \"bar\"])\n        ```\n        |   foo | bar   |\n        |------:|:------|\n        |     1 | A     |\n        |     2 | B     |\n        |     2 | A     |\n        \"\"\"\n        return _wrap(dedupe(self._data, columns))", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_655-705"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 690, "start_line_no": 665, "end_line_no": 715, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        |   foo | bar   |\n        |------:|:------|\n        |     1 | A     |\n        |     1 | A     |\n        |     2 | B     |\n        |     2 | A     |\n\n        All columns:\n\n        ```python\n        df.dedupe()\n        ```\n        |   foo | bar   |\n        |------:|:------|\n        |     1 | A     |\n        |     2 | B     |\n        |     2 | A     |\n\n        Single column:\n\n        ```python\n        df.dedupe(\"foo\")\n        ```\n        |   foo | bar   |\n        |------:|:------|\n        |     1 | A     |\n        |     2 | B     |\n\n        Multiple columns:\n\n        ```python\n        df.dedupe([\"foo\", \"bar\"])\n        ```\n        |   foo | bar   |\n        |------:|:------|\n        |     1 | A     |\n        |     2 | B     |\n        |     2 | A     |\n        \"\"\"\n        return _wrap(dedupe(self._data, columns))\n\n    def denix(self, columns: LazyColumns | None = None) -> DataFrame:\n        \"\"\"Remove rows with *NaN/None* values\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [1, None, 3, None, 5, 6], \"bar\": [1, None, 3, 4, None, None]})\n        ```\n        |   foo |   bar |", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_665-715"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 700, "start_line_no": 675, "end_line_no": 725, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        df.dedupe()\n        ```\n        |   foo | bar   |\n        |------:|:------|\n        |     1 | A     |\n        |     2 | B     |\n        |     2 | A     |\n\n        Single column:\n\n        ```python\n        df.dedupe(\"foo\")\n        ```\n        |   foo | bar   |\n        |------:|:------|\n        |     1 | A     |\n        |     2 | B     |\n\n        Multiple columns:\n\n        ```python\n        df.dedupe([\"foo\", \"bar\"])\n        ```\n        |   foo | bar   |\n        |------:|:------|\n        |     1 | A     |\n        |     2 | B     |\n        |     2 | A     |\n        \"\"\"\n        return _wrap(dedupe(self._data, columns))\n\n    def denix(self, columns: LazyColumns | None = None) -> DataFrame:\n        \"\"\"Remove rows with *NaN/None* values\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [1, None, 3, None, 5, 6], \"bar\": [1, None, 3, 4, None, None]})\n        ```\n        |   foo |   bar |\n        |------:|------:|\n        |     1 |     1 |\n        |   nan |   nan |\n        |     3 |     3 |\n        |   nan |     4 |\n        |     5 |   nan |\n        |     6 |   nan |\n\n        All columns:\n", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_675-725"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 710, "start_line_no": 685, "end_line_no": 735, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        ```python\n        df.dedupe(\"foo\")\n        ```\n        |   foo | bar   |\n        |------:|:------|\n        |     1 | A     |\n        |     2 | B     |\n\n        Multiple columns:\n\n        ```python\n        df.dedupe([\"foo\", \"bar\"])\n        ```\n        |   foo | bar   |\n        |------:|:------|\n        |     1 | A     |\n        |     2 | B     |\n        |     2 | A     |\n        \"\"\"\n        return _wrap(dedupe(self._data, columns))\n\n    def denix(self, columns: LazyColumns | None = None) -> DataFrame:\n        \"\"\"Remove rows with *NaN/None* values\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [1, None, 3, None, 5, 6], \"bar\": [1, None, 3, 4, None, None]})\n        ```\n        |   foo |   bar |\n        |------:|------:|\n        |     1 |     1 |\n        |   nan |   nan |\n        |     3 |     3 |\n        |   nan |     4 |\n        |     5 |   nan |\n        |     6 |   nan |\n\n        All columns:\n\n        ```python\n        df.denix()\n        ```\n        |   foo |   bar |\n        |------:|------:|\n        |     1 |     1 |\n        |     3 |     3 |\n\n        Single column:\n", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_685-735"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 720, "start_line_no": 695, "end_line_no": 745, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        ```python\n        df.dedupe([\"foo\", \"bar\"])\n        ```\n        |   foo | bar   |\n        |------:|:------|\n        |     1 | A     |\n        |     2 | B     |\n        |     2 | A     |\n        \"\"\"\n        return _wrap(dedupe(self._data, columns))\n\n    def denix(self, columns: LazyColumns | None = None) -> DataFrame:\n        \"\"\"Remove rows with *NaN/None* values\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [1, None, 3, None, 5, 6], \"bar\": [1, None, 3, 4, None, None]})\n        ```\n        |   foo |   bar |\n        |------:|------:|\n        |     1 |     1 |\n        |   nan |   nan |\n        |     3 |     3 |\n        |   nan |     4 |\n        |     5 |   nan |\n        |     6 |   nan |\n\n        All columns:\n\n        ```python\n        df.denix()\n        ```\n        |   foo |   bar |\n        |------:|------:|\n        |     1 |     1 |\n        |     3 |     3 |\n\n        Single column:\n\n        ```python\n        df.denix(\"bar\")\n        ```\n        |   foo |   bar |\n        |------:|------:|\n        |     1 |     1 |\n        |     3 |     3 |\n        |   nan |     4 |\n\n        Multiple columns:", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_695-745"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 730, "start_line_no": 705, "end_line_no": 755, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "\n    def denix(self, columns: LazyColumns | None = None) -> DataFrame:\n        \"\"\"Remove rows with *NaN/None* values\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [1, None, 3, None, 5, 6], \"bar\": [1, None, 3, 4, None, None]})\n        ```\n        |   foo |   bar |\n        |------:|------:|\n        |     1 |     1 |\n        |   nan |   nan |\n        |     3 |     3 |\n        |   nan |     4 |\n        |     5 |   nan |\n        |     6 |   nan |\n\n        All columns:\n\n        ```python\n        df.denix()\n        ```\n        |   foo |   bar |\n        |------:|------:|\n        |     1 |     1 |\n        |     3 |     3 |\n\n        Single column:\n\n        ```python\n        df.denix(\"bar\")\n        ```\n        |   foo |   bar |\n        |------:|------:|\n        |     1 |     1 |\n        |     3 |     3 |\n        |   nan |     4 |\n\n        Multiple columns:\n\n        ```python\n        df.denix([\"foo\", \"bar\"])\n        ```\n        |   foo |   bar |\n        |------:|------:|\n        |     1 |     1 |\n        |     3 |     3 |\n        \"\"\"\n        return _wrap(denix(self._data, columns))", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_705-755"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 740, "start_line_no": 715, "end_line_no": 765, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        |------:|------:|\n        |     1 |     1 |\n        |   nan |   nan |\n        |     3 |     3 |\n        |   nan |     4 |\n        |     5 |   nan |\n        |     6 |   nan |\n\n        All columns:\n\n        ```python\n        df.denix()\n        ```\n        |   foo |   bar |\n        |------:|------:|\n        |     1 |     1 |\n        |     3 |     3 |\n\n        Single column:\n\n        ```python\n        df.denix(\"bar\")\n        ```\n        |   foo |   bar |\n        |------:|------:|\n        |     1 |     1 |\n        |     3 |     3 |\n        |   nan |     4 |\n\n        Multiple columns:\n\n        ```python\n        df.denix([\"foo\", \"bar\"])\n        ```\n        |   foo |   bar |\n        |------:|------:|\n        |     1 |     1 |\n        |     3 |     3 |\n        \"\"\"\n        return _wrap(denix(self._data, columns))\n\n    def drop(self, columns: LazyColumns) -> DataFrame:\n        \"\"\"Drop entire columns\n\n        Examples:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [1, 2], \"bar\": [3, 4], \"baz\": [5, 6]})\n        ```\n        |   foo |   bar |   baz |", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_715-765"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 750, "start_line_no": 725, "end_line_no": 775, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        ```python\n        df.denix()\n        ```\n        |   foo |   bar |\n        |------:|------:|\n        |     1 |     1 |\n        |     3 |     3 |\n\n        Single column:\n\n        ```python\n        df.denix(\"bar\")\n        ```\n        |   foo |   bar |\n        |------:|------:|\n        |     1 |     1 |\n        |     3 |     3 |\n        |   nan |     4 |\n\n        Multiple columns:\n\n        ```python\n        df.denix([\"foo\", \"bar\"])\n        ```\n        |   foo |   bar |\n        |------:|------:|\n        |     1 |     1 |\n        |     3 |     3 |\n        \"\"\"\n        return _wrap(denix(self._data, columns))\n\n    def drop(self, columns: LazyColumns) -> DataFrame:\n        \"\"\"Drop entire columns\n\n        Examples:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [1, 2], \"bar\": [3, 4], \"baz\": [5, 6]})\n        ```\n        |   foo |   bar |   baz |\n        |------:|------:|------:|\n        |     1 |     3 |     5 |\n        |     2 |     4 |     6 |\n\n        ```python\n        df.drop(\"baz\")\n        ```\n        |   foo |   bar |\n        |------:|------:|\n        |     1 |     3 |", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_725-775"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 760, "start_line_no": 735, "end_line_no": 785, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        ```python\n        df.denix(\"bar\")\n        ```\n        |   foo |   bar |\n        |------:|------:|\n        |     1 |     1 |\n        |     3 |     3 |\n        |   nan |     4 |\n\n        Multiple columns:\n\n        ```python\n        df.denix([\"foo\", \"bar\"])\n        ```\n        |   foo |   bar |\n        |------:|------:|\n        |     1 |     1 |\n        |     3 |     3 |\n        \"\"\"\n        return _wrap(denix(self._data, columns))\n\n    def drop(self, columns: LazyColumns) -> DataFrame:\n        \"\"\"Drop entire columns\n\n        Examples:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [1, 2], \"bar\": [3, 4], \"baz\": [5, 6]})\n        ```\n        |   foo |   bar |   baz |\n        |------:|------:|------:|\n        |     1 |     3 |     5 |\n        |     2 |     4 |     6 |\n\n        ```python\n        df.drop(\"baz\")\n        ```\n        |   foo |   bar |\n        |------:|------:|\n        |     1 |     3 |\n        |     2 |     4 |\n\n        ```python\n        df.drop([\"foo\", \"baz\"])\n        ```\n        |   bar |\n        |------:|\n        |     3 |\n        |     4 |\n        \"\"\"", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_735-785"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 770, "start_line_no": 745, "end_line_no": 795, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "\n        ```python\n        df.denix([\"foo\", \"bar\"])\n        ```\n        |   foo |   bar |\n        |------:|------:|\n        |     1 |     1 |\n        |     3 |     3 |\n        \"\"\"\n        return _wrap(denix(self._data, columns))\n\n    def drop(self, columns: LazyColumns) -> DataFrame:\n        \"\"\"Drop entire columns\n\n        Examples:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [1, 2], \"bar\": [3, 4], \"baz\": [5, 6]})\n        ```\n        |   foo |   bar |   baz |\n        |------:|------:|------:|\n        |     1 |     3 |     5 |\n        |     2 |     4 |     6 |\n\n        ```python\n        df.drop(\"baz\")\n        ```\n        |   foo |   bar |\n        |------:|------:|\n        |     1 |     3 |\n        |     2 |     4 |\n\n        ```python\n        df.drop([\"foo\", \"baz\"])\n        ```\n        |   bar |\n        |------:|\n        |     3 |\n        |     4 |\n        \"\"\"\n        return _wrap(drop(self._data, columns))\n\n    def fill(\n        self,\n        columns: LazyColumns | None = None,\n        direction: Direction | None = None,\n        constant: Value | None = None,\n    ) -> DataFrame:\n        \"\"\"Fill missing values \"down\", \"up\", or with a constant\n", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_745-795"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 780, "start_line_no": 755, "end_line_no": 805, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "\n    def drop(self, columns: LazyColumns) -> DataFrame:\n        \"\"\"Drop entire columns\n\n        Examples:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [1, 2], \"bar\": [3, 4], \"baz\": [5, 6]})\n        ```\n        |   foo |   bar |   baz |\n        |------:|------:|------:|\n        |     1 |     3 |     5 |\n        |     2 |     4 |     6 |\n\n        ```python\n        df.drop(\"baz\")\n        ```\n        |   foo |   bar |\n        |------:|------:|\n        |     1 |     3 |\n        |     2 |     4 |\n\n        ```python\n        df.drop([\"foo\", \"baz\"])\n        ```\n        |   bar |\n        |------:|\n        |     3 |\n        |     4 |\n        \"\"\"\n        return _wrap(drop(self._data, columns))\n\n    def fill(\n        self,\n        columns: LazyColumns | None = None,\n        direction: Direction | None = None,\n        constant: Value | None = None,\n    ) -> DataFrame:\n        \"\"\"Fill missing values \"down\", \"up\", or with a constant\n\n        Examples:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [1, None, None, 2, None], \"bar\": [None, \"A\", None, \"B\", None]})\n        ```\n        |   foo | bar   |\n        |------:|:------|\n        |     1 |       |\n        |   nan | A     |\n        |   nan |       |", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_755-805"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 790, "start_line_no": 765, "end_line_no": 815, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        |------:|------:|------:|\n        |     1 |     3 |     5 |\n        |     2 |     4 |     6 |\n\n        ```python\n        df.drop(\"baz\")\n        ```\n        |   foo |   bar |\n        |------:|------:|\n        |     1 |     3 |\n        |     2 |     4 |\n\n        ```python\n        df.drop([\"foo\", \"baz\"])\n        ```\n        |   bar |\n        |------:|\n        |     3 |\n        |     4 |\n        \"\"\"\n        return _wrap(drop(self._data, columns))\n\n    def fill(\n        self,\n        columns: LazyColumns | None = None,\n        direction: Direction | None = None,\n        constant: Value | None = None,\n    ) -> DataFrame:\n        \"\"\"Fill missing values \"down\", \"up\", or with a constant\n\n        Examples:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [1, None, None, 2, None], \"bar\": [None, \"A\", None, \"B\", None]})\n        ```\n        |   foo | bar   |\n        |------:|:------|\n        |     1 |       |\n        |   nan | A     |\n        |   nan |       |\n        |     2 | B     |\n        |   nan |       |\n\n        Constant (all columns):\n\n        ```python\n        df.fill(constant=0)\n        ```\n        |   foo | bar   |\n        |------:|:------|", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_765-815"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 800, "start_line_no": 775, "end_line_no": 825, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        |     2 |     4 |\n\n        ```python\n        df.drop([\"foo\", \"baz\"])\n        ```\n        |   bar |\n        |------:|\n        |     3 |\n        |     4 |\n        \"\"\"\n        return _wrap(drop(self._data, columns))\n\n    def fill(\n        self,\n        columns: LazyColumns | None = None,\n        direction: Direction | None = None,\n        constant: Value | None = None,\n    ) -> DataFrame:\n        \"\"\"Fill missing values \"down\", \"up\", or with a constant\n\n        Examples:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [1, None, None, 2, None], \"bar\": [None, \"A\", None, \"B\", None]})\n        ```\n        |   foo | bar   |\n        |------:|:------|\n        |     1 |       |\n        |   nan | A     |\n        |   nan |       |\n        |     2 | B     |\n        |   nan |       |\n\n        Constant (all columns):\n\n        ```python\n        df.fill(constant=0)\n        ```\n        |   foo | bar   |\n        |------:|:------|\n        |     1 | 0     |\n        |     0 | A     |\n        |     0 | 0     |\n        |     2 | B     |\n        |     0 | 0     |\n\n        Down (all columns):\n\n        ```python\n        df.fill(direction=\"down\")", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_775-825"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 810, "start_line_no": 785, "end_line_no": 835, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        return _wrap(drop(self._data, columns))\n\n    def fill(\n        self,\n        columns: LazyColumns | None = None,\n        direction: Direction | None = None,\n        constant: Value | None = None,\n    ) -> DataFrame:\n        \"\"\"Fill missing values \"down\", \"up\", or with a constant\n\n        Examples:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [1, None, None, 2, None], \"bar\": [None, \"A\", None, \"B\", None]})\n        ```\n        |   foo | bar   |\n        |------:|:------|\n        |     1 |       |\n        |   nan | A     |\n        |   nan |       |\n        |     2 | B     |\n        |   nan |       |\n\n        Constant (all columns):\n\n        ```python\n        df.fill(constant=0)\n        ```\n        |   foo | bar   |\n        |------:|:------|\n        |     1 | 0     |\n        |     0 | A     |\n        |     0 | 0     |\n        |     2 | B     |\n        |     0 | 0     |\n\n        Down (all columns):\n\n        ```python\n        df.fill(direction=\"down\")\n        ```\n        |   foo | bar   |\n        |------:|:------|\n        |     1 |       |\n        |     1 | A     |\n        |     1 | A     |\n        |     2 | B     |\n        |     2 | B     |\n\n        Down (single column):", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_785-835"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 820, "start_line_no": 795, "end_line_no": 845, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        Examples:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [1, None, None, 2, None], \"bar\": [None, \"A\", None, \"B\", None]})\n        ```\n        |   foo | bar   |\n        |------:|:------|\n        |     1 |       |\n        |   nan | A     |\n        |   nan |       |\n        |     2 | B     |\n        |   nan |       |\n\n        Constant (all columns):\n\n        ```python\n        df.fill(constant=0)\n        ```\n        |   foo | bar   |\n        |------:|:------|\n        |     1 | 0     |\n        |     0 | A     |\n        |     0 | 0     |\n        |     2 | B     |\n        |     0 | 0     |\n\n        Down (all columns):\n\n        ```python\n        df.fill(direction=\"down\")\n        ```\n        |   foo | bar   |\n        |------:|:------|\n        |     1 |       |\n        |     1 | A     |\n        |     1 | A     |\n        |     2 | B     |\n        |     2 | B     |\n\n        Down (single column):\n\n        ```python\n        df.fill(\"foo\", direction=\"down\")\n        ```\n        |   foo | bar   |\n        |------:|:------|\n        |     1 |       |\n        |     1 | A     |\n        |     1 |       |\n        |     2 | B     |", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_795-845"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 830, "start_line_no": 805, "end_line_no": 855, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        |     2 | B     |\n        |   nan |       |\n\n        Constant (all columns):\n\n        ```python\n        df.fill(constant=0)\n        ```\n        |   foo | bar   |\n        |------:|:------|\n        |     1 | 0     |\n        |     0 | A     |\n        |     0 | 0     |\n        |     2 | B     |\n        |     0 | 0     |\n\n        Down (all columns):\n\n        ```python\n        df.fill(direction=\"down\")\n        ```\n        |   foo | bar   |\n        |------:|:------|\n        |     1 |       |\n        |     1 | A     |\n        |     1 | A     |\n        |     2 | B     |\n        |     2 | B     |\n\n        Down (single column):\n\n        ```python\n        df.fill(\"foo\", direction=\"down\")\n        ```\n        |   foo | bar   |\n        |------:|:------|\n        |     1 |       |\n        |     1 | A     |\n        |     1 |       |\n        |     2 | B     |\n        |     2 |       |\n\n        Up (single/mutiple columns):\n\n        ```python\n        df.fill([\"foo\"], direction=\"up\")\n        ```\n        |   foo | bar   |\n        |------:|:------|\n        |     1 |       |", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_805-855"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 840, "start_line_no": 815, "end_line_no": 865, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        |     1 | 0     |\n        |     0 | A     |\n        |     0 | 0     |\n        |     2 | B     |\n        |     0 | 0     |\n\n        Down (all columns):\n\n        ```python\n        df.fill(direction=\"down\")\n        ```\n        |   foo | bar   |\n        |------:|:------|\n        |     1 |       |\n        |     1 | A     |\n        |     1 | A     |\n        |     2 | B     |\n        |     2 | B     |\n\n        Down (single column):\n\n        ```python\n        df.fill(\"foo\", direction=\"down\")\n        ```\n        |   foo | bar   |\n        |------:|:------|\n        |     1 |       |\n        |     1 | A     |\n        |     1 |       |\n        |     2 | B     |\n        |     2 |       |\n\n        Up (single/mutiple columns):\n\n        ```python\n        df.fill([\"foo\"], direction=\"up\")\n        ```\n        |   foo | bar   |\n        |------:|:------|\n        |     1 |       |\n        |     2 | A     |\n        |     2 |       |\n        |     2 | B     |\n        |   nan |       |\n        \"\"\"\n        return _wrap(fill(self._data, columns, direction, constant))\n\n    def filter(self, func: Func) -> DataFrame:\n        \"\"\"Keep rows matching specific conditions\n", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_815-865"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 850, "start_line_no": 825, "end_line_no": 875, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        ```\n        |   foo | bar   |\n        |------:|:------|\n        |     1 |       |\n        |     1 | A     |\n        |     1 | A     |\n        |     2 | B     |\n        |     2 | B     |\n\n        Down (single column):\n\n        ```python\n        df.fill(\"foo\", direction=\"down\")\n        ```\n        |   foo | bar   |\n        |------:|:------|\n        |     1 |       |\n        |     1 | A     |\n        |     1 |       |\n        |     2 | B     |\n        |     2 |       |\n\n        Up (single/mutiple columns):\n\n        ```python\n        df.fill([\"foo\"], direction=\"up\")\n        ```\n        |   foo | bar   |\n        |------:|:------|\n        |     1 |       |\n        |     2 | A     |\n        |     2 |       |\n        |     2 | B     |\n        |   nan |       |\n        \"\"\"\n        return _wrap(fill(self._data, columns, direction, constant))\n\n    def filter(self, func: Func) -> DataFrame:\n        \"\"\"Keep rows matching specific conditions\n\n        Compatible operators: `|`, `&`, `< <= == != >= >`, `isin`\n\n        Examples:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [\"A\", \"A\", \"A\", \"B\"], \"bar\": [1, 2, 3, 4]})\n        ```\n        | foo   |   bar |\n        |:------|------:|\n        | A     |     1 |", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_825-875"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 860, "start_line_no": 835, "end_line_no": 885, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "\n        ```python\n        df.fill(\"foo\", direction=\"down\")\n        ```\n        |   foo | bar   |\n        |------:|:------|\n        |     1 |       |\n        |     1 | A     |\n        |     1 |       |\n        |     2 | B     |\n        |     2 |       |\n\n        Up (single/mutiple columns):\n\n        ```python\n        df.fill([\"foo\"], direction=\"up\")\n        ```\n        |   foo | bar   |\n        |------:|:------|\n        |     1 |       |\n        |     2 | A     |\n        |     2 |       |\n        |     2 | B     |\n        |   nan |       |\n        \"\"\"\n        return _wrap(fill(self._data, columns, direction, constant))\n\n    def filter(self, func: Func) -> DataFrame:\n        \"\"\"Keep rows matching specific conditions\n\n        Compatible operators: `|`, `&`, `< <= == != >= >`, `isin`\n\n        Examples:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [\"A\", \"A\", \"A\", \"B\"], \"bar\": [1, 2, 3, 4]})\n        ```\n        | foo   |   bar |\n        |:------|------:|\n        | A     |     1 |\n        | A     |     2 |\n        | A     |     3 |\n        | B     |     4 |\n\n        Single condition:\n\n        ```python\n        df.filter(lambda row: row[\"foo\"].isin([\"A\"]))\n        ```\n        | foo   |   bar |", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_835-885"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 870, "start_line_no": 845, "end_line_no": 895, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        |     2 |       |\n\n        Up (single/mutiple columns):\n\n        ```python\n        df.fill([\"foo\"], direction=\"up\")\n        ```\n        |   foo | bar   |\n        |------:|:------|\n        |     1 |       |\n        |     2 | A     |\n        |     2 |       |\n        |     2 | B     |\n        |   nan |       |\n        \"\"\"\n        return _wrap(fill(self._data, columns, direction, constant))\n\n    def filter(self, func: Func) -> DataFrame:\n        \"\"\"Keep rows matching specific conditions\n\n        Compatible operators: `|`, `&`, `< <= == != >= >`, `isin`\n\n        Examples:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [\"A\", \"A\", \"A\", \"B\"], \"bar\": [1, 2, 3, 4]})\n        ```\n        | foo   |   bar |\n        |:------|------:|\n        | A     |     1 |\n        | A     |     2 |\n        | A     |     3 |\n        | B     |     4 |\n\n        Single condition:\n\n        ```python\n        df.filter(lambda row: row[\"foo\"].isin([\"A\"]))\n        ```\n        | foo   |   bar |\n        |:------|------:|\n        | A     |     1 |\n        | A     |     2 |\n        | A     |     3 |\n\n        And (multiple conditions):\n\n        ```python\n        df.filter(lambda row: (row[\"foo\"] == \"A\") & (row[\"bar\"] <= 2))\n        ```", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_845-895"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 880, "start_line_no": 855, "end_line_no": 905, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        |     2 | A     |\n        |     2 |       |\n        |     2 | B     |\n        |   nan |       |\n        \"\"\"\n        return _wrap(fill(self._data, columns, direction, constant))\n\n    def filter(self, func: Func) -> DataFrame:\n        \"\"\"Keep rows matching specific conditions\n\n        Compatible operators: `|`, `&`, `< <= == != >= >`, `isin`\n\n        Examples:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [\"A\", \"A\", \"A\", \"B\"], \"bar\": [1, 2, 3, 4]})\n        ```\n        | foo   |   bar |\n        |:------|------:|\n        | A     |     1 |\n        | A     |     2 |\n        | A     |     3 |\n        | B     |     4 |\n\n        Single condition:\n\n        ```python\n        df.filter(lambda row: row[\"foo\"].isin([\"A\"]))\n        ```\n        | foo   |   bar |\n        |:------|------:|\n        | A     |     1 |\n        | A     |     2 |\n        | A     |     3 |\n\n        And (multiple conditions):\n\n        ```python\n        df.filter(lambda row: (row[\"foo\"] == \"A\") & (row[\"bar\"] <= 2))\n        ```\n        | foo   |   bar |\n        |:------|------:|\n        | A     |     1 |\n        | A     |     2 |\n\n        Or (multiple conditions):\n\n        ```python\n        df.filter(lambda row: (row[\"foo\"] == \"B\") | (row[\"bar\"] == 1))\n        ```", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_855-905"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 890, "start_line_no": 865, "end_line_no": 915, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        Compatible operators: `|`, `&`, `< <= == != >= >`, `isin`\n\n        Examples:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [\"A\", \"A\", \"A\", \"B\"], \"bar\": [1, 2, 3, 4]})\n        ```\n        | foo   |   bar |\n        |:------|------:|\n        | A     |     1 |\n        | A     |     2 |\n        | A     |     3 |\n        | B     |     4 |\n\n        Single condition:\n\n        ```python\n        df.filter(lambda row: row[\"foo\"].isin([\"A\"]))\n        ```\n        | foo   |   bar |\n        |:------|------:|\n        | A     |     1 |\n        | A     |     2 |\n        | A     |     3 |\n\n        And (multiple conditions):\n\n        ```python\n        df.filter(lambda row: (row[\"foo\"] == \"A\") & (row[\"bar\"] <= 2))\n        ```\n        | foo   |   bar |\n        |:------|------:|\n        | A     |     1 |\n        | A     |     2 |\n\n        Or (multiple conditions):\n\n        ```python\n        df.filter(lambda row: (row[\"foo\"] == \"B\") | (row[\"bar\"] == 1))\n        ```\n        | foo   |   bar |\n        |:------|------:|\n        | A     |     1 |\n        | B     |     4 |\n        \"\"\"\n        return _wrap(filter(self._data, func))\n\n    def group(self, by: LazyColumns) -> GroupedFrame:\n        \"\"\"Prepare groups for compatible verbs\n", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_865-915"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 900, "start_line_no": 875, "end_line_no": 925, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        | A     |     2 |\n        | A     |     3 |\n        | B     |     4 |\n\n        Single condition:\n\n        ```python\n        df.filter(lambda row: row[\"foo\"].isin([\"A\"]))\n        ```\n        | foo   |   bar |\n        |:------|------:|\n        | A     |     1 |\n        | A     |     2 |\n        | A     |     3 |\n\n        And (multiple conditions):\n\n        ```python\n        df.filter(lambda row: (row[\"foo\"] == \"A\") & (row[\"bar\"] <= 2))\n        ```\n        | foo   |   bar |\n        |:------|------:|\n        | A     |     1 |\n        | A     |     2 |\n\n        Or (multiple conditions):\n\n        ```python\n        df.filter(lambda row: (row[\"foo\"] == \"B\") | (row[\"bar\"] == 1))\n        ```\n        | foo   |   bar |\n        |:------|------:|\n        | A     |     1 |\n        | B     |     4 |\n        \"\"\"\n        return _wrap(filter(self._data, func))\n\n    def group(self, by: LazyColumns) -> GroupedFrame:\n        \"\"\"Prepare groups for compatible verbs\n\n        Compatible verbs: `accumulate`, `gather`, `pack`, `rank`, `rollup`, `take`\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [\"A\", \"A\", \"A\", \"B\", \"B\"], \"bar\": [1, 2, 3, 4, 5], \"baz\": [9, 7, 7, 5, 6]})\n        ```\n        | foo   |   bar |   baz |\n        |:------|------:|------:|\n        | A     |     1 |     9 |", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_875-925"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 910, "start_line_no": 885, "end_line_no": 935, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        |:------|------:|\n        | A     |     1 |\n        | A     |     2 |\n        | A     |     3 |\n\n        And (multiple conditions):\n\n        ```python\n        df.filter(lambda row: (row[\"foo\"] == \"A\") & (row[\"bar\"] <= 2))\n        ```\n        | foo   |   bar |\n        |:------|------:|\n        | A     |     1 |\n        | A     |     2 |\n\n        Or (multiple conditions):\n\n        ```python\n        df.filter(lambda row: (row[\"foo\"] == \"B\") | (row[\"bar\"] == 1))\n        ```\n        | foo   |   bar |\n        |:------|------:|\n        | A     |     1 |\n        | B     |     4 |\n        \"\"\"\n        return _wrap(filter(self._data, func))\n\n    def group(self, by: LazyColumns) -> GroupedFrame:\n        \"\"\"Prepare groups for compatible verbs\n\n        Compatible verbs: `accumulate`, `gather`, `pack`, `rank`, `rollup`, `take`\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [\"A\", \"A\", \"A\", \"B\", \"B\"], \"bar\": [1, 2, 3, 4, 5], \"baz\": [9, 7, 7, 5, 6]})\n        ```\n        | foo   |   bar |   baz |\n        |:------|------:|------:|\n        | A     |     1 |     9 |\n        | A     |     2 |     7 |\n        | A     |     3 |     7 |\n        | B     |     4 |     5 |\n        | B     |     5 |     6 |\n\n        + `accumulate`:\n\n        ```python\n        df.group(\"foo\").accumulate(\"bar\", into=\"bar_cumsum\")\n        ```", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_885-935"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 920, "start_line_no": 895, "end_line_no": 945, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        | foo   |   bar |\n        |:------|------:|\n        | A     |     1 |\n        | A     |     2 |\n\n        Or (multiple conditions):\n\n        ```python\n        df.filter(lambda row: (row[\"foo\"] == \"B\") | (row[\"bar\"] == 1))\n        ```\n        | foo   |   bar |\n        |:------|------:|\n        | A     |     1 |\n        | B     |     4 |\n        \"\"\"\n        return _wrap(filter(self._data, func))\n\n    def group(self, by: LazyColumns) -> GroupedFrame:\n        \"\"\"Prepare groups for compatible verbs\n\n        Compatible verbs: `accumulate`, `gather`, `pack`, `rank`, `rollup`, `take`\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [\"A\", \"A\", \"A\", \"B\", \"B\"], \"bar\": [1, 2, 3, 4, 5], \"baz\": [9, 7, 7, 5, 6]})\n        ```\n        | foo   |   bar |   baz |\n        |:------|------:|------:|\n        | A     |     1 |     9 |\n        | A     |     2 |     7 |\n        | A     |     3 |     7 |\n        | B     |     4 |     5 |\n        | B     |     5 |     6 |\n\n        + `accumulate`:\n\n        ```python\n        df.group(\"foo\").accumulate(\"bar\", into=\"bar_cumsum\")\n        ```\n        | foo   |   bar |   baz |   bar_cumsum |\n        |:------|------:|------:|-------------:|\n        | A     |     1 |     9 |            1 |\n        | A     |     2 |     7 |            3 |\n        | A     |     3 |     7 |            6 |\n        | B     |     4 |     5 |            4 |\n        | B     |     5 |     6 |            9 |\n\n        + `gather`:\n", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_895-945"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 930, "start_line_no": 905, "end_line_no": 955, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        | foo   |   bar |\n        |:------|------:|\n        | A     |     1 |\n        | B     |     4 |\n        \"\"\"\n        return _wrap(filter(self._data, func))\n\n    def group(self, by: LazyColumns) -> GroupedFrame:\n        \"\"\"Prepare groups for compatible verbs\n\n        Compatible verbs: `accumulate`, `gather`, `pack`, `rank`, `rollup`, `take`\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [\"A\", \"A\", \"A\", \"B\", \"B\"], \"bar\": [1, 2, 3, 4, 5], \"baz\": [9, 7, 7, 5, 6]})\n        ```\n        | foo   |   bar |   baz |\n        |:------|------:|------:|\n        | A     |     1 |     9 |\n        | A     |     2 |     7 |\n        | A     |     3 |     7 |\n        | B     |     4 |     5 |\n        | B     |     5 |     6 |\n\n        + `accumulate`:\n\n        ```python\n        df.group(\"foo\").accumulate(\"bar\", into=\"bar_cumsum\")\n        ```\n        | foo   |   bar |   baz |   bar_cumsum |\n        |:------|------:|------:|-------------:|\n        | A     |     1 |     9 |            1 |\n        | A     |     2 |     7 |            3 |\n        | A     |     3 |     7 |            6 |\n        | B     |     4 |     5 |            4 |\n        | B     |     5 |     6 |            9 |\n\n        + `gather`:\n\n        ```python\n        df.group(\"foo\").gather()\n        ```\n        | foo   | variable   |   value |\n        |:------|:-----------|--------:|\n        | A     | bar        |       1 |\n        | A     | bar        |       2 |\n        | A     | bar        |       3 |\n        | B     | bar        |       4 |\n        | B     | bar        |       5 |", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_905-955"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 940, "start_line_no": 915, "end_line_no": 965, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        Compatible verbs: `accumulate`, `gather`, `pack`, `rank`, `rollup`, `take`\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [\"A\", \"A\", \"A\", \"B\", \"B\"], \"bar\": [1, 2, 3, 4, 5], \"baz\": [9, 7, 7, 5, 6]})\n        ```\n        | foo   |   bar |   baz |\n        |:------|------:|------:|\n        | A     |     1 |     9 |\n        | A     |     2 |     7 |\n        | A     |     3 |     7 |\n        | B     |     4 |     5 |\n        | B     |     5 |     6 |\n\n        + `accumulate`:\n\n        ```python\n        df.group(\"foo\").accumulate(\"bar\", into=\"bar_cumsum\")\n        ```\n        | foo   |   bar |   baz |   bar_cumsum |\n        |:------|------:|------:|-------------:|\n        | A     |     1 |     9 |            1 |\n        | A     |     2 |     7 |            3 |\n        | A     |     3 |     7 |            6 |\n        | B     |     4 |     5 |            4 |\n        | B     |     5 |     6 |            9 |\n\n        + `gather`:\n\n        ```python\n        df.group(\"foo\").gather()\n        ```\n        | foo   | variable   |   value |\n        |:------|:-----------|--------:|\n        | A     | bar        |       1 |\n        | A     | bar        |       2 |\n        | A     | bar        |       3 |\n        | B     | bar        |       4 |\n        | B     | bar        |       5 |\n        | A     | baz        |       9 |\n        | A     | baz        |       7 |\n        | A     | baz        |       7 |\n        | B     | baz        |       5 |\n        | B     | baz        |       6 |\n\n        + `pack`:\n\n        ```python\n        df.group(\"foo\").pack(\"bar\", sep=\":\")", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_915-965"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 950, "start_line_no": 925, "end_line_no": 975, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        | A     |     2 |     7 |\n        | A     |     3 |     7 |\n        | B     |     4 |     5 |\n        | B     |     5 |     6 |\n\n        + `accumulate`:\n\n        ```python\n        df.group(\"foo\").accumulate(\"bar\", into=\"bar_cumsum\")\n        ```\n        | foo   |   bar |   baz |   bar_cumsum |\n        |:------|------:|------:|-------------:|\n        | A     |     1 |     9 |            1 |\n        | A     |     2 |     7 |            3 |\n        | A     |     3 |     7 |            6 |\n        | B     |     4 |     5 |            4 |\n        | B     |     5 |     6 |            9 |\n\n        + `gather`:\n\n        ```python\n        df.group(\"foo\").gather()\n        ```\n        | foo   | variable   |   value |\n        |:------|:-----------|--------:|\n        | A     | bar        |       1 |\n        | A     | bar        |       2 |\n        | A     | bar        |       3 |\n        | B     | bar        |       4 |\n        | B     | bar        |       5 |\n        | A     | baz        |       9 |\n        | A     | baz        |       7 |\n        | A     | baz        |       7 |\n        | B     | baz        |       5 |\n        | B     | baz        |       6 |\n\n        + `pack`:\n\n        ```python\n        df.group(\"foo\").pack(\"bar\", sep=\":\")\n        ```\n        | foo   | bar   |\n        |:------|:------|\n        | A     | 1:2:3 |\n        | B     | 4:5   |\n\n\n        + `rank`:\n\n        ```python", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_925-975"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 960, "start_line_no": 935, "end_line_no": 985, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        | foo   |   bar |   baz |   bar_cumsum |\n        |:------|------:|------:|-------------:|\n        | A     |     1 |     9 |            1 |\n        | A     |     2 |     7 |            3 |\n        | A     |     3 |     7 |            6 |\n        | B     |     4 |     5 |            4 |\n        | B     |     5 |     6 |            9 |\n\n        + `gather`:\n\n        ```python\n        df.group(\"foo\").gather()\n        ```\n        | foo   | variable   |   value |\n        |:------|:-----------|--------:|\n        | A     | bar        |       1 |\n        | A     | bar        |       2 |\n        | A     | bar        |       3 |\n        | B     | bar        |       4 |\n        | B     | bar        |       5 |\n        | A     | baz        |       9 |\n        | A     | baz        |       7 |\n        | A     | baz        |       7 |\n        | B     | baz        |       5 |\n        | B     | baz        |       6 |\n\n        + `pack`:\n\n        ```python\n        df.group(\"foo\").pack(\"bar\", sep=\":\")\n        ```\n        | foo   | bar   |\n        |:------|:------|\n        | A     | 1:2:3 |\n        | B     | 4:5   |\n\n\n        + `rank`:\n\n        ```python\n        df.group(\"foo\").rank(\"baz\", into=\"baz_rank\", descending=True)\n        ```\n        | foo   |   bar |   baz |   baz_rank |\n        |:------|------:|------:|-----------:|\n        | A     |     1 |     9 |          1 |\n        | A     |     2 |     7 |          2 |\n        | A     |     3 |     7 |          2 |\n        | B     |     4 |     5 |          2 |\n        | B     |     5 |     6 |          1 |\n", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_935-985"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 970, "start_line_no": 945, "end_line_no": 995, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        ```python\n        df.group(\"foo\").gather()\n        ```\n        | foo   | variable   |   value |\n        |:------|:-----------|--------:|\n        | A     | bar        |       1 |\n        | A     | bar        |       2 |\n        | A     | bar        |       3 |\n        | B     | bar        |       4 |\n        | B     | bar        |       5 |\n        | A     | baz        |       9 |\n        | A     | baz        |       7 |\n        | A     | baz        |       7 |\n        | B     | baz        |       5 |\n        | B     | baz        |       6 |\n\n        + `pack`:\n\n        ```python\n        df.group(\"foo\").pack(\"bar\", sep=\":\")\n        ```\n        | foo   | bar   |\n        |:------|:------|\n        | A     | 1:2:3 |\n        | B     | 4:5   |\n\n\n        + `rank`:\n\n        ```python\n        df.group(\"foo\").rank(\"baz\", into=\"baz_rank\", descending=True)\n        ```\n        | foo   |   bar |   baz |   baz_rank |\n        |:------|------:|------:|-----------:|\n        | A     |     1 |     9 |          1 |\n        | A     |     2 |     7 |          2 |\n        | A     |     3 |     7 |          2 |\n        | B     |     4 |     5 |          2 |\n        | B     |     5 |     6 |          1 |\n\n        + `rollup`:\n\n        ```python\n        df.group(\"foo\").rollup({\n            \"bar_mean\": (\"bar\", rf.stat.mean),\n            \"baz_min\": (\"baz\", rf.stat.min)\n        })\n        ```\n        | foo   |   bar_mean |   baz_min |\n        |:------|-----------:|----------:|", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_945-995"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 980, "start_line_no": 955, "end_line_no": 1005, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        | A     | baz        |       9 |\n        | A     | baz        |       7 |\n        | A     | baz        |       7 |\n        | B     | baz        |       5 |\n        | B     | baz        |       6 |\n\n        + `pack`:\n\n        ```python\n        df.group(\"foo\").pack(\"bar\", sep=\":\")\n        ```\n        | foo   | bar   |\n        |:------|:------|\n        | A     | 1:2:3 |\n        | B     | 4:5   |\n\n\n        + `rank`:\n\n        ```python\n        df.group(\"foo\").rank(\"baz\", into=\"baz_rank\", descending=True)\n        ```\n        | foo   |   bar |   baz |   baz_rank |\n        |:------|------:|------:|-----------:|\n        | A     |     1 |     9 |          1 |\n        | A     |     2 |     7 |          2 |\n        | A     |     3 |     7 |          2 |\n        | B     |     4 |     5 |          2 |\n        | B     |     5 |     6 |          1 |\n\n        + `rollup`:\n\n        ```python\n        df.group(\"foo\").rollup({\n            \"bar_mean\": (\"bar\", rf.stat.mean),\n            \"baz_min\": (\"baz\", rf.stat.min)\n        })\n        ```\n        | foo   |   bar_mean |   baz_min |\n        |:------|-----------:|----------:|\n        | A     |        2   |         7 |\n        | B     |        4.5 |         5 |\n\n        + `take`:\n\n        ```python\n        df.group(\"foo\").take(1)\n        ```\n        | foo   |   bar |   baz |\n        |:------|------:|------:|", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_955-1005"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 990, "start_line_no": 965, "end_line_no": 1015, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        ```\n        | foo   | bar   |\n        |:------|:------|\n        | A     | 1:2:3 |\n        | B     | 4:5   |\n\n\n        + `rank`:\n\n        ```python\n        df.group(\"foo\").rank(\"baz\", into=\"baz_rank\", descending=True)\n        ```\n        | foo   |   bar |   baz |   baz_rank |\n        |:------|------:|------:|-----------:|\n        | A     |     1 |     9 |          1 |\n        | A     |     2 |     7 |          2 |\n        | A     |     3 |     7 |          2 |\n        | B     |     4 |     5 |          2 |\n        | B     |     5 |     6 |          1 |\n\n        + `rollup`:\n\n        ```python\n        df.group(\"foo\").rollup({\n            \"bar_mean\": (\"bar\", rf.stat.mean),\n            \"baz_min\": (\"baz\", rf.stat.min)\n        })\n        ```\n        | foo   |   bar_mean |   baz_min |\n        |:------|-----------:|----------:|\n        | A     |        2   |         7 |\n        | B     |        4.5 |         5 |\n\n        + `take`:\n\n        ```python\n        df.group(\"foo\").take(1)\n        ```\n        | foo   |   bar |   baz |\n        |:------|------:|------:|\n        | A     |     1 |     9 |\n        | B     |     4 |     5 |\n\n        \"\"\"\n        return GroupedFrame(group(self._data, by))\n\n    def join(\n        self,\n        rhs: DataFrame,\n        on: LazyColumns,", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_965-1015"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 1000, "start_line_no": 975, "end_line_no": 1025, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        df.group(\"foo\").rank(\"baz\", into=\"baz_rank\", descending=True)\n        ```\n        | foo   |   bar |   baz |   baz_rank |\n        |:------|------:|------:|-----------:|\n        | A     |     1 |     9 |          1 |\n        | A     |     2 |     7 |          2 |\n        | A     |     3 |     7 |          2 |\n        | B     |     4 |     5 |          2 |\n        | B     |     5 |     6 |          1 |\n\n        + `rollup`:\n\n        ```python\n        df.group(\"foo\").rollup({\n            \"bar_mean\": (\"bar\", rf.stat.mean),\n            \"baz_min\": (\"baz\", rf.stat.min)\n        })\n        ```\n        | foo   |   bar_mean |   baz_min |\n        |:------|-----------:|----------:|\n        | A     |        2   |         7 |\n        | B     |        4.5 |         5 |\n\n        + `take`:\n\n        ```python\n        df.group(\"foo\").take(1)\n        ```\n        | foo   |   bar |   baz |\n        |:------|------:|------:|\n        | A     |     1 |     9 |\n        | B     |     4 |     5 |\n\n        \"\"\"\n        return GroupedFrame(group(self._data, by))\n\n    def join(\n        self,\n        rhs: DataFrame,\n        on: LazyColumns,\n        how: Join = \"left\",\n        postfix: tuple[str, str] = (\"_lhs\", \"_rhs\"),\n    ) -> DataFrame:\n        \"\"\"Join columns from another DataFrame\n\n        Examples:\n\n        ```python\n        adf = rf.DataFrame({\"foo\": [\"A\", \"B\", \"C\"], \"bar\": [1, 2, 3]})\n        ```", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_975-1025"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 1010, "start_line_no": 985, "end_line_no": 1035, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        + `rollup`:\n\n        ```python\n        df.group(\"foo\").rollup({\n            \"bar_mean\": (\"bar\", rf.stat.mean),\n            \"baz_min\": (\"baz\", rf.stat.min)\n        })\n        ```\n        | foo   |   bar_mean |   baz_min |\n        |:------|-----------:|----------:|\n        | A     |        2   |         7 |\n        | B     |        4.5 |         5 |\n\n        + `take`:\n\n        ```python\n        df.group(\"foo\").take(1)\n        ```\n        | foo   |   bar |   baz |\n        |:------|------:|------:|\n        | A     |     1 |     9 |\n        | B     |     4 |     5 |\n\n        \"\"\"\n        return GroupedFrame(group(self._data, by))\n\n    def join(\n        self,\n        rhs: DataFrame,\n        on: LazyColumns,\n        how: Join = \"left\",\n        postfix: tuple[str, str] = (\"_lhs\", \"_rhs\"),\n    ) -> DataFrame:\n        \"\"\"Join columns from another DataFrame\n\n        Examples:\n\n        ```python\n        adf = rf.DataFrame({\"foo\": [\"A\", \"B\", \"C\"], \"bar\": [1, 2, 3]})\n        ```\n        | foo   |   bar |\n        |:------|------:|\n        | A     |     1 |\n        | B     |     2 |\n        | C     |     3 |\n\n        ```python\n        bdf = rf.DataFrame({\"foo\": [\"A\", \"B\", \"D\"], \"baz\": [\"!\", \"@\", \"#\"]})\n        ```\n        | foo   | baz   |", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_985-1035"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 1020, "start_line_no": 995, "end_line_no": 1045, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        | A     |        2   |         7 |\n        | B     |        4.5 |         5 |\n\n        + `take`:\n\n        ```python\n        df.group(\"foo\").take(1)\n        ```\n        | foo   |   bar |   baz |\n        |:------|------:|------:|\n        | A     |     1 |     9 |\n        | B     |     4 |     5 |\n\n        \"\"\"\n        return GroupedFrame(group(self._data, by))\n\n    def join(\n        self,\n        rhs: DataFrame,\n        on: LazyColumns,\n        how: Join = \"left\",\n        postfix: tuple[str, str] = (\"_lhs\", \"_rhs\"),\n    ) -> DataFrame:\n        \"\"\"Join columns from another DataFrame\n\n        Examples:\n\n        ```python\n        adf = rf.DataFrame({\"foo\": [\"A\", \"B\", \"C\"], \"bar\": [1, 2, 3]})\n        ```\n        | foo   |   bar |\n        |:------|------:|\n        | A     |     1 |\n        | B     |     2 |\n        | C     |     3 |\n\n        ```python\n        bdf = rf.DataFrame({\"foo\": [\"A\", \"B\", \"D\"], \"baz\": [\"!\", \"@\", \"#\"]})\n        ```\n        | foo   | baz   |\n        |:------|:------|\n        | A     | !     |\n        | B     | @     |\n        | D     | #     |\n\n        Left join:\n\n        ```python\n        adf.join(bdf, on=\"foo\", how=\"left\")\n        ```", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_995-1045"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 1030, "start_line_no": 1005, "end_line_no": 1055, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        | A     |     1 |     9 |\n        | B     |     4 |     5 |\n\n        \"\"\"\n        return GroupedFrame(group(self._data, by))\n\n    def join(\n        self,\n        rhs: DataFrame,\n        on: LazyColumns,\n        how: Join = \"left\",\n        postfix: tuple[str, str] = (\"_lhs\", \"_rhs\"),\n    ) -> DataFrame:\n        \"\"\"Join columns from another DataFrame\n\n        Examples:\n\n        ```python\n        adf = rf.DataFrame({\"foo\": [\"A\", \"B\", \"C\"], \"bar\": [1, 2, 3]})\n        ```\n        | foo   |   bar |\n        |:------|------:|\n        | A     |     1 |\n        | B     |     2 |\n        | C     |     3 |\n\n        ```python\n        bdf = rf.DataFrame({\"foo\": [\"A\", \"B\", \"D\"], \"baz\": [\"!\", \"@\", \"#\"]})\n        ```\n        | foo   | baz   |\n        |:------|:------|\n        | A     | !     |\n        | B     | @     |\n        | D     | #     |\n\n        Left join:\n\n        ```python\n        adf.join(bdf, on=\"foo\", how=\"left\")\n        ```\n        | foo   |   bar | baz   |\n        |:------|------:|:------|\n        | A     |     1 | !     |\n        | B     |     2 | @     |\n        | C     |     3 | nan   |\n\n        Right join:\n\n        ```python\n        adf.join(bdf, on=\"foo\", how=\"right\")", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_1005-1055"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 1040, "start_line_no": 1015, "end_line_no": 1065, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        how: Join = \"left\",\n        postfix: tuple[str, str] = (\"_lhs\", \"_rhs\"),\n    ) -> DataFrame:\n        \"\"\"Join columns from another DataFrame\n\n        Examples:\n\n        ```python\n        adf = rf.DataFrame({\"foo\": [\"A\", \"B\", \"C\"], \"bar\": [1, 2, 3]})\n        ```\n        | foo   |   bar |\n        |:------|------:|\n        | A     |     1 |\n        | B     |     2 |\n        | C     |     3 |\n\n        ```python\n        bdf = rf.DataFrame({\"foo\": [\"A\", \"B\", \"D\"], \"baz\": [\"!\", \"@\", \"#\"]})\n        ```\n        | foo   | baz   |\n        |:------|:------|\n        | A     | !     |\n        | B     | @     |\n        | D     | #     |\n\n        Left join:\n\n        ```python\n        adf.join(bdf, on=\"foo\", how=\"left\")\n        ```\n        | foo   |   bar | baz   |\n        |:------|------:|:------|\n        | A     |     1 | !     |\n        | B     |     2 | @     |\n        | C     |     3 | nan   |\n\n        Right join:\n\n        ```python\n        adf.join(bdf, on=\"foo\", how=\"right\")\n        ```\n        | foo   |   bar | baz   |\n        |:------|------:|:------|\n        | A     |     1 | !     |\n        | B     |     2 | @     |\n        | D     |   nan | #     |\n\n        Inner join:\n\n        ```python", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_1015-1065"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 1050, "start_line_no": 1025, "end_line_no": 1075, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        | foo   |   bar |\n        |:------|------:|\n        | A     |     1 |\n        | B     |     2 |\n        | C     |     3 |\n\n        ```python\n        bdf = rf.DataFrame({\"foo\": [\"A\", \"B\", \"D\"], \"baz\": [\"!\", \"@\", \"#\"]})\n        ```\n        | foo   | baz   |\n        |:------|:------|\n        | A     | !     |\n        | B     | @     |\n        | D     | #     |\n\n        Left join:\n\n        ```python\n        adf.join(bdf, on=\"foo\", how=\"left\")\n        ```\n        | foo   |   bar | baz   |\n        |:------|------:|:------|\n        | A     |     1 | !     |\n        | B     |     2 | @     |\n        | C     |     3 | nan   |\n\n        Right join:\n\n        ```python\n        adf.join(bdf, on=\"foo\", how=\"right\")\n        ```\n        | foo   |   bar | baz   |\n        |:------|------:|:------|\n        | A     |     1 | !     |\n        | B     |     2 | @     |\n        | D     |   nan | #     |\n\n        Inner join:\n\n        ```python\n        adf.join(bdf, on=\"foo\", how=\"inner\")\n        ```\n        | foo   |   bar | baz   |\n        |:------|------:|:------|\n        | A     |     1 | !     |\n        | B     |     2 | @     |\n\n        Full join:\n\n        ```python", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_1025-1075"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 1060, "start_line_no": 1035, "end_line_no": 1085, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        |:------|:------|\n        | A     | !     |\n        | B     | @     |\n        | D     | #     |\n\n        Left join:\n\n        ```python\n        adf.join(bdf, on=\"foo\", how=\"left\")\n        ```\n        | foo   |   bar | baz   |\n        |:------|------:|:------|\n        | A     |     1 | !     |\n        | B     |     2 | @     |\n        | C     |     3 | nan   |\n\n        Right join:\n\n        ```python\n        adf.join(bdf, on=\"foo\", how=\"right\")\n        ```\n        | foo   |   bar | baz   |\n        |:------|------:|:------|\n        | A     |     1 | !     |\n        | B     |     2 | @     |\n        | D     |   nan | #     |\n\n        Inner join:\n\n        ```python\n        adf.join(bdf, on=\"foo\", how=\"inner\")\n        ```\n        | foo   |   bar | baz   |\n        |:------|------:|:------|\n        | A     |     1 | !     |\n        | B     |     2 | @     |\n\n        Full join:\n\n        ```python\n        adf.join(bdf, on=\"foo\", how=\"full\")\n        ```\n        | foo   |   bar | baz   |\n        |:------|------:|:------|\n        | A     |     1 | !     |\n        | B     |     2 | @     |\n        | C     |     3 | nan   |\n        | D     |   nan | #     |\n        \"\"\"\n        _check_type(rhs, DataFrame)", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_1035-1085"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 1070, "start_line_no": 1045, "end_line_no": 1095, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        | foo   |   bar | baz   |\n        |:------|------:|:------|\n        | A     |     1 | !     |\n        | B     |     2 | @     |\n        | C     |     3 | nan   |\n\n        Right join:\n\n        ```python\n        adf.join(bdf, on=\"foo\", how=\"right\")\n        ```\n        | foo   |   bar | baz   |\n        |:------|------:|:------|\n        | A     |     1 | !     |\n        | B     |     2 | @     |\n        | D     |   nan | #     |\n\n        Inner join:\n\n        ```python\n        adf.join(bdf, on=\"foo\", how=\"inner\")\n        ```\n        | foo   |   bar | baz   |\n        |:------|------:|:------|\n        | A     |     1 | !     |\n        | B     |     2 | @     |\n\n        Full join:\n\n        ```python\n        adf.join(bdf, on=\"foo\", how=\"full\")\n        ```\n        | foo   |   bar | baz   |\n        |:------|------:|:------|\n        | A     |     1 | !     |\n        | B     |     2 | @     |\n        | C     |     3 | nan   |\n        | D     |   nan | #     |\n        \"\"\"\n        _check_type(rhs, DataFrame)\n        return _wrap(join(self._data, rhs._data, on, how, postfix))\n\n    def mutate(self, over: dict[Column, Func]) -> DataFrame:\n        \"\"\"Create a new, or overwrite an existing column\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [1, 2, 3]})\n        ```", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_1045-1095"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 1080, "start_line_no": 1055, "end_line_no": 1105, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        ```\n        | foo   |   bar | baz   |\n        |:------|------:|:------|\n        | A     |     1 | !     |\n        | B     |     2 | @     |\n        | D     |   nan | #     |\n\n        Inner join:\n\n        ```python\n        adf.join(bdf, on=\"foo\", how=\"inner\")\n        ```\n        | foo   |   bar | baz   |\n        |:------|------:|:------|\n        | A     |     1 | !     |\n        | B     |     2 | @     |\n\n        Full join:\n\n        ```python\n        adf.join(bdf, on=\"foo\", how=\"full\")\n        ```\n        | foo   |   bar | baz   |\n        |:------|------:|:------|\n        | A     |     1 | !     |\n        | B     |     2 | @     |\n        | C     |     3 | nan   |\n        | D     |   nan | #     |\n        \"\"\"\n        _check_type(rhs, DataFrame)\n        return _wrap(join(self._data, rhs._data, on, how, postfix))\n\n    def mutate(self, over: dict[Column, Func]) -> DataFrame:\n        \"\"\"Create a new, or overwrite an existing column\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [1, 2, 3]})\n        ```\n        |   foo |\n        |------:|\n        |     1 |\n        |     2 |\n        |     3 |\n\n        ```python\n        df.mutate({\n            \"bar\": lambda row: float(row[\"foo\"]),\n            \"baz\": lambda row: \"X\" + str(row[\"bar\"] * 2),", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_1055-1105"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 1090, "start_line_no": 1065, "end_line_no": 1115, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        adf.join(bdf, on=\"foo\", how=\"inner\")\n        ```\n        | foo   |   bar | baz   |\n        |:------|------:|:------|\n        | A     |     1 | !     |\n        | B     |     2 | @     |\n\n        Full join:\n\n        ```python\n        adf.join(bdf, on=\"foo\", how=\"full\")\n        ```\n        | foo   |   bar | baz   |\n        |:------|------:|:------|\n        | A     |     1 | !     |\n        | B     |     2 | @     |\n        | C     |     3 | nan   |\n        | D     |   nan | #     |\n        \"\"\"\n        _check_type(rhs, DataFrame)\n        return _wrap(join(self._data, rhs._data, on, how, postfix))\n\n    def mutate(self, over: dict[Column, Func]) -> DataFrame:\n        \"\"\"Create a new, or overwrite an existing column\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [1, 2, 3]})\n        ```\n        |   foo |\n        |------:|\n        |     1 |\n        |     2 |\n        |     3 |\n\n        ```python\n        df.mutate({\n            \"bar\": lambda row: float(row[\"foo\"]),\n            \"baz\": lambda row: \"X\" + str(row[\"bar\"] * 2),\n            \"jaz\": lambda _: \"Jazz\"\n        })\n        ```\n        |   foo |   bar | baz   | jaz   |\n        |------:|------:|:------|:------|\n        |     1 |     1 | X2.0  | Jazz  |\n        |     2 |     2 | X4.0  | Jazz  |\n        |     3 |     3 | X6.0  | Jazz  |\n        \"\"\"\n        return _wrap(mutate(self._data, over))", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_1065-1115"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 1100, "start_line_no": 1075, "end_line_no": 1125, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        adf.join(bdf, on=\"foo\", how=\"full\")\n        ```\n        | foo   |   bar | baz   |\n        |:------|------:|:------|\n        | A     |     1 | !     |\n        | B     |     2 | @     |\n        | C     |     3 | nan   |\n        | D     |   nan | #     |\n        \"\"\"\n        _check_type(rhs, DataFrame)\n        return _wrap(join(self._data, rhs._data, on, how, postfix))\n\n    def mutate(self, over: dict[Column, Func]) -> DataFrame:\n        \"\"\"Create a new, or overwrite an existing column\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [1, 2, 3]})\n        ```\n        |   foo |\n        |------:|\n        |     1 |\n        |     2 |\n        |     3 |\n\n        ```python\n        df.mutate({\n            \"bar\": lambda row: float(row[\"foo\"]),\n            \"baz\": lambda row: \"X\" + str(row[\"bar\"] * 2),\n            \"jaz\": lambda _: \"Jazz\"\n        })\n        ```\n        |   foo |   bar | baz   | jaz   |\n        |------:|------:|:------|:------|\n        |     1 |     1 | X2.0  | Jazz  |\n        |     2 |     2 | X4.0  | Jazz  |\n        |     3 |     3 | X6.0  | Jazz  |\n        \"\"\"\n        return _wrap(mutate(self._data, over))\n\n    def rename(self, columns: dict[OldColumn, NewColumn]) -> DataFrame:\n        \"\"\"Rename column keys (from \"old\" to \"new\")\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [1, 2], \"bar\": [3, 4]})\n        ```\n        |   foo |   bar |", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_1075-1125"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 1110, "start_line_no": 1085, "end_line_no": 1135, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        return _wrap(join(self._data, rhs._data, on, how, postfix))\n\n    def mutate(self, over: dict[Column, Func]) -> DataFrame:\n        \"\"\"Create a new, or overwrite an existing column\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [1, 2, 3]})\n        ```\n        |   foo |\n        |------:|\n        |     1 |\n        |     2 |\n        |     3 |\n\n        ```python\n        df.mutate({\n            \"bar\": lambda row: float(row[\"foo\"]),\n            \"baz\": lambda row: \"X\" + str(row[\"bar\"] * 2),\n            \"jaz\": lambda _: \"Jazz\"\n        })\n        ```\n        |   foo |   bar | baz   | jaz   |\n        |------:|------:|:------|:------|\n        |     1 |     1 | X2.0  | Jazz  |\n        |     2 |     2 | X4.0  | Jazz  |\n        |     3 |     3 | X6.0  | Jazz  |\n        \"\"\"\n        return _wrap(mutate(self._data, over))\n\n    def rename(self, columns: dict[OldColumn, NewColumn]) -> DataFrame:\n        \"\"\"Rename column keys (from \"old\" to \"new\")\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [1, 2], \"bar\": [3, 4]})\n        ```\n        |   foo |   bar |\n        |------:|------:|\n        |     1 |     3 |\n        |     2 |     4 |\n\n        ```python\n        df.rename({\"foo\": \"oof\", \"bar\": \"rab\"})\n        ```\n        |   oof |   rab |\n        |------:|------:|\n        |     1 |     3 |", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_1085-1135"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 1120, "start_line_no": 1095, "end_line_no": 1145, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        |   foo |\n        |------:|\n        |     1 |\n        |     2 |\n        |     3 |\n\n        ```python\n        df.mutate({\n            \"bar\": lambda row: float(row[\"foo\"]),\n            \"baz\": lambda row: \"X\" + str(row[\"bar\"] * 2),\n            \"jaz\": lambda _: \"Jazz\"\n        })\n        ```\n        |   foo |   bar | baz   | jaz   |\n        |------:|------:|:------|:------|\n        |     1 |     1 | X2.0  | Jazz  |\n        |     2 |     2 | X4.0  | Jazz  |\n        |     3 |     3 | X6.0  | Jazz  |\n        \"\"\"\n        return _wrap(mutate(self._data, over))\n\n    def rename(self, columns: dict[OldColumn, NewColumn]) -> DataFrame:\n        \"\"\"Rename column keys (from \"old\" to \"new\")\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [1, 2], \"bar\": [3, 4]})\n        ```\n        |   foo |   bar |\n        |------:|------:|\n        |     1 |     3 |\n        |     2 |     4 |\n\n        ```python\n        df.rename({\"foo\": \"oof\", \"bar\": \"rab\"})\n        ```\n        |   oof |   rab |\n        |------:|------:|\n        |     1 |     3 |\n        |     2 |     4 |\n\n        \"\"\"\n        return _wrap(rename(self._data, columns))\n\n    def replace(self, over: dict[Column, dict[OldValue, NewValue]]) -> DataFrame:\n        \"\"\"Replace matching values within columns (from \"old\" to \"new\")\n\n        Example:\n", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_1095-1145"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 1130, "start_line_no": 1105, "end_line_no": 1155, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "            \"jaz\": lambda _: \"Jazz\"\n        })\n        ```\n        |   foo |   bar | baz   | jaz   |\n        |------:|------:|:------|:------|\n        |     1 |     1 | X2.0  | Jazz  |\n        |     2 |     2 | X4.0  | Jazz  |\n        |     3 |     3 | X6.0  | Jazz  |\n        \"\"\"\n        return _wrap(mutate(self._data, over))\n\n    def rename(self, columns: dict[OldColumn, NewColumn]) -> DataFrame:\n        \"\"\"Rename column keys (from \"old\" to \"new\")\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [1, 2], \"bar\": [3, 4]})\n        ```\n        |   foo |   bar |\n        |------:|------:|\n        |     1 |     3 |\n        |     2 |     4 |\n\n        ```python\n        df.rename({\"foo\": \"oof\", \"bar\": \"rab\"})\n        ```\n        |   oof |   rab |\n        |------:|------:|\n        |     1 |     3 |\n        |     2 |     4 |\n\n        \"\"\"\n        return _wrap(rename(self._data, columns))\n\n    def replace(self, over: dict[Column, dict[OldValue, NewValue]]) -> DataFrame:\n        \"\"\"Replace matching values within columns (from \"old\" to \"new\")\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [1, 2, 2, 2, 1], \"bar\": [1, \"A\", \"B\", True, False]})\n        ```\n        |   foo | bar   |\n        |------:|:------|\n        |     1 | 1     |\n        |     2 | A     |\n        |     2 | B     |\n        |     2 | True  |\n        |     1 | False |", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_1105-1155"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 1140, "start_line_no": 1115, "end_line_no": 1165, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "\n    def rename(self, columns: dict[OldColumn, NewColumn]) -> DataFrame:\n        \"\"\"Rename column keys (from \"old\" to \"new\")\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [1, 2], \"bar\": [3, 4]})\n        ```\n        |   foo |   bar |\n        |------:|------:|\n        |     1 |     3 |\n        |     2 |     4 |\n\n        ```python\n        df.rename({\"foo\": \"oof\", \"bar\": \"rab\"})\n        ```\n        |   oof |   rab |\n        |------:|------:|\n        |     1 |     3 |\n        |     2 |     4 |\n\n        \"\"\"\n        return _wrap(rename(self._data, columns))\n\n    def replace(self, over: dict[Column, dict[OldValue, NewValue]]) -> DataFrame:\n        \"\"\"Replace matching values within columns (from \"old\" to \"new\")\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [1, 2, 2, 2, 1], \"bar\": [1, \"A\", \"B\", True, False]})\n        ```\n        |   foo | bar   |\n        |------:|:------|\n        |     1 | 1     |\n        |     2 | A     |\n        |     2 | B     |\n        |     2 | True  |\n        |     1 | False |\n\n        ```python\n        df.replace({\n            \"foo\": {2: 222},\n            \"bar\": {False: 0, True: 1, \"A\": 2, \"B\": 3}\n        })\n        ```\n        |   foo |   bar |\n        |------:|------:|\n        |     1 |     1 |", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_1115-1165"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 1150, "start_line_no": 1125, "end_line_no": 1175, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        |------:|------:|\n        |     1 |     3 |\n        |     2 |     4 |\n\n        ```python\n        df.rename({\"foo\": \"oof\", \"bar\": \"rab\"})\n        ```\n        |   oof |   rab |\n        |------:|------:|\n        |     1 |     3 |\n        |     2 |     4 |\n\n        \"\"\"\n        return _wrap(rename(self._data, columns))\n\n    def replace(self, over: dict[Column, dict[OldValue, NewValue]]) -> DataFrame:\n        \"\"\"Replace matching values within columns (from \"old\" to \"new\")\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [1, 2, 2, 2, 1], \"bar\": [1, \"A\", \"B\", True, False]})\n        ```\n        |   foo | bar   |\n        |------:|:------|\n        |     1 | 1     |\n        |     2 | A     |\n        |     2 | B     |\n        |     2 | True  |\n        |     1 | False |\n\n        ```python\n        df.replace({\n            \"foo\": {2: 222},\n            \"bar\": {False: 0, True: 1, \"A\": 2, \"B\": 3}\n        })\n        ```\n        |   foo |   bar |\n        |------:|------:|\n        |     1 |     1 |\n        |   222 |     2 |\n        |   222 |     3 |\n        |   222 |     1 |\n        |     1 |     0 |\n        \"\"\"\n        return _wrap(replace(self._data, over))\n\n    def sample(self, rows: int | float, seed: int | None = None) -> DataFrame:\n        \"\"\"Randomly sample any number of rows\n", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_1125-1175"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 1160, "start_line_no": 1135, "end_line_no": 1185, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        |     2 |     4 |\n\n        \"\"\"\n        return _wrap(rename(self._data, columns))\n\n    def replace(self, over: dict[Column, dict[OldValue, NewValue]]) -> DataFrame:\n        \"\"\"Replace matching values within columns (from \"old\" to \"new\")\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [1, 2, 2, 2, 1], \"bar\": [1, \"A\", \"B\", True, False]})\n        ```\n        |   foo | bar   |\n        |------:|:------|\n        |     1 | 1     |\n        |     2 | A     |\n        |     2 | B     |\n        |     2 | True  |\n        |     1 | False |\n\n        ```python\n        df.replace({\n            \"foo\": {2: 222},\n            \"bar\": {False: 0, True: 1, \"A\": 2, \"B\": 3}\n        })\n        ```\n        |   foo |   bar |\n        |------:|------:|\n        |     1 |     1 |\n        |   222 |     2 |\n        |   222 |     3 |\n        |   222 |     1 |\n        |     1 |     0 |\n        \"\"\"\n        return _wrap(replace(self._data, over))\n\n    def sample(self, rows: int | float, seed: int | None = None) -> DataFrame:\n        \"\"\"Randomly sample any number of rows\n\n        Examples:\n\n        ```python\n        df = rf.DataFrame({\"foo\": range(10), \"bar\": range(10, 20)})\n        ```\n        |   foo |   bar |\n        |------:|------:|\n        |     0 |    10 |\n        |     1 |    11 |\n        |     2 |    12 |", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_1135-1185"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 1170, "start_line_no": 1145, "end_line_no": 1195, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        ```python\n        df = rf.DataFrame({\"foo\": [1, 2, 2, 2, 1], \"bar\": [1, \"A\", \"B\", True, False]})\n        ```\n        |   foo | bar   |\n        |------:|:------|\n        |     1 | 1     |\n        |     2 | A     |\n        |     2 | B     |\n        |     2 | True  |\n        |     1 | False |\n\n        ```python\n        df.replace({\n            \"foo\": {2: 222},\n            \"bar\": {False: 0, True: 1, \"A\": 2, \"B\": 3}\n        })\n        ```\n        |   foo |   bar |\n        |------:|------:|\n        |     1 |     1 |\n        |   222 |     2 |\n        |   222 |     3 |\n        |   222 |     1 |\n        |     1 |     0 |\n        \"\"\"\n        return _wrap(replace(self._data, over))\n\n    def sample(self, rows: int | float, seed: int | None = None) -> DataFrame:\n        \"\"\"Randomly sample any number of rows\n\n        Examples:\n\n        ```python\n        df = rf.DataFrame({\"foo\": range(10), \"bar\": range(10, 20)})\n        ```\n        |   foo |   bar |\n        |------:|------:|\n        |     0 |    10 |\n        |     1 |    11 |\n        |     2 |    12 |\n        |     3 |    13 |\n        |     4 |    14 |\n        |     5 |    15 |\n        |     6 |    16 |\n        |     7 |    17 |\n        |     8 |    18 |\n        |     9 |    19 |\n\n        Single row:\n", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_1145-1195"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 1180, "start_line_no": 1155, "end_line_no": 1205, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "\n        ```python\n        df.replace({\n            \"foo\": {2: 222},\n            \"bar\": {False: 0, True: 1, \"A\": 2, \"B\": 3}\n        })\n        ```\n        |   foo |   bar |\n        |------:|------:|\n        |     1 |     1 |\n        |   222 |     2 |\n        |   222 |     3 |\n        |   222 |     1 |\n        |     1 |     0 |\n        \"\"\"\n        return _wrap(replace(self._data, over))\n\n    def sample(self, rows: int | float, seed: int | None = None) -> DataFrame:\n        \"\"\"Randomly sample any number of rows\n\n        Examples:\n\n        ```python\n        df = rf.DataFrame({\"foo\": range(10), \"bar\": range(10, 20)})\n        ```\n        |   foo |   bar |\n        |------:|------:|\n        |     0 |    10 |\n        |     1 |    11 |\n        |     2 |    12 |\n        |     3 |    13 |\n        |     4 |    14 |\n        |     5 |    15 |\n        |     6 |    16 |\n        |     7 |    17 |\n        |     8 |    18 |\n        |     9 |    19 |\n\n        Single row:\n\n        ```python\n        df.sample(1)\n        ```\n        |   foo |   bar |\n        |------:|------:|\n        |     7 |    17 |\n\n        Multiple rows:\n\n        ```python", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_1155-1205"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 1190, "start_line_no": 1165, "end_line_no": 1215, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        |   222 |     2 |\n        |   222 |     3 |\n        |   222 |     1 |\n        |     1 |     0 |\n        \"\"\"\n        return _wrap(replace(self._data, over))\n\n    def sample(self, rows: int | float, seed: int | None = None) -> DataFrame:\n        \"\"\"Randomly sample any number of rows\n\n        Examples:\n\n        ```python\n        df = rf.DataFrame({\"foo\": range(10), \"bar\": range(10, 20)})\n        ```\n        |   foo |   bar |\n        |------:|------:|\n        |     0 |    10 |\n        |     1 |    11 |\n        |     2 |    12 |\n        |     3 |    13 |\n        |     4 |    14 |\n        |     5 |    15 |\n        |     6 |    16 |\n        |     7 |    17 |\n        |     8 |    18 |\n        |     9 |    19 |\n\n        Single row:\n\n        ```python\n        df.sample(1)\n        ```\n        |   foo |   bar |\n        |------:|------:|\n        |     7 |    17 |\n\n        Multiple rows:\n\n        ```python\n        df.sample(3)\n        ```\n        |   foo |   bar |\n        |------:|------:|\n        |     4 |    14 |\n        |     1 |    11 |\n        |     6 |    16 |\n\n        Percentage of total rows (30%):\n", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_1165-1215"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 1200, "start_line_no": 1175, "end_line_no": 1225, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        Examples:\n\n        ```python\n        df = rf.DataFrame({\"foo\": range(10), \"bar\": range(10, 20)})\n        ```\n        |   foo |   bar |\n        |------:|------:|\n        |     0 |    10 |\n        |     1 |    11 |\n        |     2 |    12 |\n        |     3 |    13 |\n        |     4 |    14 |\n        |     5 |    15 |\n        |     6 |    16 |\n        |     7 |    17 |\n        |     8 |    18 |\n        |     9 |    19 |\n\n        Single row:\n\n        ```python\n        df.sample(1)\n        ```\n        |   foo |   bar |\n        |------:|------:|\n        |     7 |    17 |\n\n        Multiple rows:\n\n        ```python\n        df.sample(3)\n        ```\n        |   foo |   bar |\n        |------:|------:|\n        |     4 |    14 |\n        |     1 |    11 |\n        |     6 |    16 |\n\n        Percentage of total rows (30%):\n\n        ```python\n        df.sample(0.3)\n        ```\n        |   foo |   bar |\n        |------:|------:|\n        |     4 |    14 |\n        |     3 |    13 |\n        |     1 |    11 |\n        \"\"\"\n        return _wrap(sample(self._data, rows, seed))", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_1175-1225"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 1210, "start_line_no": 1185, "end_line_no": 1235, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        |     3 |    13 |\n        |     4 |    14 |\n        |     5 |    15 |\n        |     6 |    16 |\n        |     7 |    17 |\n        |     8 |    18 |\n        |     9 |    19 |\n\n        Single row:\n\n        ```python\n        df.sample(1)\n        ```\n        |   foo |   bar |\n        |------:|------:|\n        |     7 |    17 |\n\n        Multiple rows:\n\n        ```python\n        df.sample(3)\n        ```\n        |   foo |   bar |\n        |------:|------:|\n        |     4 |    14 |\n        |     1 |    11 |\n        |     6 |    16 |\n\n        Percentage of total rows (30%):\n\n        ```python\n        df.sample(0.3)\n        ```\n        |   foo |   bar |\n        |------:|------:|\n        |     4 |    14 |\n        |     3 |    13 |\n        |     1 |    11 |\n        \"\"\"\n        return _wrap(sample(self._data, rows, seed))\n\n    def select(self, columns: LazyColumns) -> DataFrame:\n        \"\"\"Select specific columns\n\n        Examples:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [1, 2], \"bar\": [3, 4], \"baz\": [5, 6]})\n        ```\n        |   foo |   bar |   baz |", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_1185-1235"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 1220, "start_line_no": 1195, "end_line_no": 1245, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        ```python\n        df.sample(1)\n        ```\n        |   foo |   bar |\n        |------:|------:|\n        |     7 |    17 |\n\n        Multiple rows:\n\n        ```python\n        df.sample(3)\n        ```\n        |   foo |   bar |\n        |------:|------:|\n        |     4 |    14 |\n        |     1 |    11 |\n        |     6 |    16 |\n\n        Percentage of total rows (30%):\n\n        ```python\n        df.sample(0.3)\n        ```\n        |   foo |   bar |\n        |------:|------:|\n        |     4 |    14 |\n        |     3 |    13 |\n        |     1 |    11 |\n        \"\"\"\n        return _wrap(sample(self._data, rows, seed))\n\n    def select(self, columns: LazyColumns) -> DataFrame:\n        \"\"\"Select specific columns\n\n        Examples:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [1, 2], \"bar\": [3, 4], \"baz\": [5, 6]})\n        ```\n        |   foo |   bar |   baz |\n        |------:|------:|------:|\n        |     1 |     3 |     5 |\n        |     2 |     4 |     6 |\n\n        Single column:\n\n        ```python\n        df.select(\"foo\")\n        ```\n        |   foo |", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_1195-1245"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 1230, "start_line_no": 1205, "end_line_no": 1255, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        df.sample(3)\n        ```\n        |   foo |   bar |\n        |------:|------:|\n        |     4 |    14 |\n        |     1 |    11 |\n        |     6 |    16 |\n\n        Percentage of total rows (30%):\n\n        ```python\n        df.sample(0.3)\n        ```\n        |   foo |   bar |\n        |------:|------:|\n        |     4 |    14 |\n        |     3 |    13 |\n        |     1 |    11 |\n        \"\"\"\n        return _wrap(sample(self._data, rows, seed))\n\n    def select(self, columns: LazyColumns) -> DataFrame:\n        \"\"\"Select specific columns\n\n        Examples:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [1, 2], \"bar\": [3, 4], \"baz\": [5, 6]})\n        ```\n        |   foo |   bar |   baz |\n        |------:|------:|------:|\n        |     1 |     3 |     5 |\n        |     2 |     4 |     6 |\n\n        Single column:\n\n        ```python\n        df.select(\"foo\")\n        ```\n        |   foo |\n        |------:|\n        |     1 |\n        |     2 |\n\n        Multiple columns:\n\n        ```python\n        df.select([\"foo\", \"baz\"])\n        ```\n        |   foo |   baz |", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_1205-1255"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 1240, "start_line_no": 1215, "end_line_no": 1265, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        ```python\n        df.sample(0.3)\n        ```\n        |   foo |   bar |\n        |------:|------:|\n        |     4 |    14 |\n        |     3 |    13 |\n        |     1 |    11 |\n        \"\"\"\n        return _wrap(sample(self._data, rows, seed))\n\n    def select(self, columns: LazyColumns) -> DataFrame:\n        \"\"\"Select specific columns\n\n        Examples:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [1, 2], \"bar\": [3, 4], \"baz\": [5, 6]})\n        ```\n        |   foo |   bar |   baz |\n        |------:|------:|------:|\n        |     1 |     3 |     5 |\n        |     2 |     4 |     6 |\n\n        Single column:\n\n        ```python\n        df.select(\"foo\")\n        ```\n        |   foo |\n        |------:|\n        |     1 |\n        |     2 |\n\n        Multiple columns:\n\n        ```python\n        df.select([\"foo\", \"baz\"])\n        ```\n        |   foo |   baz |\n        |------:|------:|\n        |     1 |     5 |\n        |     2 |     6 |\n        \"\"\"\n        return _wrap(select(self._data, columns))\n\n    def shuffle(self, seed: int | None = None) -> DataFrame:\n        \"\"\"Shuffle the order of all rows\n\n        Example:", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_1215-1265"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 1250, "start_line_no": 1225, "end_line_no": 1275, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "\n    def select(self, columns: LazyColumns) -> DataFrame:\n        \"\"\"Select specific columns\n\n        Examples:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [1, 2], \"bar\": [3, 4], \"baz\": [5, 6]})\n        ```\n        |   foo |   bar |   baz |\n        |------:|------:|------:|\n        |     1 |     3 |     5 |\n        |     2 |     4 |     6 |\n\n        Single column:\n\n        ```python\n        df.select(\"foo\")\n        ```\n        |   foo |\n        |------:|\n        |     1 |\n        |     2 |\n\n        Multiple columns:\n\n        ```python\n        df.select([\"foo\", \"baz\"])\n        ```\n        |   foo |   baz |\n        |------:|------:|\n        |     1 |     5 |\n        |     2 |     6 |\n        \"\"\"\n        return _wrap(select(self._data, columns))\n\n    def shuffle(self, seed: int | None = None) -> DataFrame:\n        \"\"\"Shuffle the order of all rows\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": range(5), \"bar\": range(5, 10)})\n        ```\n        |   foo |   bar |\n        |------:|------:|\n        |     0 |     5 |\n        |     1 |     6 |\n        |     2 |     7 |\n        |     3 |     8 |", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_1225-1275"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 1260, "start_line_no": 1235, "end_line_no": 1285, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        |------:|------:|------:|\n        |     1 |     3 |     5 |\n        |     2 |     4 |     6 |\n\n        Single column:\n\n        ```python\n        df.select(\"foo\")\n        ```\n        |   foo |\n        |------:|\n        |     1 |\n        |     2 |\n\n        Multiple columns:\n\n        ```python\n        df.select([\"foo\", \"baz\"])\n        ```\n        |   foo |   baz |\n        |------:|------:|\n        |     1 |     5 |\n        |     2 |     6 |\n        \"\"\"\n        return _wrap(select(self._data, columns))\n\n    def shuffle(self, seed: int | None = None) -> DataFrame:\n        \"\"\"Shuffle the order of all rows\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": range(5), \"bar\": range(5, 10)})\n        ```\n        |   foo |   bar |\n        |------:|------:|\n        |     0 |     5 |\n        |     1 |     6 |\n        |     2 |     7 |\n        |     3 |     8 |\n        |     4 |     9 |\n\n        ```python\n        df.shuffle()\n        ```\n        |   foo |   bar |\n        |------:|------:|\n        |     4 |     9 |\n        |     2 |     7 |\n        |     3 |     8 |", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_1235-1285"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 1270, "start_line_no": 1245, "end_line_no": 1295, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        |------:|\n        |     1 |\n        |     2 |\n\n        Multiple columns:\n\n        ```python\n        df.select([\"foo\", \"baz\"])\n        ```\n        |   foo |   baz |\n        |------:|------:|\n        |     1 |     5 |\n        |     2 |     6 |\n        \"\"\"\n        return _wrap(select(self._data, columns))\n\n    def shuffle(self, seed: int | None = None) -> DataFrame:\n        \"\"\"Shuffle the order of all rows\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": range(5), \"bar\": range(5, 10)})\n        ```\n        |   foo |   bar |\n        |------:|------:|\n        |     0 |     5 |\n        |     1 |     6 |\n        |     2 |     7 |\n        |     3 |     8 |\n        |     4 |     9 |\n\n        ```python\n        df.shuffle()\n        ```\n        |   foo |   bar |\n        |------:|------:|\n        |     4 |     9 |\n        |     2 |     7 |\n        |     3 |     8 |\n        |     0 |     5 |\n        |     1 |     6 |\n        \"\"\"\n        return _wrap(shuffle(self._data, seed))\n\n    def sort(self, columns: LazyColumns, descending: bool = False) -> DataFrame:\n        \"\"\"Sort rows by specific columns\n\n        Examples:\n", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_1245-1295"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 1280, "start_line_no": 1255, "end_line_no": 1305, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        |------:|------:|\n        |     1 |     5 |\n        |     2 |     6 |\n        \"\"\"\n        return _wrap(select(self._data, columns))\n\n    def shuffle(self, seed: int | None = None) -> DataFrame:\n        \"\"\"Shuffle the order of all rows\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": range(5), \"bar\": range(5, 10)})\n        ```\n        |   foo |   bar |\n        |------:|------:|\n        |     0 |     5 |\n        |     1 |     6 |\n        |     2 |     7 |\n        |     3 |     8 |\n        |     4 |     9 |\n\n        ```python\n        df.shuffle()\n        ```\n        |   foo |   bar |\n        |------:|------:|\n        |     4 |     9 |\n        |     2 |     7 |\n        |     3 |     8 |\n        |     0 |     5 |\n        |     1 |     6 |\n        \"\"\"\n        return _wrap(shuffle(self._data, seed))\n\n    def sort(self, columns: LazyColumns, descending: bool = False) -> DataFrame:\n        \"\"\"Sort rows by specific columns\n\n        Examples:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [\"Z\", \"X\", \"A\", \"A\"], \"bar\": [2, -2, 4, -4]})\n        ```\n        | foo   |   bar |\n        |:------|------:|\n        | Z     |     2 |\n        | X     |    -2 |\n        | A     |     4 |\n        | A     |    -4 |\n", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_1255-1305"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 1290, "start_line_no": 1265, "end_line_no": 1315, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "\n        ```python\n        df = rf.DataFrame({\"foo\": range(5), \"bar\": range(5, 10)})\n        ```\n        |   foo |   bar |\n        |------:|------:|\n        |     0 |     5 |\n        |     1 |     6 |\n        |     2 |     7 |\n        |     3 |     8 |\n        |     4 |     9 |\n\n        ```python\n        df.shuffle()\n        ```\n        |   foo |   bar |\n        |------:|------:|\n        |     4 |     9 |\n        |     2 |     7 |\n        |     3 |     8 |\n        |     0 |     5 |\n        |     1 |     6 |\n        \"\"\"\n        return _wrap(shuffle(self._data, seed))\n\n    def sort(self, columns: LazyColumns, descending: bool = False) -> DataFrame:\n        \"\"\"Sort rows by specific columns\n\n        Examples:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [\"Z\", \"X\", \"A\", \"A\"], \"bar\": [2, -2, 4, -4]})\n        ```\n        | foo   |   bar |\n        |:------|------:|\n        | Z     |     2 |\n        | X     |    -2 |\n        | A     |     4 |\n        | A     |    -4 |\n\n        Single column:\n\n        ```python\n        df.sort(\"bar\")\n        ```\n        | foo   |   bar |\n        |:------|------:|\n        | A     |    -4 |\n        | X     |    -2 |\n        | Z     |     2 |", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_1265-1315"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 1300, "start_line_no": 1275, "end_line_no": 1325, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        |     4 |     9 |\n\n        ```python\n        df.shuffle()\n        ```\n        |   foo |   bar |\n        |------:|------:|\n        |     4 |     9 |\n        |     2 |     7 |\n        |     3 |     8 |\n        |     0 |     5 |\n        |     1 |     6 |\n        \"\"\"\n        return _wrap(shuffle(self._data, seed))\n\n    def sort(self, columns: LazyColumns, descending: bool = False) -> DataFrame:\n        \"\"\"Sort rows by specific columns\n\n        Examples:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [\"Z\", \"X\", \"A\", \"A\"], \"bar\": [2, -2, 4, -4]})\n        ```\n        | foo   |   bar |\n        |:------|------:|\n        | Z     |     2 |\n        | X     |    -2 |\n        | A     |     4 |\n        | A     |    -4 |\n\n        Single column:\n\n        ```python\n        df.sort(\"bar\")\n        ```\n        | foo   |   bar |\n        |:------|------:|\n        | A     |    -4 |\n        | X     |    -2 |\n        | Z     |     2 |\n        | A     |     4 |\n\n        Descending order:\n\n        ```python\n        df.sort(\"bar\", descending=True)\n        ```\n        | foo   |   bar |\n        |:------|------:|\n        | A     |     4 |", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_1275-1325"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 1310, "start_line_no": 1285, "end_line_no": 1335, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        |     0 |     5 |\n        |     1 |     6 |\n        \"\"\"\n        return _wrap(shuffle(self._data, seed))\n\n    def sort(self, columns: LazyColumns, descending: bool = False) -> DataFrame:\n        \"\"\"Sort rows by specific columns\n\n        Examples:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [\"Z\", \"X\", \"A\", \"A\"], \"bar\": [2, -2, 4, -4]})\n        ```\n        | foo   |   bar |\n        |:------|------:|\n        | Z     |     2 |\n        | X     |    -2 |\n        | A     |     4 |\n        | A     |    -4 |\n\n        Single column:\n\n        ```python\n        df.sort(\"bar\")\n        ```\n        | foo   |   bar |\n        |:------|------:|\n        | A     |    -4 |\n        | X     |    -2 |\n        | Z     |     2 |\n        | A     |     4 |\n\n        Descending order:\n\n        ```python\n        df.sort(\"bar\", descending=True)\n        ```\n        | foo   |   bar |\n        |:------|------:|\n        | A     |     4 |\n        | Z     |     2 |\n        | X     |    -2 |\n        | A     |    -4 |\n\n        Multiple columns:\n\n        ```python\n        df.sort([\"foo\", \"bar\"], descending=False)\n        ```\n        | foo   |   bar |", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_1285-1335"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 1320, "start_line_no": 1295, "end_line_no": 1345, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        ```python\n        df = rf.DataFrame({\"foo\": [\"Z\", \"X\", \"A\", \"A\"], \"bar\": [2, -2, 4, -4]})\n        ```\n        | foo   |   bar |\n        |:------|------:|\n        | Z     |     2 |\n        | X     |    -2 |\n        | A     |     4 |\n        | A     |    -4 |\n\n        Single column:\n\n        ```python\n        df.sort(\"bar\")\n        ```\n        | foo   |   bar |\n        |:------|------:|\n        | A     |    -4 |\n        | X     |    -2 |\n        | Z     |     2 |\n        | A     |     4 |\n\n        Descending order:\n\n        ```python\n        df.sort(\"bar\", descending=True)\n        ```\n        | foo   |   bar |\n        |:------|------:|\n        | A     |     4 |\n        | Z     |     2 |\n        | X     |    -2 |\n        | A     |    -4 |\n\n        Multiple columns:\n\n        ```python\n        df.sort([\"foo\", \"bar\"], descending=False)\n        ```\n        | foo   |   bar |\n        |:------|------:|\n        | A     |    -4 |\n        | A     |     4 |\n        | X     |    -2 |\n        | Z     |     2 |\n        \"\"\"\n        return _wrap(sort(self._data, columns, descending))\n\n    def split(\n        self, column: Column, into: Columns, sep: str, drop: bool = True", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_1295-1345"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 1330, "start_line_no": 1305, "end_line_no": 1355, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        Single column:\n\n        ```python\n        df.sort(\"bar\")\n        ```\n        | foo   |   bar |\n        |:------|------:|\n        | A     |    -4 |\n        | X     |    -2 |\n        | Z     |     2 |\n        | A     |     4 |\n\n        Descending order:\n\n        ```python\n        df.sort(\"bar\", descending=True)\n        ```\n        | foo   |   bar |\n        |:------|------:|\n        | A     |     4 |\n        | Z     |     2 |\n        | X     |    -2 |\n        | A     |    -4 |\n\n        Multiple columns:\n\n        ```python\n        df.sort([\"foo\", \"bar\"], descending=False)\n        ```\n        | foo   |   bar |\n        |:------|------:|\n        | A     |    -4 |\n        | A     |     4 |\n        | X     |    -2 |\n        | Z     |     2 |\n        \"\"\"\n        return _wrap(sort(self._data, columns, descending))\n\n    def split(\n        self, column: Column, into: Columns, sep: str, drop: bool = True\n    ) -> DataFrame:\n        \"\"\"Split a single column into multiple columns (opposite of `combine`)\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [\"A::1\", \"B::2\", \"C:3\"]})\n        ```\n        | foo   |\n        |:------|", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_1305-1355"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 1340, "start_line_no": 1315, "end_line_no": 1365, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        | A     |     4 |\n\n        Descending order:\n\n        ```python\n        df.sort(\"bar\", descending=True)\n        ```\n        | foo   |   bar |\n        |:------|------:|\n        | A     |     4 |\n        | Z     |     2 |\n        | X     |    -2 |\n        | A     |    -4 |\n\n        Multiple columns:\n\n        ```python\n        df.sort([\"foo\", \"bar\"], descending=False)\n        ```\n        | foo   |   bar |\n        |:------|------:|\n        | A     |    -4 |\n        | A     |     4 |\n        | X     |    -2 |\n        | Z     |     2 |\n        \"\"\"\n        return _wrap(sort(self._data, columns, descending))\n\n    def split(\n        self, column: Column, into: Columns, sep: str, drop: bool = True\n    ) -> DataFrame:\n        \"\"\"Split a single column into multiple columns (opposite of `combine`)\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [\"A::1\", \"B::2\", \"C:3\"]})\n        ```\n        | foo   |\n        |:------|\n        | A::1  |\n        | B::2  |\n        | C:3   |\n\n        ```python\n        df.split(\"foo\", into=[\"foo\", \"bar\"], sep=\"::\", drop=True)\n        ```\n        | foo   |   bar |\n        |:------|------:|\n        | A     |     1 |", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_1315-1365"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 1350, "start_line_no": 1325, "end_line_no": 1375, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        | Z     |     2 |\n        | X     |    -2 |\n        | A     |    -4 |\n\n        Multiple columns:\n\n        ```python\n        df.sort([\"foo\", \"bar\"], descending=False)\n        ```\n        | foo   |   bar |\n        |:------|------:|\n        | A     |    -4 |\n        | A     |     4 |\n        | X     |    -2 |\n        | Z     |     2 |\n        \"\"\"\n        return _wrap(sort(self._data, columns, descending))\n\n    def split(\n        self, column: Column, into: Columns, sep: str, drop: bool = True\n    ) -> DataFrame:\n        \"\"\"Split a single column into multiple columns (opposite of `combine`)\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [\"A::1\", \"B::2\", \"C:3\"]})\n        ```\n        | foo   |\n        |:------|\n        | A::1  |\n        | B::2  |\n        | C:3   |\n\n        ```python\n        df.split(\"foo\", into=[\"foo\", \"bar\"], sep=\"::\", drop=True)\n        ```\n        | foo   |   bar |\n        |:------|------:|\n        | A     |     1 |\n        | B     |     2 |\n        | C:3   |       |\n        \"\"\"\n        return _wrap(split(self._data, column, into, sep, drop))\n\n    def spread(self, column: Column, using: Column) -> DataFrame:\n        \"\"\"Spread rows into columns (opposite of `gather`)\n\n        Example:\n", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_1325-1375"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 1360, "start_line_no": 1335, "end_line_no": 1385, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        |:------|------:|\n        | A     |    -4 |\n        | A     |     4 |\n        | X     |    -2 |\n        | Z     |     2 |\n        \"\"\"\n        return _wrap(sort(self._data, columns, descending))\n\n    def split(\n        self, column: Column, into: Columns, sep: str, drop: bool = True\n    ) -> DataFrame:\n        \"\"\"Split a single column into multiple columns (opposite of `combine`)\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [\"A::1\", \"B::2\", \"C:3\"]})\n        ```\n        | foo   |\n        |:------|\n        | A::1  |\n        | B::2  |\n        | C:3   |\n\n        ```python\n        df.split(\"foo\", into=[\"foo\", \"bar\"], sep=\"::\", drop=True)\n        ```\n        | foo   |   bar |\n        |:------|------:|\n        | A     |     1 |\n        | B     |     2 |\n        | C:3   |       |\n        \"\"\"\n        return _wrap(split(self._data, column, into, sep, drop))\n\n    def spread(self, column: Column, using: Column) -> DataFrame:\n        \"\"\"Spread rows into columns (opposite of `gather`)\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [\"A\", \"A\", \"A\", \"B\", \"B\", \"B\", \"B\"], \"bar\": [1, 2, 3, 4, 5, 6, 7]})\n        ```\n        | foo   |   bar |\n        |:------|------:|\n        | A     |     1 |\n        | A     |     2 |\n        | A     |     3 |\n        | B     |     4 |\n        | B     |     5 |", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_1335-1385"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 1370, "start_line_no": 1345, "end_line_no": 1395, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "    ) -> DataFrame:\n        \"\"\"Split a single column into multiple columns (opposite of `combine`)\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [\"A::1\", \"B::2\", \"C:3\"]})\n        ```\n        | foo   |\n        |:------|\n        | A::1  |\n        | B::2  |\n        | C:3   |\n\n        ```python\n        df.split(\"foo\", into=[\"foo\", \"bar\"], sep=\"::\", drop=True)\n        ```\n        | foo   |   bar |\n        |:------|------:|\n        | A     |     1 |\n        | B     |     2 |\n        | C:3   |       |\n        \"\"\"\n        return _wrap(split(self._data, column, into, sep, drop))\n\n    def spread(self, column: Column, using: Column) -> DataFrame:\n        \"\"\"Spread rows into columns (opposite of `gather`)\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [\"A\", \"A\", \"A\", \"B\", \"B\", \"B\", \"B\"], \"bar\": [1, 2, 3, 4, 5, 6, 7]})\n        ```\n        | foo   |   bar |\n        |:------|------:|\n        | A     |     1 |\n        | A     |     2 |\n        | A     |     3 |\n        | B     |     4 |\n        | B     |     5 |\n        | B     |     6 |\n        | B     |     7 |\n\n        ```python\n        df.spread(\"foo\", using=\"bar\")\n        ```\n        |   A |   B |\n        |----:|----:|\n        |   1 |   4 |\n        |   2 |   5 |", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_1345-1395"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 1380, "start_line_no": 1355, "end_line_no": 1405, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        | A::1  |\n        | B::2  |\n        | C:3   |\n\n        ```python\n        df.split(\"foo\", into=[\"foo\", \"bar\"], sep=\"::\", drop=True)\n        ```\n        | foo   |   bar |\n        |:------|------:|\n        | A     |     1 |\n        | B     |     2 |\n        | C:3   |       |\n        \"\"\"\n        return _wrap(split(self._data, column, into, sep, drop))\n\n    def spread(self, column: Column, using: Column) -> DataFrame:\n        \"\"\"Spread rows into columns (opposite of `gather`)\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [\"A\", \"A\", \"A\", \"B\", \"B\", \"B\", \"B\"], \"bar\": [1, 2, 3, 4, 5, 6, 7]})\n        ```\n        | foo   |   bar |\n        |:------|------:|\n        | A     |     1 |\n        | A     |     2 |\n        | A     |     3 |\n        | B     |     4 |\n        | B     |     5 |\n        | B     |     6 |\n        | B     |     7 |\n\n        ```python\n        df.spread(\"foo\", using=\"bar\")\n        ```\n        |   A |   B |\n        |----:|----:|\n        |   1 |   4 |\n        |   2 |   5 |\n        |   3 |   6 |\n        | nan |   7 |\n        \"\"\"\n        return _wrap(spread(self._data, column, using))\n\n    def unpack(self, column: Column, sep: str) -> DataFrame:\n        \"\"\"'Explode' concatenated row values into multiple rows (opposite of `pack`)\n\n        Example:\n", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_1355-1405"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 1390, "start_line_no": 1365, "end_line_no": 1415, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        | B     |     2 |\n        | C:3   |       |\n        \"\"\"\n        return _wrap(split(self._data, column, into, sep, drop))\n\n    def spread(self, column: Column, using: Column) -> DataFrame:\n        \"\"\"Spread rows into columns (opposite of `gather`)\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [\"A\", \"A\", \"A\", \"B\", \"B\", \"B\", \"B\"], \"bar\": [1, 2, 3, 4, 5, 6, 7]})\n        ```\n        | foo   |   bar |\n        |:------|------:|\n        | A     |     1 |\n        | A     |     2 |\n        | A     |     3 |\n        | B     |     4 |\n        | B     |     5 |\n        | B     |     6 |\n        | B     |     7 |\n\n        ```python\n        df.spread(\"foo\", using=\"bar\")\n        ```\n        |   A |   B |\n        |----:|----:|\n        |   1 |   4 |\n        |   2 |   5 |\n        |   3 |   6 |\n        | nan |   7 |\n        \"\"\"\n        return _wrap(spread(self._data, column, using))\n\n    def unpack(self, column: Column, sep: str) -> DataFrame:\n        \"\"\"'Explode' concatenated row values into multiple rows (opposite of `pack`)\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\n            \"foo\": [1, 2, 3, 4],\n            \"bar\": [\"A:B\", \"B:C:D\", \"D:E\", \"F\"]\n        })\n        ```\n        |   foo | bar   |\n        |------:|:------|\n        |     1 | A:B   |\n        |     2 | B:C:D |", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_1365-1415"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 1400, "start_line_no": 1375, "end_line_no": 1425, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        ```python\n        df = rf.DataFrame({\"foo\": [\"A\", \"A\", \"A\", \"B\", \"B\", \"B\", \"B\"], \"bar\": [1, 2, 3, 4, 5, 6, 7]})\n        ```\n        | foo   |   bar |\n        |:------|------:|\n        | A     |     1 |\n        | A     |     2 |\n        | A     |     3 |\n        | B     |     4 |\n        | B     |     5 |\n        | B     |     6 |\n        | B     |     7 |\n\n        ```python\n        df.spread(\"foo\", using=\"bar\")\n        ```\n        |   A |   B |\n        |----:|----:|\n        |   1 |   4 |\n        |   2 |   5 |\n        |   3 |   6 |\n        | nan |   7 |\n        \"\"\"\n        return _wrap(spread(self._data, column, using))\n\n    def unpack(self, column: Column, sep: str) -> DataFrame:\n        \"\"\"'Explode' concatenated row values into multiple rows (opposite of `pack`)\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\n            \"foo\": [1, 2, 3, 4],\n            \"bar\": [\"A:B\", \"B:C:D\", \"D:E\", \"F\"]\n        })\n        ```\n        |   foo | bar   |\n        |------:|:------|\n        |     1 | A:B   |\n        |     2 | B:C:D |\n        |     3 | D:E   |\n        |     4 | F     |\n\n        ```python\n        df.unpack(\"bar\", sep=\":\")\n        ```\n        |   foo | bar   |\n        |------:|:------|\n        |     1 | A     |\n        |     1 | B     |", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_1375-1425"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 1410, "start_line_no": 1385, "end_line_no": 1433, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        | B     |     6 |\n        | B     |     7 |\n\n        ```python\n        df.spread(\"foo\", using=\"bar\")\n        ```\n        |   A |   B |\n        |----:|----:|\n        |   1 |   4 |\n        |   2 |   5 |\n        |   3 |   6 |\n        | nan |   7 |\n        \"\"\"\n        return _wrap(spread(self._data, column, using))\n\n    def unpack(self, column: Column, sep: str) -> DataFrame:\n        \"\"\"'Explode' concatenated row values into multiple rows (opposite of `pack`)\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\n            \"foo\": [1, 2, 3, 4],\n            \"bar\": [\"A:B\", \"B:C:D\", \"D:E\", \"F\"]\n        })\n        ```\n        |   foo | bar   |\n        |------:|:------|\n        |     1 | A:B   |\n        |     2 | B:C:D |\n        |     3 | D:E   |\n        |     4 | F     |\n\n        ```python\n        df.unpack(\"bar\", sep=\":\")\n        ```\n        |   foo | bar   |\n        |------:|:------|\n        |     1 | A     |\n        |     1 | B     |\n        |     2 | B     |\n        |     2 | C     |\n        |     2 | D     |\n        |     3 | D     |\n        |     3 | E     |\n        |     4 | F     |\n        \"\"\"\n        return _wrap(unpack(self._data, column, sep))", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_1385-1433"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 1420, "start_line_no": 1395, "end_line_no": 1433, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        |   3 |   6 |\n        | nan |   7 |\n        \"\"\"\n        return _wrap(spread(self._data, column, using))\n\n    def unpack(self, column: Column, sep: str) -> DataFrame:\n        \"\"\"'Explode' concatenated row values into multiple rows (opposite of `pack`)\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\n            \"foo\": [1, 2, 3, 4],\n            \"bar\": [\"A:B\", \"B:C:D\", \"D:E\", \"F\"]\n        })\n        ```\n        |   foo | bar   |\n        |------:|:------|\n        |     1 | A:B   |\n        |     2 | B:C:D |\n        |     3 | D:E   |\n        |     4 | F     |\n\n        ```python\n        df.unpack(\"bar\", sep=\":\")\n        ```\n        |   foo | bar   |\n        |------:|:------|\n        |     1 | A     |\n        |     1 | B     |\n        |     2 | B     |\n        |     2 | C     |\n        |     2 | D     |\n        |     3 | D     |\n        |     3 | E     |\n        |     4 | F     |\n        \"\"\"\n        return _wrap(unpack(self._data, column, sep))", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_1395-1433"}
{"title": "maxhumber_redframes-redframes-core.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "core.py"], "line_no": 1430, "start_line_no": 1405, "end_line_no": 1433, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        ```python\n        df = rf.DataFrame({\n            \"foo\": [1, 2, 3, 4],\n            \"bar\": [\"A:B\", \"B:C:D\", \"D:E\", \"F\"]\n        })\n        ```\n        |   foo | bar   |\n        |------:|:------|\n        |     1 | A:B   |\n        |     2 | B:C:D |\n        |     3 | D:E   |\n        |     4 | F     |\n\n        ```python\n        df.unpack(\"bar\", sep=\":\")\n        ```\n        |   foo | bar   |\n        |------:|:------|\n        |     1 | A     |\n        |     1 | B     |\n        |     2 | B     |\n        |     2 | C     |\n        |     2 | D     |\n        |     3 | D     |\n        |     3 | E     |\n        |     4 | F     |\n        \"\"\"\n        return _wrap(unpack(self._data, column, sep))", "id": "maxhumber_redframes_maxhumber_redframes-redframes-core.py_1405-1433"}
{"title": "maxhumber_redframes-redframes-stat.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "stat.py"], "line_no": 0, "start_line_no": 0, "end_line_no": 11, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}, {"fpath_tuple": ["maxhumber_redframes", "redframes", "stat.py"], "line_no": 10, "start_line_no": 0, "end_line_no": 11, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "\"\"\"Common summary functions/statistics\"\"\"\n\nimport numpy as np  # pyright: ignore[reportMissingImports]\n\ncount = len\nmean = np.mean\nsum = np.sum\nmax = np.max\nmedian = np.median\nmin = np.min\nstd = np.std", "id": "maxhumber_redframes_maxhumber_redframes-redframes-stat.py_0-11"}
{"title": "maxhumber_redframes-redframes-types.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "types.py"], "line_no": 0, "start_line_no": 0, "end_line_no": 25, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "from __future__ import annotations\n\nimport datetime\nfrom typing import Any, Callable, Literal, Union\n\nimport numpy as np  # pyright: ignore[reportMissingImports]\nimport pandas as pd  # pyright: ignore[reportMissingImports]\nimport pandas.core.groupby.generic as pg  # pyright: ignore[reportMissingImports]\n\nValue = Any\nValues = list[Value]\nOldValue = Value\nNewValue = Value\nColumn = str\nColumns = list[Column]\nLazyColumns = Union[Column, Columns]\nOldColumn = Column\nNewColumn = Column\nDirection = Literal[\"up\", \"down\"]\nFunc = Callable[..., Any]\nJoin = Literal[\"left\", \"right\", \"inner\", \"full\"]\nNumpyArray = np.ndarray\nNumpyType = np.dtype\nPandasDataFrame = pd.DataFrame\nPandasGroupedFrame = pg.DataFrameGroupBy", "id": "maxhumber_redframes_maxhumber_redframes-redframes-types.py_0-25"}
{"title": "maxhumber_redframes-redframes-types.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "types.py"], "line_no": 10, "start_line_no": 0, "end_line_no": 28, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}, {"fpath_tuple": ["maxhumber_redframes", "redframes", "types.py"], "line_no": 20, "start_line_no": 0, "end_line_no": 28, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "from __future__ import annotations\n\nimport datetime\nfrom typing import Any, Callable, Literal, Union\n\nimport numpy as np  # pyright: ignore[reportMissingImports]\nimport pandas as pd  # pyright: ignore[reportMissingImports]\nimport pandas.core.groupby.generic as pg  # pyright: ignore[reportMissingImports]\n\nValue = Any\nValues = list[Value]\nOldValue = Value\nNewValue = Value\nColumn = str\nColumns = list[Column]\nLazyColumns = Union[Column, Columns]\nOldColumn = Column\nNewColumn = Column\nDirection = Literal[\"up\", \"down\"]\nFunc = Callable[..., Any]\nJoin = Literal[\"left\", \"right\", \"inner\", \"full\"]\nNumpyArray = np.ndarray\nNumpyType = np.dtype\nPandasDataFrame = pd.DataFrame\nPandasGroupedFrame = pg.DataFrameGroupBy\nPandasIndex = pd.Index\nPandasRangeIndex = pd.RangeIndex\nDateTime = datetime.datetime", "id": "maxhumber_redframes_maxhumber_redframes-redframes-types.py_0-28"}
{"title": "maxhumber_redframes-redframes-version.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "version.py"], "line_no": 0, "start_line_no": 0, "end_line_no": 1, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "__version__ = \"1.4\"", "id": "maxhumber_redframes_maxhumber_redframes-redframes-version.py_0-1"}
{"title": "maxhumber_redframes-redframes-__init__.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "__init__.py"], "line_no": 0, "start_line_no": 0, "end_line_no": 4, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "from . import stat\nfrom .core import DataFrame\nfrom .io import load, save, unwrap, wrap\nfrom .version import __version__", "id": "maxhumber_redframes_maxhumber_redframes-redframes-__init__.py_0-4"}
{"title": "maxhumber_redframes-redframes-io-convert.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "io", "convert.py"], "line_no": 0, "start_line_no": 0, "end_line_no": 25, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "from __future__ import annotations\n\nfrom ..checks import _check_columns, _check_index, _check_type\nfrom ..core import DataFrame\nfrom ..types import PandasDataFrame\n\n\ndef unwrap(rdf: DataFrame) -> PandasDataFrame:\n    \"\"\"Convert a rf.DataFrame into a pd.DataFrame (opposite of `wrap`)\n\n    Example:\n\n    ```python\n    rdf = rf.DataFrame({\"foo\": range(10)})\n    pdf = rf.unwrap(rdf)\n    ```\n    \"\"\"\n    _check_type(rdf, DataFrame)\n    return rdf._data.copy()\n\n\ndef wrap(pdf: PandasDataFrame) -> DataFrame:\n    \"\"\"Convert a pd.DataFrame into a rf.DataFrame (opposite of `unwrap`)\n\n    Example:", "id": "maxhumber_redframes_maxhumber_redframes-redframes-io-convert.py_0-25"}
{"title": "maxhumber_redframes-redframes-io-convert.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "io", "convert.py"], "line_no": 10, "start_line_no": 0, "end_line_no": 35, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "from __future__ import annotations\n\nfrom ..checks import _check_columns, _check_index, _check_type\nfrom ..core import DataFrame\nfrom ..types import PandasDataFrame\n\n\ndef unwrap(rdf: DataFrame) -> PandasDataFrame:\n    \"\"\"Convert a rf.DataFrame into a pd.DataFrame (opposite of `wrap`)\n\n    Example:\n\n    ```python\n    rdf = rf.DataFrame({\"foo\": range(10)})\n    pdf = rf.unwrap(rdf)\n    ```\n    \"\"\"\n    _check_type(rdf, DataFrame)\n    return rdf._data.copy()\n\n\ndef wrap(pdf: PandasDataFrame) -> DataFrame:\n    \"\"\"Convert a pd.DataFrame into a rf.DataFrame (opposite of `unwrap`)\n\n    Example:\n\n    ```python\n    pdf = pd.DataFrame({\"foo\": range(10)})\n    rdf = rf.wrap(pdf)\n    ```\n    \"\"\"\n    _check_type(pdf, PandasDataFrame)\n    _check_index(pdf)\n    _check_columns(pdf)\n    rdf = DataFrame()", "id": "maxhumber_redframes_maxhumber_redframes-redframes-io-convert.py_0-35"}
{"title": "maxhumber_redframes-redframes-io-convert.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "io", "convert.py"], "line_no": 20, "start_line_no": 0, "end_line_no": 45, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "from __future__ import annotations\n\nfrom ..checks import _check_columns, _check_index, _check_type\nfrom ..core import DataFrame\nfrom ..types import PandasDataFrame\n\n\ndef unwrap(rdf: DataFrame) -> PandasDataFrame:\n    \"\"\"Convert a rf.DataFrame into a pd.DataFrame (opposite of `wrap`)\n\n    Example:\n\n    ```python\n    rdf = rf.DataFrame({\"foo\": range(10)})\n    pdf = rf.unwrap(rdf)\n    ```\n    \"\"\"\n    _check_type(rdf, DataFrame)\n    return rdf._data.copy()\n\n\ndef wrap(pdf: PandasDataFrame) -> DataFrame:\n    \"\"\"Convert a pd.DataFrame into a rf.DataFrame (opposite of `unwrap`)\n\n    Example:\n\n    ```python\n    pdf = pd.DataFrame({\"foo\": range(10)})\n    rdf = rf.wrap(pdf)\n    ```\n    \"\"\"\n    _check_type(pdf, PandasDataFrame)\n    _check_index(pdf)\n    _check_columns(pdf)\n    rdf = DataFrame()\n    rdf._data = pdf.copy()\n    return rdf\n\n\ndef convert(df: DataFrame | PandasDataFrame) -> PandasDataFrame | DataFrame:\n    \"\"\"Convert a rf.DataFrame into a pd.DataFrame (and/or vice versa)\n\n    Example:\n\n    ```python", "id": "maxhumber_redframes_maxhumber_redframes-redframes-io-convert.py_0-45"}
{"title": "maxhumber_redframes-redframes-io-convert.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "io", "convert.py"], "line_no": 30, "start_line_no": 5, "end_line_no": 55, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "\n\ndef unwrap(rdf: DataFrame) -> PandasDataFrame:\n    \"\"\"Convert a rf.DataFrame into a pd.DataFrame (opposite of `wrap`)\n\n    Example:\n\n    ```python\n    rdf = rf.DataFrame({\"foo\": range(10)})\n    pdf = rf.unwrap(rdf)\n    ```\n    \"\"\"\n    _check_type(rdf, DataFrame)\n    return rdf._data.copy()\n\n\ndef wrap(pdf: PandasDataFrame) -> DataFrame:\n    \"\"\"Convert a pd.DataFrame into a rf.DataFrame (opposite of `unwrap`)\n\n    Example:\n\n    ```python\n    pdf = pd.DataFrame({\"foo\": range(10)})\n    rdf = rf.wrap(pdf)\n    ```\n    \"\"\"\n    _check_type(pdf, PandasDataFrame)\n    _check_index(pdf)\n    _check_columns(pdf)\n    rdf = DataFrame()\n    rdf._data = pdf.copy()\n    return rdf\n\n\ndef convert(df: DataFrame | PandasDataFrame) -> PandasDataFrame | DataFrame:\n    \"\"\"Convert a rf.DataFrame into a pd.DataFrame (and/or vice versa)\n\n    Example:\n\n    ```python\n    redf = rf.DataFrame({\"foo\": range(10)})\n    padf = rf.convert(redf) # now a pd.DataFrame\n    redf = rf.convert(padf) # now a rf.DataFrame\n    ```\n    \"\"\"\n    if isinstance(df, DataFrame):\n        return unwrap(df)\n    if isinstance(df, PandasDataFrame):\n        return wrap(df)\n    raise TypeError(\"must be rf.DataFrame | pd.DataFrame\")", "id": "maxhumber_redframes_maxhumber_redframes-redframes-io-convert.py_5-55"}
{"title": "maxhumber_redframes-redframes-io-convert.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "io", "convert.py"], "line_no": 40, "start_line_no": 15, "end_line_no": 55, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "    ```\n    \"\"\"\n    _check_type(rdf, DataFrame)\n    return rdf._data.copy()\n\n\ndef wrap(pdf: PandasDataFrame) -> DataFrame:\n    \"\"\"Convert a pd.DataFrame into a rf.DataFrame (opposite of `unwrap`)\n\n    Example:\n\n    ```python\n    pdf = pd.DataFrame({\"foo\": range(10)})\n    rdf = rf.wrap(pdf)\n    ```\n    \"\"\"\n    _check_type(pdf, PandasDataFrame)\n    _check_index(pdf)\n    _check_columns(pdf)\n    rdf = DataFrame()\n    rdf._data = pdf.copy()\n    return rdf\n\n\ndef convert(df: DataFrame | PandasDataFrame) -> PandasDataFrame | DataFrame:\n    \"\"\"Convert a rf.DataFrame into a pd.DataFrame (and/or vice versa)\n\n    Example:\n\n    ```python\n    redf = rf.DataFrame({\"foo\": range(10)})\n    padf = rf.convert(redf) # now a pd.DataFrame\n    redf = rf.convert(padf) # now a rf.DataFrame\n    ```\n    \"\"\"\n    if isinstance(df, DataFrame):\n        return unwrap(df)\n    if isinstance(df, PandasDataFrame):\n        return wrap(df)\n    raise TypeError(\"must be rf.DataFrame | pd.DataFrame\")", "id": "maxhumber_redframes_maxhumber_redframes-redframes-io-convert.py_15-55"}
{"title": "maxhumber_redframes-redframes-io-convert.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "io", "convert.py"], "line_no": 50, "start_line_no": 25, "end_line_no": 55, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "\n    ```python\n    pdf = pd.DataFrame({\"foo\": range(10)})\n    rdf = rf.wrap(pdf)\n    ```\n    \"\"\"\n    _check_type(pdf, PandasDataFrame)\n    _check_index(pdf)\n    _check_columns(pdf)\n    rdf = DataFrame()\n    rdf._data = pdf.copy()\n    return rdf\n\n\ndef convert(df: DataFrame | PandasDataFrame) -> PandasDataFrame | DataFrame:\n    \"\"\"Convert a rf.DataFrame into a pd.DataFrame (and/or vice versa)\n\n    Example:\n\n    ```python\n    redf = rf.DataFrame({\"foo\": range(10)})\n    padf = rf.convert(redf) # now a pd.DataFrame\n    redf = rf.convert(padf) # now a rf.DataFrame\n    ```\n    \"\"\"\n    if isinstance(df, DataFrame):\n        return unwrap(df)\n    if isinstance(df, PandasDataFrame):\n        return wrap(df)\n    raise TypeError(\"must be rf.DataFrame | pd.DataFrame\")", "id": "maxhumber_redframes_maxhumber_redframes-redframes-io-convert.py_25-55"}
{"title": "maxhumber_redframes-redframes-io-load.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "io", "load.py"], "line_no": 0, "start_line_no": 0, "end_line_no": 23, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}, {"fpath_tuple": ["maxhumber_redframes", "redframes", "io", "load.py"], "line_no": 10, "start_line_no": 0, "end_line_no": 23, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}, {"fpath_tuple": ["maxhumber_redframes", "redframes", "io", "load.py"], "line_no": 20, "start_line_no": 0, "end_line_no": 23, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "import pandas as pd  # pyright: ignore[reportMissingImports]\n\nfrom redframes.types import PandasDataFrame\n\nfrom ..checks import _check_columns, _check_file, _check_index, _check_type\nfrom ..core import DataFrame, _wrap\n\n\ndef load(path: str, **kwargs) -> DataFrame:\n    \"\"\"Load a csv file into a rf.DataFrame (opposite of `save`)\n\n    Example:\n\n    ```python\n    df = rf.load(\"example.csv\")\n    ```\n    \"\"\"\n    _check_type(path, str)\n    _check_file(path)\n    data: PandasDataFrame = pd.read_csv(path, **kwargs)  # type: ignore\n    _check_index(data)\n    _check_columns(data)\n    return _wrap(data)", "id": "maxhumber_redframes_maxhumber_redframes-redframes-io-load.py_0-23"}
{"title": "maxhumber_redframes-redframes-io-save.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "io", "save.py"], "line_no": 0, "start_line_no": 0, "end_line_no": 17, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}, {"fpath_tuple": ["maxhumber_redframes", "redframes", "io", "save.py"], "line_no": 10, "start_line_no": 0, "end_line_no": 17, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "from ..checks import _check_file, _check_type\nfrom ..core import DataFrame\n\n\ndef save(df: DataFrame, path: str, **kwargs) -> None:\n    \"\"\"Save a rf.DataFrame to a csv file (opposite of `load`)\n\n    Example:\n\n    ```python\n    rf.save(df, \"example.csv\")\n    ```\n    \"\"\"\n    _check_type(df, DataFrame)\n    _check_type(path, str)\n    _check_file(path)\n    df._data.to_csv(path, index=False, **kwargs)", "id": "maxhumber_redframes_maxhumber_redframes-redframes-io-save.py_0-17"}
{"title": "maxhumber_redframes-redframes-io-__init__.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "io", "__init__.py"], "line_no": 0, "start_line_no": 0, "end_line_no": 3, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "from .convert import unwrap, wrap\nfrom .load import load\nfrom .save import save", "id": "maxhumber_redframes_maxhumber_redframes-redframes-io-__init__.py_0-3"}
{"title": "maxhumber_redframes-redframes-verbs-accumulate.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "verbs", "accumulate.py"], "line_no": 0, "start_line_no": 0, "end_line_no": 25, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}, {"fpath_tuple": ["maxhumber_redframes", "redframes", "verbs", "accumulate.py"], "line_no": 10, "start_line_no": 0, "end_line_no": 25, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}, {"fpath_tuple": ["maxhumber_redframes", "redframes", "verbs", "accumulate.py"], "line_no": 20, "start_line_no": 0, "end_line_no": 25, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "from __future__ import annotations\n\nimport warnings\n\nfrom ..checks import _check_type\nfrom ..types import Column, PandasDataFrame, PandasGroupedFrame\n\n\ndef accumulate(\n    df: PandasDataFrame | PandasGroupedFrame, column: Column, into: Column\n) -> PandasDataFrame:\n    _check_type(column, str)\n    _check_type(into, str)\n    if isinstance(df, PandasDataFrame):\n        into_is_not_column = into != column\n        into_is_in_df_columns = into in df.columns\n        if into_is_not_column and into_is_in_df_columns:\n            message = f\"overwriting existing column '{into}'\"\n            warnings.warn(message)\n        df = df.copy()\n    result = df[column].cumsum()\n    if isinstance(df, PandasGroupedFrame):\n        df = df.obj.copy()  # type: ignore\n    df[into] = result  # type: ignore\n    return df  # type: ignore", "id": "maxhumber_redframes_maxhumber_redframes-redframes-verbs-accumulate.py_0-25"}
{"title": "maxhumber_redframes-redframes-verbs-append.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "verbs", "append.py"], "line_no": 0, "start_line_no": 0, "end_line_no": 9, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "import pandas as pd  # pyright: ignore[reportMissingImports]\n\nfrom ..types import PandasDataFrame\n\n\ndef append(top: PandasDataFrame, bottom: PandasDataFrame) -> PandasDataFrame:\n    df = pd.concat([top, bottom])\n    df = df.reset_index(drop=True)\n    return df", "id": "maxhumber_redframes_maxhumber_redframes-redframes-verbs-append.py_0-9"}
{"title": "maxhumber_redframes-redframes-verbs-combine.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "verbs", "combine.py"], "line_no": 0, "start_line_no": 0, "end_line_no": 25, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "from __future__ import annotations\n\nimport warnings\n\nfrom ..checks import _check_type\nfrom ..types import Column, Columns, PandasDataFrame\n\n\ndef combine(\n    df: PandasDataFrame, columns: Columns, into: Column, sep: str, drop: bool = True\n) -> PandasDataFrame:\n    _check_type(columns, list)\n    _check_type(into, str)\n    _check_type(sep, str)\n    _check_type(drop, bool)\n    into_is_in_columns = into in columns\n    into_is_not_in_columns = not into_is_in_columns\n    into_is_in_df_columns = into in df.columns\n    if into_is_not_in_columns and into_is_in_df_columns:\n        message = f\"overwriting existing column '{into}'\"\n        warnings.warn(message)\n    df = df.copy()\n    new = df[columns].apply(lambda row: sep.join(row.values.astype(str)), axis=1)\n    if drop:\n        df = df.drop(columns, axis=1)", "id": "maxhumber_redframes_maxhumber_redframes-redframes-verbs-combine.py_0-25"}
{"title": "maxhumber_redframes-redframes-verbs-combine.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "verbs", "combine.py"], "line_no": 10, "start_line_no": 0, "end_line_no": 27, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}, {"fpath_tuple": ["maxhumber_redframes", "redframes", "verbs", "combine.py"], "line_no": 20, "start_line_no": 0, "end_line_no": 27, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "from __future__ import annotations\n\nimport warnings\n\nfrom ..checks import _check_type\nfrom ..types import Column, Columns, PandasDataFrame\n\n\ndef combine(\n    df: PandasDataFrame, columns: Columns, into: Column, sep: str, drop: bool = True\n) -> PandasDataFrame:\n    _check_type(columns, list)\n    _check_type(into, str)\n    _check_type(sep, str)\n    _check_type(drop, bool)\n    into_is_in_columns = into in columns\n    into_is_not_in_columns = not into_is_in_columns\n    into_is_in_df_columns = into in df.columns\n    if into_is_not_in_columns and into_is_in_df_columns:\n        message = f\"overwriting existing column '{into}'\"\n        warnings.warn(message)\n    df = df.copy()\n    new = df[columns].apply(lambda row: sep.join(row.values.astype(str)), axis=1)\n    if drop:\n        df = df.drop(columns, axis=1)\n    df[into] = new\n    return df", "id": "maxhumber_redframes_maxhumber_redframes-redframes-verbs-combine.py_0-27"}
{"title": "maxhumber_redframes-redframes-verbs-cross.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "verbs", "cross.py"], "line_no": 0, "start_line_no": 0, "end_line_no": 17, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}, {"fpath_tuple": ["maxhumber_redframes", "redframes", "verbs", "cross.py"], "line_no": 10, "start_line_no": 0, "end_line_no": 17, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "from __future__ import annotations\n\nimport pandas as pd  # pyright: ignore[reportMissingImports]\n\nfrom ..checks import _check_type\nfrom ..types import PandasDataFrame\n\n\ndef cross(\n    lhs: PandasDataFrame,\n    rhs: PandasDataFrame,\n    postfix: tuple[str, str] = (\"_lhs\", \"_rhs\"),\n) -> PandasDataFrame:\n    _check_type(postfix, tuple)\n    df = pd.merge(lhs, rhs, how=\"cross\", suffixes=postfix)\n    df = df.reset_index(drop=True)\n    return df", "id": "maxhumber_redframes_maxhumber_redframes-redframes-verbs-cross.py_0-17"}
{"title": "maxhumber_redframes-redframes-verbs-dedupe.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "verbs", "dedupe.py"], "line_no": 0, "start_line_no": 0, "end_line_no": 12, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}, {"fpath_tuple": ["maxhumber_redframes", "redframes", "verbs", "dedupe.py"], "line_no": 10, "start_line_no": 0, "end_line_no": 12, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "from __future__ import annotations\n\nfrom ..checks import _check_keys, _check_type\nfrom ..types import LazyColumns, PandasDataFrame\n\n\ndef dedupe(df: PandasDataFrame, columns: LazyColumns | None = None) -> PandasDataFrame:\n    _check_type(columns, {list, str, None})\n    _check_keys(columns, df.columns)\n    df = df.drop_duplicates(subset=columns, keep=\"first\")\n    df = df.reset_index(drop=True)\n    return df", "id": "maxhumber_redframes_maxhumber_redframes-redframes-verbs-dedupe.py_0-12"}
{"title": "maxhumber_redframes-redframes-verbs-denix.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "verbs", "denix.py"], "line_no": 0, "start_line_no": 0, "end_line_no": 20, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}, {"fpath_tuple": ["maxhumber_redframes", "redframes", "verbs", "denix.py"], "line_no": 10, "start_line_no": 0, "end_line_no": 20, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "from __future__ import annotations\n\nfrom ..checks import _check_type\nfrom ..types import LazyColumns, PandasDataFrame\n\n\ndef denix(df: PandasDataFrame, columns: LazyColumns | None = None) -> PandasDataFrame:\n    _check_type(columns, {list, str, None})\n    columns = [columns] if isinstance(columns, str) else columns\n    if isinstance(columns, list):\n        bad_keys = set(columns).difference(df.columns)\n        if bad_keys:\n            if len(bad_keys) == 1:\n                message = f\"columns argument contains invalid key {bad_keys}\"\n            else:\n                message = f\"columns argument contains invalid keys {bad_keys}\"\n            raise KeyError(message)\n    df = df.dropna(subset=columns)\n    df = df.reset_index(drop=True)\n    return df", "id": "maxhumber_redframes_maxhumber_redframes-redframes-verbs-denix.py_0-20"}
{"title": "maxhumber_redframes-redframes-verbs-drop.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "verbs", "drop.py"], "line_no": 0, "start_line_no": 0, "end_line_no": 10, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "from __future__ import annotations\n\nfrom ..checks import _check_type\nfrom ..types import LazyColumns, PandasDataFrame\n\n\ndef drop(df: PandasDataFrame, columns: LazyColumns) -> PandasDataFrame:\n    _check_type(columns, {list, str})\n    df = df.drop(columns, axis=1)\n    return df", "id": "maxhumber_redframes_maxhumber_redframes-redframes-verbs-drop.py_0-10"}
{"title": "maxhumber_redframes-redframes-verbs-fill.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "verbs", "fill.py"], "line_no": 0, "start_line_no": 0, "end_line_no": 25, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "from __future__ import annotations\n\nfrom ..checks import _check_type\nfrom ..types import Direction, LazyColumns, PandasDataFrame, Value\n\n\ndef fill(\n    df: PandasDataFrame,\n    columns: LazyColumns | None = None,\n    direction: Direction | None = None,\n    constant: Value | None = None,\n) -> PandasDataFrame:\n    _check_type(columns, {list, str, None})\n    _check_type(direction, {str, None})\n    columns = [columns] if isinstance(columns, str) else columns\n    if (direction != None) and (constant != None):\n        raise ValueError(\"either direction OR constant must be None\")\n    if (direction == None) and (constant == None):\n        raise ValueError(\"either direction OR constant must not be None\")\n    if direction != None:\n        if not (direction in [\"down\", \"up\"]):\n            raise ValueError(\"must be one of {'down', 'up'}\")\n        method = {\"down\": \"ffill\", \"up\": \"bfill\"}.get(direction)\n        value = None\n    if constant != None:", "id": "maxhumber_redframes_maxhumber_redframes-redframes-verbs-fill.py_0-25"}
{"title": "maxhumber_redframes-redframes-verbs-fill.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "verbs", "fill.py"], "line_no": 10, "start_line_no": 0, "end_line_no": 33, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}, {"fpath_tuple": ["maxhumber_redframes", "redframes", "verbs", "fill.py"], "line_no": 20, "start_line_no": 0, "end_line_no": 33, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "from __future__ import annotations\n\nfrom ..checks import _check_type\nfrom ..types import Direction, LazyColumns, PandasDataFrame, Value\n\n\ndef fill(\n    df: PandasDataFrame,\n    columns: LazyColumns | None = None,\n    direction: Direction | None = None,\n    constant: Value | None = None,\n) -> PandasDataFrame:\n    _check_type(columns, {list, str, None})\n    _check_type(direction, {str, None})\n    columns = [columns] if isinstance(columns, str) else columns\n    if (direction != None) and (constant != None):\n        raise ValueError(\"either direction OR constant must be None\")\n    if (direction == None) and (constant == None):\n        raise ValueError(\"either direction OR constant must not be None\")\n    if direction != None:\n        if not (direction in [\"down\", \"up\"]):\n            raise ValueError(\"must be one of {'down', 'up'}\")\n        method = {\"down\": \"ffill\", \"up\": \"bfill\"}.get(direction)\n        value = None\n    if constant != None:\n        value = constant\n        method = None\n    df = df.copy()\n    if columns:\n        df[columns] = df[columns].fillna(value=value, method=method)  # type: ignore\n    else:\n        df = df.fillna(value=value, method=method)  # type: ignore\n    return df", "id": "maxhumber_redframes_maxhumber_redframes-redframes-verbs-fill.py_0-33"}
{"title": "maxhumber_redframes-redframes-verbs-fill.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "verbs", "fill.py"], "line_no": 30, "start_line_no": 5, "end_line_no": 33, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "\ndef fill(\n    df: PandasDataFrame,\n    columns: LazyColumns | None = None,\n    direction: Direction | None = None,\n    constant: Value | None = None,\n) -> PandasDataFrame:\n    _check_type(columns, {list, str, None})\n    _check_type(direction, {str, None})\n    columns = [columns] if isinstance(columns, str) else columns\n    if (direction != None) and (constant != None):\n        raise ValueError(\"either direction OR constant must be None\")\n    if (direction == None) and (constant == None):\n        raise ValueError(\"either direction OR constant must not be None\")\n    if direction != None:\n        if not (direction in [\"down\", \"up\"]):\n            raise ValueError(\"must be one of {'down', 'up'}\")\n        method = {\"down\": \"ffill\", \"up\": \"bfill\"}.get(direction)\n        value = None\n    if constant != None:\n        value = constant\n        method = None\n    df = df.copy()\n    if columns:\n        df[columns] = df[columns].fillna(value=value, method=method)  # type: ignore\n    else:\n        df = df.fillna(value=value, method=method)  # type: ignore\n    return df", "id": "maxhumber_redframes_maxhumber_redframes-redframes-verbs-fill.py_5-33"}
{"title": "maxhumber_redframes-redframes-verbs-filter.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "verbs", "filter.py"], "line_no": 0, "start_line_no": 0, "end_line_no": 9, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "from ..types import Func, PandasDataFrame\n\n\ndef filter(df: PandasDataFrame, func: Func) -> PandasDataFrame:\n    if not callable(func):\n        raise TypeError(\"must be Func\")\n    df = df.loc[func]  # type: ignore\n    df = df.reset_index(drop=True)\n    return df", "id": "maxhumber_redframes_maxhumber_redframes-redframes-verbs-filter.py_0-9"}
{"title": "maxhumber_redframes-redframes-verbs-gather.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "verbs", "gather.py"], "line_no": 0, "start_line_no": 0, "end_line_no": 25, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "from __future__ import annotations\n\nimport warnings\n\nimport pandas as pd  # pyright: ignore[reportMissingImports]\n\nfrom ..checks import _check_type\nfrom ..types import Column, Columns, LazyColumns, PandasDataFrame, PandasGroupedFrame\n\n\ndef _melt(\n    df: PandasDataFrame,\n    cols_to_keep: list[str],\n    cols_to_gather: list[str],\n    into: tuple[str, str],\n) -> PandasDataFrame:\n    df = pd.melt(\n        df,\n        id_vars=cols_to_keep,\n        value_vars=cols_to_gather,\n        var_name=into[0],\n        value_name=into[1],\n    )\n    df = df.dropna(subset=into[1])  # type: ignore\n    df = df.reset_index(drop=True)", "id": "maxhumber_redframes_maxhumber_redframes-redframes-verbs-gather.py_0-25"}
{"title": "maxhumber_redframes-redframes-verbs-gather.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "verbs", "gather.py"], "line_no": 10, "start_line_no": 0, "end_line_no": 35, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "from __future__ import annotations\n\nimport warnings\n\nimport pandas as pd  # pyright: ignore[reportMissingImports]\n\nfrom ..checks import _check_type\nfrom ..types import Column, Columns, LazyColumns, PandasDataFrame, PandasGroupedFrame\n\n\ndef _melt(\n    df: PandasDataFrame,\n    cols_to_keep: list[str],\n    cols_to_gather: list[str],\n    into: tuple[str, str],\n) -> PandasDataFrame:\n    df = pd.melt(\n        df,\n        id_vars=cols_to_keep,\n        value_vars=cols_to_gather,\n        var_name=into[0],\n        value_name=into[1],\n    )\n    df = df.dropna(subset=into[1])  # type: ignore\n    df = df.reset_index(drop=True)\n    return df\n\n\ndef _grouped_melt(df: PandasGroupedFrame, into: tuple[str, str]) -> PandasDataFrame:\n    cols_to_keep = df.grouper.names  # type: ignore\n    cols_to_gather = [col for col in df.obj.columns if col not in cols_to_keep]  # type: ignore\n    df = _melt(df.obj, cols_to_keep, cols_to_gather, into)  # type: ignore\n    return df\n\n", "id": "maxhumber_redframes_maxhumber_redframes-redframes-verbs-gather.py_0-35"}
{"title": "maxhumber_redframes-redframes-verbs-gather.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "verbs", "gather.py"], "line_no": 20, "start_line_no": 0, "end_line_no": 45, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "from __future__ import annotations\n\nimport warnings\n\nimport pandas as pd  # pyright: ignore[reportMissingImports]\n\nfrom ..checks import _check_type\nfrom ..types import Column, Columns, LazyColumns, PandasDataFrame, PandasGroupedFrame\n\n\ndef _melt(\n    df: PandasDataFrame,\n    cols_to_keep: list[str],\n    cols_to_gather: list[str],\n    into: tuple[str, str],\n) -> PandasDataFrame:\n    df = pd.melt(\n        df,\n        id_vars=cols_to_keep,\n        value_vars=cols_to_gather,\n        var_name=into[0],\n        value_name=into[1],\n    )\n    df = df.dropna(subset=into[1])  # type: ignore\n    df = df.reset_index(drop=True)\n    return df\n\n\ndef _grouped_melt(df: PandasGroupedFrame, into: tuple[str, str]) -> PandasDataFrame:\n    cols_to_keep = df.grouper.names  # type: ignore\n    cols_to_gather = [col for col in df.obj.columns if col not in cols_to_keep]  # type: ignore\n    df = _melt(df.obj, cols_to_keep, cols_to_gather, into)  # type: ignore\n    return df\n\n\ndef gather(\n    df: PandasDataFrame | PandasGroupedFrame,\n    columns: Columns | None = None,\n    beside: LazyColumns | None = None,\n    into: tuple[Column, Column] = (\"variable\", \"value\"),\n) -> PandasDataFrame:\n    _check_type(columns, {list, None})\n    _check_type(beside, {str, list, None})\n    _check_type(into, tuple)\n    if (columns == None) and (beside != None) and isinstance(df, PandasDataFrame):", "id": "maxhumber_redframes_maxhumber_redframes-redframes-verbs-gather.py_0-45"}
{"title": "maxhumber_redframes-redframes-verbs-gather.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "verbs", "gather.py"], "line_no": 30, "start_line_no": 5, "end_line_no": 55, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "\nfrom ..checks import _check_type\nfrom ..types import Column, Columns, LazyColumns, PandasDataFrame, PandasGroupedFrame\n\n\ndef _melt(\n    df: PandasDataFrame,\n    cols_to_keep: list[str],\n    cols_to_gather: list[str],\n    into: tuple[str, str],\n) -> PandasDataFrame:\n    df = pd.melt(\n        df,\n        id_vars=cols_to_keep,\n        value_vars=cols_to_gather,\n        var_name=into[0],\n        value_name=into[1],\n    )\n    df = df.dropna(subset=into[1])  # type: ignore\n    df = df.reset_index(drop=True)\n    return df\n\n\ndef _grouped_melt(df: PandasGroupedFrame, into: tuple[str, str]) -> PandasDataFrame:\n    cols_to_keep = df.grouper.names  # type: ignore\n    cols_to_gather = [col for col in df.obj.columns if col not in cols_to_keep]  # type: ignore\n    df = _melt(df.obj, cols_to_keep, cols_to_gather, into)  # type: ignore\n    return df\n\n\ndef gather(\n    df: PandasDataFrame | PandasGroupedFrame,\n    columns: Columns | None = None,\n    beside: LazyColumns | None = None,\n    into: tuple[Column, Column] = (\"variable\", \"value\"),\n) -> PandasDataFrame:\n    _check_type(columns, {list, None})\n    _check_type(beside, {str, list, None})\n    _check_type(into, tuple)\n    if (columns == None) and (beside != None) and isinstance(df, PandasDataFrame):\n        warnings.warn(\n            \"Marked for removal, please use `df.group(...).gather(...)` instead\",\n            FutureWarning,\n        )\n    if not (isinstance(into, tuple) and (len(into) == 2)):\n        raise TypeError(\"must be tuple[str, str]\")\n    if into[0] == into[1]:\n        raise TypeError(\"must be unique\")\n    if isinstance(df, PandasGroupedFrame):\n        if (into[0] in df.obj.columns) or (into[1] in df.obj.columns):  # type: ignore", "id": "maxhumber_redframes_maxhumber_redframes-redframes-verbs-gather.py_5-55"}
{"title": "maxhumber_redframes-redframes-verbs-gather.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "verbs", "gather.py"], "line_no": 40, "start_line_no": 15, "end_line_no": 65, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": ") -> PandasDataFrame:\n    df = pd.melt(\n        df,\n        id_vars=cols_to_keep,\n        value_vars=cols_to_gather,\n        var_name=into[0],\n        value_name=into[1],\n    )\n    df = df.dropna(subset=into[1])  # type: ignore\n    df = df.reset_index(drop=True)\n    return df\n\n\ndef _grouped_melt(df: PandasGroupedFrame, into: tuple[str, str]) -> PandasDataFrame:\n    cols_to_keep = df.grouper.names  # type: ignore\n    cols_to_gather = [col for col in df.obj.columns if col not in cols_to_keep]  # type: ignore\n    df = _melt(df.obj, cols_to_keep, cols_to_gather, into)  # type: ignore\n    return df\n\n\ndef gather(\n    df: PandasDataFrame | PandasGroupedFrame,\n    columns: Columns | None = None,\n    beside: LazyColumns | None = None,\n    into: tuple[Column, Column] = (\"variable\", \"value\"),\n) -> PandasDataFrame:\n    _check_type(columns, {list, None})\n    _check_type(beside, {str, list, None})\n    _check_type(into, tuple)\n    if (columns == None) and (beside != None) and isinstance(df, PandasDataFrame):\n        warnings.warn(\n            \"Marked for removal, please use `df.group(...).gather(...)` instead\",\n            FutureWarning,\n        )\n    if not (isinstance(into, tuple) and (len(into) == 2)):\n        raise TypeError(\"must be tuple[str, str]\")\n    if into[0] == into[1]:\n        raise TypeError(\"must be unique\")\n    if isinstance(df, PandasGroupedFrame):\n        if (into[0] in df.obj.columns) or (into[1] in df.obj.columns):  # type: ignore\n            raise ValueError(\"must not be an existing column key\")\n        if columns != None:\n            raise ValueError(\"columns is incompatible with group+gather\")\n        if beside != None:\n            raise ValueError(\"beside is incompatible with group+gather\")\n        df = _grouped_melt(df, into)\n        return df\n    if (into[0] in df.columns) or (into[1] in df.columns):\n        raise ValueError(\"must not be an existing column key\")\n    if (columns != None) and (beside != None):", "id": "maxhumber_redframes_maxhumber_redframes-redframes-verbs-gather.py_15-65"}
{"title": "maxhumber_redframes-redframes-verbs-gather.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "verbs", "gather.py"], "line_no": 50, "start_line_no": 25, "end_line_no": 75, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "    return df\n\n\ndef _grouped_melt(df: PandasGroupedFrame, into: tuple[str, str]) -> PandasDataFrame:\n    cols_to_keep = df.grouper.names  # type: ignore\n    cols_to_gather = [col for col in df.obj.columns if col not in cols_to_keep]  # type: ignore\n    df = _melt(df.obj, cols_to_keep, cols_to_gather, into)  # type: ignore\n    return df\n\n\ndef gather(\n    df: PandasDataFrame | PandasGroupedFrame,\n    columns: Columns | None = None,\n    beside: LazyColumns | None = None,\n    into: tuple[Column, Column] = (\"variable\", \"value\"),\n) -> PandasDataFrame:\n    _check_type(columns, {list, None})\n    _check_type(beside, {str, list, None})\n    _check_type(into, tuple)\n    if (columns == None) and (beside != None) and isinstance(df, PandasDataFrame):\n        warnings.warn(\n            \"Marked for removal, please use `df.group(...).gather(...)` instead\",\n            FutureWarning,\n        )\n    if not (isinstance(into, tuple) and (len(into) == 2)):\n        raise TypeError(\"must be tuple[str, str]\")\n    if into[0] == into[1]:\n        raise TypeError(\"must be unique\")\n    if isinstance(df, PandasGroupedFrame):\n        if (into[0] in df.obj.columns) or (into[1] in df.obj.columns):  # type: ignore\n            raise ValueError(\"must not be an existing column key\")\n        if columns != None:\n            raise ValueError(\"columns is incompatible with group+gather\")\n        if beside != None:\n            raise ValueError(\"beside is incompatible with group+gather\")\n        df = _grouped_melt(df, into)\n        return df\n    if (into[0] in df.columns) or (into[1] in df.columns):\n        raise ValueError(\"must not be an existing column key\")\n    if (columns != None) and (beside != None):\n        raise ValueError(\"columns OR beside must be None\")\n    if (columns == None) and (beside == None):\n        id_vars = []\n        value_vars = list(df.columns)\n    if isinstance(beside, str):\n        beside = [beside]\n    if isinstance(beside, list):\n        id_vars = beside\n        value_vars = [col for col in df.columns if col not in id_vars]\n    if isinstance(columns, list):", "id": "maxhumber_redframes_maxhumber_redframes-redframes-verbs-gather.py_25-75"}
{"title": "maxhumber_redframes-redframes-verbs-gather.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "verbs", "gather.py"], "line_no": 60, "start_line_no": 35, "end_line_no": 79, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "def gather(\n    df: PandasDataFrame | PandasGroupedFrame,\n    columns: Columns | None = None,\n    beside: LazyColumns | None = None,\n    into: tuple[Column, Column] = (\"variable\", \"value\"),\n) -> PandasDataFrame:\n    _check_type(columns, {list, None})\n    _check_type(beside, {str, list, None})\n    _check_type(into, tuple)\n    if (columns == None) and (beside != None) and isinstance(df, PandasDataFrame):\n        warnings.warn(\n            \"Marked for removal, please use `df.group(...).gather(...)` instead\",\n            FutureWarning,\n        )\n    if not (isinstance(into, tuple) and (len(into) == 2)):\n        raise TypeError(\"must be tuple[str, str]\")\n    if into[0] == into[1]:\n        raise TypeError(\"must be unique\")\n    if isinstance(df, PandasGroupedFrame):\n        if (into[0] in df.obj.columns) or (into[1] in df.obj.columns):  # type: ignore\n            raise ValueError(\"must not be an existing column key\")\n        if columns != None:\n            raise ValueError(\"columns is incompatible with group+gather\")\n        if beside != None:\n            raise ValueError(\"beside is incompatible with group+gather\")\n        df = _grouped_melt(df, into)\n        return df\n    if (into[0] in df.columns) or (into[1] in df.columns):\n        raise ValueError(\"must not be an existing column key\")\n    if (columns != None) and (beside != None):\n        raise ValueError(\"columns OR beside must be None\")\n    if (columns == None) and (beside == None):\n        id_vars = []\n        value_vars = list(df.columns)\n    if isinstance(beside, str):\n        beside = [beside]\n    if isinstance(beside, list):\n        id_vars = beside\n        value_vars = [col for col in df.columns if col not in id_vars]\n    if isinstance(columns, list):\n        id_vars = [col for col in df.columns if col not in columns]\n        value_vars = columns\n    df = _melt(df, id_vars, value_vars, into)  # pyright: ignore[reportUnboundVariable]\n    return df", "id": "maxhumber_redframes_maxhumber_redframes-redframes-verbs-gather.py_35-79"}
{"title": "maxhumber_redframes-redframes-verbs-gather.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "verbs", "gather.py"], "line_no": 70, "start_line_no": 45, "end_line_no": 79, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        warnings.warn(\n            \"Marked for removal, please use `df.group(...).gather(...)` instead\",\n            FutureWarning,\n        )\n    if not (isinstance(into, tuple) and (len(into) == 2)):\n        raise TypeError(\"must be tuple[str, str]\")\n    if into[0] == into[1]:\n        raise TypeError(\"must be unique\")\n    if isinstance(df, PandasGroupedFrame):\n        if (into[0] in df.obj.columns) or (into[1] in df.obj.columns):  # type: ignore\n            raise ValueError(\"must not be an existing column key\")\n        if columns != None:\n            raise ValueError(\"columns is incompatible with group+gather\")\n        if beside != None:\n            raise ValueError(\"beside is incompatible with group+gather\")\n        df = _grouped_melt(df, into)\n        return df\n    if (into[0] in df.columns) or (into[1] in df.columns):\n        raise ValueError(\"must not be an existing column key\")\n    if (columns != None) and (beside != None):\n        raise ValueError(\"columns OR beside must be None\")\n    if (columns == None) and (beside == None):\n        id_vars = []\n        value_vars = list(df.columns)\n    if isinstance(beside, str):\n        beside = [beside]\n    if isinstance(beside, list):\n        id_vars = beside\n        value_vars = [col for col in df.columns if col not in id_vars]\n    if isinstance(columns, list):\n        id_vars = [col for col in df.columns if col not in columns]\n        value_vars = columns\n    df = _melt(df, id_vars, value_vars, into)  # pyright: ignore[reportUnboundVariable]\n    return df", "id": "maxhumber_redframes_maxhumber_redframes-redframes-verbs-gather.py_45-79"}
{"title": "maxhumber_redframes-redframes-verbs-group.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "verbs", "group.py"], "line_no": 0, "start_line_no": 0, "end_line_no": 10, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "from __future__ import annotations\n\nfrom ..checks import _check_type\nfrom ..types import LazyColumns, PandasDataFrame, PandasGroupedFrame\n\n\ndef group(df: PandasDataFrame, by: LazyColumns) -> PandasGroupedFrame:\n    _check_type(by, {list, str})\n    gdf = df.groupby(by, as_index=False, sort=False)\n    return gdf", "id": "maxhumber_redframes_maxhumber_redframes-redframes-verbs-group.py_0-10"}
{"title": "maxhumber_redframes-redframes-verbs-join.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "verbs", "join.py"], "line_no": 0, "start_line_no": 0, "end_line_no": 25, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "from __future__ import annotations\n\nimport pandas as pd  # pyright: ignore[reportMissingImports]\n\nfrom ..checks import _check_type\nfrom ..types import Join, LazyColumns, PandasDataFrame\n\n\ndef join(\n    lhs: PandasDataFrame,\n    rhs: PandasDataFrame,\n    on: LazyColumns,\n    how: Join = \"left\",\n    postfix: tuple[str, str] = (\"_lhs\", \"_rhs\"),\n) -> PandasDataFrame:\n    _check_type(on, {list, str})\n    _check_type(how, str)\n    _check_type(postfix, tuple)\n    if not how in [\"left\", \"right\", \"inner\", \"full\"]:\n        message = (\n            \"on argument is invalid, must be one of {'left', 'right', 'inner', 'full'}\"\n        )\n        raise ValueError(message)\n    how = \"outer\" if (how == \"full\") else how  # type: ignore\n    df = pd.merge(lhs, rhs, on=on, how=how, suffixes=postfix)", "id": "maxhumber_redframes_maxhumber_redframes-redframes-verbs-join.py_0-25"}
{"title": "maxhumber_redframes-redframes-verbs-join.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "verbs", "join.py"], "line_no": 10, "start_line_no": 0, "end_line_no": 27, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}, {"fpath_tuple": ["maxhumber_redframes", "redframes", "verbs", "join.py"], "line_no": 20, "start_line_no": 0, "end_line_no": 27, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "from __future__ import annotations\n\nimport pandas as pd  # pyright: ignore[reportMissingImports]\n\nfrom ..checks import _check_type\nfrom ..types import Join, LazyColumns, PandasDataFrame\n\n\ndef join(\n    lhs: PandasDataFrame,\n    rhs: PandasDataFrame,\n    on: LazyColumns,\n    how: Join = \"left\",\n    postfix: tuple[str, str] = (\"_lhs\", \"_rhs\"),\n) -> PandasDataFrame:\n    _check_type(on, {list, str})\n    _check_type(how, str)\n    _check_type(postfix, tuple)\n    if not how in [\"left\", \"right\", \"inner\", \"full\"]:\n        message = (\n            \"on argument is invalid, must be one of {'left', 'right', 'inner', 'full'}\"\n        )\n        raise ValueError(message)\n    how = \"outer\" if (how == \"full\") else how  # type: ignore\n    df = pd.merge(lhs, rhs, on=on, how=how, suffixes=postfix)\n    df = df.reset_index(drop=True)\n    return df", "id": "maxhumber_redframes_maxhumber_redframes-redframes-verbs-join.py_0-27"}
{"title": "maxhumber_redframes-redframes-verbs-mutate.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "verbs", "mutate.py"], "line_no": 0, "start_line_no": 0, "end_line_no": 12, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}, {"fpath_tuple": ["maxhumber_redframes", "redframes", "verbs", "mutate.py"], "line_no": 10, "start_line_no": 0, "end_line_no": 12, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "from __future__ import annotations\n\nfrom ..checks import _check_type\nfrom ..types import Column, Func, PandasDataFrame\n\n\ndef mutate(df: PandasDataFrame, over: dict[Column, Func]) -> PandasDataFrame:\n    _check_type(over, dict)\n    df = df.copy()\n    for column, mutation in over.items():\n        df[column] = df.apply(mutation, axis=1)\n    return df  # type: ignore", "id": "maxhumber_redframes_maxhumber_redframes-redframes-verbs-mutate.py_0-12"}
{"title": "maxhumber_redframes-redframes-verbs-pack.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "verbs", "pack.py"], "line_no": 0, "start_line_no": 0, "end_line_no": 16, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}, {"fpath_tuple": ["maxhumber_redframes", "redframes", "verbs", "pack.py"], "line_no": 10, "start_line_no": 0, "end_line_no": 16, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "from __future__ import annotations\n\nfrom ..checks import _check_type\nfrom ..types import Column, PandasDataFrame, PandasGroupedFrame\n\n\ndef pack(\n    df: PandasDataFrame | PandasGroupedFrame, column: Column, sep: str\n) -> PandasDataFrame:\n    _check_type(column, str)\n    _check_type(sep, str)\n    order = df.obj.columns if isinstance(df, PandasGroupedFrame) else df.columns  # type: ignore\n    df = df.agg(**{column: (column, lambda x: x.astype(str).str.cat(sep=sep))})  # type: ignore\n    df = df[[col for col in df.columns if col in order]]\n    df = df.reset_index(drop=True)\n    return df", "id": "maxhumber_redframes_maxhumber_redframes-redframes-verbs-pack.py_0-16"}
{"title": "maxhumber_redframes-redframes-verbs-rank.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "verbs", "rank.py"], "line_no": 0, "start_line_no": 0, "end_line_no": 25, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "from __future__ import annotations\n\nimport warnings\n\nfrom ..checks import _check_type\nfrom ..types import Column, PandasDataFrame, PandasGroupedFrame\n\n\ndef rank(\n    df: PandasDataFrame | PandasGroupedFrame,\n    column: Column,\n    into: Column,\n    descending: bool = False,\n) -> PandasDataFrame:\n    _check_type(column, str)\n    _check_type(into, str)\n    _check_type(descending, bool)\n    if isinstance(df, PandasDataFrame):\n        into_is_not_column = into != column\n        into_is_in_df_columns = into in df.columns\n        if into_is_not_column and into_is_in_df_columns:\n            message = f\"overwriting existing column '{into}'\"\n            warnings.warn(message)\n        df = df.copy()\n    result = df[column].rank(method=\"dense\", ascending=not descending)", "id": "maxhumber_redframes_maxhumber_redframes-redframes-verbs-rank.py_0-25"}
{"title": "maxhumber_redframes-redframes-verbs-rank.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "verbs", "rank.py"], "line_no": 10, "start_line_no": 0, "end_line_no": 29, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}, {"fpath_tuple": ["maxhumber_redframes", "redframes", "verbs", "rank.py"], "line_no": 20, "start_line_no": 0, "end_line_no": 29, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "from __future__ import annotations\n\nimport warnings\n\nfrom ..checks import _check_type\nfrom ..types import Column, PandasDataFrame, PandasGroupedFrame\n\n\ndef rank(\n    df: PandasDataFrame | PandasGroupedFrame,\n    column: Column,\n    into: Column,\n    descending: bool = False,\n) -> PandasDataFrame:\n    _check_type(column, str)\n    _check_type(into, str)\n    _check_type(descending, bool)\n    if isinstance(df, PandasDataFrame):\n        into_is_not_column = into != column\n        into_is_in_df_columns = into in df.columns\n        if into_is_not_column and into_is_in_df_columns:\n            message = f\"overwriting existing column '{into}'\"\n            warnings.warn(message)\n        df = df.copy()\n    result = df[column].rank(method=\"dense\", ascending=not descending)\n    if isinstance(df, PandasGroupedFrame):\n        df = df.obj.copy()  # type: ignore\n    df[into] = result  # type: ignore\n    return df  # type: ignore", "id": "maxhumber_redframes_maxhumber_redframes-redframes-verbs-rank.py_0-29"}
{"title": "maxhumber_redframes-redframes-verbs-rename.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "verbs", "rename.py"], "line_no": 0, "start_line_no": 0, "end_line_no": 17, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}, {"fpath_tuple": ["maxhumber_redframes", "redframes", "verbs", "rename.py"], "line_no": 10, "start_line_no": 0, "end_line_no": 17, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "from ..checks import _check_type, _check_values\nfrom ..types import NewColumn, OldColumn, PandasDataFrame\n\n\ndef rename(df: PandasDataFrame, columns: dict[OldColumn, NewColumn]) -> PandasDataFrame:\n    _check_type(columns, dict)\n    cv = columns.values()\n    _check_values(cv, str)\n    if len(set(cv)) != len(cv):\n        raise KeyError(\"columns must be unique\")\n    missing_keys = set(columns.keys()) - set(df.columns)\n    if missing_keys and len(missing_keys) == 1:\n        raise KeyError(f\"column key ({missing_keys}) is invalid\")\n    if missing_keys and len(missing_keys) > 1:\n        raise KeyError(f\"column keys ({missing_keys}) are invalid\")\n    df = df.rename(columns=columns)\n    return df", "id": "maxhumber_redframes_maxhumber_redframes-redframes-verbs-rename.py_0-17"}
{"title": "maxhumber_redframes-redframes-verbs-replace.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "verbs", "replace.py"], "line_no": 0, "start_line_no": 0, "end_line_no": 15, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}, {"fpath_tuple": ["maxhumber_redframes", "redframes", "verbs", "replace.py"], "line_no": 10, "start_line_no": 0, "end_line_no": 15, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "from ..checks import _check_type\nfrom ..types import Column, NewValue, OldValue, PandasDataFrame\n\n\ndef replace(\n    df: PandasDataFrame, over: dict[Column, dict[OldValue, NewValue]]\n) -> PandasDataFrame:\n    _check_type(over, dict)\n    bad_columns = list(set(over.keys()) - set(df.columns))\n    if bad_columns and len(bad_columns) == 1:\n        raise KeyError(f\"column key: {bad_columns} is invalid\")\n    if bad_columns and len(bad_columns) > 1:\n        raise KeyError(f\"column keys: {bad_columns} are invalid\")\n    df = df.replace(over)\n    return df", "id": "maxhumber_redframes_maxhumber_redframes-redframes-verbs-replace.py_0-15"}
{"title": "maxhumber_redframes-redframes-verbs-rollup.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "verbs", "rollup.py"], "line_no": 0, "start_line_no": 0, "end_line_no": 25, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "from __future__ import annotations\n\nfrom ..checks import _check_type\nfrom ..types import Column, Func, PandasDataFrame, PandasGroupedFrame\n\n\ndef rollup(\n    df: PandasDataFrame | PandasGroupedFrame,\n    over: dict[Column, tuple[Column, Func]],\n) -> PandasDataFrame:\n    _check_type(over, dict)\n    if isinstance(df, PandasGroupedFrame):\n        groups = set(df.grouper.names)  # type: ignore\n        keys = set(over.keys())\n        if groups.intersection(keys):\n            raise KeyError(\"unable to overwrite group keys\")\n        df = df.agg(**over)\n        df = df.reset_index(drop=True)\n    else:\n        df = df.agg(**over)  # type: ignore\n        df = df.T  # type: ignore\n        df = df.reset_index(drop=True)  # type: ignore\n        df = df.fillna(method=\"ffill\")  # type: ignore\n        df = df.fillna(method=\"bfill\")  # type: ignore\n        df = df.head(1)  # type: ignore", "id": "maxhumber_redframes_maxhumber_redframes-redframes-verbs-rollup.py_0-25"}
{"title": "maxhumber_redframes-redframes-verbs-rollup.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "verbs", "rollup.py"], "line_no": 10, "start_line_no": 0, "end_line_no": 26, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}, {"fpath_tuple": ["maxhumber_redframes", "redframes", "verbs", "rollup.py"], "line_no": 20, "start_line_no": 0, "end_line_no": 26, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "from __future__ import annotations\n\nfrom ..checks import _check_type\nfrom ..types import Column, Func, PandasDataFrame, PandasGroupedFrame\n\n\ndef rollup(\n    df: PandasDataFrame | PandasGroupedFrame,\n    over: dict[Column, tuple[Column, Func]],\n) -> PandasDataFrame:\n    _check_type(over, dict)\n    if isinstance(df, PandasGroupedFrame):\n        groups = set(df.grouper.names)  # type: ignore\n        keys = set(over.keys())\n        if groups.intersection(keys):\n            raise KeyError(\"unable to overwrite group keys\")\n        df = df.agg(**over)\n        df = df.reset_index(drop=True)\n    else:\n        df = df.agg(**over)  # type: ignore\n        df = df.T  # type: ignore\n        df = df.reset_index(drop=True)  # type: ignore\n        df = df.fillna(method=\"ffill\")  # type: ignore\n        df = df.fillna(method=\"bfill\")  # type: ignore\n        df = df.head(1)  # type: ignore\n    return df", "id": "maxhumber_redframes_maxhumber_redframes-redframes-verbs-rollup.py_0-26"}
{"title": "maxhumber_redframes-redframes-verbs-sample.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "verbs", "sample.py"], "line_no": 0, "start_line_no": 0, "end_line_no": 20, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}, {"fpath_tuple": ["maxhumber_redframes", "redframes", "verbs", "sample.py"], "line_no": 10, "start_line_no": 0, "end_line_no": 20, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "from __future__ import annotations\n\nfrom ..checks import _check_type\nfrom ..types import PandasDataFrame\n\n\ndef sample(\n    df: PandasDataFrame, rows: int | float, seed: int | None = None\n) -> PandasDataFrame:\n    _check_type(rows, {int, float})\n    if rows >= 1:\n        if isinstance(rows, float):\n            raise ValueError(\"must be int if > 1\")\n        df = df.sample(rows, random_state=seed)\n    elif 0 < rows < 1:\n        df = df.sample(frac=rows, random_state=seed)\n    else:\n        raise ValueError(\"must be > 0\")\n    df = df.reset_index(drop=True)\n    return df", "id": "maxhumber_redframes_maxhumber_redframes-redframes-verbs-sample.py_0-20"}
{"title": "maxhumber_redframes-redframes-verbs-select.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "verbs", "select.py"], "line_no": 0, "start_line_no": 0, "end_line_no": 18, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}, {"fpath_tuple": ["maxhumber_redframes", "redframes", "verbs", "select.py"], "line_no": 10, "start_line_no": 0, "end_line_no": 18, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "import pandas as pd  # pyright: ignore[reportMissingImports]\n\nfrom ..checks import _check_type\nfrom ..types import LazyColumns, PandasDataFrame\n\n\ndef select(df: PandasDataFrame, columns: LazyColumns) -> PandasDataFrame:\n    _check_type(columns, {list, str})\n    columns = [columns] if isinstance(columns, str) else columns\n    if len(set(columns)) != len(columns):\n        raise KeyError(f\"column keys must be unique\")\n    bad_columns = list(set(columns) - set(df.columns))\n    if bad_columns and len(bad_columns) == 1:\n        raise KeyError(f\"column key: {bad_columns} is invalid\")\n    if bad_columns and len(bad_columns) > 1:\n        raise KeyError(f\"column keys: {bad_columns} are invalid\")\n    df = df[columns]\n    return df", "id": "maxhumber_redframes_maxhumber_redframes-redframes-verbs-select.py_0-18"}
{"title": "maxhumber_redframes-redframes-verbs-shuffle.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "verbs", "shuffle.py"], "line_no": 0, "start_line_no": 0, "end_line_no": 11, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}, {"fpath_tuple": ["maxhumber_redframes", "redframes", "verbs", "shuffle.py"], "line_no": 10, "start_line_no": 0, "end_line_no": 11, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "from __future__ import annotations\n\nfrom ..checks import _check_type\nfrom ..types import PandasDataFrame\n\n\ndef shuffle(df: PandasDataFrame, seed: int | None = None) -> PandasDataFrame:\n    _check_type(seed, {int, None})\n    df = df.sample(frac=1, random_state=seed)\n    df = df.reset_index(drop=True)\n    return df", "id": "maxhumber_redframes_maxhumber_redframes-redframes-verbs-shuffle.py_0-11"}
{"title": "maxhumber_redframes-redframes-verbs-sort.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "verbs", "sort.py"], "line_no": 0, "start_line_no": 0, "end_line_no": 15, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}, {"fpath_tuple": ["maxhumber_redframes", "redframes", "verbs", "sort.py"], "line_no": 10, "start_line_no": 0, "end_line_no": 15, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "from __future__ import annotations\n\nfrom ..checks import _check_keys, _check_type\nfrom ..types import LazyColumns, PandasDataFrame\n\n\ndef sort(\n    df: PandasDataFrame, columns: LazyColumns, descending: bool = False\n) -> PandasDataFrame:\n    _check_type(columns, {list, str})\n    _check_type(descending, bool)\n    _check_keys(columns, df.columns)\n    df = df.sort_values(by=columns, ascending=not descending)\n    df = df.reset_index(drop=True)\n    return df", "id": "maxhumber_redframes_maxhumber_redframes-redframes-verbs-sort.py_0-15"}
{"title": "maxhumber_redframes-redframes-verbs-split.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "verbs", "split.py"], "line_no": 0, "start_line_no": 0, "end_line_no": 25, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "import uuid\n\nfrom ..checks import _check_type\nfrom ..types import Column, Columns, PandasDataFrame\n\n\ndef split(\n    df: PandasDataFrame, column: Column, into: Columns, sep: str, drop: bool = True\n) -> PandasDataFrame:\n    _check_type(column, str)\n    _check_type(into, list)\n    _check_type(sep, str)\n    _check_type(drop, bool)\n    if len(into) != len(set(into)):\n        raise KeyError(\"into keys must be unique\")\n    if (column in into) and (not drop):\n        raise KeyError(\"into keys must be unique\")\n    bad_keys = set(df.columns).difference(set([column])).intersection(set(into))\n    if bad_keys:\n        raise KeyError(\"into keys must be unique\")\n    columns = {uuid.uuid4().hex: col for col in into}\n    temp = list(columns.keys())\n    df = df.copy()\n    df[temp] = df[column].str.split(sep, expand=True)\n    if drop:", "id": "maxhumber_redframes_maxhumber_redframes-redframes-verbs-split.py_0-25"}
{"title": "maxhumber_redframes-redframes-verbs-split.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "verbs", "split.py"], "line_no": 10, "start_line_no": 0, "end_line_no": 28, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}, {"fpath_tuple": ["maxhumber_redframes", "redframes", "verbs", "split.py"], "line_no": 20, "start_line_no": 0, "end_line_no": 28, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "import uuid\n\nfrom ..checks import _check_type\nfrom ..types import Column, Columns, PandasDataFrame\n\n\ndef split(\n    df: PandasDataFrame, column: Column, into: Columns, sep: str, drop: bool = True\n) -> PandasDataFrame:\n    _check_type(column, str)\n    _check_type(into, list)\n    _check_type(sep, str)\n    _check_type(drop, bool)\n    if len(into) != len(set(into)):\n        raise KeyError(\"into keys must be unique\")\n    if (column in into) and (not drop):\n        raise KeyError(\"into keys must be unique\")\n    bad_keys = set(df.columns).difference(set([column])).intersection(set(into))\n    if bad_keys:\n        raise KeyError(\"into keys must be unique\")\n    columns = {uuid.uuid4().hex: col for col in into}\n    temp = list(columns.keys())\n    df = df.copy()\n    df[temp] = df[column].str.split(sep, expand=True)\n    if drop:\n        df = df.drop(column, axis=1)\n    df = df.rename(columns=columns)\n    return df", "id": "maxhumber_redframes_maxhumber_redframes-redframes-verbs-split.py_0-28"}
{"title": "maxhumber_redframes-redframes-verbs-spread.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "verbs", "spread.py"], "line_no": 0, "start_line_no": 0, "end_line_no": 24, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}, {"fpath_tuple": ["maxhumber_redframes", "redframes", "verbs", "spread.py"], "line_no": 10, "start_line_no": 0, "end_line_no": 24, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}, {"fpath_tuple": ["maxhumber_redframes", "redframes", "verbs", "spread.py"], "line_no": 20, "start_line_no": 0, "end_line_no": 24, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "import uuid\n\nimport pandas as pd  # pyright: ignore[reportMissingImports]\n\nfrom ..checks import _check_type\nfrom ..types import Column, PandasDataFrame\n\n\ndef spread(df: PandasDataFrame, column: Column, using: Column) -> PandasDataFrame:\n    _check_type(column, str)\n    _check_type(using, str)\n    if column == using:\n        raise KeyError(\"column and using must be unique\")\n    original_shape = df.shape[1]\n    if original_shape == 2:\n        temp = uuid.uuid4().hex\n        df[temp] = df.groupby(column).cumcount()\n    index = [col for col in df.columns if col not in [column, using]]\n    df = pd.pivot_table(df, index=index, columns=[column], values=[using], aggfunc=\"first\")  # type: ignore\n    df.columns = [col for col in df.columns.get_level_values(1)]  # type: ignore\n    df = df.reset_index().rename_axis(None, axis=0)\n    if original_shape == 2:\n        df = df.drop(temp, axis=1)  # type: ignore\n    return df", "id": "maxhumber_redframes_maxhumber_redframes-redframes-verbs-spread.py_0-24"}
{"title": "maxhumber_redframes-redframes-verbs-take.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "verbs", "take.py"], "line_no": 0, "start_line_no": 0, "end_line_no": 25, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "from __future__ import annotations\n\nfrom ..checks import _check_type\nfrom ..types import PandasDataFrame, PandasGroupedFrame\n\n\ndef take(\n    df: PandasDataFrame | PandasGroupedFrame, rows: int = 1, **kwargs\n) -> PandasDataFrame:\n    if kwargs:  # compatibility: sklearn / train_test_split\n        df = df.take(rows, **kwargs)  # type: ignore\n        df = df.reset_index(drop=True)\n        return df\n    _check_type(rows, int)\n    if isinstance(df, PandasDataFrame):\n        if rows > df.shape[0]:\n            raise ValueError(\"rows argument is invalid, exceeds total size\")\n    if rows == 0:\n        raise ValueError(\"rows argument is invalid, must not be 0\")\n    if rows <= -1:\n        df = df.tail(rows * -1)\n    else:\n        df = df.head(rows)\n    if isinstance(df, PandasGroupedFrame):\n        df = df.reset_index()", "id": "maxhumber_redframes_maxhumber_redframes-redframes-verbs-take.py_0-25"}
{"title": "maxhumber_redframes-redframes-verbs-take.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "verbs", "take.py"], "line_no": 10, "start_line_no": 0, "end_line_no": 28, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}, {"fpath_tuple": ["maxhumber_redframes", "redframes", "verbs", "take.py"], "line_no": 20, "start_line_no": 0, "end_line_no": 28, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "from __future__ import annotations\n\nfrom ..checks import _check_type\nfrom ..types import PandasDataFrame, PandasGroupedFrame\n\n\ndef take(\n    df: PandasDataFrame | PandasGroupedFrame, rows: int = 1, **kwargs\n) -> PandasDataFrame:\n    if kwargs:  # compatibility: sklearn / train_test_split\n        df = df.take(rows, **kwargs)  # type: ignore\n        df = df.reset_index(drop=True)\n        return df\n    _check_type(rows, int)\n    if isinstance(df, PandasDataFrame):\n        if rows > df.shape[0]:\n            raise ValueError(\"rows argument is invalid, exceeds total size\")\n    if rows == 0:\n        raise ValueError(\"rows argument is invalid, must not be 0\")\n    if rows <= -1:\n        df = df.tail(rows * -1)\n    else:\n        df = df.head(rows)\n    if isinstance(df, PandasGroupedFrame):\n        df = df.reset_index()\n    else:\n        df = df.reset_index(drop=True)\n    return df", "id": "maxhumber_redframes_maxhumber_redframes-redframes-verbs-take.py_0-28"}
{"title": "maxhumber_redframes-redframes-verbs-unpack.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "verbs", "unpack.py"], "line_no": 0, "start_line_no": 0, "end_line_no": 13, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}, {"fpath_tuple": ["maxhumber_redframes", "redframes", "verbs", "unpack.py"], "line_no": 10, "start_line_no": 0, "end_line_no": 13, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "from __future__ import annotations\n\nfrom ..checks import _check_type\nfrom ..types import Column, PandasDataFrame\n\n\ndef unpack(df: PandasDataFrame, column: Column, sep: str) -> PandasDataFrame:\n    _check_type(column, str)\n    _check_type(sep, str)\n    df = df.assign(**{column: df[column].str.split(sep)})\n    df = df.explode(column)\n    df = df.reset_index(drop=True)\n    return df", "id": "maxhumber_redframes_maxhumber_redframes-redframes-verbs-unpack.py_0-13"}
{"title": "maxhumber_redframes-redframes-verbs-__init__.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "verbs", "__init__.py"], "line_no": 0, "start_line_no": 0, "end_line_no": 25, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "from .accumulate import accumulate\nfrom .append import append\nfrom .combine import combine\nfrom .cross import cross\nfrom .dedupe import dedupe\nfrom .denix import denix\nfrom .drop import drop\nfrom .fill import fill\nfrom .filter import filter\nfrom .gather import gather\nfrom .group import group\nfrom .join import join\nfrom .mutate import mutate\nfrom .pack import pack\nfrom .rank import rank\nfrom .rename import rename\nfrom .replace import replace\nfrom .rollup import rollup\nfrom .sample import sample\nfrom .select import select\nfrom .shuffle import shuffle\nfrom .sort import sort\nfrom .split import split\nfrom .spread import spread\nfrom .take import take", "id": "maxhumber_redframes_maxhumber_redframes-redframes-verbs-__init__.py_0-25"}
{"title": "maxhumber_redframes-redframes-verbs-__init__.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "redframes", "verbs", "__init__.py"], "line_no": 10, "start_line_no": 0, "end_line_no": 26, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}, {"fpath_tuple": ["maxhumber_redframes", "redframes", "verbs", "__init__.py"], "line_no": 20, "start_line_no": 0, "end_line_no": 26, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "from .accumulate import accumulate\nfrom .append import append\nfrom .combine import combine\nfrom .cross import cross\nfrom .dedupe import dedupe\nfrom .denix import denix\nfrom .drop import drop\nfrom .fill import fill\nfrom .filter import filter\nfrom .gather import gather\nfrom .group import group\nfrom .join import join\nfrom .mutate import mutate\nfrom .pack import pack\nfrom .rank import rank\nfrom .rename import rename\nfrom .replace import replace\nfrom .rollup import rollup\nfrom .sample import sample\nfrom .select import select\nfrom .shuffle import shuffle\nfrom .sort import sort\nfrom .split import split\nfrom .spread import spread\nfrom .take import take\nfrom .unpack import unpack", "id": "maxhumber_redframes_maxhumber_redframes-redframes-verbs-__init__.py_0-26"}
{"title": "maxhumber_redframes-tests-test_deprecations.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_deprecations.py"], "line_no": 0, "start_line_no": 0, "end_line_no": 25, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "import unittest\n\nimport redframes as rf\n\n\nclass TestDeprecations(unittest.TestCase):\n    def test_summarize_deprecation(self):\n        df = rf.DataFrame({\"foo\": range(10)})\n        expected = rf.DataFrame({\"foo\": [4.5]})\n        message = \"Marked for removal, please use `rollup` instead\"\n        with self.assertWarnsRegex(FutureWarning, message):\n            result = df.summarize({\"foo\": (\"foo\", rf.stat.mean)})\n            self.assertEqual(result, expected)\n\n    def test_gather_beside_deprecation(self):\n        df = rf.DataFrame({\"foo\": [1, 1, 2, 2], \"bar\": [1, 2, 3, 4]})\n        expected = rf.DataFrame(\n            {\n                \"foo\": [1, 1, 2, 2],\n                \"variable\": [\"bar\", \"bar\", \"bar\", \"bar\"],\n                \"value\": [1, 2, 3, 4],\n            }\n        )\n        with self.assertWarnsRegex(FutureWarning, \"Marked for removal*\"):\n            result = df.gather(beside=\"foo\")", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_deprecations.py_0-25"}
{"title": "maxhumber_redframes-tests-test_deprecations.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_deprecations.py"], "line_no": 10, "start_line_no": 0, "end_line_no": 26, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}, {"fpath_tuple": ["maxhumber_redframes", "tests", "test_deprecations.py"], "line_no": 20, "start_line_no": 0, "end_line_no": 26, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "import unittest\n\nimport redframes as rf\n\n\nclass TestDeprecations(unittest.TestCase):\n    def test_summarize_deprecation(self):\n        df = rf.DataFrame({\"foo\": range(10)})\n        expected = rf.DataFrame({\"foo\": [4.5]})\n        message = \"Marked for removal, please use `rollup` instead\"\n        with self.assertWarnsRegex(FutureWarning, message):\n            result = df.summarize({\"foo\": (\"foo\", rf.stat.mean)})\n            self.assertEqual(result, expected)\n\n    def test_gather_beside_deprecation(self):\n        df = rf.DataFrame({\"foo\": [1, 1, 2, 2], \"bar\": [1, 2, 3, 4]})\n        expected = rf.DataFrame(\n            {\n                \"foo\": [1, 1, 2, 2],\n                \"variable\": [\"bar\", \"bar\", \"bar\", \"bar\"],\n                \"value\": [1, 2, 3, 4],\n            }\n        )\n        with self.assertWarnsRegex(FutureWarning, \"Marked for removal*\"):\n            result = df.gather(beside=\"foo\")\n            self.assertEqual(result, expected)", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_deprecations.py_0-26"}
{"title": "maxhumber_redframes-tests-test_docstrings.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_docstrings.py"], "line_no": 0, "start_line_no": 0, "end_line_no": 25, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "import unittest\n\nimport redframes as rf\n\n\nclass TestDocstrings(unittest.TestCase):\n    def test_take(self):\n        df = rf.DataFrame({\"foo\": range(10)})\n        result1 = df.take(1)\n        result2 = df.take(-2)\n        expected1 = rf.DataFrame({\"foo\": [0]})\n        expected2 = rf.DataFrame({\"foo\": [8, 9]})\n        self.assertEqual(result1, expected1)\n        self.assertEqual(result2, expected2)\n\n    def test_accumulate(self):\n        df = rf.DataFrame({\"foo\": [1, 2, 3, 4]})\n        result = df.accumulate(\"foo\", into=\"cumsum\")\n        expected = rf.DataFrame({\"foo\": [1, 2, 3, 4], \"cumsum\": [1, 3, 6, 10]})\n        self.assertEqual(result, expected)\n\n    def test_gather(self):\n        df = rf.DataFrame(\n            {\n                \"foo\": [1, 2, 1, 2],", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_docstrings.py_0-25"}
{"title": "maxhumber_redframes-tests-test_docstrings.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_docstrings.py"], "line_no": 10, "start_line_no": 0, "end_line_no": 35, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "import unittest\n\nimport redframes as rf\n\n\nclass TestDocstrings(unittest.TestCase):\n    def test_take(self):\n        df = rf.DataFrame({\"foo\": range(10)})\n        result1 = df.take(1)\n        result2 = df.take(-2)\n        expected1 = rf.DataFrame({\"foo\": [0]})\n        expected2 = rf.DataFrame({\"foo\": [8, 9]})\n        self.assertEqual(result1, expected1)\n        self.assertEqual(result2, expected2)\n\n    def test_accumulate(self):\n        df = rf.DataFrame({\"foo\": [1, 2, 3, 4]})\n        result = df.accumulate(\"foo\", into=\"cumsum\")\n        expected = rf.DataFrame({\"foo\": [1, 2, 3, 4], \"cumsum\": [1, 3, 6, 10]})\n        self.assertEqual(result, expected)\n\n    def test_gather(self):\n        df = rf.DataFrame(\n            {\n                \"foo\": [1, 2, 1, 2],\n                \"bar\": [\"A\", \"B\", \"C\", \"D\"],\n                \"baz\": [\"!\", \"@\", \"#\", \"$\"],\n                \"jaz\": range(4),\n            }\n        )\n        result1 = df.gather()\n        result2 = df.gather([\"foo\", \"bar\"], into=(\"var\", \"val\"))\n        result3 = df.group([\"foo\", \"bar\"]).gather(into=(\"variable\", \"value\"))\n        expected1 = rf.DataFrame(\n            {", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_docstrings.py_0-35"}
{"title": "maxhumber_redframes-tests-test_docstrings.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_docstrings.py"], "line_no": 20, "start_line_no": 0, "end_line_no": 45, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "import unittest\n\nimport redframes as rf\n\n\nclass TestDocstrings(unittest.TestCase):\n    def test_take(self):\n        df = rf.DataFrame({\"foo\": range(10)})\n        result1 = df.take(1)\n        result2 = df.take(-2)\n        expected1 = rf.DataFrame({\"foo\": [0]})\n        expected2 = rf.DataFrame({\"foo\": [8, 9]})\n        self.assertEqual(result1, expected1)\n        self.assertEqual(result2, expected2)\n\n    def test_accumulate(self):\n        df = rf.DataFrame({\"foo\": [1, 2, 3, 4]})\n        result = df.accumulate(\"foo\", into=\"cumsum\")\n        expected = rf.DataFrame({\"foo\": [1, 2, 3, 4], \"cumsum\": [1, 3, 6, 10]})\n        self.assertEqual(result, expected)\n\n    def test_gather(self):\n        df = rf.DataFrame(\n            {\n                \"foo\": [1, 2, 1, 2],\n                \"bar\": [\"A\", \"B\", \"C\", \"D\"],\n                \"baz\": [\"!\", \"@\", \"#\", \"$\"],\n                \"jaz\": range(4),\n            }\n        )\n        result1 = df.gather()\n        result2 = df.gather([\"foo\", \"bar\"], into=(\"var\", \"val\"))\n        result3 = df.group([\"foo\", \"bar\"]).gather(into=(\"variable\", \"value\"))\n        expected1 = rf.DataFrame(\n            {\n                \"variable\": [\n                    \"foo\",\n                    \"foo\",\n                    \"foo\",\n                    \"foo\",\n                    \"bar\",\n                    \"bar\",\n                    \"bar\",\n                    \"bar\",\n                    \"baz\",", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_docstrings.py_0-45"}
{"title": "maxhumber_redframes-tests-test_docstrings.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_docstrings.py"], "line_no": 30, "start_line_no": 5, "end_line_no": 55, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "class TestDocstrings(unittest.TestCase):\n    def test_take(self):\n        df = rf.DataFrame({\"foo\": range(10)})\n        result1 = df.take(1)\n        result2 = df.take(-2)\n        expected1 = rf.DataFrame({\"foo\": [0]})\n        expected2 = rf.DataFrame({\"foo\": [8, 9]})\n        self.assertEqual(result1, expected1)\n        self.assertEqual(result2, expected2)\n\n    def test_accumulate(self):\n        df = rf.DataFrame({\"foo\": [1, 2, 3, 4]})\n        result = df.accumulate(\"foo\", into=\"cumsum\")\n        expected = rf.DataFrame({\"foo\": [1, 2, 3, 4], \"cumsum\": [1, 3, 6, 10]})\n        self.assertEqual(result, expected)\n\n    def test_gather(self):\n        df = rf.DataFrame(\n            {\n                \"foo\": [1, 2, 1, 2],\n                \"bar\": [\"A\", \"B\", \"C\", \"D\"],\n                \"baz\": [\"!\", \"@\", \"#\", \"$\"],\n                \"jaz\": range(4),\n            }\n        )\n        result1 = df.gather()\n        result2 = df.gather([\"foo\", \"bar\"], into=(\"var\", \"val\"))\n        result3 = df.group([\"foo\", \"bar\"]).gather(into=(\"variable\", \"value\"))\n        expected1 = rf.DataFrame(\n            {\n                \"variable\": [\n                    \"foo\",\n                    \"foo\",\n                    \"foo\",\n                    \"foo\",\n                    \"bar\",\n                    \"bar\",\n                    \"bar\",\n                    \"bar\",\n                    \"baz\",\n                    \"baz\",\n                    \"baz\",\n                    \"baz\",\n                    \"jaz\",\n                    \"jaz\",\n                    \"jaz\",\n                    \"jaz\",\n                ],\n                \"value\": [\n                    1,", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_docstrings.py_5-55"}
{"title": "maxhumber_redframes-tests-test_docstrings.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_docstrings.py"], "line_no": 40, "start_line_no": 15, "end_line_no": 65, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "    def test_accumulate(self):\n        df = rf.DataFrame({\"foo\": [1, 2, 3, 4]})\n        result = df.accumulate(\"foo\", into=\"cumsum\")\n        expected = rf.DataFrame({\"foo\": [1, 2, 3, 4], \"cumsum\": [1, 3, 6, 10]})\n        self.assertEqual(result, expected)\n\n    def test_gather(self):\n        df = rf.DataFrame(\n            {\n                \"foo\": [1, 2, 1, 2],\n                \"bar\": [\"A\", \"B\", \"C\", \"D\"],\n                \"baz\": [\"!\", \"@\", \"#\", \"$\"],\n                \"jaz\": range(4),\n            }\n        )\n        result1 = df.gather()\n        result2 = df.gather([\"foo\", \"bar\"], into=(\"var\", \"val\"))\n        result3 = df.group([\"foo\", \"bar\"]).gather(into=(\"variable\", \"value\"))\n        expected1 = rf.DataFrame(\n            {\n                \"variable\": [\n                    \"foo\",\n                    \"foo\",\n                    \"foo\",\n                    \"foo\",\n                    \"bar\",\n                    \"bar\",\n                    \"bar\",\n                    \"bar\",\n                    \"baz\",\n                    \"baz\",\n                    \"baz\",\n                    \"baz\",\n                    \"jaz\",\n                    \"jaz\",\n                    \"jaz\",\n                    \"jaz\",\n                ],\n                \"value\": [\n                    1,\n                    2,\n                    1,\n                    2,\n                    \"A\",\n                    \"B\",\n                    \"C\",\n                    \"D\",\n                    \"!\",\n                    \"@\",\n                    \"#\",", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_docstrings.py_15-65"}
{"title": "maxhumber_redframes-tests-test_docstrings.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_docstrings.py"], "line_no": 50, "start_line_no": 25, "end_line_no": 75, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "                \"bar\": [\"A\", \"B\", \"C\", \"D\"],\n                \"baz\": [\"!\", \"@\", \"#\", \"$\"],\n                \"jaz\": range(4),\n            }\n        )\n        result1 = df.gather()\n        result2 = df.gather([\"foo\", \"bar\"], into=(\"var\", \"val\"))\n        result3 = df.group([\"foo\", \"bar\"]).gather(into=(\"variable\", \"value\"))\n        expected1 = rf.DataFrame(\n            {\n                \"variable\": [\n                    \"foo\",\n                    \"foo\",\n                    \"foo\",\n                    \"foo\",\n                    \"bar\",\n                    \"bar\",\n                    \"bar\",\n                    \"bar\",\n                    \"baz\",\n                    \"baz\",\n                    \"baz\",\n                    \"baz\",\n                    \"jaz\",\n                    \"jaz\",\n                    \"jaz\",\n                    \"jaz\",\n                ],\n                \"value\": [\n                    1,\n                    2,\n                    1,\n                    2,\n                    \"A\",\n                    \"B\",\n                    \"C\",\n                    \"D\",\n                    \"!\",\n                    \"@\",\n                    \"#\",\n                    \"$\",\n                    0,\n                    1,\n                    2,\n                    3,\n                ],\n            }\n        )\n        expected2 = rf.DataFrame(\n            {", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_docstrings.py_25-75"}
{"title": "maxhumber_redframes-tests-test_docstrings.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_docstrings.py"], "line_no": 60, "start_line_no": 35, "end_line_no": 85, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "                \"variable\": [\n                    \"foo\",\n                    \"foo\",\n                    \"foo\",\n                    \"foo\",\n                    \"bar\",\n                    \"bar\",\n                    \"bar\",\n                    \"bar\",\n                    \"baz\",\n                    \"baz\",\n                    \"baz\",\n                    \"baz\",\n                    \"jaz\",\n                    \"jaz\",\n                    \"jaz\",\n                    \"jaz\",\n                ],\n                \"value\": [\n                    1,\n                    2,\n                    1,\n                    2,\n                    \"A\",\n                    \"B\",\n                    \"C\",\n                    \"D\",\n                    \"!\",\n                    \"@\",\n                    \"#\",\n                    \"$\",\n                    0,\n                    1,\n                    2,\n                    3,\n                ],\n            }\n        )\n        expected2 = rf.DataFrame(\n            {\n                \"baz\": [\"!\", \"@\", \"#\", \"$\", \"!\", \"@\", \"#\", \"$\"],\n                \"jaz\": [0, 1, 2, 3, 0, 1, 2, 3],\n                \"var\": [\"foo\", \"foo\", \"foo\", \"foo\", \"bar\", \"bar\", \"bar\", \"bar\"],\n                \"val\": [1, 2, 1, 2, \"A\", \"B\", \"C\", \"D\"],\n            }\n        )\n        expected3 = rf.DataFrame(\n            {\n                \"foo\": [1, 2, 1, 2, 1, 2, 1, 2],\n                \"bar\": [\"A\", \"B\", \"C\", \"D\", \"A\", \"B\", \"C\", \"D\"],", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_docstrings.py_35-85"}
{"title": "maxhumber_redframes-tests-test_docstrings.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_docstrings.py"], "line_no": 70, "start_line_no": 45, "end_line_no": 95, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "                    \"baz\",\n                    \"baz\",\n                    \"baz\",\n                    \"jaz\",\n                    \"jaz\",\n                    \"jaz\",\n                    \"jaz\",\n                ],\n                \"value\": [\n                    1,\n                    2,\n                    1,\n                    2,\n                    \"A\",\n                    \"B\",\n                    \"C\",\n                    \"D\",\n                    \"!\",\n                    \"@\",\n                    \"#\",\n                    \"$\",\n                    0,\n                    1,\n                    2,\n                    3,\n                ],\n            }\n        )\n        expected2 = rf.DataFrame(\n            {\n                \"baz\": [\"!\", \"@\", \"#\", \"$\", \"!\", \"@\", \"#\", \"$\"],\n                \"jaz\": [0, 1, 2, 3, 0, 1, 2, 3],\n                \"var\": [\"foo\", \"foo\", \"foo\", \"foo\", \"bar\", \"bar\", \"bar\", \"bar\"],\n                \"val\": [1, 2, 1, 2, \"A\", \"B\", \"C\", \"D\"],\n            }\n        )\n        expected3 = rf.DataFrame(\n            {\n                \"foo\": [1, 2, 1, 2, 1, 2, 1, 2],\n                \"bar\": [\"A\", \"B\", \"C\", \"D\", \"A\", \"B\", \"C\", \"D\"],\n                \"variable\": [\"baz\", \"baz\", \"baz\", \"baz\", \"jaz\", \"jaz\", \"jaz\", \"jaz\"],\n                \"value\": [\"!\", \"@\", \"#\", \"$\", 0, 1, 2, 3],\n            }\n        )\n        self.assertEqual(result1, expected1)\n        self.assertEqual(result2, expected2)\n        self.assertEqual(result3, expected3)\n\n    def test_pack(self):\n        df = rf.DataFrame(", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_docstrings.py_45-95"}
{"title": "maxhumber_redframes-tests-test_docstrings.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_docstrings.py"], "line_no": 80, "start_line_no": 55, "end_line_no": 105, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "                    2,\n                    1,\n                    2,\n                    \"A\",\n                    \"B\",\n                    \"C\",\n                    \"D\",\n                    \"!\",\n                    \"@\",\n                    \"#\",\n                    \"$\",\n                    0,\n                    1,\n                    2,\n                    3,\n                ],\n            }\n        )\n        expected2 = rf.DataFrame(\n            {\n                \"baz\": [\"!\", \"@\", \"#\", \"$\", \"!\", \"@\", \"#\", \"$\"],\n                \"jaz\": [0, 1, 2, 3, 0, 1, 2, 3],\n                \"var\": [\"foo\", \"foo\", \"foo\", \"foo\", \"bar\", \"bar\", \"bar\", \"bar\"],\n                \"val\": [1, 2, 1, 2, \"A\", \"B\", \"C\", \"D\"],\n            }\n        )\n        expected3 = rf.DataFrame(\n            {\n                \"foo\": [1, 2, 1, 2, 1, 2, 1, 2],\n                \"bar\": [\"A\", \"B\", \"C\", \"D\", \"A\", \"B\", \"C\", \"D\"],\n                \"variable\": [\"baz\", \"baz\", \"baz\", \"baz\", \"jaz\", \"jaz\", \"jaz\", \"jaz\"],\n                \"value\": [\"!\", \"@\", \"#\", \"$\", 0, 1, 2, 3],\n            }\n        )\n        self.assertEqual(result1, expected1)\n        self.assertEqual(result2, expected2)\n        self.assertEqual(result3, expected3)\n\n    def test_pack(self):\n        df = rf.DataFrame(\n            {\"foo\": [\"A\", \"A\", \"B\", \"A\", \"B\", \"C\"], \"bar\": [1, 2, 3, 4, 5, 6]}\n        )\n        result1 = df.pack(\"foo\", sep=\"+\")\n        result2 = df.group(\"foo\").pack(\"bar\", sep=\"|\")\n        expected1 = rf.DataFrame({\"foo\": [\"A+A+B+A+B+C\"]})\n        expected2 = rf.DataFrame({\"foo\": [\"A\", \"B\", \"C\"], \"bar\": [\"1|2|4\", \"3|5\", \"6\"]})\n        self.assertEqual(result1, expected1)\n        self.assertEqual(result2, expected2)\n\n    def test_rank(self):", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_docstrings.py_55-105"}
{"title": "maxhumber_redframes-tests-test_docstrings.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_docstrings.py"], "line_no": 90, "start_line_no": 65, "end_line_no": 115, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "                    \"$\",\n                    0,\n                    1,\n                    2,\n                    3,\n                ],\n            }\n        )\n        expected2 = rf.DataFrame(\n            {\n                \"baz\": [\"!\", \"@\", \"#\", \"$\", \"!\", \"@\", \"#\", \"$\"],\n                \"jaz\": [0, 1, 2, 3, 0, 1, 2, 3],\n                \"var\": [\"foo\", \"foo\", \"foo\", \"foo\", \"bar\", \"bar\", \"bar\", \"bar\"],\n                \"val\": [1, 2, 1, 2, \"A\", \"B\", \"C\", \"D\"],\n            }\n        )\n        expected3 = rf.DataFrame(\n            {\n                \"foo\": [1, 2, 1, 2, 1, 2, 1, 2],\n                \"bar\": [\"A\", \"B\", \"C\", \"D\", \"A\", \"B\", \"C\", \"D\"],\n                \"variable\": [\"baz\", \"baz\", \"baz\", \"baz\", \"jaz\", \"jaz\", \"jaz\", \"jaz\"],\n                \"value\": [\"!\", \"@\", \"#\", \"$\", 0, 1, 2, 3],\n            }\n        )\n        self.assertEqual(result1, expected1)\n        self.assertEqual(result2, expected2)\n        self.assertEqual(result3, expected3)\n\n    def test_pack(self):\n        df = rf.DataFrame(\n            {\"foo\": [\"A\", \"A\", \"B\", \"A\", \"B\", \"C\"], \"bar\": [1, 2, 3, 4, 5, 6]}\n        )\n        result1 = df.pack(\"foo\", sep=\"+\")\n        result2 = df.group(\"foo\").pack(\"bar\", sep=\"|\")\n        expected1 = rf.DataFrame({\"foo\": [\"A+A+B+A+B+C\"]})\n        expected2 = rf.DataFrame({\"foo\": [\"A\", \"B\", \"C\"], \"bar\": [\"1|2|4\", \"3|5\", \"6\"]})\n        self.assertEqual(result1, expected1)\n        self.assertEqual(result2, expected2)\n\n    def test_rank(self):\n        df = rf.DataFrame({\"foo\": [2, 3, 3, 99, 1000, 1, -6, 4]})\n        result = df.rank(\"foo\", into=\"rank\", descending=True)\n        expected = rf.DataFrame(\n            {\"foo\": [2, 3, 3, 99, 1000, 1, -6, 4], \"rank\": [5.0, 4, 4, 2, 1, 6, 7, 3]}\n        )\n        self.assertEqual(result, expected)\n\n    def test_rollup(self):\n        df = rf.DataFrame({\"foo\": [1, 2, 3, 4, 5], \"bar\": [99, 100, 1, -5, 2]})\n        result = df.rollup(", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_docstrings.py_65-115"}
{"title": "maxhumber_redframes-tests-test_docstrings.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_docstrings.py"], "line_no": 100, "start_line_no": 75, "end_line_no": 125, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "                \"baz\": [\"!\", \"@\", \"#\", \"$\", \"!\", \"@\", \"#\", \"$\"],\n                \"jaz\": [0, 1, 2, 3, 0, 1, 2, 3],\n                \"var\": [\"foo\", \"foo\", \"foo\", \"foo\", \"bar\", \"bar\", \"bar\", \"bar\"],\n                \"val\": [1, 2, 1, 2, \"A\", \"B\", \"C\", \"D\"],\n            }\n        )\n        expected3 = rf.DataFrame(\n            {\n                \"foo\": [1, 2, 1, 2, 1, 2, 1, 2],\n                \"bar\": [\"A\", \"B\", \"C\", \"D\", \"A\", \"B\", \"C\", \"D\"],\n                \"variable\": [\"baz\", \"baz\", \"baz\", \"baz\", \"jaz\", \"jaz\", \"jaz\", \"jaz\"],\n                \"value\": [\"!\", \"@\", \"#\", \"$\", 0, 1, 2, 3],\n            }\n        )\n        self.assertEqual(result1, expected1)\n        self.assertEqual(result2, expected2)\n        self.assertEqual(result3, expected3)\n\n    def test_pack(self):\n        df = rf.DataFrame(\n            {\"foo\": [\"A\", \"A\", \"B\", \"A\", \"B\", \"C\"], \"bar\": [1, 2, 3, 4, 5, 6]}\n        )\n        result1 = df.pack(\"foo\", sep=\"+\")\n        result2 = df.group(\"foo\").pack(\"bar\", sep=\"|\")\n        expected1 = rf.DataFrame({\"foo\": [\"A+A+B+A+B+C\"]})\n        expected2 = rf.DataFrame({\"foo\": [\"A\", \"B\", \"C\"], \"bar\": [\"1|2|4\", \"3|5\", \"6\"]})\n        self.assertEqual(result1, expected1)\n        self.assertEqual(result2, expected2)\n\n    def test_rank(self):\n        df = rf.DataFrame({\"foo\": [2, 3, 3, 99, 1000, 1, -6, 4]})\n        result = df.rank(\"foo\", into=\"rank\", descending=True)\n        expected = rf.DataFrame(\n            {\"foo\": [2, 3, 3, 99, 1000, 1, -6, 4], \"rank\": [5.0, 4, 4, 2, 1, 6, 7, 3]}\n        )\n        self.assertEqual(result, expected)\n\n    def test_rollup(self):\n        df = rf.DataFrame({\"foo\": [1, 2, 3, 4, 5], \"bar\": [99, 100, 1, -5, 2]})\n        result = df.rollup(\n            {\n                \"fcount\": (\"foo\", rf.stat.count),\n                \"fmean\": (\"foo\", rf.stat.mean),\n                \"fsum\": (\"foo\", rf.stat.sum),\n                \"fmax\": (\"foo\", rf.stat.max),\n                \"bmedian\": (\"bar\", rf.stat.median),\n                \"bmin\": (\"bar\", rf.stat.min),\n                \"bstd\": (\"bar\", rf.stat.std),\n            }\n        )", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_docstrings.py_75-125"}
{"title": "maxhumber_redframes-tests-test_docstrings.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_docstrings.py"], "line_no": 110, "start_line_no": 85, "end_line_no": 135, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "                \"variable\": [\"baz\", \"baz\", \"baz\", \"baz\", \"jaz\", \"jaz\", \"jaz\", \"jaz\"],\n                \"value\": [\"!\", \"@\", \"#\", \"$\", 0, 1, 2, 3],\n            }\n        )\n        self.assertEqual(result1, expected1)\n        self.assertEqual(result2, expected2)\n        self.assertEqual(result3, expected3)\n\n    def test_pack(self):\n        df = rf.DataFrame(\n            {\"foo\": [\"A\", \"A\", \"B\", \"A\", \"B\", \"C\"], \"bar\": [1, 2, 3, 4, 5, 6]}\n        )\n        result1 = df.pack(\"foo\", sep=\"+\")\n        result2 = df.group(\"foo\").pack(\"bar\", sep=\"|\")\n        expected1 = rf.DataFrame({\"foo\": [\"A+A+B+A+B+C\"]})\n        expected2 = rf.DataFrame({\"foo\": [\"A\", \"B\", \"C\"], \"bar\": [\"1|2|4\", \"3|5\", \"6\"]})\n        self.assertEqual(result1, expected1)\n        self.assertEqual(result2, expected2)\n\n    def test_rank(self):\n        df = rf.DataFrame({\"foo\": [2, 3, 3, 99, 1000, 1, -6, 4]})\n        result = df.rank(\"foo\", into=\"rank\", descending=True)\n        expected = rf.DataFrame(\n            {\"foo\": [2, 3, 3, 99, 1000, 1, -6, 4], \"rank\": [5.0, 4, 4, 2, 1, 6, 7, 3]}\n        )\n        self.assertEqual(result, expected)\n\n    def test_rollup(self):\n        df = rf.DataFrame({\"foo\": [1, 2, 3, 4, 5], \"bar\": [99, 100, 1, -5, 2]})\n        result = df.rollup(\n            {\n                \"fcount\": (\"foo\", rf.stat.count),\n                \"fmean\": (\"foo\", rf.stat.mean),\n                \"fsum\": (\"foo\", rf.stat.sum),\n                \"fmax\": (\"foo\", rf.stat.max),\n                \"bmedian\": (\"bar\", rf.stat.median),\n                \"bmin\": (\"bar\", rf.stat.min),\n                \"bstd\": (\"bar\", rf.stat.std),\n            }\n        )\n        expected = rf.DataFrame(\n            {\n                \"fcount\": [5.0],\n                \"fmean\": [3.0],\n                \"fsum\": [15.0],\n                \"fmax\": [5.0],\n                \"bmedian\": [2.0],\n                \"bmin\": [-5.0],\n                \"bstd\": [54.929955397760885],\n            }", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_docstrings.py_85-135"}
{"title": "maxhumber_redframes-tests-test_docstrings.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_docstrings.py"], "line_no": 120, "start_line_no": 95, "end_line_no": 145, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "            {\"foo\": [\"A\", \"A\", \"B\", \"A\", \"B\", \"C\"], \"bar\": [1, 2, 3, 4, 5, 6]}\n        )\n        result1 = df.pack(\"foo\", sep=\"+\")\n        result2 = df.group(\"foo\").pack(\"bar\", sep=\"|\")\n        expected1 = rf.DataFrame({\"foo\": [\"A+A+B+A+B+C\"]})\n        expected2 = rf.DataFrame({\"foo\": [\"A\", \"B\", \"C\"], \"bar\": [\"1|2|4\", \"3|5\", \"6\"]})\n        self.assertEqual(result1, expected1)\n        self.assertEqual(result2, expected2)\n\n    def test_rank(self):\n        df = rf.DataFrame({\"foo\": [2, 3, 3, 99, 1000, 1, -6, 4]})\n        result = df.rank(\"foo\", into=\"rank\", descending=True)\n        expected = rf.DataFrame(\n            {\"foo\": [2, 3, 3, 99, 1000, 1, -6, 4], \"rank\": [5.0, 4, 4, 2, 1, 6, 7, 3]}\n        )\n        self.assertEqual(result, expected)\n\n    def test_rollup(self):\n        df = rf.DataFrame({\"foo\": [1, 2, 3, 4, 5], \"bar\": [99, 100, 1, -5, 2]})\n        result = df.rollup(\n            {\n                \"fcount\": (\"foo\", rf.stat.count),\n                \"fmean\": (\"foo\", rf.stat.mean),\n                \"fsum\": (\"foo\", rf.stat.sum),\n                \"fmax\": (\"foo\", rf.stat.max),\n                \"bmedian\": (\"bar\", rf.stat.median),\n                \"bmin\": (\"bar\", rf.stat.min),\n                \"bstd\": (\"bar\", rf.stat.std),\n            }\n        )\n        expected = rf.DataFrame(\n            {\n                \"fcount\": [5.0],\n                \"fmean\": [3.0],\n                \"fsum\": [15.0],\n                \"fmax\": [5.0],\n                \"bmedian\": [2.0],\n                \"bmin\": [-5.0],\n                \"bstd\": [54.929955397760885],\n            }\n        )\n        self.assertEqual(result, expected)\n\n    def test_init(self):\n        rf.DataFrame({\"foo\": [1, 2], \"bar\": [\"A\", \"B\"]})\n        self.assertTrue(True)\n\n    def test_eq(self):\n        adf = rf.DataFrame({\"foo\": [1]})\n        bdf = rf.DataFrame({\"bar\": [1]})", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_docstrings.py_95-145"}
{"title": "maxhumber_redframes-tests-test_docstrings.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_docstrings.py"], "line_no": 130, "start_line_no": 105, "end_line_no": 155, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        df = rf.DataFrame({\"foo\": [2, 3, 3, 99, 1000, 1, -6, 4]})\n        result = df.rank(\"foo\", into=\"rank\", descending=True)\n        expected = rf.DataFrame(\n            {\"foo\": [2, 3, 3, 99, 1000, 1, -6, 4], \"rank\": [5.0, 4, 4, 2, 1, 6, 7, 3]}\n        )\n        self.assertEqual(result, expected)\n\n    def test_rollup(self):\n        df = rf.DataFrame({\"foo\": [1, 2, 3, 4, 5], \"bar\": [99, 100, 1, -5, 2]})\n        result = df.rollup(\n            {\n                \"fcount\": (\"foo\", rf.stat.count),\n                \"fmean\": (\"foo\", rf.stat.mean),\n                \"fsum\": (\"foo\", rf.stat.sum),\n                \"fmax\": (\"foo\", rf.stat.max),\n                \"bmedian\": (\"bar\", rf.stat.median),\n                \"bmin\": (\"bar\", rf.stat.min),\n                \"bstd\": (\"bar\", rf.stat.std),\n            }\n        )\n        expected = rf.DataFrame(\n            {\n                \"fcount\": [5.0],\n                \"fmean\": [3.0],\n                \"fsum\": [15.0],\n                \"fmax\": [5.0],\n                \"bmedian\": [2.0],\n                \"bmin\": [-5.0],\n                \"bstd\": [54.929955397760885],\n            }\n        )\n        self.assertEqual(result, expected)\n\n    def test_init(self):\n        rf.DataFrame({\"foo\": [1, 2], \"bar\": [\"A\", \"B\"]})\n        self.assertTrue(True)\n\n    def test_eq(self):\n        adf = rf.DataFrame({\"foo\": [1]})\n        bdf = rf.DataFrame({\"bar\": [1]})\n        cdf = rf.DataFrame({\"foo\": [1]})\n        self.assertFalse(adf == bdf)\n        self.assertTrue(adf == cdf)\n\n    def test_getitem(self):\n        df = rf.DataFrame({\"foo\": [1, 2], \"bar\": [\"A\", \"B\"]})\n        result = df[\"foo\"]\n        expected = [1, 2]\n        self.assertEqual(result, expected)\n", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_docstrings.py_105-155"}
{"title": "maxhumber_redframes-tests-test_docstrings.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_docstrings.py"], "line_no": 140, "start_line_no": 115, "end_line_no": 165, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "            {\n                \"fcount\": (\"foo\", rf.stat.count),\n                \"fmean\": (\"foo\", rf.stat.mean),\n                \"fsum\": (\"foo\", rf.stat.sum),\n                \"fmax\": (\"foo\", rf.stat.max),\n                \"bmedian\": (\"bar\", rf.stat.median),\n                \"bmin\": (\"bar\", rf.stat.min),\n                \"bstd\": (\"bar\", rf.stat.std),\n            }\n        )\n        expected = rf.DataFrame(\n            {\n                \"fcount\": [5.0],\n                \"fmean\": [3.0],\n                \"fsum\": [15.0],\n                \"fmax\": [5.0],\n                \"bmedian\": [2.0],\n                \"bmin\": [-5.0],\n                \"bstd\": [54.929955397760885],\n            }\n        )\n        self.assertEqual(result, expected)\n\n    def test_init(self):\n        rf.DataFrame({\"foo\": [1, 2], \"bar\": [\"A\", \"B\"]})\n        self.assertTrue(True)\n\n    def test_eq(self):\n        adf = rf.DataFrame({\"foo\": [1]})\n        bdf = rf.DataFrame({\"bar\": [1]})\n        cdf = rf.DataFrame({\"foo\": [1]})\n        self.assertFalse(adf == bdf)\n        self.assertTrue(adf == cdf)\n\n    def test_getitem(self):\n        df = rf.DataFrame({\"foo\": [1, 2], \"bar\": [\"A\", \"B\"]})\n        result = df[\"foo\"]\n        expected = [1, 2]\n        self.assertEqual(result, expected)\n\n    def test_str(self):\n        df = rf.DataFrame({\"foo\": [1, 2], \"bar\": [\"A\", \"B\"]})\n        result = str(df)\n        expected = \"rf.DataFrame({'foo': [1, 2], 'bar': ['A', 'B']})\"\n        self.assertEqual(result, expected)\n\n    def test_columns(self):\n        df = rf.DataFrame({\"foo\": [1, 2], \"bar\": [\"A\", \"B\"], \"baz\": [True, False]})\n        result = df.columns\n        expected = [\"foo\", \"bar\", \"baz\"]", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_docstrings.py_115-165"}
{"title": "maxhumber_redframes-tests-test_docstrings.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_docstrings.py"], "line_no": 150, "start_line_no": 125, "end_line_no": 175, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        expected = rf.DataFrame(\n            {\n                \"fcount\": [5.0],\n                \"fmean\": [3.0],\n                \"fsum\": [15.0],\n                \"fmax\": [5.0],\n                \"bmedian\": [2.0],\n                \"bmin\": [-5.0],\n                \"bstd\": [54.929955397760885],\n            }\n        )\n        self.assertEqual(result, expected)\n\n    def test_init(self):\n        rf.DataFrame({\"foo\": [1, 2], \"bar\": [\"A\", \"B\"]})\n        self.assertTrue(True)\n\n    def test_eq(self):\n        adf = rf.DataFrame({\"foo\": [1]})\n        bdf = rf.DataFrame({\"bar\": [1]})\n        cdf = rf.DataFrame({\"foo\": [1]})\n        self.assertFalse(adf == bdf)\n        self.assertTrue(adf == cdf)\n\n    def test_getitem(self):\n        df = rf.DataFrame({\"foo\": [1, 2], \"bar\": [\"A\", \"B\"]})\n        result = df[\"foo\"]\n        expected = [1, 2]\n        self.assertEqual(result, expected)\n\n    def test_str(self):\n        df = rf.DataFrame({\"foo\": [1, 2], \"bar\": [\"A\", \"B\"]})\n        result = str(df)\n        expected = \"rf.DataFrame({'foo': [1, 2], 'bar': ['A', 'B']})\"\n        self.assertEqual(result, expected)\n\n    def test_columns(self):\n        df = rf.DataFrame({\"foo\": [1, 2], \"bar\": [\"A\", \"B\"], \"baz\": [True, False]})\n        result = df.columns\n        expected = [\"foo\", \"bar\", \"baz\"]\n        self.assertEqual(result, expected)\n\n    def test_dimensions(self):\n        df = rf.DataFrame({\"foo\": range(10), \"bar\": range(10, 20)})\n        result = df.dimensions\n        expected = {\"rows\": 10, \"columns\": 2}\n        self.assertEqual(result, expected)\n\n    def test_empty(self):\n        df = rf.DataFrame()", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_docstrings.py_125-175"}
{"title": "maxhumber_redframes-tests-test_docstrings.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_docstrings.py"], "line_no": 160, "start_line_no": 135, "end_line_no": 185, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        )\n        self.assertEqual(result, expected)\n\n    def test_init(self):\n        rf.DataFrame({\"foo\": [1, 2], \"bar\": [\"A\", \"B\"]})\n        self.assertTrue(True)\n\n    def test_eq(self):\n        adf = rf.DataFrame({\"foo\": [1]})\n        bdf = rf.DataFrame({\"bar\": [1]})\n        cdf = rf.DataFrame({\"foo\": [1]})\n        self.assertFalse(adf == bdf)\n        self.assertTrue(adf == cdf)\n\n    def test_getitem(self):\n        df = rf.DataFrame({\"foo\": [1, 2], \"bar\": [\"A\", \"B\"]})\n        result = df[\"foo\"]\n        expected = [1, 2]\n        self.assertEqual(result, expected)\n\n    def test_str(self):\n        df = rf.DataFrame({\"foo\": [1, 2], \"bar\": [\"A\", \"B\"]})\n        result = str(df)\n        expected = \"rf.DataFrame({'foo': [1, 2], 'bar': ['A', 'B']})\"\n        self.assertEqual(result, expected)\n\n    def test_columns(self):\n        df = rf.DataFrame({\"foo\": [1, 2], \"bar\": [\"A\", \"B\"], \"baz\": [True, False]})\n        result = df.columns\n        expected = [\"foo\", \"bar\", \"baz\"]\n        self.assertEqual(result, expected)\n\n    def test_dimensions(self):\n        df = rf.DataFrame({\"foo\": range(10), \"bar\": range(10, 20)})\n        result = df.dimensions\n        expected = {\"rows\": 10, \"columns\": 2}\n        self.assertEqual(result, expected)\n\n    def test_empty(self):\n        df = rf.DataFrame()\n        result = df.empty\n        expected = True\n        self.assertEqual(result, expected)\n\n    def test_memory(self):\n        df = rf.DataFrame({\"foo\": [1, 2, 3], \"bar\": [\"A\", \"B\", \"C\"]})\n        result = df.memory\n        expected = \"326 B\"\n        self.assertEqual(result, expected)\n", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_docstrings.py_135-185"}
{"title": "maxhumber_redframes-tests-test_docstrings.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_docstrings.py"], "line_no": 170, "start_line_no": 145, "end_line_no": 195, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        cdf = rf.DataFrame({\"foo\": [1]})\n        self.assertFalse(adf == bdf)\n        self.assertTrue(adf == cdf)\n\n    def test_getitem(self):\n        df = rf.DataFrame({\"foo\": [1, 2], \"bar\": [\"A\", \"B\"]})\n        result = df[\"foo\"]\n        expected = [1, 2]\n        self.assertEqual(result, expected)\n\n    def test_str(self):\n        df = rf.DataFrame({\"foo\": [1, 2], \"bar\": [\"A\", \"B\"]})\n        result = str(df)\n        expected = \"rf.DataFrame({'foo': [1, 2], 'bar': ['A', 'B']})\"\n        self.assertEqual(result, expected)\n\n    def test_columns(self):\n        df = rf.DataFrame({\"foo\": [1, 2], \"bar\": [\"A\", \"B\"], \"baz\": [True, False]})\n        result = df.columns\n        expected = [\"foo\", \"bar\", \"baz\"]\n        self.assertEqual(result, expected)\n\n    def test_dimensions(self):\n        df = rf.DataFrame({\"foo\": range(10), \"bar\": range(10, 20)})\n        result = df.dimensions\n        expected = {\"rows\": 10, \"columns\": 2}\n        self.assertEqual(result, expected)\n\n    def test_empty(self):\n        df = rf.DataFrame()\n        result = df.empty\n        expected = True\n        self.assertEqual(result, expected)\n\n    def test_memory(self):\n        df = rf.DataFrame({\"foo\": [1, 2, 3], \"bar\": [\"A\", \"B\", \"C\"]})\n        result = df.memory\n        expected = \"326 B\"\n        self.assertEqual(result, expected)\n\n    def test_types(self):\n        df = rf.DataFrame({\"foo\": [1, 2], \"bar\": [\"A\", \"B\"], \"baz\": [True, False]})\n        result = df.types\n        expected = {\"foo\": int, \"bar\": object, \"baz\": bool}\n        self.assertEqual(result, expected)\n\n    def test_append(self):\n        df1 = rf.DataFrame({\"foo\": [1, 2], \"bar\": [\"A\", \"B\"]})\n        df2 = rf.DataFrame({\"bar\": [\"C\", \"D\"], \"foo\": [3, 4], \"baz\": [\"$\", \"@\"]})\n        result = df1.append(df2)", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_docstrings.py_145-195"}
{"title": "maxhumber_redframes-tests-test_docstrings.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_docstrings.py"], "line_no": 180, "start_line_no": 155, "end_line_no": 205, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "    def test_str(self):\n        df = rf.DataFrame({\"foo\": [1, 2], \"bar\": [\"A\", \"B\"]})\n        result = str(df)\n        expected = \"rf.DataFrame({'foo': [1, 2], 'bar': ['A', 'B']})\"\n        self.assertEqual(result, expected)\n\n    def test_columns(self):\n        df = rf.DataFrame({\"foo\": [1, 2], \"bar\": [\"A\", \"B\"], \"baz\": [True, False]})\n        result = df.columns\n        expected = [\"foo\", \"bar\", \"baz\"]\n        self.assertEqual(result, expected)\n\n    def test_dimensions(self):\n        df = rf.DataFrame({\"foo\": range(10), \"bar\": range(10, 20)})\n        result = df.dimensions\n        expected = {\"rows\": 10, \"columns\": 2}\n        self.assertEqual(result, expected)\n\n    def test_empty(self):\n        df = rf.DataFrame()\n        result = df.empty\n        expected = True\n        self.assertEqual(result, expected)\n\n    def test_memory(self):\n        df = rf.DataFrame({\"foo\": [1, 2, 3], \"bar\": [\"A\", \"B\", \"C\"]})\n        result = df.memory\n        expected = \"326 B\"\n        self.assertEqual(result, expected)\n\n    def test_types(self):\n        df = rf.DataFrame({\"foo\": [1, 2], \"bar\": [\"A\", \"B\"], \"baz\": [True, False]})\n        result = df.types\n        expected = {\"foo\": int, \"bar\": object, \"baz\": bool}\n        self.assertEqual(result, expected)\n\n    def test_append(self):\n        df1 = rf.DataFrame({\"foo\": [1, 2], \"bar\": [\"A\", \"B\"]})\n        df2 = rf.DataFrame({\"bar\": [\"C\", \"D\"], \"foo\": [3, 4], \"baz\": [\"$\", \"@\"]})\n        result = df1.append(df2)\n        expected = rf.DataFrame(\n            {\n                \"foo\": [1, 2, 3, 4],\n                \"bar\": [\"A\", \"B\", \"C\", \"D\"],\n                \"baz\": [None, None, \"$\", \"@\"],\n            }\n        )\n        self.assertEqual(result, expected)\n\n    def test_combine(self):", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_docstrings.py_155-205"}
{"title": "maxhumber_redframes-tests-test_docstrings.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_docstrings.py"], "line_no": 190, "start_line_no": 165, "end_line_no": 215, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        self.assertEqual(result, expected)\n\n    def test_dimensions(self):\n        df = rf.DataFrame({\"foo\": range(10), \"bar\": range(10, 20)})\n        result = df.dimensions\n        expected = {\"rows\": 10, \"columns\": 2}\n        self.assertEqual(result, expected)\n\n    def test_empty(self):\n        df = rf.DataFrame()\n        result = df.empty\n        expected = True\n        self.assertEqual(result, expected)\n\n    def test_memory(self):\n        df = rf.DataFrame({\"foo\": [1, 2, 3], \"bar\": [\"A\", \"B\", \"C\"]})\n        result = df.memory\n        expected = \"326 B\"\n        self.assertEqual(result, expected)\n\n    def test_types(self):\n        df = rf.DataFrame({\"foo\": [1, 2], \"bar\": [\"A\", \"B\"], \"baz\": [True, False]})\n        result = df.types\n        expected = {\"foo\": int, \"bar\": object, \"baz\": bool}\n        self.assertEqual(result, expected)\n\n    def test_append(self):\n        df1 = rf.DataFrame({\"foo\": [1, 2], \"bar\": [\"A\", \"B\"]})\n        df2 = rf.DataFrame({\"bar\": [\"C\", \"D\"], \"foo\": [3, 4], \"baz\": [\"$\", \"@\"]})\n        result = df1.append(df2)\n        expected = rf.DataFrame(\n            {\n                \"foo\": [1, 2, 3, 4],\n                \"bar\": [\"A\", \"B\", \"C\", \"D\"],\n                \"baz\": [None, None, \"$\", \"@\"],\n            }\n        )\n        self.assertEqual(result, expected)\n\n    def test_combine(self):\n        df = rf.DataFrame({\"foo\": [1, 2], \"bar\": [\"A\", \"B\"]})\n        result = df.combine([\"bar\", \"foo\"], into=\"baz\", sep=\"::\", drop=True)\n        expected = rf.DataFrame({\"baz\": [\"A::1\", \"B::2\"]})\n        self.assertEqual(result, expected)\n\n    def test_cross(self):\n        df = rf.DataFrame({\"foo\": [\"a\", \"b\", \"c\"], \"bar\": [1, 2, 3]})\n        dfa = rf.DataFrame({\"foo\": [1, 2, 3]})\n        dfb = rf.DataFrame({\"bar\": [1, 2, 3]})\n        result1 = df.cross()", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_docstrings.py_165-215"}
{"title": "maxhumber_redframes-tests-test_docstrings.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_docstrings.py"], "line_no": 200, "start_line_no": 175, "end_line_no": 225, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        result = df.empty\n        expected = True\n        self.assertEqual(result, expected)\n\n    def test_memory(self):\n        df = rf.DataFrame({\"foo\": [1, 2, 3], \"bar\": [\"A\", \"B\", \"C\"]})\n        result = df.memory\n        expected = \"326 B\"\n        self.assertEqual(result, expected)\n\n    def test_types(self):\n        df = rf.DataFrame({\"foo\": [1, 2], \"bar\": [\"A\", \"B\"], \"baz\": [True, False]})\n        result = df.types\n        expected = {\"foo\": int, \"bar\": object, \"baz\": bool}\n        self.assertEqual(result, expected)\n\n    def test_append(self):\n        df1 = rf.DataFrame({\"foo\": [1, 2], \"bar\": [\"A\", \"B\"]})\n        df2 = rf.DataFrame({\"bar\": [\"C\", \"D\"], \"foo\": [3, 4], \"baz\": [\"$\", \"@\"]})\n        result = df1.append(df2)\n        expected = rf.DataFrame(\n            {\n                \"foo\": [1, 2, 3, 4],\n                \"bar\": [\"A\", \"B\", \"C\", \"D\"],\n                \"baz\": [None, None, \"$\", \"@\"],\n            }\n        )\n        self.assertEqual(result, expected)\n\n    def test_combine(self):\n        df = rf.DataFrame({\"foo\": [1, 2], \"bar\": [\"A\", \"B\"]})\n        result = df.combine([\"bar\", \"foo\"], into=\"baz\", sep=\"::\", drop=True)\n        expected = rf.DataFrame({\"baz\": [\"A::1\", \"B::2\"]})\n        self.assertEqual(result, expected)\n\n    def test_cross(self):\n        df = rf.DataFrame({\"foo\": [\"a\", \"b\", \"c\"], \"bar\": [1, 2, 3]})\n        dfa = rf.DataFrame({\"foo\": [1, 2, 3]})\n        dfb = rf.DataFrame({\"bar\": [1, 2, 3]})\n        result1 = df.cross()\n        result2 = dfa.cross(dfb, postfix=(\"_a\", \"_b\"))\n        expected1 = rf.DataFrame(\n            {\n                \"foo_lhs\": [\"a\", \"a\", \"a\", \"b\", \"b\", \"b\", \"c\", \"c\", \"c\"],\n                \"bar_lhs\": [1, 1, 1, 2, 2, 2, 3, 3, 3],\n                \"foo_rhs\": [\"a\", \"b\", \"c\", \"a\", \"b\", \"c\", \"a\", \"b\", \"c\"],\n                \"bar_rhs\": [1, 2, 3, 1, 2, 3, 1, 2, 3],\n            }\n        )\n        expected2 = rf.DataFrame(", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_docstrings.py_175-225"}
{"title": "maxhumber_redframes-tests-test_docstrings.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_docstrings.py"], "line_no": 210, "start_line_no": 185, "end_line_no": 235, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "    def test_types(self):\n        df = rf.DataFrame({\"foo\": [1, 2], \"bar\": [\"A\", \"B\"], \"baz\": [True, False]})\n        result = df.types\n        expected = {\"foo\": int, \"bar\": object, \"baz\": bool}\n        self.assertEqual(result, expected)\n\n    def test_append(self):\n        df1 = rf.DataFrame({\"foo\": [1, 2], \"bar\": [\"A\", \"B\"]})\n        df2 = rf.DataFrame({\"bar\": [\"C\", \"D\"], \"foo\": [3, 4], \"baz\": [\"$\", \"@\"]})\n        result = df1.append(df2)\n        expected = rf.DataFrame(\n            {\n                \"foo\": [1, 2, 3, 4],\n                \"bar\": [\"A\", \"B\", \"C\", \"D\"],\n                \"baz\": [None, None, \"$\", \"@\"],\n            }\n        )\n        self.assertEqual(result, expected)\n\n    def test_combine(self):\n        df = rf.DataFrame({\"foo\": [1, 2], \"bar\": [\"A\", \"B\"]})\n        result = df.combine([\"bar\", \"foo\"], into=\"baz\", sep=\"::\", drop=True)\n        expected = rf.DataFrame({\"baz\": [\"A::1\", \"B::2\"]})\n        self.assertEqual(result, expected)\n\n    def test_cross(self):\n        df = rf.DataFrame({\"foo\": [\"a\", \"b\", \"c\"], \"bar\": [1, 2, 3]})\n        dfa = rf.DataFrame({\"foo\": [1, 2, 3]})\n        dfb = rf.DataFrame({\"bar\": [1, 2, 3]})\n        result1 = df.cross()\n        result2 = dfa.cross(dfb, postfix=(\"_a\", \"_b\"))\n        expected1 = rf.DataFrame(\n            {\n                \"foo_lhs\": [\"a\", \"a\", \"a\", \"b\", \"b\", \"b\", \"c\", \"c\", \"c\"],\n                \"bar_lhs\": [1, 1, 1, 2, 2, 2, 3, 3, 3],\n                \"foo_rhs\": [\"a\", \"b\", \"c\", \"a\", \"b\", \"c\", \"a\", \"b\", \"c\"],\n                \"bar_rhs\": [1, 2, 3, 1, 2, 3, 1, 2, 3],\n            }\n        )\n        expected2 = rf.DataFrame(\n            {\"foo\": [1, 1, 1, 2, 2, 2, 3, 3, 3], \"bar\": [1, 2, 3, 1, 2, 3, 1, 2, 3]}\n        )\n        self.assertEqual(result1, expected1)\n        self.assertEqual(result2, expected2)\n\n    def test_dedupe(self):\n        df = rf.DataFrame({\"foo\": [1, 1, 2, 2], \"bar\": [\"A\", \"A\", \"B\", \"A\"]})\n        result1 = df.dedupe()\n        result2 = df.dedupe(\"foo\")\n        result3 = df.dedupe([\"foo\", \"bar\"])", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_docstrings.py_185-235"}
{"title": "maxhumber_redframes-tests-test_docstrings.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_docstrings.py"], "line_no": 220, "start_line_no": 195, "end_line_no": 245, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        expected = rf.DataFrame(\n            {\n                \"foo\": [1, 2, 3, 4],\n                \"bar\": [\"A\", \"B\", \"C\", \"D\"],\n                \"baz\": [None, None, \"$\", \"@\"],\n            }\n        )\n        self.assertEqual(result, expected)\n\n    def test_combine(self):\n        df = rf.DataFrame({\"foo\": [1, 2], \"bar\": [\"A\", \"B\"]})\n        result = df.combine([\"bar\", \"foo\"], into=\"baz\", sep=\"::\", drop=True)\n        expected = rf.DataFrame({\"baz\": [\"A::1\", \"B::2\"]})\n        self.assertEqual(result, expected)\n\n    def test_cross(self):\n        df = rf.DataFrame({\"foo\": [\"a\", \"b\", \"c\"], \"bar\": [1, 2, 3]})\n        dfa = rf.DataFrame({\"foo\": [1, 2, 3]})\n        dfb = rf.DataFrame({\"bar\": [1, 2, 3]})\n        result1 = df.cross()\n        result2 = dfa.cross(dfb, postfix=(\"_a\", \"_b\"))\n        expected1 = rf.DataFrame(\n            {\n                \"foo_lhs\": [\"a\", \"a\", \"a\", \"b\", \"b\", \"b\", \"c\", \"c\", \"c\"],\n                \"bar_lhs\": [1, 1, 1, 2, 2, 2, 3, 3, 3],\n                \"foo_rhs\": [\"a\", \"b\", \"c\", \"a\", \"b\", \"c\", \"a\", \"b\", \"c\"],\n                \"bar_rhs\": [1, 2, 3, 1, 2, 3, 1, 2, 3],\n            }\n        )\n        expected2 = rf.DataFrame(\n            {\"foo\": [1, 1, 1, 2, 2, 2, 3, 3, 3], \"bar\": [1, 2, 3, 1, 2, 3, 1, 2, 3]}\n        )\n        self.assertEqual(result1, expected1)\n        self.assertEqual(result2, expected2)\n\n    def test_dedupe(self):\n        df = rf.DataFrame({\"foo\": [1, 1, 2, 2], \"bar\": [\"A\", \"A\", \"B\", \"A\"]})\n        result1 = df.dedupe()\n        result2 = df.dedupe(\"foo\")\n        result3 = df.dedupe([\"foo\", \"bar\"])\n        expected1 = rf.DataFrame({\"foo\": [1, 2, 2], \"bar\": [\"A\", \"B\", \"A\"]})\n        expected2 = rf.DataFrame({\"foo\": [1, 2], \"bar\": [\"A\", \"B\"]})\n        expected3 = rf.DataFrame({\"foo\": [1, 2, 2], \"bar\": [\"A\", \"B\", \"A\"]})\n        self.assertEqual(result1, expected1)\n        self.assertEqual(result2, expected2)\n        self.assertEqual(result3, expected3)\n\n    def test_denix(self):\n        df = rf.DataFrame(\n            {\"foo\": [1, None, 3, None, 5, 6], \"bar\": [1, None, 3, 4, None, None]}", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_docstrings.py_195-245"}
{"title": "maxhumber_redframes-tests-test_docstrings.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_docstrings.py"], "line_no": 230, "start_line_no": 205, "end_line_no": 255, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        df = rf.DataFrame({\"foo\": [1, 2], \"bar\": [\"A\", \"B\"]})\n        result = df.combine([\"bar\", \"foo\"], into=\"baz\", sep=\"::\", drop=True)\n        expected = rf.DataFrame({\"baz\": [\"A::1\", \"B::2\"]})\n        self.assertEqual(result, expected)\n\n    def test_cross(self):\n        df = rf.DataFrame({\"foo\": [\"a\", \"b\", \"c\"], \"bar\": [1, 2, 3]})\n        dfa = rf.DataFrame({\"foo\": [1, 2, 3]})\n        dfb = rf.DataFrame({\"bar\": [1, 2, 3]})\n        result1 = df.cross()\n        result2 = dfa.cross(dfb, postfix=(\"_a\", \"_b\"))\n        expected1 = rf.DataFrame(\n            {\n                \"foo_lhs\": [\"a\", \"a\", \"a\", \"b\", \"b\", \"b\", \"c\", \"c\", \"c\"],\n                \"bar_lhs\": [1, 1, 1, 2, 2, 2, 3, 3, 3],\n                \"foo_rhs\": [\"a\", \"b\", \"c\", \"a\", \"b\", \"c\", \"a\", \"b\", \"c\"],\n                \"bar_rhs\": [1, 2, 3, 1, 2, 3, 1, 2, 3],\n            }\n        )\n        expected2 = rf.DataFrame(\n            {\"foo\": [1, 1, 1, 2, 2, 2, 3, 3, 3], \"bar\": [1, 2, 3, 1, 2, 3, 1, 2, 3]}\n        )\n        self.assertEqual(result1, expected1)\n        self.assertEqual(result2, expected2)\n\n    def test_dedupe(self):\n        df = rf.DataFrame({\"foo\": [1, 1, 2, 2], \"bar\": [\"A\", \"A\", \"B\", \"A\"]})\n        result1 = df.dedupe()\n        result2 = df.dedupe(\"foo\")\n        result3 = df.dedupe([\"foo\", \"bar\"])\n        expected1 = rf.DataFrame({\"foo\": [1, 2, 2], \"bar\": [\"A\", \"B\", \"A\"]})\n        expected2 = rf.DataFrame({\"foo\": [1, 2], \"bar\": [\"A\", \"B\"]})\n        expected3 = rf.DataFrame({\"foo\": [1, 2, 2], \"bar\": [\"A\", \"B\", \"A\"]})\n        self.assertEqual(result1, expected1)\n        self.assertEqual(result2, expected2)\n        self.assertEqual(result3, expected3)\n\n    def test_denix(self):\n        df = rf.DataFrame(\n            {\"foo\": [1, None, 3, None, 5, 6], \"bar\": [1, None, 3, 4, None, None]}\n        )\n        result1 = df.denix()\n        result2 = df.denix(\"bar\")\n        result3 = df.denix([\"foo\", \"bar\"])\n        expected1 = rf.DataFrame({\"foo\": [1.0, 3.0], \"bar\": [1.0, 3.0]})\n        expected2 = rf.DataFrame({\"foo\": [1.0, 3.0, None], \"bar\": [1.0, 3.0, 4.0]})\n        expected3 = rf.DataFrame({\"foo\": [1.0, 3.0], \"bar\": [1.0, 3.0]})\n        self.assertEqual(result1, expected1)\n        self.assertEqual(result2, expected2)\n        self.assertEqual(result3, expected3)", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_docstrings.py_205-255"}
{"title": "maxhumber_redframes-tests-test_docstrings.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_docstrings.py"], "line_no": 240, "start_line_no": 215, "end_line_no": 265, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        result2 = dfa.cross(dfb, postfix=(\"_a\", \"_b\"))\n        expected1 = rf.DataFrame(\n            {\n                \"foo_lhs\": [\"a\", \"a\", \"a\", \"b\", \"b\", \"b\", \"c\", \"c\", \"c\"],\n                \"bar_lhs\": [1, 1, 1, 2, 2, 2, 3, 3, 3],\n                \"foo_rhs\": [\"a\", \"b\", \"c\", \"a\", \"b\", \"c\", \"a\", \"b\", \"c\"],\n                \"bar_rhs\": [1, 2, 3, 1, 2, 3, 1, 2, 3],\n            }\n        )\n        expected2 = rf.DataFrame(\n            {\"foo\": [1, 1, 1, 2, 2, 2, 3, 3, 3], \"bar\": [1, 2, 3, 1, 2, 3, 1, 2, 3]}\n        )\n        self.assertEqual(result1, expected1)\n        self.assertEqual(result2, expected2)\n\n    def test_dedupe(self):\n        df = rf.DataFrame({\"foo\": [1, 1, 2, 2], \"bar\": [\"A\", \"A\", \"B\", \"A\"]})\n        result1 = df.dedupe()\n        result2 = df.dedupe(\"foo\")\n        result3 = df.dedupe([\"foo\", \"bar\"])\n        expected1 = rf.DataFrame({\"foo\": [1, 2, 2], \"bar\": [\"A\", \"B\", \"A\"]})\n        expected2 = rf.DataFrame({\"foo\": [1, 2], \"bar\": [\"A\", \"B\"]})\n        expected3 = rf.DataFrame({\"foo\": [1, 2, 2], \"bar\": [\"A\", \"B\", \"A\"]})\n        self.assertEqual(result1, expected1)\n        self.assertEqual(result2, expected2)\n        self.assertEqual(result3, expected3)\n\n    def test_denix(self):\n        df = rf.DataFrame(\n            {\"foo\": [1, None, 3, None, 5, 6], \"bar\": [1, None, 3, 4, None, None]}\n        )\n        result1 = df.denix()\n        result2 = df.denix(\"bar\")\n        result3 = df.denix([\"foo\", \"bar\"])\n        expected1 = rf.DataFrame({\"foo\": [1.0, 3.0], \"bar\": [1.0, 3.0]})\n        expected2 = rf.DataFrame({\"foo\": [1.0, 3.0, None], \"bar\": [1.0, 3.0, 4.0]})\n        expected3 = rf.DataFrame({\"foo\": [1.0, 3.0], \"bar\": [1.0, 3.0]})\n        self.assertEqual(result1, expected1)\n        self.assertEqual(result2, expected2)\n        self.assertEqual(result3, expected3)\n\n    def test_drop(self):\n        df = rf.DataFrame({\"foo\": [1, 2], \"bar\": [3, 4], \"baz\": [5, 6]})\n        result1 = df.drop(\"baz\")\n        result2 = df.drop([\"foo\", \"baz\"])\n        expected1 = rf.DataFrame({\"foo\": [1, 2], \"bar\": [3, 4]})\n        expected2 = rf.DataFrame({\"bar\": [3, 4]})\n        self.assertEqual(result1, expected1)\n        self.assertEqual(result2, expected2)\n", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_docstrings.py_215-265"}
{"title": "maxhumber_redframes-tests-test_docstrings.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_docstrings.py"], "line_no": 250, "start_line_no": 225, "end_line_no": 275, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "            {\"foo\": [1, 1, 1, 2, 2, 2, 3, 3, 3], \"bar\": [1, 2, 3, 1, 2, 3, 1, 2, 3]}\n        )\n        self.assertEqual(result1, expected1)\n        self.assertEqual(result2, expected2)\n\n    def test_dedupe(self):\n        df = rf.DataFrame({\"foo\": [1, 1, 2, 2], \"bar\": [\"A\", \"A\", \"B\", \"A\"]})\n        result1 = df.dedupe()\n        result2 = df.dedupe(\"foo\")\n        result3 = df.dedupe([\"foo\", \"bar\"])\n        expected1 = rf.DataFrame({\"foo\": [1, 2, 2], \"bar\": [\"A\", \"B\", \"A\"]})\n        expected2 = rf.DataFrame({\"foo\": [1, 2], \"bar\": [\"A\", \"B\"]})\n        expected3 = rf.DataFrame({\"foo\": [1, 2, 2], \"bar\": [\"A\", \"B\", \"A\"]})\n        self.assertEqual(result1, expected1)\n        self.assertEqual(result2, expected2)\n        self.assertEqual(result3, expected3)\n\n    def test_denix(self):\n        df = rf.DataFrame(\n            {\"foo\": [1, None, 3, None, 5, 6], \"bar\": [1, None, 3, 4, None, None]}\n        )\n        result1 = df.denix()\n        result2 = df.denix(\"bar\")\n        result3 = df.denix([\"foo\", \"bar\"])\n        expected1 = rf.DataFrame({\"foo\": [1.0, 3.0], \"bar\": [1.0, 3.0]})\n        expected2 = rf.DataFrame({\"foo\": [1.0, 3.0, None], \"bar\": [1.0, 3.0, 4.0]})\n        expected3 = rf.DataFrame({\"foo\": [1.0, 3.0], \"bar\": [1.0, 3.0]})\n        self.assertEqual(result1, expected1)\n        self.assertEqual(result2, expected2)\n        self.assertEqual(result3, expected3)\n\n    def test_drop(self):\n        df = rf.DataFrame({\"foo\": [1, 2], \"bar\": [3, 4], \"baz\": [5, 6]})\n        result1 = df.drop(\"baz\")\n        result2 = df.drop([\"foo\", \"baz\"])\n        expected1 = rf.DataFrame({\"foo\": [1, 2], \"bar\": [3, 4]})\n        expected2 = rf.DataFrame({\"bar\": [3, 4]})\n        self.assertEqual(result1, expected1)\n        self.assertEqual(result2, expected2)\n\n    def test_fill(self):\n        df = rf.DataFrame(\n            {\"foo\": [1, None, None, 2, None], \"bar\": [None, \"A\", None, \"B\", None]}\n        )\n        result1 = df.fill(constant=0)\n        result2 = df.fill(direction=\"down\")\n        result3 = df.fill(\"foo\", direction=\"down\")\n        result4 = df.fill([\"foo\"], direction=\"up\")\n        expected1 = rf.DataFrame(\n            {\"foo\": [1.0, 0.0, 0.0, 2.0, 0.0], \"bar\": [0, \"A\", 0, \"B\", 0]}", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_docstrings.py_225-275"}
{"title": "maxhumber_redframes-tests-test_docstrings.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_docstrings.py"], "line_no": 260, "start_line_no": 235, "end_line_no": 285, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        expected1 = rf.DataFrame({\"foo\": [1, 2, 2], \"bar\": [\"A\", \"B\", \"A\"]})\n        expected2 = rf.DataFrame({\"foo\": [1, 2], \"bar\": [\"A\", \"B\"]})\n        expected3 = rf.DataFrame({\"foo\": [1, 2, 2], \"bar\": [\"A\", \"B\", \"A\"]})\n        self.assertEqual(result1, expected1)\n        self.assertEqual(result2, expected2)\n        self.assertEqual(result3, expected3)\n\n    def test_denix(self):\n        df = rf.DataFrame(\n            {\"foo\": [1, None, 3, None, 5, 6], \"bar\": [1, None, 3, 4, None, None]}\n        )\n        result1 = df.denix()\n        result2 = df.denix(\"bar\")\n        result3 = df.denix([\"foo\", \"bar\"])\n        expected1 = rf.DataFrame({\"foo\": [1.0, 3.0], \"bar\": [1.0, 3.0]})\n        expected2 = rf.DataFrame({\"foo\": [1.0, 3.0, None], \"bar\": [1.0, 3.0, 4.0]})\n        expected3 = rf.DataFrame({\"foo\": [1.0, 3.0], \"bar\": [1.0, 3.0]})\n        self.assertEqual(result1, expected1)\n        self.assertEqual(result2, expected2)\n        self.assertEqual(result3, expected3)\n\n    def test_drop(self):\n        df = rf.DataFrame({\"foo\": [1, 2], \"bar\": [3, 4], \"baz\": [5, 6]})\n        result1 = df.drop(\"baz\")\n        result2 = df.drop([\"foo\", \"baz\"])\n        expected1 = rf.DataFrame({\"foo\": [1, 2], \"bar\": [3, 4]})\n        expected2 = rf.DataFrame({\"bar\": [3, 4]})\n        self.assertEqual(result1, expected1)\n        self.assertEqual(result2, expected2)\n\n    def test_fill(self):\n        df = rf.DataFrame(\n            {\"foo\": [1, None, None, 2, None], \"bar\": [None, \"A\", None, \"B\", None]}\n        )\n        result1 = df.fill(constant=0)\n        result2 = df.fill(direction=\"down\")\n        result3 = df.fill(\"foo\", direction=\"down\")\n        result4 = df.fill([\"foo\"], direction=\"up\")\n        expected1 = rf.DataFrame(\n            {\"foo\": [1.0, 0.0, 0.0, 2.0, 0.0], \"bar\": [0, \"A\", 0, \"B\", 0]}\n        )\n        expected2 = rf.DataFrame(\n            {\"foo\": [1.0, 1.0, 1.0, 2.0, 2.0], \"bar\": [None, \"A\", \"A\", \"B\", \"B\"]}\n        )\n        expected3 = rf.DataFrame(\n            {\"foo\": [1.0, 1.0, 1.0, 2.0, 2.0], \"bar\": [None, \"A\", None, \"B\", None]}\n        )\n        expected4 = rf.DataFrame(\n            {\"foo\": [1.0, 2.0, 2.0, 2.0, None], \"bar\": [None, \"A\", None, \"B\", None]}\n        )", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_docstrings.py_235-285"}
{"title": "maxhumber_redframes-tests-test_docstrings.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_docstrings.py"], "line_no": 270, "start_line_no": 245, "end_line_no": 295, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        )\n        result1 = df.denix()\n        result2 = df.denix(\"bar\")\n        result3 = df.denix([\"foo\", \"bar\"])\n        expected1 = rf.DataFrame({\"foo\": [1.0, 3.0], \"bar\": [1.0, 3.0]})\n        expected2 = rf.DataFrame({\"foo\": [1.0, 3.0, None], \"bar\": [1.0, 3.0, 4.0]})\n        expected3 = rf.DataFrame({\"foo\": [1.0, 3.0], \"bar\": [1.0, 3.0]})\n        self.assertEqual(result1, expected1)\n        self.assertEqual(result2, expected2)\n        self.assertEqual(result3, expected3)\n\n    def test_drop(self):\n        df = rf.DataFrame({\"foo\": [1, 2], \"bar\": [3, 4], \"baz\": [5, 6]})\n        result1 = df.drop(\"baz\")\n        result2 = df.drop([\"foo\", \"baz\"])\n        expected1 = rf.DataFrame({\"foo\": [1, 2], \"bar\": [3, 4]})\n        expected2 = rf.DataFrame({\"bar\": [3, 4]})\n        self.assertEqual(result1, expected1)\n        self.assertEqual(result2, expected2)\n\n    def test_fill(self):\n        df = rf.DataFrame(\n            {\"foo\": [1, None, None, 2, None], \"bar\": [None, \"A\", None, \"B\", None]}\n        )\n        result1 = df.fill(constant=0)\n        result2 = df.fill(direction=\"down\")\n        result3 = df.fill(\"foo\", direction=\"down\")\n        result4 = df.fill([\"foo\"], direction=\"up\")\n        expected1 = rf.DataFrame(\n            {\"foo\": [1.0, 0.0, 0.0, 2.0, 0.0], \"bar\": [0, \"A\", 0, \"B\", 0]}\n        )\n        expected2 = rf.DataFrame(\n            {\"foo\": [1.0, 1.0, 1.0, 2.0, 2.0], \"bar\": [None, \"A\", \"A\", \"B\", \"B\"]}\n        )\n        expected3 = rf.DataFrame(\n            {\"foo\": [1.0, 1.0, 1.0, 2.0, 2.0], \"bar\": [None, \"A\", None, \"B\", None]}\n        )\n        expected4 = rf.DataFrame(\n            {\"foo\": [1.0, 2.0, 2.0, 2.0, None], \"bar\": [None, \"A\", None, \"B\", None]}\n        )\n        self.assertEqual(result1, expected1)\n        self.assertEqual(result2, expected2)\n        self.assertEqual(result3, expected3)\n        self.assertEqual(result4, expected4)\n\n    def test_filter(self):\n        df = rf.DataFrame({\"foo\": [\"A\", \"A\", \"A\", \"B\"], \"bar\": [1, 2, 3, 4]})\n        result1 = df.filter(lambda row: row[\"foo\"].isin([\"A\"]))\n        result2 = df.filter(lambda row: (row[\"foo\"] == \"A\") & (row[\"bar\"] <= 2))\n        result3 = df.filter(lambda row: (row[\"foo\"] == \"B\") | (row[\"bar\"] == 1))", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_docstrings.py_245-295"}
{"title": "maxhumber_redframes-tests-test_docstrings.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_docstrings.py"], "line_no": 280, "start_line_no": 255, "end_line_no": 305, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "\n    def test_drop(self):\n        df = rf.DataFrame({\"foo\": [1, 2], \"bar\": [3, 4], \"baz\": [5, 6]})\n        result1 = df.drop(\"baz\")\n        result2 = df.drop([\"foo\", \"baz\"])\n        expected1 = rf.DataFrame({\"foo\": [1, 2], \"bar\": [3, 4]})\n        expected2 = rf.DataFrame({\"bar\": [3, 4]})\n        self.assertEqual(result1, expected1)\n        self.assertEqual(result2, expected2)\n\n    def test_fill(self):\n        df = rf.DataFrame(\n            {\"foo\": [1, None, None, 2, None], \"bar\": [None, \"A\", None, \"B\", None]}\n        )\n        result1 = df.fill(constant=0)\n        result2 = df.fill(direction=\"down\")\n        result3 = df.fill(\"foo\", direction=\"down\")\n        result4 = df.fill([\"foo\"], direction=\"up\")\n        expected1 = rf.DataFrame(\n            {\"foo\": [1.0, 0.0, 0.0, 2.0, 0.0], \"bar\": [0, \"A\", 0, \"B\", 0]}\n        )\n        expected2 = rf.DataFrame(\n            {\"foo\": [1.0, 1.0, 1.0, 2.0, 2.0], \"bar\": [None, \"A\", \"A\", \"B\", \"B\"]}\n        )\n        expected3 = rf.DataFrame(\n            {\"foo\": [1.0, 1.0, 1.0, 2.0, 2.0], \"bar\": [None, \"A\", None, \"B\", None]}\n        )\n        expected4 = rf.DataFrame(\n            {\"foo\": [1.0, 2.0, 2.0, 2.0, None], \"bar\": [None, \"A\", None, \"B\", None]}\n        )\n        self.assertEqual(result1, expected1)\n        self.assertEqual(result2, expected2)\n        self.assertEqual(result3, expected3)\n        self.assertEqual(result4, expected4)\n\n    def test_filter(self):\n        df = rf.DataFrame({\"foo\": [\"A\", \"A\", \"A\", \"B\"], \"bar\": [1, 2, 3, 4]})\n        result1 = df.filter(lambda row: row[\"foo\"].isin([\"A\"]))\n        result2 = df.filter(lambda row: (row[\"foo\"] == \"A\") & (row[\"bar\"] <= 2))\n        result3 = df.filter(lambda row: (row[\"foo\"] == \"B\") | (row[\"bar\"] == 1))\n        expected1 = rf.DataFrame({\"foo\": [\"A\", \"A\", \"A\"], \"bar\": [1, 2, 3]})\n        expected2 = rf.DataFrame({\"foo\": [\"A\", \"A\"], \"bar\": [1, 2]})\n        expected3 = rf.DataFrame({\"foo\": [\"A\", \"B\"], \"bar\": [1, 4]})\n        self.assertEqual(result1, expected1)\n        self.assertEqual(result2, expected2)\n        self.assertEqual(result3, expected3)\n\n    def test_group(self):\n        df = rf.DataFrame(\n            {", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_docstrings.py_255-305"}
{"title": "maxhumber_redframes-tests-test_docstrings.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_docstrings.py"], "line_no": 290, "start_line_no": 265, "end_line_no": 315, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "    def test_fill(self):\n        df = rf.DataFrame(\n            {\"foo\": [1, None, None, 2, None], \"bar\": [None, \"A\", None, \"B\", None]}\n        )\n        result1 = df.fill(constant=0)\n        result2 = df.fill(direction=\"down\")\n        result3 = df.fill(\"foo\", direction=\"down\")\n        result4 = df.fill([\"foo\"], direction=\"up\")\n        expected1 = rf.DataFrame(\n            {\"foo\": [1.0, 0.0, 0.0, 2.0, 0.0], \"bar\": [0, \"A\", 0, \"B\", 0]}\n        )\n        expected2 = rf.DataFrame(\n            {\"foo\": [1.0, 1.0, 1.0, 2.0, 2.0], \"bar\": [None, \"A\", \"A\", \"B\", \"B\"]}\n        )\n        expected3 = rf.DataFrame(\n            {\"foo\": [1.0, 1.0, 1.0, 2.0, 2.0], \"bar\": [None, \"A\", None, \"B\", None]}\n        )\n        expected4 = rf.DataFrame(\n            {\"foo\": [1.0, 2.0, 2.0, 2.0, None], \"bar\": [None, \"A\", None, \"B\", None]}\n        )\n        self.assertEqual(result1, expected1)\n        self.assertEqual(result2, expected2)\n        self.assertEqual(result3, expected3)\n        self.assertEqual(result4, expected4)\n\n    def test_filter(self):\n        df = rf.DataFrame({\"foo\": [\"A\", \"A\", \"A\", \"B\"], \"bar\": [1, 2, 3, 4]})\n        result1 = df.filter(lambda row: row[\"foo\"].isin([\"A\"]))\n        result2 = df.filter(lambda row: (row[\"foo\"] == \"A\") & (row[\"bar\"] <= 2))\n        result3 = df.filter(lambda row: (row[\"foo\"] == \"B\") | (row[\"bar\"] == 1))\n        expected1 = rf.DataFrame({\"foo\": [\"A\", \"A\", \"A\"], \"bar\": [1, 2, 3]})\n        expected2 = rf.DataFrame({\"foo\": [\"A\", \"A\"], \"bar\": [1, 2]})\n        expected3 = rf.DataFrame({\"foo\": [\"A\", \"B\"], \"bar\": [1, 4]})\n        self.assertEqual(result1, expected1)\n        self.assertEqual(result2, expected2)\n        self.assertEqual(result3, expected3)\n\n    def test_group(self):\n        df = rf.DataFrame(\n            {\n                \"foo\": [\"A\", \"A\", \"A\", \"B\", \"B\"],\n                \"bar\": [1, 2, 3, 4, 5],\n                \"baz\": [9, 7, 7, 5, 6],\n            }\n        )\n        result1 = df.group(\"foo\").accumulate(\"bar\", into=\"bar_cumsum\")\n        result2 = df.group(\"foo\").gather()\n        result3 = df.group(\"foo\").pack(\"bar\", sep=\":\")\n        result4 = df.group(\"foo\").rank(\"baz\", into=\"baz_rank\", descending=True)\n        result5 = df.group(\"foo\").rollup(", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_docstrings.py_265-315"}
{"title": "maxhumber_redframes-tests-test_docstrings.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_docstrings.py"], "line_no": 300, "start_line_no": 275, "end_line_no": 325, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        )\n        expected2 = rf.DataFrame(\n            {\"foo\": [1.0, 1.0, 1.0, 2.0, 2.0], \"bar\": [None, \"A\", \"A\", \"B\", \"B\"]}\n        )\n        expected3 = rf.DataFrame(\n            {\"foo\": [1.0, 1.0, 1.0, 2.0, 2.0], \"bar\": [None, \"A\", None, \"B\", None]}\n        )\n        expected4 = rf.DataFrame(\n            {\"foo\": [1.0, 2.0, 2.0, 2.0, None], \"bar\": [None, \"A\", None, \"B\", None]}\n        )\n        self.assertEqual(result1, expected1)\n        self.assertEqual(result2, expected2)\n        self.assertEqual(result3, expected3)\n        self.assertEqual(result4, expected4)\n\n    def test_filter(self):\n        df = rf.DataFrame({\"foo\": [\"A\", \"A\", \"A\", \"B\"], \"bar\": [1, 2, 3, 4]})\n        result1 = df.filter(lambda row: row[\"foo\"].isin([\"A\"]))\n        result2 = df.filter(lambda row: (row[\"foo\"] == \"A\") & (row[\"bar\"] <= 2))\n        result3 = df.filter(lambda row: (row[\"foo\"] == \"B\") | (row[\"bar\"] == 1))\n        expected1 = rf.DataFrame({\"foo\": [\"A\", \"A\", \"A\"], \"bar\": [1, 2, 3]})\n        expected2 = rf.DataFrame({\"foo\": [\"A\", \"A\"], \"bar\": [1, 2]})\n        expected3 = rf.DataFrame({\"foo\": [\"A\", \"B\"], \"bar\": [1, 4]})\n        self.assertEqual(result1, expected1)\n        self.assertEqual(result2, expected2)\n        self.assertEqual(result3, expected3)\n\n    def test_group(self):\n        df = rf.DataFrame(\n            {\n                \"foo\": [\"A\", \"A\", \"A\", \"B\", \"B\"],\n                \"bar\": [1, 2, 3, 4, 5],\n                \"baz\": [9, 7, 7, 5, 6],\n            }\n        )\n        result1 = df.group(\"foo\").accumulate(\"bar\", into=\"bar_cumsum\")\n        result2 = df.group(\"foo\").gather()\n        result3 = df.group(\"foo\").pack(\"bar\", sep=\":\")\n        result4 = df.group(\"foo\").rank(\"baz\", into=\"baz_rank\", descending=True)\n        result5 = df.group(\"foo\").rollup(\n            {\"bar_mean\": (\"bar\", rf.stat.mean), \"baz_min\": (\"baz\", rf.stat.min)}\n        )\n        result6 = df.group(\"foo\").take(1)\n        expected1 = rf.DataFrame(\n            {\n                \"foo\": [\"A\", \"A\", \"A\", \"B\", \"B\"],\n                \"bar\": [1, 2, 3, 4, 5],\n                \"baz\": [9, 7, 7, 5, 6],\n                \"bar_cumsum\": [1, 3, 6, 4, 9],\n            }", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_docstrings.py_275-325"}
{"title": "maxhumber_redframes-tests-test_docstrings.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_docstrings.py"], "line_no": 310, "start_line_no": 285, "end_line_no": 335, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        self.assertEqual(result1, expected1)\n        self.assertEqual(result2, expected2)\n        self.assertEqual(result3, expected3)\n        self.assertEqual(result4, expected4)\n\n    def test_filter(self):\n        df = rf.DataFrame({\"foo\": [\"A\", \"A\", \"A\", \"B\"], \"bar\": [1, 2, 3, 4]})\n        result1 = df.filter(lambda row: row[\"foo\"].isin([\"A\"]))\n        result2 = df.filter(lambda row: (row[\"foo\"] == \"A\") & (row[\"bar\"] <= 2))\n        result3 = df.filter(lambda row: (row[\"foo\"] == \"B\") | (row[\"bar\"] == 1))\n        expected1 = rf.DataFrame({\"foo\": [\"A\", \"A\", \"A\"], \"bar\": [1, 2, 3]})\n        expected2 = rf.DataFrame({\"foo\": [\"A\", \"A\"], \"bar\": [1, 2]})\n        expected3 = rf.DataFrame({\"foo\": [\"A\", \"B\"], \"bar\": [1, 4]})\n        self.assertEqual(result1, expected1)\n        self.assertEqual(result2, expected2)\n        self.assertEqual(result3, expected3)\n\n    def test_group(self):\n        df = rf.DataFrame(\n            {\n                \"foo\": [\"A\", \"A\", \"A\", \"B\", \"B\"],\n                \"bar\": [1, 2, 3, 4, 5],\n                \"baz\": [9, 7, 7, 5, 6],\n            }\n        )\n        result1 = df.group(\"foo\").accumulate(\"bar\", into=\"bar_cumsum\")\n        result2 = df.group(\"foo\").gather()\n        result3 = df.group(\"foo\").pack(\"bar\", sep=\":\")\n        result4 = df.group(\"foo\").rank(\"baz\", into=\"baz_rank\", descending=True)\n        result5 = df.group(\"foo\").rollup(\n            {\"bar_mean\": (\"bar\", rf.stat.mean), \"baz_min\": (\"baz\", rf.stat.min)}\n        )\n        result6 = df.group(\"foo\").take(1)\n        expected1 = rf.DataFrame(\n            {\n                \"foo\": [\"A\", \"A\", \"A\", \"B\", \"B\"],\n                \"bar\": [1, 2, 3, 4, 5],\n                \"baz\": [9, 7, 7, 5, 6],\n                \"bar_cumsum\": [1, 3, 6, 4, 9],\n            }\n        )\n        expected2 = rf.DataFrame(\n            {\n                \"foo\": [\"A\", \"A\", \"A\", \"B\", \"B\", \"A\", \"A\", \"A\", \"B\", \"B\"],\n                \"variable\": [\n                    \"bar\",\n                    \"bar\",\n                    \"bar\",\n                    \"bar\",\n                    \"bar\",", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_docstrings.py_285-335"}
{"title": "maxhumber_redframes-tests-test_docstrings.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_docstrings.py"], "line_no": 320, "start_line_no": 295, "end_line_no": 345, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        expected1 = rf.DataFrame({\"foo\": [\"A\", \"A\", \"A\"], \"bar\": [1, 2, 3]})\n        expected2 = rf.DataFrame({\"foo\": [\"A\", \"A\"], \"bar\": [1, 2]})\n        expected3 = rf.DataFrame({\"foo\": [\"A\", \"B\"], \"bar\": [1, 4]})\n        self.assertEqual(result1, expected1)\n        self.assertEqual(result2, expected2)\n        self.assertEqual(result3, expected3)\n\n    def test_group(self):\n        df = rf.DataFrame(\n            {\n                \"foo\": [\"A\", \"A\", \"A\", \"B\", \"B\"],\n                \"bar\": [1, 2, 3, 4, 5],\n                \"baz\": [9, 7, 7, 5, 6],\n            }\n        )\n        result1 = df.group(\"foo\").accumulate(\"bar\", into=\"bar_cumsum\")\n        result2 = df.group(\"foo\").gather()\n        result3 = df.group(\"foo\").pack(\"bar\", sep=\":\")\n        result4 = df.group(\"foo\").rank(\"baz\", into=\"baz_rank\", descending=True)\n        result5 = df.group(\"foo\").rollup(\n            {\"bar_mean\": (\"bar\", rf.stat.mean), \"baz_min\": (\"baz\", rf.stat.min)}\n        )\n        result6 = df.group(\"foo\").take(1)\n        expected1 = rf.DataFrame(\n            {\n                \"foo\": [\"A\", \"A\", \"A\", \"B\", \"B\"],\n                \"bar\": [1, 2, 3, 4, 5],\n                \"baz\": [9, 7, 7, 5, 6],\n                \"bar_cumsum\": [1, 3, 6, 4, 9],\n            }\n        )\n        expected2 = rf.DataFrame(\n            {\n                \"foo\": [\"A\", \"A\", \"A\", \"B\", \"B\", \"A\", \"A\", \"A\", \"B\", \"B\"],\n                \"variable\": [\n                    \"bar\",\n                    \"bar\",\n                    \"bar\",\n                    \"bar\",\n                    \"bar\",\n                    \"baz\",\n                    \"baz\",\n                    \"baz\",\n                    \"baz\",\n                    \"baz\",\n                ],\n                \"value\": [1, 2, 3, 4, 5, 9, 7, 7, 5, 6],\n            }\n        )\n        expected3 = rf.DataFrame({\"foo\": [\"A\", \"B\"], \"bar\": [\"1:2:3\", \"4:5\"]})", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_docstrings.py_295-345"}
{"title": "maxhumber_redframes-tests-test_docstrings.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_docstrings.py"], "line_no": 330, "start_line_no": 305, "end_line_no": 355, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "                \"foo\": [\"A\", \"A\", \"A\", \"B\", \"B\"],\n                \"bar\": [1, 2, 3, 4, 5],\n                \"baz\": [9, 7, 7, 5, 6],\n            }\n        )\n        result1 = df.group(\"foo\").accumulate(\"bar\", into=\"bar_cumsum\")\n        result2 = df.group(\"foo\").gather()\n        result3 = df.group(\"foo\").pack(\"bar\", sep=\":\")\n        result4 = df.group(\"foo\").rank(\"baz\", into=\"baz_rank\", descending=True)\n        result5 = df.group(\"foo\").rollup(\n            {\"bar_mean\": (\"bar\", rf.stat.mean), \"baz_min\": (\"baz\", rf.stat.min)}\n        )\n        result6 = df.group(\"foo\").take(1)\n        expected1 = rf.DataFrame(\n            {\n                \"foo\": [\"A\", \"A\", \"A\", \"B\", \"B\"],\n                \"bar\": [1, 2, 3, 4, 5],\n                \"baz\": [9, 7, 7, 5, 6],\n                \"bar_cumsum\": [1, 3, 6, 4, 9],\n            }\n        )\n        expected2 = rf.DataFrame(\n            {\n                \"foo\": [\"A\", \"A\", \"A\", \"B\", \"B\", \"A\", \"A\", \"A\", \"B\", \"B\"],\n                \"variable\": [\n                    \"bar\",\n                    \"bar\",\n                    \"bar\",\n                    \"bar\",\n                    \"bar\",\n                    \"baz\",\n                    \"baz\",\n                    \"baz\",\n                    \"baz\",\n                    \"baz\",\n                ],\n                \"value\": [1, 2, 3, 4, 5, 9, 7, 7, 5, 6],\n            }\n        )\n        expected3 = rf.DataFrame({\"foo\": [\"A\", \"B\"], \"bar\": [\"1:2:3\", \"4:5\"]})\n        expected4 = rf.DataFrame(\n            {\n                \"foo\": [\"A\", \"A\", \"A\", \"B\", \"B\"],\n                \"bar\": [1, 2, 3, 4, 5],\n                \"baz\": [9, 7, 7, 5, 6],\n                \"baz_rank\": [1.0, 2.0, 2.0, 2.0, 1.0],\n            }\n        )\n        expected5 = rf.DataFrame(\n            {\"foo\": [\"A\", \"B\"], \"bar_mean\": [2.0, 4.5], \"baz_min\": [7, 5]}", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_docstrings.py_305-355"}
{"title": "maxhumber_redframes-tests-test_docstrings.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_docstrings.py"], "line_no": 340, "start_line_no": 315, "end_line_no": 365, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "            {\"bar_mean\": (\"bar\", rf.stat.mean), \"baz_min\": (\"baz\", rf.stat.min)}\n        )\n        result6 = df.group(\"foo\").take(1)\n        expected1 = rf.DataFrame(\n            {\n                \"foo\": [\"A\", \"A\", \"A\", \"B\", \"B\"],\n                \"bar\": [1, 2, 3, 4, 5],\n                \"baz\": [9, 7, 7, 5, 6],\n                \"bar_cumsum\": [1, 3, 6, 4, 9],\n            }\n        )\n        expected2 = rf.DataFrame(\n            {\n                \"foo\": [\"A\", \"A\", \"A\", \"B\", \"B\", \"A\", \"A\", \"A\", \"B\", \"B\"],\n                \"variable\": [\n                    \"bar\",\n                    \"bar\",\n                    \"bar\",\n                    \"bar\",\n                    \"bar\",\n                    \"baz\",\n                    \"baz\",\n                    \"baz\",\n                    \"baz\",\n                    \"baz\",\n                ],\n                \"value\": [1, 2, 3, 4, 5, 9, 7, 7, 5, 6],\n            }\n        )\n        expected3 = rf.DataFrame({\"foo\": [\"A\", \"B\"], \"bar\": [\"1:2:3\", \"4:5\"]})\n        expected4 = rf.DataFrame(\n            {\n                \"foo\": [\"A\", \"A\", \"A\", \"B\", \"B\"],\n                \"bar\": [1, 2, 3, 4, 5],\n                \"baz\": [9, 7, 7, 5, 6],\n                \"baz_rank\": [1.0, 2.0, 2.0, 2.0, 1.0],\n            }\n        )\n        expected5 = rf.DataFrame(\n            {\"foo\": [\"A\", \"B\"], \"bar_mean\": [2.0, 4.5], \"baz_min\": [7, 5]}\n        )\n        expected6 = rf.DataFrame({\"foo\": [\"A\", \"B\"], \"bar\": [1, 4], \"baz\": [9, 5]})\n        self.assertEqual(result1, expected1)\n        self.assertEqual(result2, expected2)\n        self.assertEqual(result3, expected3)\n        self.assertEqual(result4, expected4)\n        self.assertEqual(result5, expected5)\n        self.assertEqual(result6, expected6)\n\n    def test_join(self):", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_docstrings.py_315-365"}
{"title": "maxhumber_redframes-tests-test_docstrings.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_docstrings.py"], "line_no": 350, "start_line_no": 325, "end_line_no": 375, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        )\n        expected2 = rf.DataFrame(\n            {\n                \"foo\": [\"A\", \"A\", \"A\", \"B\", \"B\", \"A\", \"A\", \"A\", \"B\", \"B\"],\n                \"variable\": [\n                    \"bar\",\n                    \"bar\",\n                    \"bar\",\n                    \"bar\",\n                    \"bar\",\n                    \"baz\",\n                    \"baz\",\n                    \"baz\",\n                    \"baz\",\n                    \"baz\",\n                ],\n                \"value\": [1, 2, 3, 4, 5, 9, 7, 7, 5, 6],\n            }\n        )\n        expected3 = rf.DataFrame({\"foo\": [\"A\", \"B\"], \"bar\": [\"1:2:3\", \"4:5\"]})\n        expected4 = rf.DataFrame(\n            {\n                \"foo\": [\"A\", \"A\", \"A\", \"B\", \"B\"],\n                \"bar\": [1, 2, 3, 4, 5],\n                \"baz\": [9, 7, 7, 5, 6],\n                \"baz_rank\": [1.0, 2.0, 2.0, 2.0, 1.0],\n            }\n        )\n        expected5 = rf.DataFrame(\n            {\"foo\": [\"A\", \"B\"], \"bar_mean\": [2.0, 4.5], \"baz_min\": [7, 5]}\n        )\n        expected6 = rf.DataFrame({\"foo\": [\"A\", \"B\"], \"bar\": [1, 4], \"baz\": [9, 5]})\n        self.assertEqual(result1, expected1)\n        self.assertEqual(result2, expected2)\n        self.assertEqual(result3, expected3)\n        self.assertEqual(result4, expected4)\n        self.assertEqual(result5, expected5)\n        self.assertEqual(result6, expected6)\n\n    def test_join(self):\n        adf = rf.DataFrame({\"foo\": [\"A\", \"B\", \"C\"], \"bar\": [1, 2, 3]})\n        bdf = rf.DataFrame({\"foo\": [\"A\", \"B\", \"D\"], \"baz\": [\"!\", \"@\", \"#\"]})\n        result1 = adf.join(bdf, on=\"foo\", how=\"left\")\n        result2 = adf.join(bdf, on=\"foo\", how=\"right\")\n        result3 = adf.join(bdf, on=\"foo\", how=\"inner\")\n        result4 = adf.join(bdf, on=\"foo\", how=\"full\")\n        expected1 = rf.DataFrame(\n            {\"foo\": [\"A\", \"B\", \"C\"], \"bar\": [1, 2, 3], \"baz\": [\"!\", \"@\", None]}\n        )\n        expected2 = rf.DataFrame(", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_docstrings.py_325-375"}
{"title": "maxhumber_redframes-tests-test_docstrings.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_docstrings.py"], "line_no": 360, "start_line_no": 335, "end_line_no": 385, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "                    \"baz\",\n                    \"baz\",\n                    \"baz\",\n                    \"baz\",\n                    \"baz\",\n                ],\n                \"value\": [1, 2, 3, 4, 5, 9, 7, 7, 5, 6],\n            }\n        )\n        expected3 = rf.DataFrame({\"foo\": [\"A\", \"B\"], \"bar\": [\"1:2:3\", \"4:5\"]})\n        expected4 = rf.DataFrame(\n            {\n                \"foo\": [\"A\", \"A\", \"A\", \"B\", \"B\"],\n                \"bar\": [1, 2, 3, 4, 5],\n                \"baz\": [9, 7, 7, 5, 6],\n                \"baz_rank\": [1.0, 2.0, 2.0, 2.0, 1.0],\n            }\n        )\n        expected5 = rf.DataFrame(\n            {\"foo\": [\"A\", \"B\"], \"bar_mean\": [2.0, 4.5], \"baz_min\": [7, 5]}\n        )\n        expected6 = rf.DataFrame({\"foo\": [\"A\", \"B\"], \"bar\": [1, 4], \"baz\": [9, 5]})\n        self.assertEqual(result1, expected1)\n        self.assertEqual(result2, expected2)\n        self.assertEqual(result3, expected3)\n        self.assertEqual(result4, expected4)\n        self.assertEqual(result5, expected5)\n        self.assertEqual(result6, expected6)\n\n    def test_join(self):\n        adf = rf.DataFrame({\"foo\": [\"A\", \"B\", \"C\"], \"bar\": [1, 2, 3]})\n        bdf = rf.DataFrame({\"foo\": [\"A\", \"B\", \"D\"], \"baz\": [\"!\", \"@\", \"#\"]})\n        result1 = adf.join(bdf, on=\"foo\", how=\"left\")\n        result2 = adf.join(bdf, on=\"foo\", how=\"right\")\n        result3 = adf.join(bdf, on=\"foo\", how=\"inner\")\n        result4 = adf.join(bdf, on=\"foo\", how=\"full\")\n        expected1 = rf.DataFrame(\n            {\"foo\": [\"A\", \"B\", \"C\"], \"bar\": [1, 2, 3], \"baz\": [\"!\", \"@\", None]}\n        )\n        expected2 = rf.DataFrame(\n            {\"foo\": [\"A\", \"B\", \"D\"], \"bar\": [1.0, 2.0, None], \"baz\": [\"!\", \"@\", \"#\"]}\n        )\n        expected3 = rf.DataFrame({\"foo\": [\"A\", \"B\"], \"bar\": [1, 2], \"baz\": [\"!\", \"@\"]})\n        expected4 = rf.DataFrame(\n            {\n                \"foo\": [\"A\", \"B\", \"C\", \"D\"],\n                \"bar\": [1.0, 2.0, 3.0, None],\n                \"baz\": [\"!\", \"@\", None, \"#\"],\n            }\n        )", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_docstrings.py_335-385"}
{"title": "maxhumber_redframes-tests-test_docstrings.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_docstrings.py"], "line_no": 370, "start_line_no": 345, "end_line_no": 395, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        expected4 = rf.DataFrame(\n            {\n                \"foo\": [\"A\", \"A\", \"A\", \"B\", \"B\"],\n                \"bar\": [1, 2, 3, 4, 5],\n                \"baz\": [9, 7, 7, 5, 6],\n                \"baz_rank\": [1.0, 2.0, 2.0, 2.0, 1.0],\n            }\n        )\n        expected5 = rf.DataFrame(\n            {\"foo\": [\"A\", \"B\"], \"bar_mean\": [2.0, 4.5], \"baz_min\": [7, 5]}\n        )\n        expected6 = rf.DataFrame({\"foo\": [\"A\", \"B\"], \"bar\": [1, 4], \"baz\": [9, 5]})\n        self.assertEqual(result1, expected1)\n        self.assertEqual(result2, expected2)\n        self.assertEqual(result3, expected3)\n        self.assertEqual(result4, expected4)\n        self.assertEqual(result5, expected5)\n        self.assertEqual(result6, expected6)\n\n    def test_join(self):\n        adf = rf.DataFrame({\"foo\": [\"A\", \"B\", \"C\"], \"bar\": [1, 2, 3]})\n        bdf = rf.DataFrame({\"foo\": [\"A\", \"B\", \"D\"], \"baz\": [\"!\", \"@\", \"#\"]})\n        result1 = adf.join(bdf, on=\"foo\", how=\"left\")\n        result2 = adf.join(bdf, on=\"foo\", how=\"right\")\n        result3 = adf.join(bdf, on=\"foo\", how=\"inner\")\n        result4 = adf.join(bdf, on=\"foo\", how=\"full\")\n        expected1 = rf.DataFrame(\n            {\"foo\": [\"A\", \"B\", \"C\"], \"bar\": [1, 2, 3], \"baz\": [\"!\", \"@\", None]}\n        )\n        expected2 = rf.DataFrame(\n            {\"foo\": [\"A\", \"B\", \"D\"], \"bar\": [1.0, 2.0, None], \"baz\": [\"!\", \"@\", \"#\"]}\n        )\n        expected3 = rf.DataFrame({\"foo\": [\"A\", \"B\"], \"bar\": [1, 2], \"baz\": [\"!\", \"@\"]})\n        expected4 = rf.DataFrame(\n            {\n                \"foo\": [\"A\", \"B\", \"C\", \"D\"],\n                \"bar\": [1.0, 2.0, 3.0, None],\n                \"baz\": [\"!\", \"@\", None, \"#\"],\n            }\n        )\n        self.assertEqual(result1, expected1)\n        self.assertEqual(result2, expected2)\n        self.assertEqual(result3, expected3)\n        self.assertEqual(result4, expected4)\n\n    def test_mutate(self):\n        df = rf.DataFrame({\"foo\": [1, 2, 3]})\n        result = df.mutate(\n            {\n                \"bar\": lambda row: float(row[\"foo\"]),", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_docstrings.py_345-395"}
{"title": "maxhumber_redframes-tests-test_docstrings.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_docstrings.py"], "line_no": 380, "start_line_no": 355, "end_line_no": 405, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        )\n        expected6 = rf.DataFrame({\"foo\": [\"A\", \"B\"], \"bar\": [1, 4], \"baz\": [9, 5]})\n        self.assertEqual(result1, expected1)\n        self.assertEqual(result2, expected2)\n        self.assertEqual(result3, expected3)\n        self.assertEqual(result4, expected4)\n        self.assertEqual(result5, expected5)\n        self.assertEqual(result6, expected6)\n\n    def test_join(self):\n        adf = rf.DataFrame({\"foo\": [\"A\", \"B\", \"C\"], \"bar\": [1, 2, 3]})\n        bdf = rf.DataFrame({\"foo\": [\"A\", \"B\", \"D\"], \"baz\": [\"!\", \"@\", \"#\"]})\n        result1 = adf.join(bdf, on=\"foo\", how=\"left\")\n        result2 = adf.join(bdf, on=\"foo\", how=\"right\")\n        result3 = adf.join(bdf, on=\"foo\", how=\"inner\")\n        result4 = adf.join(bdf, on=\"foo\", how=\"full\")\n        expected1 = rf.DataFrame(\n            {\"foo\": [\"A\", \"B\", \"C\"], \"bar\": [1, 2, 3], \"baz\": [\"!\", \"@\", None]}\n        )\n        expected2 = rf.DataFrame(\n            {\"foo\": [\"A\", \"B\", \"D\"], \"bar\": [1.0, 2.0, None], \"baz\": [\"!\", \"@\", \"#\"]}\n        )\n        expected3 = rf.DataFrame({\"foo\": [\"A\", \"B\"], \"bar\": [1, 2], \"baz\": [\"!\", \"@\"]})\n        expected4 = rf.DataFrame(\n            {\n                \"foo\": [\"A\", \"B\", \"C\", \"D\"],\n                \"bar\": [1.0, 2.0, 3.0, None],\n                \"baz\": [\"!\", \"@\", None, \"#\"],\n            }\n        )\n        self.assertEqual(result1, expected1)\n        self.assertEqual(result2, expected2)\n        self.assertEqual(result3, expected3)\n        self.assertEqual(result4, expected4)\n\n    def test_mutate(self):\n        df = rf.DataFrame({\"foo\": [1, 2, 3]})\n        result = df.mutate(\n            {\n                \"bar\": lambda row: float(row[\"foo\"]),\n                \"baz\": lambda row: \"X\" + str(row[\"bar\"] * 2),\n                \"jaz\": lambda _: \"Jazz\",\n            }\n        )\n        expected = rf.DataFrame(\n            {\n                \"foo\": [1, 2, 3],\n                \"bar\": [1.0, 2.0, 3.0],\n                \"baz\": [\"X2.0\", \"X4.0\", \"X6.0\"],\n                \"jaz\": [\"Jazz\", \"Jazz\", \"Jazz\"],", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_docstrings.py_355-405"}
{"title": "maxhumber_redframes-tests-test_docstrings.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_docstrings.py"], "line_no": 390, "start_line_no": 365, "end_line_no": 415, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        adf = rf.DataFrame({\"foo\": [\"A\", \"B\", \"C\"], \"bar\": [1, 2, 3]})\n        bdf = rf.DataFrame({\"foo\": [\"A\", \"B\", \"D\"], \"baz\": [\"!\", \"@\", \"#\"]})\n        result1 = adf.join(bdf, on=\"foo\", how=\"left\")\n        result2 = adf.join(bdf, on=\"foo\", how=\"right\")\n        result3 = adf.join(bdf, on=\"foo\", how=\"inner\")\n        result4 = adf.join(bdf, on=\"foo\", how=\"full\")\n        expected1 = rf.DataFrame(\n            {\"foo\": [\"A\", \"B\", \"C\"], \"bar\": [1, 2, 3], \"baz\": [\"!\", \"@\", None]}\n        )\n        expected2 = rf.DataFrame(\n            {\"foo\": [\"A\", \"B\", \"D\"], \"bar\": [1.0, 2.0, None], \"baz\": [\"!\", \"@\", \"#\"]}\n        )\n        expected3 = rf.DataFrame({\"foo\": [\"A\", \"B\"], \"bar\": [1, 2], \"baz\": [\"!\", \"@\"]})\n        expected4 = rf.DataFrame(\n            {\n                \"foo\": [\"A\", \"B\", \"C\", \"D\"],\n                \"bar\": [1.0, 2.0, 3.0, None],\n                \"baz\": [\"!\", \"@\", None, \"#\"],\n            }\n        )\n        self.assertEqual(result1, expected1)\n        self.assertEqual(result2, expected2)\n        self.assertEqual(result3, expected3)\n        self.assertEqual(result4, expected4)\n\n    def test_mutate(self):\n        df = rf.DataFrame({\"foo\": [1, 2, 3]})\n        result = df.mutate(\n            {\n                \"bar\": lambda row: float(row[\"foo\"]),\n                \"baz\": lambda row: \"X\" + str(row[\"bar\"] * 2),\n                \"jaz\": lambda _: \"Jazz\",\n            }\n        )\n        expected = rf.DataFrame(\n            {\n                \"foo\": [1, 2, 3],\n                \"bar\": [1.0, 2.0, 3.0],\n                \"baz\": [\"X2.0\", \"X4.0\", \"X6.0\"],\n                \"jaz\": [\"Jazz\", \"Jazz\", \"Jazz\"],\n            }\n        )\n        self.assertEqual(result, expected)\n\n    def test_rename(self):\n        df = rf.DataFrame({\"foo\": [1, 2], \"bar\": [3, 4]})\n        result = df.rename({\"foo\": \"oof\", \"bar\": \"rab\"})\n        expected = rf.DataFrame({\"oof\": [1, 2], \"rab\": [3, 4]})\n        self.assertEqual(result, expected)\n", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_docstrings.py_365-415"}
{"title": "maxhumber_redframes-tests-test_docstrings.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_docstrings.py"], "line_no": 400, "start_line_no": 375, "end_line_no": 425, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "            {\"foo\": [\"A\", \"B\", \"D\"], \"bar\": [1.0, 2.0, None], \"baz\": [\"!\", \"@\", \"#\"]}\n        )\n        expected3 = rf.DataFrame({\"foo\": [\"A\", \"B\"], \"bar\": [1, 2], \"baz\": [\"!\", \"@\"]})\n        expected4 = rf.DataFrame(\n            {\n                \"foo\": [\"A\", \"B\", \"C\", \"D\"],\n                \"bar\": [1.0, 2.0, 3.0, None],\n                \"baz\": [\"!\", \"@\", None, \"#\"],\n            }\n        )\n        self.assertEqual(result1, expected1)\n        self.assertEqual(result2, expected2)\n        self.assertEqual(result3, expected3)\n        self.assertEqual(result4, expected4)\n\n    def test_mutate(self):\n        df = rf.DataFrame({\"foo\": [1, 2, 3]})\n        result = df.mutate(\n            {\n                \"bar\": lambda row: float(row[\"foo\"]),\n                \"baz\": lambda row: \"X\" + str(row[\"bar\"] * 2),\n                \"jaz\": lambda _: \"Jazz\",\n            }\n        )\n        expected = rf.DataFrame(\n            {\n                \"foo\": [1, 2, 3],\n                \"bar\": [1.0, 2.0, 3.0],\n                \"baz\": [\"X2.0\", \"X4.0\", \"X6.0\"],\n                \"jaz\": [\"Jazz\", \"Jazz\", \"Jazz\"],\n            }\n        )\n        self.assertEqual(result, expected)\n\n    def test_rename(self):\n        df = rf.DataFrame({\"foo\": [1, 2], \"bar\": [3, 4]})\n        result = df.rename({\"foo\": \"oof\", \"bar\": \"rab\"})\n        expected = rf.DataFrame({\"oof\": [1, 2], \"rab\": [3, 4]})\n        self.assertEqual(result, expected)\n\n    def test_replace(self):\n        df = rf.DataFrame({\"foo\": [1, 2, 2, 2, 1], \"bar\": [1, \"A\", \"B\", True, False]})\n        result = df.replace(\n            {\"foo\": {2: 222}, \"bar\": {False: 0, True: 1, \"A\": 2, \"B\": 3}}\n        )\n        expected = rf.DataFrame({\"foo\": [1, 222, 222, 222, 1], \"bar\": [1, 2, 3, 1, 0]})\n        self.assertEqual(result, expected)\n\n    def test_sample(self):\n        df = rf.DataFrame({\"foo\": range(10), \"bar\": range(10, 20)})", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_docstrings.py_375-425"}
{"title": "maxhumber_redframes-tests-test_docstrings.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_docstrings.py"], "line_no": 410, "start_line_no": 385, "end_line_no": 435, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        self.assertEqual(result1, expected1)\n        self.assertEqual(result2, expected2)\n        self.assertEqual(result3, expected3)\n        self.assertEqual(result4, expected4)\n\n    def test_mutate(self):\n        df = rf.DataFrame({\"foo\": [1, 2, 3]})\n        result = df.mutate(\n            {\n                \"bar\": lambda row: float(row[\"foo\"]),\n                \"baz\": lambda row: \"X\" + str(row[\"bar\"] * 2),\n                \"jaz\": lambda _: \"Jazz\",\n            }\n        )\n        expected = rf.DataFrame(\n            {\n                \"foo\": [1, 2, 3],\n                \"bar\": [1.0, 2.0, 3.0],\n                \"baz\": [\"X2.0\", \"X4.0\", \"X6.0\"],\n                \"jaz\": [\"Jazz\", \"Jazz\", \"Jazz\"],\n            }\n        )\n        self.assertEqual(result, expected)\n\n    def test_rename(self):\n        df = rf.DataFrame({\"foo\": [1, 2], \"bar\": [3, 4]})\n        result = df.rename({\"foo\": \"oof\", \"bar\": \"rab\"})\n        expected = rf.DataFrame({\"oof\": [1, 2], \"rab\": [3, 4]})\n        self.assertEqual(result, expected)\n\n    def test_replace(self):\n        df = rf.DataFrame({\"foo\": [1, 2, 2, 2, 1], \"bar\": [1, \"A\", \"B\", True, False]})\n        result = df.replace(\n            {\"foo\": {2: 222}, \"bar\": {False: 0, True: 1, \"A\": 2, \"B\": 3}}\n        )\n        expected = rf.DataFrame({\"foo\": [1, 222, 222, 222, 1], \"bar\": [1, 2, 3, 1, 0]})\n        self.assertEqual(result, expected)\n\n    def test_sample(self):\n        df = rf.DataFrame({\"foo\": range(10), \"bar\": range(10, 20)})\n        result1 = df.sample(1)\n        result2 = df.sample(3)\n        result3 = df.sample(0.3)\n        self.assertEqual(len(result1), 1)\n        self.assertEqual(len(result2), 3)\n        self.assertEqual(len(result3), 3)\n\n    def test_select(self):\n        df = rf.DataFrame({\"foo\": [1, 2], \"bar\": [3, 4], \"baz\": [5, 6]})\n        result1 = df.select(\"foo\")", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_docstrings.py_385-435"}
{"title": "maxhumber_redframes-tests-test_docstrings.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_docstrings.py"], "line_no": 420, "start_line_no": 395, "end_line_no": 445, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "                \"baz\": lambda row: \"X\" + str(row[\"bar\"] * 2),\n                \"jaz\": lambda _: \"Jazz\",\n            }\n        )\n        expected = rf.DataFrame(\n            {\n                \"foo\": [1, 2, 3],\n                \"bar\": [1.0, 2.0, 3.0],\n                \"baz\": [\"X2.0\", \"X4.0\", \"X6.0\"],\n                \"jaz\": [\"Jazz\", \"Jazz\", \"Jazz\"],\n            }\n        )\n        self.assertEqual(result, expected)\n\n    def test_rename(self):\n        df = rf.DataFrame({\"foo\": [1, 2], \"bar\": [3, 4]})\n        result = df.rename({\"foo\": \"oof\", \"bar\": \"rab\"})\n        expected = rf.DataFrame({\"oof\": [1, 2], \"rab\": [3, 4]})\n        self.assertEqual(result, expected)\n\n    def test_replace(self):\n        df = rf.DataFrame({\"foo\": [1, 2, 2, 2, 1], \"bar\": [1, \"A\", \"B\", True, False]})\n        result = df.replace(\n            {\"foo\": {2: 222}, \"bar\": {False: 0, True: 1, \"A\": 2, \"B\": 3}}\n        )\n        expected = rf.DataFrame({\"foo\": [1, 222, 222, 222, 1], \"bar\": [1, 2, 3, 1, 0]})\n        self.assertEqual(result, expected)\n\n    def test_sample(self):\n        df = rf.DataFrame({\"foo\": range(10), \"bar\": range(10, 20)})\n        result1 = df.sample(1)\n        result2 = df.sample(3)\n        result3 = df.sample(0.3)\n        self.assertEqual(len(result1), 1)\n        self.assertEqual(len(result2), 3)\n        self.assertEqual(len(result3), 3)\n\n    def test_select(self):\n        df = rf.DataFrame({\"foo\": [1, 2], \"bar\": [3, 4], \"baz\": [5, 6]})\n        result1 = df.select(\"foo\")\n        result2 = df.select([\"foo\", \"baz\"])\n        expected1 = rf.DataFrame({\"foo\": [1, 2]})\n        expected2 = rf.DataFrame({\"foo\": [1, 2], \"baz\": [5, 6]})\n        self.assertEqual(result1, expected1)\n        self.assertEqual(result2, expected2)\n\n    def test_shuffle(self):\n        df = rf.DataFrame({\"foo\": range(5), \"bar\": range(5, 10)})\n        result = df.shuffle()\n        self.assertNotEqual(df, result)", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_docstrings.py_395-445"}
{"title": "maxhumber_redframes-tests-test_docstrings.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_docstrings.py"], "line_no": 430, "start_line_no": 405, "end_line_no": 455, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "            }\n        )\n        self.assertEqual(result, expected)\n\n    def test_rename(self):\n        df = rf.DataFrame({\"foo\": [1, 2], \"bar\": [3, 4]})\n        result = df.rename({\"foo\": \"oof\", \"bar\": \"rab\"})\n        expected = rf.DataFrame({\"oof\": [1, 2], \"rab\": [3, 4]})\n        self.assertEqual(result, expected)\n\n    def test_replace(self):\n        df = rf.DataFrame({\"foo\": [1, 2, 2, 2, 1], \"bar\": [1, \"A\", \"B\", True, False]})\n        result = df.replace(\n            {\"foo\": {2: 222}, \"bar\": {False: 0, True: 1, \"A\": 2, \"B\": 3}}\n        )\n        expected = rf.DataFrame({\"foo\": [1, 222, 222, 222, 1], \"bar\": [1, 2, 3, 1, 0]})\n        self.assertEqual(result, expected)\n\n    def test_sample(self):\n        df = rf.DataFrame({\"foo\": range(10), \"bar\": range(10, 20)})\n        result1 = df.sample(1)\n        result2 = df.sample(3)\n        result3 = df.sample(0.3)\n        self.assertEqual(len(result1), 1)\n        self.assertEqual(len(result2), 3)\n        self.assertEqual(len(result3), 3)\n\n    def test_select(self):\n        df = rf.DataFrame({\"foo\": [1, 2], \"bar\": [3, 4], \"baz\": [5, 6]})\n        result1 = df.select(\"foo\")\n        result2 = df.select([\"foo\", \"baz\"])\n        expected1 = rf.DataFrame({\"foo\": [1, 2]})\n        expected2 = rf.DataFrame({\"foo\": [1, 2], \"baz\": [5, 6]})\n        self.assertEqual(result1, expected1)\n        self.assertEqual(result2, expected2)\n\n    def test_shuffle(self):\n        df = rf.DataFrame({\"foo\": range(5), \"bar\": range(5, 10)})\n        result = df.shuffle()\n        self.assertNotEqual(df, result)\n\n    def test_sort(self):\n        df = rf.DataFrame({\"foo\": [\"Z\", \"X\", \"A\", \"A\"], \"bar\": [2, -2, 4, -4]})\n        result1 = df.sort(\"bar\")\n        result2 = df.sort(\"bar\", descending=True)\n        result3 = df.sort([\"foo\", \"bar\"], descending=False)\n        expected1 = rf.DataFrame({\"foo\": [\"A\", \"X\", \"Z\", \"A\"], \"bar\": [-4, -2, 2, 4]})\n        expected2 = rf.DataFrame({\"foo\": [\"A\", \"Z\", \"X\", \"A\"], \"bar\": [4, 2, -2, -4]})\n        expected3 = rf.DataFrame({\"foo\": [\"A\", \"A\", \"X\", \"Z\"], \"bar\": [-4, 4, -2, 2]})\n        self.assertEqual(result1, expected1)", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_docstrings.py_405-455"}
{"title": "maxhumber_redframes-tests-test_docstrings.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_docstrings.py"], "line_no": 440, "start_line_no": 415, "end_line_no": 465, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "    def test_replace(self):\n        df = rf.DataFrame({\"foo\": [1, 2, 2, 2, 1], \"bar\": [1, \"A\", \"B\", True, False]})\n        result = df.replace(\n            {\"foo\": {2: 222}, \"bar\": {False: 0, True: 1, \"A\": 2, \"B\": 3}}\n        )\n        expected = rf.DataFrame({\"foo\": [1, 222, 222, 222, 1], \"bar\": [1, 2, 3, 1, 0]})\n        self.assertEqual(result, expected)\n\n    def test_sample(self):\n        df = rf.DataFrame({\"foo\": range(10), \"bar\": range(10, 20)})\n        result1 = df.sample(1)\n        result2 = df.sample(3)\n        result3 = df.sample(0.3)\n        self.assertEqual(len(result1), 1)\n        self.assertEqual(len(result2), 3)\n        self.assertEqual(len(result3), 3)\n\n    def test_select(self):\n        df = rf.DataFrame({\"foo\": [1, 2], \"bar\": [3, 4], \"baz\": [5, 6]})\n        result1 = df.select(\"foo\")\n        result2 = df.select([\"foo\", \"baz\"])\n        expected1 = rf.DataFrame({\"foo\": [1, 2]})\n        expected2 = rf.DataFrame({\"foo\": [1, 2], \"baz\": [5, 6]})\n        self.assertEqual(result1, expected1)\n        self.assertEqual(result2, expected2)\n\n    def test_shuffle(self):\n        df = rf.DataFrame({\"foo\": range(5), \"bar\": range(5, 10)})\n        result = df.shuffle()\n        self.assertNotEqual(df, result)\n\n    def test_sort(self):\n        df = rf.DataFrame({\"foo\": [\"Z\", \"X\", \"A\", \"A\"], \"bar\": [2, -2, 4, -4]})\n        result1 = df.sort(\"bar\")\n        result2 = df.sort(\"bar\", descending=True)\n        result3 = df.sort([\"foo\", \"bar\"], descending=False)\n        expected1 = rf.DataFrame({\"foo\": [\"A\", \"X\", \"Z\", \"A\"], \"bar\": [-4, -2, 2, 4]})\n        expected2 = rf.DataFrame({\"foo\": [\"A\", \"Z\", \"X\", \"A\"], \"bar\": [4, 2, -2, -4]})\n        expected3 = rf.DataFrame({\"foo\": [\"A\", \"A\", \"X\", \"Z\"], \"bar\": [-4, 4, -2, 2]})\n        self.assertEqual(result1, expected1)\n        self.assertEqual(result2, expected2)\n        self.assertEqual(result3, expected3)\n\n    def test_split(self):\n        df = rf.DataFrame({\"foo\": [\"A::1\", \"B::2\", \"C:3\"]})\n        result = df.split(\"foo\", into=[\"foo\", \"bar\"], sep=\"::\", drop=True)\n        expected = rf.DataFrame({\"foo\": [\"A\", \"B\", \"C:3\"], \"bar\": [\"1\", \"2\", None]})\n        self.assertEqual(result, expected)\n\n    def test_spread(self):", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_docstrings.py_415-465"}
{"title": "maxhumber_redframes-tests-test_docstrings.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_docstrings.py"], "line_no": 450, "start_line_no": 425, "end_line_no": 475, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        result1 = df.sample(1)\n        result2 = df.sample(3)\n        result3 = df.sample(0.3)\n        self.assertEqual(len(result1), 1)\n        self.assertEqual(len(result2), 3)\n        self.assertEqual(len(result3), 3)\n\n    def test_select(self):\n        df = rf.DataFrame({\"foo\": [1, 2], \"bar\": [3, 4], \"baz\": [5, 6]})\n        result1 = df.select(\"foo\")\n        result2 = df.select([\"foo\", \"baz\"])\n        expected1 = rf.DataFrame({\"foo\": [1, 2]})\n        expected2 = rf.DataFrame({\"foo\": [1, 2], \"baz\": [5, 6]})\n        self.assertEqual(result1, expected1)\n        self.assertEqual(result2, expected2)\n\n    def test_shuffle(self):\n        df = rf.DataFrame({\"foo\": range(5), \"bar\": range(5, 10)})\n        result = df.shuffle()\n        self.assertNotEqual(df, result)\n\n    def test_sort(self):\n        df = rf.DataFrame({\"foo\": [\"Z\", \"X\", \"A\", \"A\"], \"bar\": [2, -2, 4, -4]})\n        result1 = df.sort(\"bar\")\n        result2 = df.sort(\"bar\", descending=True)\n        result3 = df.sort([\"foo\", \"bar\"], descending=False)\n        expected1 = rf.DataFrame({\"foo\": [\"A\", \"X\", \"Z\", \"A\"], \"bar\": [-4, -2, 2, 4]})\n        expected2 = rf.DataFrame({\"foo\": [\"A\", \"Z\", \"X\", \"A\"], \"bar\": [4, 2, -2, -4]})\n        expected3 = rf.DataFrame({\"foo\": [\"A\", \"A\", \"X\", \"Z\"], \"bar\": [-4, 4, -2, 2]})\n        self.assertEqual(result1, expected1)\n        self.assertEqual(result2, expected2)\n        self.assertEqual(result3, expected3)\n\n    def test_split(self):\n        df = rf.DataFrame({\"foo\": [\"A::1\", \"B::2\", \"C:3\"]})\n        result = df.split(\"foo\", into=[\"foo\", \"bar\"], sep=\"::\", drop=True)\n        expected = rf.DataFrame({\"foo\": [\"A\", \"B\", \"C:3\"], \"bar\": [\"1\", \"2\", None]})\n        self.assertEqual(result, expected)\n\n    def test_spread(self):\n        df = rf.DataFrame(\n            {\"foo\": [\"A\", \"A\", \"A\", \"B\", \"B\", \"B\", \"B\"], \"bar\": [1, 2, 3, 4, 5, 6, 7]}\n        )\n        result = df.spread(\"foo\", using=\"bar\")\n        expected = rf.DataFrame({\"A\": [1.0, 2.0, 3.0, None], \"B\": [4.0, 5.0, 6.0, 7.0]})\n        self.assertEqual(result, expected)\n\n    def test_unpack(self):\n        df = rf.DataFrame({\"foo\": [1, 2, 3, 4], \"bar\": [\"A:B\", \"B:C:D\", \"D:E\", \"F\"]})\n        result = df.unpack(\"bar\", sep=\":\")", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_docstrings.py_425-475"}
{"title": "maxhumber_redframes-tests-test_docstrings.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_docstrings.py"], "line_no": 460, "start_line_no": 435, "end_line_no": 482, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        result2 = df.select([\"foo\", \"baz\"])\n        expected1 = rf.DataFrame({\"foo\": [1, 2]})\n        expected2 = rf.DataFrame({\"foo\": [1, 2], \"baz\": [5, 6]})\n        self.assertEqual(result1, expected1)\n        self.assertEqual(result2, expected2)\n\n    def test_shuffle(self):\n        df = rf.DataFrame({\"foo\": range(5), \"bar\": range(5, 10)})\n        result = df.shuffle()\n        self.assertNotEqual(df, result)\n\n    def test_sort(self):\n        df = rf.DataFrame({\"foo\": [\"Z\", \"X\", \"A\", \"A\"], \"bar\": [2, -2, 4, -4]})\n        result1 = df.sort(\"bar\")\n        result2 = df.sort(\"bar\", descending=True)\n        result3 = df.sort([\"foo\", \"bar\"], descending=False)\n        expected1 = rf.DataFrame({\"foo\": [\"A\", \"X\", \"Z\", \"A\"], \"bar\": [-4, -2, 2, 4]})\n        expected2 = rf.DataFrame({\"foo\": [\"A\", \"Z\", \"X\", \"A\"], \"bar\": [4, 2, -2, -4]})\n        expected3 = rf.DataFrame({\"foo\": [\"A\", \"A\", \"X\", \"Z\"], \"bar\": [-4, 4, -2, 2]})\n        self.assertEqual(result1, expected1)\n        self.assertEqual(result2, expected2)\n        self.assertEqual(result3, expected3)\n\n    def test_split(self):\n        df = rf.DataFrame({\"foo\": [\"A::1\", \"B::2\", \"C:3\"]})\n        result = df.split(\"foo\", into=[\"foo\", \"bar\"], sep=\"::\", drop=True)\n        expected = rf.DataFrame({\"foo\": [\"A\", \"B\", \"C:3\"], \"bar\": [\"1\", \"2\", None]})\n        self.assertEqual(result, expected)\n\n    def test_spread(self):\n        df = rf.DataFrame(\n            {\"foo\": [\"A\", \"A\", \"A\", \"B\", \"B\", \"B\", \"B\"], \"bar\": [1, 2, 3, 4, 5, 6, 7]}\n        )\n        result = df.spread(\"foo\", using=\"bar\")\n        expected = rf.DataFrame({\"A\": [1.0, 2.0, 3.0, None], \"B\": [4.0, 5.0, 6.0, 7.0]})\n        self.assertEqual(result, expected)\n\n    def test_unpack(self):\n        df = rf.DataFrame({\"foo\": [1, 2, 3, 4], \"bar\": [\"A:B\", \"B:C:D\", \"D:E\", \"F\"]})\n        result = df.unpack(\"bar\", sep=\":\")\n        expected = rf.DataFrame(\n            {\n                \"foo\": [1, 1, 2, 2, 2, 3, 3, 4],\n                \"bar\": [\"A\", \"B\", \"B\", \"C\", \"D\", \"D\", \"E\", \"F\"],\n            }\n        )\n        self.assertEqual(result, expected)", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_docstrings.py_435-482"}
{"title": "maxhumber_redframes-tests-test_docstrings.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_docstrings.py"], "line_no": 470, "start_line_no": 445, "end_line_no": 482, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "\n    def test_sort(self):\n        df = rf.DataFrame({\"foo\": [\"Z\", \"X\", \"A\", \"A\"], \"bar\": [2, -2, 4, -4]})\n        result1 = df.sort(\"bar\")\n        result2 = df.sort(\"bar\", descending=True)\n        result3 = df.sort([\"foo\", \"bar\"], descending=False)\n        expected1 = rf.DataFrame({\"foo\": [\"A\", \"X\", \"Z\", \"A\"], \"bar\": [-4, -2, 2, 4]})\n        expected2 = rf.DataFrame({\"foo\": [\"A\", \"Z\", \"X\", \"A\"], \"bar\": [4, 2, -2, -4]})\n        expected3 = rf.DataFrame({\"foo\": [\"A\", \"A\", \"X\", \"Z\"], \"bar\": [-4, 4, -2, 2]})\n        self.assertEqual(result1, expected1)\n        self.assertEqual(result2, expected2)\n        self.assertEqual(result3, expected3)\n\n    def test_split(self):\n        df = rf.DataFrame({\"foo\": [\"A::1\", \"B::2\", \"C:3\"]})\n        result = df.split(\"foo\", into=[\"foo\", \"bar\"], sep=\"::\", drop=True)\n        expected = rf.DataFrame({\"foo\": [\"A\", \"B\", \"C:3\"], \"bar\": [\"1\", \"2\", None]})\n        self.assertEqual(result, expected)\n\n    def test_spread(self):\n        df = rf.DataFrame(\n            {\"foo\": [\"A\", \"A\", \"A\", \"B\", \"B\", \"B\", \"B\"], \"bar\": [1, 2, 3, 4, 5, 6, 7]}\n        )\n        result = df.spread(\"foo\", using=\"bar\")\n        expected = rf.DataFrame({\"A\": [1.0, 2.0, 3.0, None], \"B\": [4.0, 5.0, 6.0, 7.0]})\n        self.assertEqual(result, expected)\n\n    def test_unpack(self):\n        df = rf.DataFrame({\"foo\": [1, 2, 3, 4], \"bar\": [\"A:B\", \"B:C:D\", \"D:E\", \"F\"]})\n        result = df.unpack(\"bar\", sep=\":\")\n        expected = rf.DataFrame(\n            {\n                \"foo\": [1, 1, 2, 2, 2, 3, 3, 4],\n                \"bar\": [\"A\", \"B\", \"B\", \"C\", \"D\", \"D\", \"E\", \"F\"],\n            }\n        )\n        self.assertEqual(result, expected)", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_docstrings.py_445-482"}
{"title": "maxhumber_redframes-tests-test_docstrings.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_docstrings.py"], "line_no": 480, "start_line_no": 455, "end_line_no": 482, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        self.assertEqual(result2, expected2)\n        self.assertEqual(result3, expected3)\n\n    def test_split(self):\n        df = rf.DataFrame({\"foo\": [\"A::1\", \"B::2\", \"C:3\"]})\n        result = df.split(\"foo\", into=[\"foo\", \"bar\"], sep=\"::\", drop=True)\n        expected = rf.DataFrame({\"foo\": [\"A\", \"B\", \"C:3\"], \"bar\": [\"1\", \"2\", None]})\n        self.assertEqual(result, expected)\n\n    def test_spread(self):\n        df = rf.DataFrame(\n            {\"foo\": [\"A\", \"A\", \"A\", \"B\", \"B\", \"B\", \"B\"], \"bar\": [1, 2, 3, 4, 5, 6, 7]}\n        )\n        result = df.spread(\"foo\", using=\"bar\")\n        expected = rf.DataFrame({\"A\": [1.0, 2.0, 3.0, None], \"B\": [4.0, 5.0, 6.0, 7.0]})\n        self.assertEqual(result, expected)\n\n    def test_unpack(self):\n        df = rf.DataFrame({\"foo\": [1, 2, 3, 4], \"bar\": [\"A:B\", \"B:C:D\", \"D:E\", \"F\"]})\n        result = df.unpack(\"bar\", sep=\":\")\n        expected = rf.DataFrame(\n            {\n                \"foo\": [1, 1, 2, 2, 2, 3, 3, 4],\n                \"bar\": [\"A\", \"B\", \"B\", \"C\", \"D\", \"D\", \"E\", \"F\"],\n            }\n        )\n        self.assertEqual(result, expected)", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_docstrings.py_455-482"}
{"title": "maxhumber_redframes-tests-test_dupe_columns.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_dupe_columns.py"], "line_no": 0, "start_line_no": 0, "end_line_no": 25, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "import unittest\n\nimport redframes as rf\n\n\nclass TestDupeColumns(unittest.TestCase):\n    def setUp(self):\n        self.df = rf.DataFrame(\n            {\n                \"foo\": range(10),\n                \"bar\": [1, 3.2, 4.5, 2, -1, 30, None, 1.1, 1.1, 9],\n                \"baz\": [\"A\", \"A\", None, \"B\", \"B\", \"A\", \"B\", \"C\", \"C\", \"A\"],\n                \"jaz\": [\n                    \"1::1\",\n                    \"2::2\",\n                    \"3:3\",\n                    \"4::4\",\n                    \"5::5\",\n                    \"6::7\",\n                    \"7::8\",\n                    \"8::9\",\n                    \"9::0\",\n                    \"0::-1\",\n                ],\n                \"raz\": [1, 2, 3, None, None, None, 9, 9, None, None],", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_dupe_columns.py_0-25"}
{"title": "maxhumber_redframes-tests-test_dupe_columns.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_dupe_columns.py"], "line_no": 10, "start_line_no": 0, "end_line_no": 35, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "import unittest\n\nimport redframes as rf\n\n\nclass TestDupeColumns(unittest.TestCase):\n    def setUp(self):\n        self.df = rf.DataFrame(\n            {\n                \"foo\": range(10),\n                \"bar\": [1, 3.2, 4.5, 2, -1, 30, None, 1.1, 1.1, 9],\n                \"baz\": [\"A\", \"A\", None, \"B\", \"B\", \"A\", \"B\", \"C\", \"C\", \"A\"],\n                \"jaz\": [\n                    \"1::1\",\n                    \"2::2\",\n                    \"3:3\",\n                    \"4::4\",\n                    \"5::5\",\n                    \"6::7\",\n                    \"7::8\",\n                    \"8::9\",\n                    \"9::0\",\n                    \"0::-1\",\n                ],\n                \"raz\": [1, 2, 3, None, None, None, 9, 9, None, None],\n            }\n        )\n\n    def test_accumulate_not_unqiue(self):\n        self.df.accumulate(\"foo\", into=\"foo\")\n        self.assertTrue(True)\n\n    def test_accumulate_overwrite_existing(self):\n        with self.assertWarnsRegex(UserWarning, \"overwriting existing column *\"):\n            self.df.accumulate(\"foo\", into=\"bar\")", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_dupe_columns.py_0-35"}
{"title": "maxhumber_redframes-tests-test_dupe_columns.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_dupe_columns.py"], "line_no": 20, "start_line_no": 0, "end_line_no": 45, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "import unittest\n\nimport redframes as rf\n\n\nclass TestDupeColumns(unittest.TestCase):\n    def setUp(self):\n        self.df = rf.DataFrame(\n            {\n                \"foo\": range(10),\n                \"bar\": [1, 3.2, 4.5, 2, -1, 30, None, 1.1, 1.1, 9],\n                \"baz\": [\"A\", \"A\", None, \"B\", \"B\", \"A\", \"B\", \"C\", \"C\", \"A\"],\n                \"jaz\": [\n                    \"1::1\",\n                    \"2::2\",\n                    \"3:3\",\n                    \"4::4\",\n                    \"5::5\",\n                    \"6::7\",\n                    \"7::8\",\n                    \"8::9\",\n                    \"9::0\",\n                    \"0::-1\",\n                ],\n                \"raz\": [1, 2, 3, None, None, None, 9, 9, None, None],\n            }\n        )\n\n    def test_accumulate_not_unqiue(self):\n        self.df.accumulate(\"foo\", into=\"foo\")\n        self.assertTrue(True)\n\n    def test_accumulate_overwrite_existing(self):\n        with self.assertWarnsRegex(UserWarning, \"overwriting existing column *\"):\n            self.df.accumulate(\"foo\", into=\"bar\")\n\n    def test_combine_into_overwrite(self):\n        self.df.combine([\"foo\", \"bar\"], into=\"foo\", sep=\"-\")\n        self.assertTrue(True)\n\n    def test_combine_overwrite_existing(self):\n        with self.assertWarnsRegex(UserWarning, \"overwriting existing column *\"):\n            self.df.combine([\"foo\", \"bar\"], into=\"baz\", sep=\"-\")\n\n    def test_combine_overwrite_no_drop(self):", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_dupe_columns.py_0-45"}
{"title": "maxhumber_redframes-tests-test_dupe_columns.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_dupe_columns.py"], "line_no": 30, "start_line_no": 5, "end_line_no": 55, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "class TestDupeColumns(unittest.TestCase):\n    def setUp(self):\n        self.df = rf.DataFrame(\n            {\n                \"foo\": range(10),\n                \"bar\": [1, 3.2, 4.5, 2, -1, 30, None, 1.1, 1.1, 9],\n                \"baz\": [\"A\", \"A\", None, \"B\", \"B\", \"A\", \"B\", \"C\", \"C\", \"A\"],\n                \"jaz\": [\n                    \"1::1\",\n                    \"2::2\",\n                    \"3:3\",\n                    \"4::4\",\n                    \"5::5\",\n                    \"6::7\",\n                    \"7::8\",\n                    \"8::9\",\n                    \"9::0\",\n                    \"0::-1\",\n                ],\n                \"raz\": [1, 2, 3, None, None, None, 9, 9, None, None],\n            }\n        )\n\n    def test_accumulate_not_unqiue(self):\n        self.df.accumulate(\"foo\", into=\"foo\")\n        self.assertTrue(True)\n\n    def test_accumulate_overwrite_existing(self):\n        with self.assertWarnsRegex(UserWarning, \"overwriting existing column *\"):\n            self.df.accumulate(\"foo\", into=\"bar\")\n\n    def test_combine_into_overwrite(self):\n        self.df.combine([\"foo\", \"bar\"], into=\"foo\", sep=\"-\")\n        self.assertTrue(True)\n\n    def test_combine_overwrite_existing(self):\n        with self.assertWarnsRegex(UserWarning, \"overwriting existing column *\"):\n            self.df.combine([\"foo\", \"bar\"], into=\"baz\", sep=\"-\")\n\n    def test_combine_overwrite_no_drop(self):\n        self.df.combine([\"foo\", \"bar\"], into=\"foo\", sep=\"-\", drop=False)\n        self.assertTrue(True)\n\n    def test_gather_same_column_names(self):\n        with self.assertRaisesRegex(TypeError, \"must be unique\"):\n            self.df.gather(into=(\"foo\", \"foo\"))\n\n    def test_gather_exising_column_name_for_variable(self):\n        with self.assertRaisesRegex(ValueError, \"must not be an existing column key\"):\n            self.df.gather(into=(\"foo\", \"value\"))", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_dupe_columns.py_5-55"}
{"title": "maxhumber_redframes-tests-test_dupe_columns.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_dupe_columns.py"], "line_no": 40, "start_line_no": 15, "end_line_no": 65, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "                    \"3:3\",\n                    \"4::4\",\n                    \"5::5\",\n                    \"6::7\",\n                    \"7::8\",\n                    \"8::9\",\n                    \"9::0\",\n                    \"0::-1\",\n                ],\n                \"raz\": [1, 2, 3, None, None, None, 9, 9, None, None],\n            }\n        )\n\n    def test_accumulate_not_unqiue(self):\n        self.df.accumulate(\"foo\", into=\"foo\")\n        self.assertTrue(True)\n\n    def test_accumulate_overwrite_existing(self):\n        with self.assertWarnsRegex(UserWarning, \"overwriting existing column *\"):\n            self.df.accumulate(\"foo\", into=\"bar\")\n\n    def test_combine_into_overwrite(self):\n        self.df.combine([\"foo\", \"bar\"], into=\"foo\", sep=\"-\")\n        self.assertTrue(True)\n\n    def test_combine_overwrite_existing(self):\n        with self.assertWarnsRegex(UserWarning, \"overwriting existing column *\"):\n            self.df.combine([\"foo\", \"bar\"], into=\"baz\", sep=\"-\")\n\n    def test_combine_overwrite_no_drop(self):\n        self.df.combine([\"foo\", \"bar\"], into=\"foo\", sep=\"-\", drop=False)\n        self.assertTrue(True)\n\n    def test_gather_same_column_names(self):\n        with self.assertRaisesRegex(TypeError, \"must be unique\"):\n            self.df.gather(into=(\"foo\", \"foo\"))\n\n    def test_gather_exising_column_name_for_variable(self):\n        with self.assertRaisesRegex(ValueError, \"must not be an existing column key\"):\n            self.df.gather(into=(\"foo\", \"value\"))\n\n    def test_gather_exising_column_name_for_value(self):\n        with self.assertRaisesRegex(ValueError, \"must not be an existing column key\"):\n            self.df.gather(into=(\"variable\", \"foo\"))\n\n    def test_gather_exising_column_key(self):\n        with self.assertRaisesRegex(ValueError, \"must not be an existing column key\"):\n            self.df.gather([\"foo\", \"bar\"], into=(\"raz\", \"baz\"))\n\n    def test_gather_group_into_conflict(self):", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_dupe_columns.py_15-65"}
{"title": "maxhumber_redframes-tests-test_dupe_columns.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_dupe_columns.py"], "line_no": 50, "start_line_no": 25, "end_line_no": 75, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "            }\n        )\n\n    def test_accumulate_not_unqiue(self):\n        self.df.accumulate(\"foo\", into=\"foo\")\n        self.assertTrue(True)\n\n    def test_accumulate_overwrite_existing(self):\n        with self.assertWarnsRegex(UserWarning, \"overwriting existing column *\"):\n            self.df.accumulate(\"foo\", into=\"bar\")\n\n    def test_combine_into_overwrite(self):\n        self.df.combine([\"foo\", \"bar\"], into=\"foo\", sep=\"-\")\n        self.assertTrue(True)\n\n    def test_combine_overwrite_existing(self):\n        with self.assertWarnsRegex(UserWarning, \"overwriting existing column *\"):\n            self.df.combine([\"foo\", \"bar\"], into=\"baz\", sep=\"-\")\n\n    def test_combine_overwrite_no_drop(self):\n        self.df.combine([\"foo\", \"bar\"], into=\"foo\", sep=\"-\", drop=False)\n        self.assertTrue(True)\n\n    def test_gather_same_column_names(self):\n        with self.assertRaisesRegex(TypeError, \"must be unique\"):\n            self.df.gather(into=(\"foo\", \"foo\"))\n\n    def test_gather_exising_column_name_for_variable(self):\n        with self.assertRaisesRegex(ValueError, \"must not be an existing column key\"):\n            self.df.gather(into=(\"foo\", \"value\"))\n\n    def test_gather_exising_column_name_for_value(self):\n        with self.assertRaisesRegex(ValueError, \"must not be an existing column key\"):\n            self.df.gather(into=(\"variable\", \"foo\"))\n\n    def test_gather_exising_column_key(self):\n        with self.assertRaisesRegex(ValueError, \"must not be an existing column key\"):\n            self.df.gather([\"foo\", \"bar\"], into=(\"raz\", \"baz\"))\n\n    def test_gather_group_into_conflict(self):\n        with self.assertRaisesRegex(ValueError, \"must not be an existing column key\"):\n            self.df.group(\"foo\").gather(into=(\"foo\", \"bar\"))\n\n    def test_rank_into_overwrite(self):\n        self.df.rank(\"bar\", into=\"bar\", descending=True)\n        self.assertTrue(True)\n\n    def test_rank_overwrite_existing(self):\n        with self.assertWarnsRegex(UserWarning, \"overwriting existing column *\"):\n            self.df.rank(\"bar\", into=\"baz\", descending=True)", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_dupe_columns.py_25-75"}
{"title": "maxhumber_redframes-tests-test_dupe_columns.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_dupe_columns.py"], "line_no": 60, "start_line_no": 35, "end_line_no": 85, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "\n    def test_combine_into_overwrite(self):\n        self.df.combine([\"foo\", \"bar\"], into=\"foo\", sep=\"-\")\n        self.assertTrue(True)\n\n    def test_combine_overwrite_existing(self):\n        with self.assertWarnsRegex(UserWarning, \"overwriting existing column *\"):\n            self.df.combine([\"foo\", \"bar\"], into=\"baz\", sep=\"-\")\n\n    def test_combine_overwrite_no_drop(self):\n        self.df.combine([\"foo\", \"bar\"], into=\"foo\", sep=\"-\", drop=False)\n        self.assertTrue(True)\n\n    def test_gather_same_column_names(self):\n        with self.assertRaisesRegex(TypeError, \"must be unique\"):\n            self.df.gather(into=(\"foo\", \"foo\"))\n\n    def test_gather_exising_column_name_for_variable(self):\n        with self.assertRaisesRegex(ValueError, \"must not be an existing column key\"):\n            self.df.gather(into=(\"foo\", \"value\"))\n\n    def test_gather_exising_column_name_for_value(self):\n        with self.assertRaisesRegex(ValueError, \"must not be an existing column key\"):\n            self.df.gather(into=(\"variable\", \"foo\"))\n\n    def test_gather_exising_column_key(self):\n        with self.assertRaisesRegex(ValueError, \"must not be an existing column key\"):\n            self.df.gather([\"foo\", \"bar\"], into=(\"raz\", \"baz\"))\n\n    def test_gather_group_into_conflict(self):\n        with self.assertRaisesRegex(ValueError, \"must not be an existing column key\"):\n            self.df.group(\"foo\").gather(into=(\"foo\", \"bar\"))\n\n    def test_rank_into_overwrite(self):\n        self.df.rank(\"bar\", into=\"bar\", descending=True)\n        self.assertTrue(True)\n\n    def test_rank_overwrite_existing(self):\n        with self.assertWarnsRegex(UserWarning, \"overwriting existing column *\"):\n            self.df.rank(\"bar\", into=\"baz\", descending=True)\n\n    def test_rename_duplicated_dict_values(self):\n        with self.assertRaisesRegex(KeyError, \"columns must be unique\"):\n            self.df.rename({\"foo\": \"oof\", \"bar\": \"oof\"})\n\n    def test_rollup_group_existing_column(self):\n        with self.assertRaisesRegex(KeyError, \"unable to overwrite group key\"):\n            self.df.group(\"baz\").rollup({\"baz\": (\"foo\", rf.stat.max)})\n\n    def test_select_duplicate_keys(self):", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_dupe_columns.py_35-85"}
{"title": "maxhumber_redframes-tests-test_dupe_columns.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_dupe_columns.py"], "line_no": 70, "start_line_no": 45, "end_line_no": 95, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        self.df.combine([\"foo\", \"bar\"], into=\"foo\", sep=\"-\", drop=False)\n        self.assertTrue(True)\n\n    def test_gather_same_column_names(self):\n        with self.assertRaisesRegex(TypeError, \"must be unique\"):\n            self.df.gather(into=(\"foo\", \"foo\"))\n\n    def test_gather_exising_column_name_for_variable(self):\n        with self.assertRaisesRegex(ValueError, \"must not be an existing column key\"):\n            self.df.gather(into=(\"foo\", \"value\"))\n\n    def test_gather_exising_column_name_for_value(self):\n        with self.assertRaisesRegex(ValueError, \"must not be an existing column key\"):\n            self.df.gather(into=(\"variable\", \"foo\"))\n\n    def test_gather_exising_column_key(self):\n        with self.assertRaisesRegex(ValueError, \"must not be an existing column key\"):\n            self.df.gather([\"foo\", \"bar\"], into=(\"raz\", \"baz\"))\n\n    def test_gather_group_into_conflict(self):\n        with self.assertRaisesRegex(ValueError, \"must not be an existing column key\"):\n            self.df.group(\"foo\").gather(into=(\"foo\", \"bar\"))\n\n    def test_rank_into_overwrite(self):\n        self.df.rank(\"bar\", into=\"bar\", descending=True)\n        self.assertTrue(True)\n\n    def test_rank_overwrite_existing(self):\n        with self.assertWarnsRegex(UserWarning, \"overwriting existing column *\"):\n            self.df.rank(\"bar\", into=\"baz\", descending=True)\n\n    def test_rename_duplicated_dict_values(self):\n        with self.assertRaisesRegex(KeyError, \"columns must be unique\"):\n            self.df.rename({\"foo\": \"oof\", \"bar\": \"oof\"})\n\n    def test_rollup_group_existing_column(self):\n        with self.assertRaisesRegex(KeyError, \"unable to overwrite group key\"):\n            self.df.group(\"baz\").rollup({\"baz\": (\"foo\", rf.stat.max)})\n\n    def test_select_duplicate_keys(self):\n        with self.assertRaisesRegex(KeyError, \"column keys must be unique\"):\n            self.df.select([\"foo\", \"foo\"])\n\n    def test_split_overwrite_into_one(self):\n        self.df.split(\"jaz\", into=[\"jaz\", \"paz\"], sep=\"::\")\n        self.assertTrue(True)\n\n    def test_split_overwrite_into_existing(self):\n        with self.assertRaisesRegex(KeyError, \"into keys must be unique\"):\n            self.df.split(\"jaz\", into=[\"jaz\", \"foo\"], sep=\"::\")", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_dupe_columns.py_45-95"}
{"title": "maxhumber_redframes-tests-test_dupe_columns.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_dupe_columns.py"], "line_no": 80, "start_line_no": 55, "end_line_no": 103, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "\n    def test_gather_exising_column_name_for_value(self):\n        with self.assertRaisesRegex(ValueError, \"must not be an existing column key\"):\n            self.df.gather(into=(\"variable\", \"foo\"))\n\n    def test_gather_exising_column_key(self):\n        with self.assertRaisesRegex(ValueError, \"must not be an existing column key\"):\n            self.df.gather([\"foo\", \"bar\"], into=(\"raz\", \"baz\"))\n\n    def test_gather_group_into_conflict(self):\n        with self.assertRaisesRegex(ValueError, \"must not be an existing column key\"):\n            self.df.group(\"foo\").gather(into=(\"foo\", \"bar\"))\n\n    def test_rank_into_overwrite(self):\n        self.df.rank(\"bar\", into=\"bar\", descending=True)\n        self.assertTrue(True)\n\n    def test_rank_overwrite_existing(self):\n        with self.assertWarnsRegex(UserWarning, \"overwriting existing column *\"):\n            self.df.rank(\"bar\", into=\"baz\", descending=True)\n\n    def test_rename_duplicated_dict_values(self):\n        with self.assertRaisesRegex(KeyError, \"columns must be unique\"):\n            self.df.rename({\"foo\": \"oof\", \"bar\": \"oof\"})\n\n    def test_rollup_group_existing_column(self):\n        with self.assertRaisesRegex(KeyError, \"unable to overwrite group key\"):\n            self.df.group(\"baz\").rollup({\"baz\": (\"foo\", rf.stat.max)})\n\n    def test_select_duplicate_keys(self):\n        with self.assertRaisesRegex(KeyError, \"column keys must be unique\"):\n            self.df.select([\"foo\", \"foo\"])\n\n    def test_split_overwrite_into_one(self):\n        self.df.split(\"jaz\", into=[\"jaz\", \"paz\"], sep=\"::\")\n        self.assertTrue(True)\n\n    def test_split_overwrite_into_existing(self):\n        with self.assertRaisesRegex(KeyError, \"into keys must be unique\"):\n            self.df.split(\"jaz\", into=[\"jaz\", \"foo\"], sep=\"::\")\n\n    def test_split_duplicated_into_keys(self):\n        with self.assertRaisesRegex(KeyError, \"into keys must be unique\"):\n            self.df.split(\"jaz\", into=[\"paz\", \"paz\"], sep=\"::\")\n\n    def test_spread_duplicated_column_names(self):\n        with self.assertRaisesRegex(KeyError, \"column and using must be unique\"):\n            self.df.gather().spread(\"variable\", \"variable\")", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_dupe_columns.py_55-103"}
{"title": "maxhumber_redframes-tests-test_dupe_columns.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_dupe_columns.py"], "line_no": 90, "start_line_no": 65, "end_line_no": 103, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        with self.assertRaisesRegex(ValueError, \"must not be an existing column key\"):\n            self.df.group(\"foo\").gather(into=(\"foo\", \"bar\"))\n\n    def test_rank_into_overwrite(self):\n        self.df.rank(\"bar\", into=\"bar\", descending=True)\n        self.assertTrue(True)\n\n    def test_rank_overwrite_existing(self):\n        with self.assertWarnsRegex(UserWarning, \"overwriting existing column *\"):\n            self.df.rank(\"bar\", into=\"baz\", descending=True)\n\n    def test_rename_duplicated_dict_values(self):\n        with self.assertRaisesRegex(KeyError, \"columns must be unique\"):\n            self.df.rename({\"foo\": \"oof\", \"bar\": \"oof\"})\n\n    def test_rollup_group_existing_column(self):\n        with self.assertRaisesRegex(KeyError, \"unable to overwrite group key\"):\n            self.df.group(\"baz\").rollup({\"baz\": (\"foo\", rf.stat.max)})\n\n    def test_select_duplicate_keys(self):\n        with self.assertRaisesRegex(KeyError, \"column keys must be unique\"):\n            self.df.select([\"foo\", \"foo\"])\n\n    def test_split_overwrite_into_one(self):\n        self.df.split(\"jaz\", into=[\"jaz\", \"paz\"], sep=\"::\")\n        self.assertTrue(True)\n\n    def test_split_overwrite_into_existing(self):\n        with self.assertRaisesRegex(KeyError, \"into keys must be unique\"):\n            self.df.split(\"jaz\", into=[\"jaz\", \"foo\"], sep=\"::\")\n\n    def test_split_duplicated_into_keys(self):\n        with self.assertRaisesRegex(KeyError, \"into keys must be unique\"):\n            self.df.split(\"jaz\", into=[\"paz\", \"paz\"], sep=\"::\")\n\n    def test_spread_duplicated_column_names(self):\n        with self.assertRaisesRegex(KeyError, \"column and using must be unique\"):\n            self.df.gather().spread(\"variable\", \"variable\")", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_dupe_columns.py_65-103"}
{"title": "maxhumber_redframes-tests-test_dupe_columns.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_dupe_columns.py"], "line_no": 100, "start_line_no": 75, "end_line_no": 103, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "\n    def test_rename_duplicated_dict_values(self):\n        with self.assertRaisesRegex(KeyError, \"columns must be unique\"):\n            self.df.rename({\"foo\": \"oof\", \"bar\": \"oof\"})\n\n    def test_rollup_group_existing_column(self):\n        with self.assertRaisesRegex(KeyError, \"unable to overwrite group key\"):\n            self.df.group(\"baz\").rollup({\"baz\": (\"foo\", rf.stat.max)})\n\n    def test_select_duplicate_keys(self):\n        with self.assertRaisesRegex(KeyError, \"column keys must be unique\"):\n            self.df.select([\"foo\", \"foo\"])\n\n    def test_split_overwrite_into_one(self):\n        self.df.split(\"jaz\", into=[\"jaz\", \"paz\"], sep=\"::\")\n        self.assertTrue(True)\n\n    def test_split_overwrite_into_existing(self):\n        with self.assertRaisesRegex(KeyError, \"into keys must be unique\"):\n            self.df.split(\"jaz\", into=[\"jaz\", \"foo\"], sep=\"::\")\n\n    def test_split_duplicated_into_keys(self):\n        with self.assertRaisesRegex(KeyError, \"into keys must be unique\"):\n            self.df.split(\"jaz\", into=[\"paz\", \"paz\"], sep=\"::\")\n\n    def test_spread_duplicated_column_names(self):\n        with self.assertRaisesRegex(KeyError, \"column and using must be unique\"):\n            self.df.gather().spread(\"variable\", \"variable\")", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_dupe_columns.py_75-103"}
{"title": "maxhumber_redframes-tests-test_index.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_index.py"], "line_no": 0, "start_line_no": 0, "end_line_no": 25, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "import unittest\n\nimport pandas as pd\n\nimport redframes as rf\n\n\ndef index_is_okay(df: rf.DataFrame) -> bool:\n    index = df._data.index\n    is_unnamed = index.name == None\n    is_range = isinstance(index, pd.RangeIndex)\n    is_zero_start = index.start == 0\n    is_one_step = index.step == 1\n    return all([is_unnamed, is_range, is_zero_start, is_one_step])\n\n\nclass TestIndex(unittest.TestCase):\n    def setUp(self):\n        self.df = rf.DataFrame(\n            {\n                \"foo\": range(10),\n                \"bar\": [1, 3.2, 4.5, 2, -1, 30, None, 1.1, 1.1, 9],\n                \"baz\": [\"A\", \"A\", None, \"B\", \"B\", \"A\", \"B\", \"C\", \"C\", \"A\"],\n                \"jaz\": [\n                    \"1::1\",", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_index.py_0-25"}
{"title": "maxhumber_redframes-tests-test_index.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_index.py"], "line_no": 10, "start_line_no": 0, "end_line_no": 35, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "import unittest\n\nimport pandas as pd\n\nimport redframes as rf\n\n\ndef index_is_okay(df: rf.DataFrame) -> bool:\n    index = df._data.index\n    is_unnamed = index.name == None\n    is_range = isinstance(index, pd.RangeIndex)\n    is_zero_start = index.start == 0\n    is_one_step = index.step == 1\n    return all([is_unnamed, is_range, is_zero_start, is_one_step])\n\n\nclass TestIndex(unittest.TestCase):\n    def setUp(self):\n        self.df = rf.DataFrame(\n            {\n                \"foo\": range(10),\n                \"bar\": [1, 3.2, 4.5, 2, -1, 30, None, 1.1, 1.1, 9],\n                \"baz\": [\"A\", \"A\", None, \"B\", \"B\", \"A\", \"B\", \"C\", \"C\", \"A\"],\n                \"jaz\": [\n                    \"1::1\",\n                    \"2::2\",\n                    \"3:3\",\n                    \"4::4\",\n                    \"5::5\",\n                    \"6::7\",\n                    \"7::8\",\n                    \"8::9\",\n                    \"9::0\",\n                    \"0::-1\",\n                ],", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_index.py_0-35"}
{"title": "maxhumber_redframes-tests-test_index.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_index.py"], "line_no": 20, "start_line_no": 0, "end_line_no": 45, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "import unittest\n\nimport pandas as pd\n\nimport redframes as rf\n\n\ndef index_is_okay(df: rf.DataFrame) -> bool:\n    index = df._data.index\n    is_unnamed = index.name == None\n    is_range = isinstance(index, pd.RangeIndex)\n    is_zero_start = index.start == 0\n    is_one_step = index.step == 1\n    return all([is_unnamed, is_range, is_zero_start, is_one_step])\n\n\nclass TestIndex(unittest.TestCase):\n    def setUp(self):\n        self.df = rf.DataFrame(\n            {\n                \"foo\": range(10),\n                \"bar\": [1, 3.2, 4.5, 2, -1, 30, None, 1.1, 1.1, 9],\n                \"baz\": [\"A\", \"A\", None, \"B\", \"B\", \"A\", \"B\", \"C\", \"C\", \"A\"],\n                \"jaz\": [\n                    \"1::1\",\n                    \"2::2\",\n                    \"3:3\",\n                    \"4::4\",\n                    \"5::5\",\n                    \"6::7\",\n                    \"7::8\",\n                    \"8::9\",\n                    \"9::0\",\n                    \"0::-1\",\n                ],\n                \"raz\": [1, 2, 3, None, None, None, 9, 9, None, None],\n            }\n        )\n\n    def test_accumulate(self):\n        new = self.df.accumulate(\"foo\", into=\"foo\")\n        self.assertTrue(index_is_okay(new))\n\n    def test_append(self):\n        df_bottom = rf.DataFrame({\"foo\": [10]})", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_index.py_0-45"}
{"title": "maxhumber_redframes-tests-test_index.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_index.py"], "line_no": 30, "start_line_no": 5, "end_line_no": 55, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "\n\ndef index_is_okay(df: rf.DataFrame) -> bool:\n    index = df._data.index\n    is_unnamed = index.name == None\n    is_range = isinstance(index, pd.RangeIndex)\n    is_zero_start = index.start == 0\n    is_one_step = index.step == 1\n    return all([is_unnamed, is_range, is_zero_start, is_one_step])\n\n\nclass TestIndex(unittest.TestCase):\n    def setUp(self):\n        self.df = rf.DataFrame(\n            {\n                \"foo\": range(10),\n                \"bar\": [1, 3.2, 4.5, 2, -1, 30, None, 1.1, 1.1, 9],\n                \"baz\": [\"A\", \"A\", None, \"B\", \"B\", \"A\", \"B\", \"C\", \"C\", \"A\"],\n                \"jaz\": [\n                    \"1::1\",\n                    \"2::2\",\n                    \"3:3\",\n                    \"4::4\",\n                    \"5::5\",\n                    \"6::7\",\n                    \"7::8\",\n                    \"8::9\",\n                    \"9::0\",\n                    \"0::-1\",\n                ],\n                \"raz\": [1, 2, 3, None, None, None, 9, 9, None, None],\n            }\n        )\n\n    def test_accumulate(self):\n        new = self.df.accumulate(\"foo\", into=\"foo\")\n        self.assertTrue(index_is_okay(new))\n\n    def test_append(self):\n        df_bottom = rf.DataFrame({\"foo\": [10]})\n        new = self.df.append(df_bottom)\n        self.assertTrue(index_is_okay(new))\n\n    def test_combine(self):\n        new = self.df.combine([\"foo\", \"bar\"], into=\"foo\", sep=\"-\")\n        self.assertTrue(index_is_okay(new))\n\n    def test_cross(self):\n        new = self.df.cross()\n        self.assertTrue(index_is_okay(new))", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_index.py_5-55"}
{"title": "maxhumber_redframes-tests-test_index.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_index.py"], "line_no": 40, "start_line_no": 15, "end_line_no": 65, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "\nclass TestIndex(unittest.TestCase):\n    def setUp(self):\n        self.df = rf.DataFrame(\n            {\n                \"foo\": range(10),\n                \"bar\": [1, 3.2, 4.5, 2, -1, 30, None, 1.1, 1.1, 9],\n                \"baz\": [\"A\", \"A\", None, \"B\", \"B\", \"A\", \"B\", \"C\", \"C\", \"A\"],\n                \"jaz\": [\n                    \"1::1\",\n                    \"2::2\",\n                    \"3:3\",\n                    \"4::4\",\n                    \"5::5\",\n                    \"6::7\",\n                    \"7::8\",\n                    \"8::9\",\n                    \"9::0\",\n                    \"0::-1\",\n                ],\n                \"raz\": [1, 2, 3, None, None, None, 9, 9, None, None],\n            }\n        )\n\n    def test_accumulate(self):\n        new = self.df.accumulate(\"foo\", into=\"foo\")\n        self.assertTrue(index_is_okay(new))\n\n    def test_append(self):\n        df_bottom = rf.DataFrame({\"foo\": [10]})\n        new = self.df.append(df_bottom)\n        self.assertTrue(index_is_okay(new))\n\n    def test_combine(self):\n        new = self.df.combine([\"foo\", \"bar\"], into=\"foo\", sep=\"-\")\n        self.assertTrue(index_is_okay(new))\n\n    def test_cross(self):\n        new = self.df.cross()\n        self.assertTrue(index_is_okay(new))\n\n    def test_dedupe(self):\n        new = self.df.dedupe(\"baz\")\n        self.assertTrue(index_is_okay(new))\n\n    def test_denix(self):\n        new = self.df.denix()\n        self.assertTrue(index_is_okay(new))\n\n    def test_drop(self):", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_index.py_15-65"}
{"title": "maxhumber_redframes-tests-test_index.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_index.py"], "line_no": 50, "start_line_no": 25, "end_line_no": 75, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "                    \"2::2\",\n                    \"3:3\",\n                    \"4::4\",\n                    \"5::5\",\n                    \"6::7\",\n                    \"7::8\",\n                    \"8::9\",\n                    \"9::0\",\n                    \"0::-1\",\n                ],\n                \"raz\": [1, 2, 3, None, None, None, 9, 9, None, None],\n            }\n        )\n\n    def test_accumulate(self):\n        new = self.df.accumulate(\"foo\", into=\"foo\")\n        self.assertTrue(index_is_okay(new))\n\n    def test_append(self):\n        df_bottom = rf.DataFrame({\"foo\": [10]})\n        new = self.df.append(df_bottom)\n        self.assertTrue(index_is_okay(new))\n\n    def test_combine(self):\n        new = self.df.combine([\"foo\", \"bar\"], into=\"foo\", sep=\"-\")\n        self.assertTrue(index_is_okay(new))\n\n    def test_cross(self):\n        new = self.df.cross()\n        self.assertTrue(index_is_okay(new))\n\n    def test_dedupe(self):\n        new = self.df.dedupe(\"baz\")\n        self.assertTrue(index_is_okay(new))\n\n    def test_denix(self):\n        new = self.df.denix()\n        self.assertTrue(index_is_okay(new))\n\n    def test_drop(self):\n        new = self.df.drop(\"foo\")\n        self.assertTrue(index_is_okay(new))\n\n    def test_fill(self):\n        new = self.df.fill(\"baz\", direction=\"down\")\n        self.assertTrue(index_is_okay(new))\n\n    def test_filter(self):\n        new = self.df.filter(lambda row: row[\"bar\"] > 5)\n        self.assertTrue(index_is_okay(new))", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_index.py_25-75"}
{"title": "maxhumber_redframes-tests-test_index.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_index.py"], "line_no": 60, "start_line_no": 35, "end_line_no": 85, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "                \"raz\": [1, 2, 3, None, None, None, 9, 9, None, None],\n            }\n        )\n\n    def test_accumulate(self):\n        new = self.df.accumulate(\"foo\", into=\"foo\")\n        self.assertTrue(index_is_okay(new))\n\n    def test_append(self):\n        df_bottom = rf.DataFrame({\"foo\": [10]})\n        new = self.df.append(df_bottom)\n        self.assertTrue(index_is_okay(new))\n\n    def test_combine(self):\n        new = self.df.combine([\"foo\", \"bar\"], into=\"foo\", sep=\"-\")\n        self.assertTrue(index_is_okay(new))\n\n    def test_cross(self):\n        new = self.df.cross()\n        self.assertTrue(index_is_okay(new))\n\n    def test_dedupe(self):\n        new = self.df.dedupe(\"baz\")\n        self.assertTrue(index_is_okay(new))\n\n    def test_denix(self):\n        new = self.df.denix()\n        self.assertTrue(index_is_okay(new))\n\n    def test_drop(self):\n        new = self.df.drop(\"foo\")\n        self.assertTrue(index_is_okay(new))\n\n    def test_fill(self):\n        new = self.df.fill(\"baz\", direction=\"down\")\n        self.assertTrue(index_is_okay(new))\n\n    def test_filter(self):\n        new = self.df.filter(lambda row: row[\"bar\"] > 5)\n        self.assertTrue(index_is_okay(new))\n\n    def test_gather(self):\n        new = self.df.gather()\n        self.assertTrue(index_is_okay(new))\n\n    def test_group(self):\n        new = self.df.group(\"baz\").rollup({\"foo\": (\"foo\", rf.stat.mean)})\n        self.assertTrue(index_is_okay(new))\n\n    def test_join(self):", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_index.py_35-85"}
{"title": "maxhumber_redframes-tests-test_index.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_index.py"], "line_no": 70, "start_line_no": 45, "end_line_no": 95, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        new = self.df.append(df_bottom)\n        self.assertTrue(index_is_okay(new))\n\n    def test_combine(self):\n        new = self.df.combine([\"foo\", \"bar\"], into=\"foo\", sep=\"-\")\n        self.assertTrue(index_is_okay(new))\n\n    def test_cross(self):\n        new = self.df.cross()\n        self.assertTrue(index_is_okay(new))\n\n    def test_dedupe(self):\n        new = self.df.dedupe(\"baz\")\n        self.assertTrue(index_is_okay(new))\n\n    def test_denix(self):\n        new = self.df.denix()\n        self.assertTrue(index_is_okay(new))\n\n    def test_drop(self):\n        new = self.df.drop(\"foo\")\n        self.assertTrue(index_is_okay(new))\n\n    def test_fill(self):\n        new = self.df.fill(\"baz\", direction=\"down\")\n        self.assertTrue(index_is_okay(new))\n\n    def test_filter(self):\n        new = self.df.filter(lambda row: row[\"bar\"] > 5)\n        self.assertTrue(index_is_okay(new))\n\n    def test_gather(self):\n        new = self.df.gather()\n        self.assertTrue(index_is_okay(new))\n\n    def test_group(self):\n        new = self.df.group(\"baz\").rollup({\"foo\": (\"foo\", rf.stat.mean)})\n        self.assertTrue(index_is_okay(new))\n\n    def test_join(self):\n        df_right = rf.DataFrame({\"baz\": [\"A\", \"B\"], \"haz\": [\"Apple\", \"Banana\"]})\n        new = self.df.join(df_right, on=\"baz\")\n        self.assertTrue(index_is_okay(new))\n\n    def test_mutate(self):\n        new = self.df.mutate({\"foo\": lambda row: row[\"foo\"] * 10})\n        self.assertTrue(index_is_okay(new))\n\n    def test_pack(self):\n        new = self.df.pack(\"baz\", sep=\"|\")", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_index.py_45-95"}
{"title": "maxhumber_redframes-tests-test_index.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_index.py"], "line_no": 80, "start_line_no": 55, "end_line_no": 105, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "\n    def test_dedupe(self):\n        new = self.df.dedupe(\"baz\")\n        self.assertTrue(index_is_okay(new))\n\n    def test_denix(self):\n        new = self.df.denix()\n        self.assertTrue(index_is_okay(new))\n\n    def test_drop(self):\n        new = self.df.drop(\"foo\")\n        self.assertTrue(index_is_okay(new))\n\n    def test_fill(self):\n        new = self.df.fill(\"baz\", direction=\"down\")\n        self.assertTrue(index_is_okay(new))\n\n    def test_filter(self):\n        new = self.df.filter(lambda row: row[\"bar\"] > 5)\n        self.assertTrue(index_is_okay(new))\n\n    def test_gather(self):\n        new = self.df.gather()\n        self.assertTrue(index_is_okay(new))\n\n    def test_group(self):\n        new = self.df.group(\"baz\").rollup({\"foo\": (\"foo\", rf.stat.mean)})\n        self.assertTrue(index_is_okay(new))\n\n    def test_join(self):\n        df_right = rf.DataFrame({\"baz\": [\"A\", \"B\"], \"haz\": [\"Apple\", \"Banana\"]})\n        new = self.df.join(df_right, on=\"baz\")\n        self.assertTrue(index_is_okay(new))\n\n    def test_mutate(self):\n        new = self.df.mutate({\"foo\": lambda row: row[\"foo\"] * 10})\n        self.assertTrue(index_is_okay(new))\n\n    def test_pack(self):\n        new = self.df.pack(\"baz\", sep=\"|\")\n        self.assertTrue(index_is_okay(new))\n\n    def test_rank(self):\n        new = self.df.rank(\"bar\", into=\"bar_rank\", descending=True)\n        self.assertTrue(index_is_okay(new))\n\n    def test_rename(self):\n        new = self.df.rename({\"foo\": \"oof\"})\n        self.assertTrue(index_is_okay(new))\n", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_index.py_55-105"}
{"title": "maxhumber_redframes-tests-test_index.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_index.py"], "line_no": 90, "start_line_no": 65, "end_line_no": 115, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        new = self.df.drop(\"foo\")\n        self.assertTrue(index_is_okay(new))\n\n    def test_fill(self):\n        new = self.df.fill(\"baz\", direction=\"down\")\n        self.assertTrue(index_is_okay(new))\n\n    def test_filter(self):\n        new = self.df.filter(lambda row: row[\"bar\"] > 5)\n        self.assertTrue(index_is_okay(new))\n\n    def test_gather(self):\n        new = self.df.gather()\n        self.assertTrue(index_is_okay(new))\n\n    def test_group(self):\n        new = self.df.group(\"baz\").rollup({\"foo\": (\"foo\", rf.stat.mean)})\n        self.assertTrue(index_is_okay(new))\n\n    def test_join(self):\n        df_right = rf.DataFrame({\"baz\": [\"A\", \"B\"], \"haz\": [\"Apple\", \"Banana\"]})\n        new = self.df.join(df_right, on=\"baz\")\n        self.assertTrue(index_is_okay(new))\n\n    def test_mutate(self):\n        new = self.df.mutate({\"foo\": lambda row: row[\"foo\"] * 10})\n        self.assertTrue(index_is_okay(new))\n\n    def test_pack(self):\n        new = self.df.pack(\"baz\", sep=\"|\")\n        self.assertTrue(index_is_okay(new))\n\n    def test_rank(self):\n        new = self.df.rank(\"bar\", into=\"bar_rank\", descending=True)\n        self.assertTrue(index_is_okay(new))\n\n    def test_rename(self):\n        new = self.df.rename({\"foo\": \"oof\"})\n        self.assertTrue(index_is_okay(new))\n\n    def test_replace(self):\n        new = self.df.replace({\"baz\": {\"B\": \"Banana\"}})\n        self.assertTrue(index_is_okay(new))\n\n    def test_rollup(self):\n        new = self.df.rollup({\"bar_mean\": (\"bar\", rf.stat.mean)})\n        self.assertTrue(index_is_okay(new))\n\n    def test_sample(self):\n        new = self.df.sample(5)", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_index.py_65-115"}
{"title": "maxhumber_redframes-tests-test_index.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_index.py"], "line_no": 100, "start_line_no": 75, "end_line_no": 125, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "\n    def test_gather(self):\n        new = self.df.gather()\n        self.assertTrue(index_is_okay(new))\n\n    def test_group(self):\n        new = self.df.group(\"baz\").rollup({\"foo\": (\"foo\", rf.stat.mean)})\n        self.assertTrue(index_is_okay(new))\n\n    def test_join(self):\n        df_right = rf.DataFrame({\"baz\": [\"A\", \"B\"], \"haz\": [\"Apple\", \"Banana\"]})\n        new = self.df.join(df_right, on=\"baz\")\n        self.assertTrue(index_is_okay(new))\n\n    def test_mutate(self):\n        new = self.df.mutate({\"foo\": lambda row: row[\"foo\"] * 10})\n        self.assertTrue(index_is_okay(new))\n\n    def test_pack(self):\n        new = self.df.pack(\"baz\", sep=\"|\")\n        self.assertTrue(index_is_okay(new))\n\n    def test_rank(self):\n        new = self.df.rank(\"bar\", into=\"bar_rank\", descending=True)\n        self.assertTrue(index_is_okay(new))\n\n    def test_rename(self):\n        new = self.df.rename({\"foo\": \"oof\"})\n        self.assertTrue(index_is_okay(new))\n\n    def test_replace(self):\n        new = self.df.replace({\"baz\": {\"B\": \"Banana\"}})\n        self.assertTrue(index_is_okay(new))\n\n    def test_rollup(self):\n        new = self.df.rollup({\"bar_mean\": (\"bar\", rf.stat.mean)})\n        self.assertTrue(index_is_okay(new))\n\n    def test_sample(self):\n        new = self.df.sample(5)\n        self.assertTrue(index_is_okay(new))\n\n    def test_select(self):\n        new = self.df.select([\"foo\", \"bar\"])\n        self.assertTrue(index_is_okay(new))\n\n    def test_shuffle(self):\n        new = self.df.shuffle()\n        self.assertTrue(index_is_okay(new))\n", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_index.py_75-125"}
{"title": "maxhumber_redframes-tests-test_index.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_index.py"], "line_no": 110, "start_line_no": 85, "end_line_no": 135, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        df_right = rf.DataFrame({\"baz\": [\"A\", \"B\"], \"haz\": [\"Apple\", \"Banana\"]})\n        new = self.df.join(df_right, on=\"baz\")\n        self.assertTrue(index_is_okay(new))\n\n    def test_mutate(self):\n        new = self.df.mutate({\"foo\": lambda row: row[\"foo\"] * 10})\n        self.assertTrue(index_is_okay(new))\n\n    def test_pack(self):\n        new = self.df.pack(\"baz\", sep=\"|\")\n        self.assertTrue(index_is_okay(new))\n\n    def test_rank(self):\n        new = self.df.rank(\"bar\", into=\"bar_rank\", descending=True)\n        self.assertTrue(index_is_okay(new))\n\n    def test_rename(self):\n        new = self.df.rename({\"foo\": \"oof\"})\n        self.assertTrue(index_is_okay(new))\n\n    def test_replace(self):\n        new = self.df.replace({\"baz\": {\"B\": \"Banana\"}})\n        self.assertTrue(index_is_okay(new))\n\n    def test_rollup(self):\n        new = self.df.rollup({\"bar_mean\": (\"bar\", rf.stat.mean)})\n        self.assertTrue(index_is_okay(new))\n\n    def test_sample(self):\n        new = self.df.sample(5)\n        self.assertTrue(index_is_okay(new))\n\n    def test_select(self):\n        new = self.df.select([\"foo\", \"bar\"])\n        self.assertTrue(index_is_okay(new))\n\n    def test_shuffle(self):\n        new = self.df.shuffle()\n        self.assertTrue(index_is_okay(new))\n\n    def test_sort(self):\n        new = self.df.sort(\"bar\", descending=True)\n        self.assertTrue(index_is_okay(new))\n\n    def test_split(self):\n        new = self.df.split(\"jaz\", into=[\"jaz_1\", \"jaz_2\"], sep=\"::\")\n        self.assertTrue(index_is_okay(new))\n\n    def test_spread(self):\n        new = self.df.denix(\"baz\").select([\"baz\", \"foo\"]).spread(\"baz\", \"foo\")", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_index.py_85-135"}
{"title": "maxhumber_redframes-tests-test_index.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_index.py"], "line_no": 120, "start_line_no": 95, "end_line_no": 144, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        self.assertTrue(index_is_okay(new))\n\n    def test_rank(self):\n        new = self.df.rank(\"bar\", into=\"bar_rank\", descending=True)\n        self.assertTrue(index_is_okay(new))\n\n    def test_rename(self):\n        new = self.df.rename({\"foo\": \"oof\"})\n        self.assertTrue(index_is_okay(new))\n\n    def test_replace(self):\n        new = self.df.replace({\"baz\": {\"B\": \"Banana\"}})\n        self.assertTrue(index_is_okay(new))\n\n    def test_rollup(self):\n        new = self.df.rollup({\"bar_mean\": (\"bar\", rf.stat.mean)})\n        self.assertTrue(index_is_okay(new))\n\n    def test_sample(self):\n        new = self.df.sample(5)\n        self.assertTrue(index_is_okay(new))\n\n    def test_select(self):\n        new = self.df.select([\"foo\", \"bar\"])\n        self.assertTrue(index_is_okay(new))\n\n    def test_shuffle(self):\n        new = self.df.shuffle()\n        self.assertTrue(index_is_okay(new))\n\n    def test_sort(self):\n        new = self.df.sort(\"bar\", descending=True)\n        self.assertTrue(index_is_okay(new))\n\n    def test_split(self):\n        new = self.df.split(\"jaz\", into=[\"jaz_1\", \"jaz_2\"], sep=\"::\")\n        self.assertTrue(index_is_okay(new))\n\n    def test_spread(self):\n        new = self.df.denix(\"baz\").select([\"baz\", \"foo\"]).spread(\"baz\", \"foo\")\n        self.assertTrue(index_is_okay(new))\n\n    def test_take(self):\n        new = self.df.take(-3)\n        self.assertTrue(index_is_okay(new))\n\n    def test_unpack(self):\n        new = self.df.unpack(\"jaz\", sep=\"::\")\n        self.assertTrue(index_is_okay(new))", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_index.py_95-144"}
{"title": "maxhumber_redframes-tests-test_index.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_index.py"], "line_no": 130, "start_line_no": 105, "end_line_no": 144, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "    def test_replace(self):\n        new = self.df.replace({\"baz\": {\"B\": \"Banana\"}})\n        self.assertTrue(index_is_okay(new))\n\n    def test_rollup(self):\n        new = self.df.rollup({\"bar_mean\": (\"bar\", rf.stat.mean)})\n        self.assertTrue(index_is_okay(new))\n\n    def test_sample(self):\n        new = self.df.sample(5)\n        self.assertTrue(index_is_okay(new))\n\n    def test_select(self):\n        new = self.df.select([\"foo\", \"bar\"])\n        self.assertTrue(index_is_okay(new))\n\n    def test_shuffle(self):\n        new = self.df.shuffle()\n        self.assertTrue(index_is_okay(new))\n\n    def test_sort(self):\n        new = self.df.sort(\"bar\", descending=True)\n        self.assertTrue(index_is_okay(new))\n\n    def test_split(self):\n        new = self.df.split(\"jaz\", into=[\"jaz_1\", \"jaz_2\"], sep=\"::\")\n        self.assertTrue(index_is_okay(new))\n\n    def test_spread(self):\n        new = self.df.denix(\"baz\").select([\"baz\", \"foo\"]).spread(\"baz\", \"foo\")\n        self.assertTrue(index_is_okay(new))\n\n    def test_take(self):\n        new = self.df.take(-3)\n        self.assertTrue(index_is_okay(new))\n\n    def test_unpack(self):\n        new = self.df.unpack(\"jaz\", sep=\"::\")\n        self.assertTrue(index_is_okay(new))", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_index.py_105-144"}
{"title": "maxhumber_redframes-tests-test_index.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_index.py"], "line_no": 140, "start_line_no": 115, "end_line_no": 144, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        self.assertTrue(index_is_okay(new))\n\n    def test_select(self):\n        new = self.df.select([\"foo\", \"bar\"])\n        self.assertTrue(index_is_okay(new))\n\n    def test_shuffle(self):\n        new = self.df.shuffle()\n        self.assertTrue(index_is_okay(new))\n\n    def test_sort(self):\n        new = self.df.sort(\"bar\", descending=True)\n        self.assertTrue(index_is_okay(new))\n\n    def test_split(self):\n        new = self.df.split(\"jaz\", into=[\"jaz_1\", \"jaz_2\"], sep=\"::\")\n        self.assertTrue(index_is_okay(new))\n\n    def test_spread(self):\n        new = self.df.denix(\"baz\").select([\"baz\", \"foo\"]).spread(\"baz\", \"foo\")\n        self.assertTrue(index_is_okay(new))\n\n    def test_take(self):\n        new = self.df.take(-3)\n        self.assertTrue(index_is_okay(new))\n\n    def test_unpack(self):\n        new = self.df.unpack(\"jaz\", sep=\"::\")\n        self.assertTrue(index_is_okay(new))", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_index.py_115-144"}
{"title": "maxhumber_redframes-tests-test_interchange.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_interchange.py"], "line_no": 0, "start_line_no": 0, "end_line_no": 13, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}, {"fpath_tuple": ["maxhumber_redframes", "tests", "test_interchange.py"], "line_no": 10, "start_line_no": 0, "end_line_no": 13, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "import unittest\n\nimport pandas as pd\n\nimport redframes as rf\n\n\nclass TestInterchange(unittest.TestCase):\n    def test_wrap_no_side_effect(self):\n        rdf = rf.DataFrame({\"foo\": [1, 2], \"bar\": [3, 4]})\n        result = pd.api.interchange.from_dataframe(rdf)\n        expected = pd.DataFrame({\"foo\": [1, 2], \"bar\": [3, 4]})\n        self.assertTrue(result.equals(expected))", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_interchange.py_0-13"}
{"title": "maxhumber_redframes-tests-test_io.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_io.py"], "line_no": 0, "start_line_no": 0, "end_line_no": 25, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "import unittest\nfrom pathlib import Path\nfrom shutil import rmtree as delete\nfrom tempfile import mkdtemp as make_temp_dir\n\nimport pandas as pd\n\nimport redframes as rf\n\n\nclass TestIO(unittest.TestCase):\n    def setUp(self):\n        self.tempdir = tempdir = make_temp_dir()\n        self.df = rf.DataFrame({\"foo\": [1, 2], \"bar\": [3, 4]})\n        self.pdf = pd.DataFrame({\"foo\": [1, 2], \"bar\": [3, 4]})\n        self.path = str(Path(tempdir) / \"example.csv\")\n\n    def tearDown(self):\n        delete(self.tempdir)\n\n    def test_load_missing_file(self):\n        with self.assertRaises(FileNotFoundError):\n            rf.load(\"test_missing_file.csv\")\n\n    def test_load_bad_format(self):", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_io.py_0-25"}
{"title": "maxhumber_redframes-tests-test_io.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_io.py"], "line_no": 10, "start_line_no": 0, "end_line_no": 35, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "import unittest\nfrom pathlib import Path\nfrom shutil import rmtree as delete\nfrom tempfile import mkdtemp as make_temp_dir\n\nimport pandas as pd\n\nimport redframes as rf\n\n\nclass TestIO(unittest.TestCase):\n    def setUp(self):\n        self.tempdir = tempdir = make_temp_dir()\n        self.df = rf.DataFrame({\"foo\": [1, 2], \"bar\": [3, 4]})\n        self.pdf = pd.DataFrame({\"foo\": [1, 2], \"bar\": [3, 4]})\n        self.path = str(Path(tempdir) / \"example.csv\")\n\n    def tearDown(self):\n        delete(self.tempdir)\n\n    def test_load_missing_file(self):\n        with self.assertRaises(FileNotFoundError):\n            rf.load(\"test_missing_file.csv\")\n\n    def test_load_bad_format(self):\n        with self.assertRaisesRegex(TypeError, \"must end in .csv\"):\n            rf.load(\"test_bad_file_format.json\")\n\n    def test_save_bad_path_format(self):\n        with self.assertRaisesRegex(TypeError, \"must end in .csv\"):\n            rf.save(self.df, \"example.json\")\n\n    def test_save_bad_type(self):\n        with self.assertRaisesRegex(TypeError, \"must be DataFrame\"):\n            rf.save(1, \"example.json\")", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_io.py_0-35"}
{"title": "maxhumber_redframes-tests-test_io.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_io.py"], "line_no": 20, "start_line_no": 0, "end_line_no": 45, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "import unittest\nfrom pathlib import Path\nfrom shutil import rmtree as delete\nfrom tempfile import mkdtemp as make_temp_dir\n\nimport pandas as pd\n\nimport redframes as rf\n\n\nclass TestIO(unittest.TestCase):\n    def setUp(self):\n        self.tempdir = tempdir = make_temp_dir()\n        self.df = rf.DataFrame({\"foo\": [1, 2], \"bar\": [3, 4]})\n        self.pdf = pd.DataFrame({\"foo\": [1, 2], \"bar\": [3, 4]})\n        self.path = str(Path(tempdir) / \"example.csv\")\n\n    def tearDown(self):\n        delete(self.tempdir)\n\n    def test_load_missing_file(self):\n        with self.assertRaises(FileNotFoundError):\n            rf.load(\"test_missing_file.csv\")\n\n    def test_load_bad_format(self):\n        with self.assertRaisesRegex(TypeError, \"must end in .csv\"):\n            rf.load(\"test_bad_file_format.json\")\n\n    def test_save_bad_path_format(self):\n        with self.assertRaisesRegex(TypeError, \"must end in .csv\"):\n            rf.save(self.df, \"example.json\")\n\n    def test_save_bad_type(self):\n        with self.assertRaisesRegex(TypeError, \"must be DataFrame\"):\n            rf.save(1, \"example.json\")\n\n    def test_unwrap_bad_type(self):\n        with self.assertRaisesRegex(TypeError, \"must be DataFrame\"):\n            rf.unwrap(1)\n\n    def test_wrap_bad_type(self):\n        with self.assertRaisesRegex(TypeError, \"must be DataFrame\"):\n            rf.wrap(1)\n\n    def test_unwrap_wrong_direction(self):", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_io.py_0-45"}
{"title": "maxhumber_redframes-tests-test_io.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_io.py"], "line_no": 30, "start_line_no": 5, "end_line_no": 55, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "import pandas as pd\n\nimport redframes as rf\n\n\nclass TestIO(unittest.TestCase):\n    def setUp(self):\n        self.tempdir = tempdir = make_temp_dir()\n        self.df = rf.DataFrame({\"foo\": [1, 2], \"bar\": [3, 4]})\n        self.pdf = pd.DataFrame({\"foo\": [1, 2], \"bar\": [3, 4]})\n        self.path = str(Path(tempdir) / \"example.csv\")\n\n    def tearDown(self):\n        delete(self.tempdir)\n\n    def test_load_missing_file(self):\n        with self.assertRaises(FileNotFoundError):\n            rf.load(\"test_missing_file.csv\")\n\n    def test_load_bad_format(self):\n        with self.assertRaisesRegex(TypeError, \"must end in .csv\"):\n            rf.load(\"test_bad_file_format.json\")\n\n    def test_save_bad_path_format(self):\n        with self.assertRaisesRegex(TypeError, \"must end in .csv\"):\n            rf.save(self.df, \"example.json\")\n\n    def test_save_bad_type(self):\n        with self.assertRaisesRegex(TypeError, \"must be DataFrame\"):\n            rf.save(1, \"example.json\")\n\n    def test_unwrap_bad_type(self):\n        with self.assertRaisesRegex(TypeError, \"must be DataFrame\"):\n            rf.unwrap(1)\n\n    def test_wrap_bad_type(self):\n        with self.assertRaisesRegex(TypeError, \"must be DataFrame\"):\n            rf.wrap(1)\n\n    def test_unwrap_wrong_direction(self):\n        with self.assertRaisesRegex(TypeError, \"must be DataFrame\"):\n            rf.unwrap(self.pdf)\n\n    def test_wrap_wrong_direction(self):\n        with self.assertRaisesRegex(TypeError, \"must be DataFrame\"):\n            rf.wrap(self.df)\n\n    def test_unwrap_no_side_effect(self):\n        pdf = rf.unwrap(self.df)\n        pdf.columns = [\"oof\", \"rab\"]", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_io.py_5-55"}
{"title": "maxhumber_redframes-tests-test_io.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_io.py"], "line_no": 40, "start_line_no": 15, "end_line_no": 65, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        self.path = str(Path(tempdir) / \"example.csv\")\n\n    def tearDown(self):\n        delete(self.tempdir)\n\n    def test_load_missing_file(self):\n        with self.assertRaises(FileNotFoundError):\n            rf.load(\"test_missing_file.csv\")\n\n    def test_load_bad_format(self):\n        with self.assertRaisesRegex(TypeError, \"must end in .csv\"):\n            rf.load(\"test_bad_file_format.json\")\n\n    def test_save_bad_path_format(self):\n        with self.assertRaisesRegex(TypeError, \"must end in .csv\"):\n            rf.save(self.df, \"example.json\")\n\n    def test_save_bad_type(self):\n        with self.assertRaisesRegex(TypeError, \"must be DataFrame\"):\n            rf.save(1, \"example.json\")\n\n    def test_unwrap_bad_type(self):\n        with self.assertRaisesRegex(TypeError, \"must be DataFrame\"):\n            rf.unwrap(1)\n\n    def test_wrap_bad_type(self):\n        with self.assertRaisesRegex(TypeError, \"must be DataFrame\"):\n            rf.wrap(1)\n\n    def test_unwrap_wrong_direction(self):\n        with self.assertRaisesRegex(TypeError, \"must be DataFrame\"):\n            rf.unwrap(self.pdf)\n\n    def test_wrap_wrong_direction(self):\n        with self.assertRaisesRegex(TypeError, \"must be DataFrame\"):\n            rf.wrap(self.df)\n\n    def test_unwrap_no_side_effect(self):\n        pdf = rf.unwrap(self.df)\n        pdf.columns = [\"oof\", \"rab\"]\n        expected = rf.DataFrame({\"foo\": [1, 2], \"bar\": [3, 4]})\n        self.assertEqual(self.df, expected)\n\n    def test_wrap_no_side_effect(self):\n        df = rf.wrap(self.pdf)\n        df = df.rename({\"foo\": \"oof\"})\n        expected = pd.DataFrame({\"foo\": [1, 2], \"bar\": [3, 4]})\n        self.assertTrue(self.pdf.equals(expected))\n\n    def test_round_trip_save_load(self):", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_io.py_15-65"}
{"title": "maxhumber_redframes-tests-test_io.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_io.py"], "line_no": 50, "start_line_no": 25, "end_line_no": 75, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        with self.assertRaisesRegex(TypeError, \"must end in .csv\"):\n            rf.load(\"test_bad_file_format.json\")\n\n    def test_save_bad_path_format(self):\n        with self.assertRaisesRegex(TypeError, \"must end in .csv\"):\n            rf.save(self.df, \"example.json\")\n\n    def test_save_bad_type(self):\n        with self.assertRaisesRegex(TypeError, \"must be DataFrame\"):\n            rf.save(1, \"example.json\")\n\n    def test_unwrap_bad_type(self):\n        with self.assertRaisesRegex(TypeError, \"must be DataFrame\"):\n            rf.unwrap(1)\n\n    def test_wrap_bad_type(self):\n        with self.assertRaisesRegex(TypeError, \"must be DataFrame\"):\n            rf.wrap(1)\n\n    def test_unwrap_wrong_direction(self):\n        with self.assertRaisesRegex(TypeError, \"must be DataFrame\"):\n            rf.unwrap(self.pdf)\n\n    def test_wrap_wrong_direction(self):\n        with self.assertRaisesRegex(TypeError, \"must be DataFrame\"):\n            rf.wrap(self.df)\n\n    def test_unwrap_no_side_effect(self):\n        pdf = rf.unwrap(self.df)\n        pdf.columns = [\"oof\", \"rab\"]\n        expected = rf.DataFrame({\"foo\": [1, 2], \"bar\": [3, 4]})\n        self.assertEqual(self.df, expected)\n\n    def test_wrap_no_side_effect(self):\n        df = rf.wrap(self.pdf)\n        df = df.rename({\"foo\": \"oof\"})\n        expected = pd.DataFrame({\"foo\": [1, 2], \"bar\": [3, 4]})\n        self.assertTrue(self.pdf.equals(expected))\n\n    def test_round_trip_save_load(self):\n        rf.save(self.df, self.path)\n        result = rf.load(self.path)\n        expected = rf.DataFrame({\"foo\": [1, 2], \"bar\": [3, 4]})\n        self.assertEqual(result, expected)\n\n    def test_round_trip_unwrap_wrap(self):\n        pdf = rf.unwrap(self.df)\n        result = rf.wrap(pdf)\n        expected = rf.DataFrame({\"foo\": [1, 2], \"bar\": [3, 4]})\n        self.assertEqual(result, expected)", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_io.py_25-75"}
{"title": "maxhumber_redframes-tests-test_io.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_io.py"], "line_no": 60, "start_line_no": 35, "end_line_no": 75, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "\n    def test_unwrap_bad_type(self):\n        with self.assertRaisesRegex(TypeError, \"must be DataFrame\"):\n            rf.unwrap(1)\n\n    def test_wrap_bad_type(self):\n        with self.assertRaisesRegex(TypeError, \"must be DataFrame\"):\n            rf.wrap(1)\n\n    def test_unwrap_wrong_direction(self):\n        with self.assertRaisesRegex(TypeError, \"must be DataFrame\"):\n            rf.unwrap(self.pdf)\n\n    def test_wrap_wrong_direction(self):\n        with self.assertRaisesRegex(TypeError, \"must be DataFrame\"):\n            rf.wrap(self.df)\n\n    def test_unwrap_no_side_effect(self):\n        pdf = rf.unwrap(self.df)\n        pdf.columns = [\"oof\", \"rab\"]\n        expected = rf.DataFrame({\"foo\": [1, 2], \"bar\": [3, 4]})\n        self.assertEqual(self.df, expected)\n\n    def test_wrap_no_side_effect(self):\n        df = rf.wrap(self.pdf)\n        df = df.rename({\"foo\": \"oof\"})\n        expected = pd.DataFrame({\"foo\": [1, 2], \"bar\": [3, 4]})\n        self.assertTrue(self.pdf.equals(expected))\n\n    def test_round_trip_save_load(self):\n        rf.save(self.df, self.path)\n        result = rf.load(self.path)\n        expected = rf.DataFrame({\"foo\": [1, 2], \"bar\": [3, 4]})\n        self.assertEqual(result, expected)\n\n    def test_round_trip_unwrap_wrap(self):\n        pdf = rf.unwrap(self.df)\n        result = rf.wrap(pdf)\n        expected = rf.DataFrame({\"foo\": [1, 2], \"bar\": [3, 4]})\n        self.assertEqual(result, expected)", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_io.py_35-75"}
{"title": "maxhumber_redframes-tests-test_io.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_io.py"], "line_no": 70, "start_line_no": 45, "end_line_no": 75, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        with self.assertRaisesRegex(TypeError, \"must be DataFrame\"):\n            rf.unwrap(self.pdf)\n\n    def test_wrap_wrong_direction(self):\n        with self.assertRaisesRegex(TypeError, \"must be DataFrame\"):\n            rf.wrap(self.df)\n\n    def test_unwrap_no_side_effect(self):\n        pdf = rf.unwrap(self.df)\n        pdf.columns = [\"oof\", \"rab\"]\n        expected = rf.DataFrame({\"foo\": [1, 2], \"bar\": [3, 4]})\n        self.assertEqual(self.df, expected)\n\n    def test_wrap_no_side_effect(self):\n        df = rf.wrap(self.pdf)\n        df = df.rename({\"foo\": \"oof\"})\n        expected = pd.DataFrame({\"foo\": [1, 2], \"bar\": [3, 4]})\n        self.assertTrue(self.pdf.equals(expected))\n\n    def test_round_trip_save_load(self):\n        rf.save(self.df, self.path)\n        result = rf.load(self.path)\n        expected = rf.DataFrame({\"foo\": [1, 2], \"bar\": [3, 4]})\n        self.assertEqual(result, expected)\n\n    def test_round_trip_unwrap_wrap(self):\n        pdf = rf.unwrap(self.df)\n        result = rf.wrap(pdf)\n        expected = rf.DataFrame({\"foo\": [1, 2], \"bar\": [3, 4]})\n        self.assertEqual(result, expected)", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_io.py_45-75"}
{"title": "maxhumber_redframes-tests-test_ladybugs.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_ladybugs.py"], "line_no": 0, "start_line_no": 0, "end_line_no": 25, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "import unittest\n\nimport pandas as pd\n\nimport redframes as rf\n\n\nclass TestLadyBugs(unittest.TestCase):\n    def test_gather_spread_string_values(self):\n        df = rf.DataFrame(\n            {\"foo\": [\"A\", \"B\", \"C\"], \"bar\": [\"D\", \"E\", \"F\"], \"baz\": [\"G\", \"H\", \"I\"]}\n        )\n        result = df.gather().spread(\"variable\", \"value\")\n        expected = rf.DataFrame(\n            {\"bar\": [\"D\", \"E\", \"F\"], \"baz\": [\"G\", \"H\", \"I\"], \"foo\": [\"A\", \"B\", \"C\"]}\n        )\n        self.assertEqual(result, expected)\n\n    def test_types_mixed_column(self):\n        df = rf.DataFrame({\"foo\": [1, None, 2.0, \"3\"]})\n        result = df.types\n        expected = {\"foo\": object}\n        self.assertEqual(result, expected)\n\n    def test_comine_overwrite_and_drop_other(self):", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_ladybugs.py_0-25"}
{"title": "maxhumber_redframes-tests-test_ladybugs.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_ladybugs.py"], "line_no": 10, "start_line_no": 0, "end_line_no": 35, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "import unittest\n\nimport pandas as pd\n\nimport redframes as rf\n\n\nclass TestLadyBugs(unittest.TestCase):\n    def test_gather_spread_string_values(self):\n        df = rf.DataFrame(\n            {\"foo\": [\"A\", \"B\", \"C\"], \"bar\": [\"D\", \"E\", \"F\"], \"baz\": [\"G\", \"H\", \"I\"]}\n        )\n        result = df.gather().spread(\"variable\", \"value\")\n        expected = rf.DataFrame(\n            {\"bar\": [\"D\", \"E\", \"F\"], \"baz\": [\"G\", \"H\", \"I\"], \"foo\": [\"A\", \"B\", \"C\"]}\n        )\n        self.assertEqual(result, expected)\n\n    def test_types_mixed_column(self):\n        df = rf.DataFrame({\"foo\": [1, None, 2.0, \"3\"]})\n        result = df.types\n        expected = {\"foo\": object}\n        self.assertEqual(result, expected)\n\n    def test_comine_overwrite_and_drop_other(self):\n        df = rf.DataFrame({\"foo\": [1, 2, 3], \"bar\": [1, 2, 3]})\n        result = df.combine([\"foo\", \"bar\"], into=\"foo\", sep=\"-\", drop=True)\n        expected = rf.DataFrame({\"foo\": [\"1-1\", \"2-2\", \"3-3\"]})\n        self.assertEqual(result, expected)\n\n    def test_sample_float_1_point_0(self):\n        df = rf.DataFrame({\"foo\": range(100)})\n        with self.assertRaisesRegex(ValueError, \"must be int if > 1\"):\n            df.sample(1.0)\n", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_ladybugs.py_0-35"}
{"title": "maxhumber_redframes-tests-test_ladybugs.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_ladybugs.py"], "line_no": 20, "start_line_no": 0, "end_line_no": 45, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "import unittest\n\nimport pandas as pd\n\nimport redframes as rf\n\n\nclass TestLadyBugs(unittest.TestCase):\n    def test_gather_spread_string_values(self):\n        df = rf.DataFrame(\n            {\"foo\": [\"A\", \"B\", \"C\"], \"bar\": [\"D\", \"E\", \"F\"], \"baz\": [\"G\", \"H\", \"I\"]}\n        )\n        result = df.gather().spread(\"variable\", \"value\")\n        expected = rf.DataFrame(\n            {\"bar\": [\"D\", \"E\", \"F\"], \"baz\": [\"G\", \"H\", \"I\"], \"foo\": [\"A\", \"B\", \"C\"]}\n        )\n        self.assertEqual(result, expected)\n\n    def test_types_mixed_column(self):\n        df = rf.DataFrame({\"foo\": [1, None, 2.0, \"3\"]})\n        result = df.types\n        expected = {\"foo\": object}\n        self.assertEqual(result, expected)\n\n    def test_comine_overwrite_and_drop_other(self):\n        df = rf.DataFrame({\"foo\": [1, 2, 3], \"bar\": [1, 2, 3]})\n        result = df.combine([\"foo\", \"bar\"], into=\"foo\", sep=\"-\", drop=True)\n        expected = rf.DataFrame({\"foo\": [\"1-1\", \"2-2\", \"3-3\"]})\n        self.assertEqual(result, expected)\n\n    def test_sample_float_1_point_0(self):\n        df = rf.DataFrame({\"foo\": range(100)})\n        with self.assertRaisesRegex(ValueError, \"must be int if > 1\"):\n            df.sample(1.0)\n\n    def test_sample_negative_1(self):\n        df = rf.DataFrame({\"foo\": range(100)})\n        with self.assertRaisesRegex(ValueError, \"must be > 0\"):\n            df.sample(-1)\n\n    def test_io_wrap_multi_columns(self):\n        columns = pd.MultiIndex.from_arrays(\n            [[\"route\", \"action\", \"action\"], [\"type\", \"source\", \"destination\"]]\n        )\n        pdf = pd.DataFrame([[1, 2, 3]], columns=columns)", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_ladybugs.py_0-45"}
{"title": "maxhumber_redframes-tests-test_ladybugs.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_ladybugs.py"], "line_no": 30, "start_line_no": 5, "end_line_no": 55, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "\n\nclass TestLadyBugs(unittest.TestCase):\n    def test_gather_spread_string_values(self):\n        df = rf.DataFrame(\n            {\"foo\": [\"A\", \"B\", \"C\"], \"bar\": [\"D\", \"E\", \"F\"], \"baz\": [\"G\", \"H\", \"I\"]}\n        )\n        result = df.gather().spread(\"variable\", \"value\")\n        expected = rf.DataFrame(\n            {\"bar\": [\"D\", \"E\", \"F\"], \"baz\": [\"G\", \"H\", \"I\"], \"foo\": [\"A\", \"B\", \"C\"]}\n        )\n        self.assertEqual(result, expected)\n\n    def test_types_mixed_column(self):\n        df = rf.DataFrame({\"foo\": [1, None, 2.0, \"3\"]})\n        result = df.types\n        expected = {\"foo\": object}\n        self.assertEqual(result, expected)\n\n    def test_comine_overwrite_and_drop_other(self):\n        df = rf.DataFrame({\"foo\": [1, 2, 3], \"bar\": [1, 2, 3]})\n        result = df.combine([\"foo\", \"bar\"], into=\"foo\", sep=\"-\", drop=True)\n        expected = rf.DataFrame({\"foo\": [\"1-1\", \"2-2\", \"3-3\"]})\n        self.assertEqual(result, expected)\n\n    def test_sample_float_1_point_0(self):\n        df = rf.DataFrame({\"foo\": range(100)})\n        with self.assertRaisesRegex(ValueError, \"must be int if > 1\"):\n            df.sample(1.0)\n\n    def test_sample_negative_1(self):\n        df = rf.DataFrame({\"foo\": range(100)})\n        with self.assertRaisesRegex(ValueError, \"must be > 0\"):\n            df.sample(-1)\n\n    def test_io_wrap_multi_columns(self):\n        columns = pd.MultiIndex.from_arrays(\n            [[\"route\", \"action\", \"action\"], [\"type\", \"source\", \"destination\"]]\n        )\n        pdf = pd.DataFrame([[1, 2, 3]], columns=columns)\n        with self.assertRaisesRegex(KeyError, \"must be flat\"):\n            rf.wrap(pdf)\n\n    def test_group_gather_beside_conflict(self):\n        df = rf.DataFrame(\n            {\n                \"foo\": [1, 1, 1, 2, 2, 1, 3, 3],\n                \"bar\": range(8),\n                \"baz\": range(8),\n                \"jaz\": range(8),", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_ladybugs.py_5-55"}
{"title": "maxhumber_redframes-tests-test_ladybugs.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_ladybugs.py"], "line_no": 40, "start_line_no": 15, "end_line_no": 65, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        )\n        self.assertEqual(result, expected)\n\n    def test_types_mixed_column(self):\n        df = rf.DataFrame({\"foo\": [1, None, 2.0, \"3\"]})\n        result = df.types\n        expected = {\"foo\": object}\n        self.assertEqual(result, expected)\n\n    def test_comine_overwrite_and_drop_other(self):\n        df = rf.DataFrame({\"foo\": [1, 2, 3], \"bar\": [1, 2, 3]})\n        result = df.combine([\"foo\", \"bar\"], into=\"foo\", sep=\"-\", drop=True)\n        expected = rf.DataFrame({\"foo\": [\"1-1\", \"2-2\", \"3-3\"]})\n        self.assertEqual(result, expected)\n\n    def test_sample_float_1_point_0(self):\n        df = rf.DataFrame({\"foo\": range(100)})\n        with self.assertRaisesRegex(ValueError, \"must be int if > 1\"):\n            df.sample(1.0)\n\n    def test_sample_negative_1(self):\n        df = rf.DataFrame({\"foo\": range(100)})\n        with self.assertRaisesRegex(ValueError, \"must be > 0\"):\n            df.sample(-1)\n\n    def test_io_wrap_multi_columns(self):\n        columns = pd.MultiIndex.from_arrays(\n            [[\"route\", \"action\", \"action\"], [\"type\", \"source\", \"destination\"]]\n        )\n        pdf = pd.DataFrame([[1, 2, 3]], columns=columns)\n        with self.assertRaisesRegex(KeyError, \"must be flat\"):\n            rf.wrap(pdf)\n\n    def test_group_gather_beside_conflict(self):\n        df = rf.DataFrame(\n            {\n                \"foo\": [1, 1, 1, 2, 2, 1, 3, 3],\n                \"bar\": range(8),\n                \"baz\": range(8),\n                \"jaz\": range(8),\n            }\n        )\n        with self.assertRaisesRegex(ValueError, \"beside is incompatible*\"):\n            df.group(\"foo\").gather(beside=\"bar\")\n\n    def test_group_gather_columns_conflict(self):\n        df = rf.DataFrame(\n            {\n                \"foo\": [1, 1, 1, 2, 2, 1, 3, 3],\n                \"bar\": range(8),", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_ladybugs.py_15-65"}
{"title": "maxhumber_redframes-tests-test_ladybugs.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_ladybugs.py"], "line_no": 50, "start_line_no": 25, "end_line_no": 71, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        df = rf.DataFrame({\"foo\": [1, 2, 3], \"bar\": [1, 2, 3]})\n        result = df.combine([\"foo\", \"bar\"], into=\"foo\", sep=\"-\", drop=True)\n        expected = rf.DataFrame({\"foo\": [\"1-1\", \"2-2\", \"3-3\"]})\n        self.assertEqual(result, expected)\n\n    def test_sample_float_1_point_0(self):\n        df = rf.DataFrame({\"foo\": range(100)})\n        with self.assertRaisesRegex(ValueError, \"must be int if > 1\"):\n            df.sample(1.0)\n\n    def test_sample_negative_1(self):\n        df = rf.DataFrame({\"foo\": range(100)})\n        with self.assertRaisesRegex(ValueError, \"must be > 0\"):\n            df.sample(-1)\n\n    def test_io_wrap_multi_columns(self):\n        columns = pd.MultiIndex.from_arrays(\n            [[\"route\", \"action\", \"action\"], [\"type\", \"source\", \"destination\"]]\n        )\n        pdf = pd.DataFrame([[1, 2, 3]], columns=columns)\n        with self.assertRaisesRegex(KeyError, \"must be flat\"):\n            rf.wrap(pdf)\n\n    def test_group_gather_beside_conflict(self):\n        df = rf.DataFrame(\n            {\n                \"foo\": [1, 1, 1, 2, 2, 1, 3, 3],\n                \"bar\": range(8),\n                \"baz\": range(8),\n                \"jaz\": range(8),\n            }\n        )\n        with self.assertRaisesRegex(ValueError, \"beside is incompatible*\"):\n            df.group(\"foo\").gather(beside=\"bar\")\n\n    def test_group_gather_columns_conflict(self):\n        df = rf.DataFrame(\n            {\n                \"foo\": [1, 1, 1, 2, 2, 1, 3, 3],\n                \"bar\": range(8),\n                \"baz\": range(8),\n                \"jaz\": range(8),\n            }\n        )\n        with self.assertRaisesRegex(ValueError, \"columns is incompatible*\"):\n            df.group(\"foo\").gather(columns=[\"foo\", \"bar\"])", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_ladybugs.py_25-71"}
{"title": "maxhumber_redframes-tests-test_ladybugs.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_ladybugs.py"], "line_no": 60, "start_line_no": 35, "end_line_no": 71, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "    def test_sample_negative_1(self):\n        df = rf.DataFrame({\"foo\": range(100)})\n        with self.assertRaisesRegex(ValueError, \"must be > 0\"):\n            df.sample(-1)\n\n    def test_io_wrap_multi_columns(self):\n        columns = pd.MultiIndex.from_arrays(\n            [[\"route\", \"action\", \"action\"], [\"type\", \"source\", \"destination\"]]\n        )\n        pdf = pd.DataFrame([[1, 2, 3]], columns=columns)\n        with self.assertRaisesRegex(KeyError, \"must be flat\"):\n            rf.wrap(pdf)\n\n    def test_group_gather_beside_conflict(self):\n        df = rf.DataFrame(\n            {\n                \"foo\": [1, 1, 1, 2, 2, 1, 3, 3],\n                \"bar\": range(8),\n                \"baz\": range(8),\n                \"jaz\": range(8),\n            }\n        )\n        with self.assertRaisesRegex(ValueError, \"beside is incompatible*\"):\n            df.group(\"foo\").gather(beside=\"bar\")\n\n    def test_group_gather_columns_conflict(self):\n        df = rf.DataFrame(\n            {\n                \"foo\": [1, 1, 1, 2, 2, 1, 3, 3],\n                \"bar\": range(8),\n                \"baz\": range(8),\n                \"jaz\": range(8),\n            }\n        )\n        with self.assertRaisesRegex(ValueError, \"columns is incompatible*\"):\n            df.group(\"foo\").gather(columns=[\"foo\", \"bar\"])", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_ladybugs.py_35-71"}
{"title": "maxhumber_redframes-tests-test_ladybugs.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_ladybugs.py"], "line_no": 70, "start_line_no": 45, "end_line_no": 71, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        with self.assertRaisesRegex(KeyError, \"must be flat\"):\n            rf.wrap(pdf)\n\n    def test_group_gather_beside_conflict(self):\n        df = rf.DataFrame(\n            {\n                \"foo\": [1, 1, 1, 2, 2, 1, 3, 3],\n                \"bar\": range(8),\n                \"baz\": range(8),\n                \"jaz\": range(8),\n            }\n        )\n        with self.assertRaisesRegex(ValueError, \"beside is incompatible*\"):\n            df.group(\"foo\").gather(beside=\"bar\")\n\n    def test_group_gather_columns_conflict(self):\n        df = rf.DataFrame(\n            {\n                \"foo\": [1, 1, 1, 2, 2, 1, 3, 3],\n                \"bar\": range(8),\n                \"baz\": range(8),\n                \"jaz\": range(8),\n            }\n        )\n        with self.assertRaisesRegex(ValueError, \"columns is incompatible*\"):\n            df.group(\"foo\").gather(columns=[\"foo\", \"bar\"])", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_ladybugs.py_45-71"}
{"title": "maxhumber_redframes-tests-test_readme.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_readme.py"], "line_no": 0, "start_line_no": 0, "end_line_no": 25, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "import unittest\nfrom pathlib import Path\nfrom shutil import rmtree as delete\nfrom tempfile import mkdtemp as make_temp_dir\n\n\nclass TestReadme(unittest.TestCase):\n    def setUp(self):\n        self.tempdir = tempdir = make_temp_dir()\n        self.path = str(Path(tempdir) / \"bears.csv\")\n\n    def tearDown(self):\n        delete(self.tempdir)\n\n    def test_quick_start(self):\n        import redframes as rf\n\n        df = rf.DataFrame(\n            {\n                \"bear\": [\n                    \"Brown bear\",\n                    \"Polar bear\",\n                    \"Asian black bear\",\n                    \"American black bear\",\n                    \"Sun bear\",", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_readme.py_0-25"}
{"title": "maxhumber_redframes-tests-test_readme.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_readme.py"], "line_no": 10, "start_line_no": 0, "end_line_no": 35, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "import unittest\nfrom pathlib import Path\nfrom shutil import rmtree as delete\nfrom tempfile import mkdtemp as make_temp_dir\n\n\nclass TestReadme(unittest.TestCase):\n    def setUp(self):\n        self.tempdir = tempdir = make_temp_dir()\n        self.path = str(Path(tempdir) / \"bears.csv\")\n\n    def tearDown(self):\n        delete(self.tempdir)\n\n    def test_quick_start(self):\n        import redframes as rf\n\n        df = rf.DataFrame(\n            {\n                \"bear\": [\n                    \"Brown bear\",\n                    \"Polar bear\",\n                    \"Asian black bear\",\n                    \"American black bear\",\n                    \"Sun bear\",\n                    \"Sloth bear\",\n                    \"Spectacled bear\",\n                    \"Giant panda\",\n                ],\n                \"genus\": [\n                    \"Ursus\",\n                    \"Ursus\",\n                    \"Ursus\",\n                    \"Ursus\",\n                    \"Helarctos\",", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_readme.py_0-35"}
{"title": "maxhumber_redframes-tests-test_readme.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_readme.py"], "line_no": 20, "start_line_no": 0, "end_line_no": 45, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "import unittest\nfrom pathlib import Path\nfrom shutil import rmtree as delete\nfrom tempfile import mkdtemp as make_temp_dir\n\n\nclass TestReadme(unittest.TestCase):\n    def setUp(self):\n        self.tempdir = tempdir = make_temp_dir()\n        self.path = str(Path(tempdir) / \"bears.csv\")\n\n    def tearDown(self):\n        delete(self.tempdir)\n\n    def test_quick_start(self):\n        import redframes as rf\n\n        df = rf.DataFrame(\n            {\n                \"bear\": [\n                    \"Brown bear\",\n                    \"Polar bear\",\n                    \"Asian black bear\",\n                    \"American black bear\",\n                    \"Sun bear\",\n                    \"Sloth bear\",\n                    \"Spectacled bear\",\n                    \"Giant panda\",\n                ],\n                \"genus\": [\n                    \"Ursus\",\n                    \"Ursus\",\n                    \"Ursus\",\n                    \"Ursus\",\n                    \"Helarctos\",\n                    \"Melursus\",\n                    \"Tremarctos\",\n                    \"Ailuropoda\",\n                ],\n                \"weight (male, lbs)\": [\n                    \"300-860\",\n                    \"880-1320\",\n                    \"220-440\",\n                    \"125-500\",\n                    \"60-150\",", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_readme.py_0-45"}
{"title": "maxhumber_redframes-tests-test_readme.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_readme.py"], "line_no": 30, "start_line_no": 5, "end_line_no": 55, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "\nclass TestReadme(unittest.TestCase):\n    def setUp(self):\n        self.tempdir = tempdir = make_temp_dir()\n        self.path = str(Path(tempdir) / \"bears.csv\")\n\n    def tearDown(self):\n        delete(self.tempdir)\n\n    def test_quick_start(self):\n        import redframes as rf\n\n        df = rf.DataFrame(\n            {\n                \"bear\": [\n                    \"Brown bear\",\n                    \"Polar bear\",\n                    \"Asian black bear\",\n                    \"American black bear\",\n                    \"Sun bear\",\n                    \"Sloth bear\",\n                    \"Spectacled bear\",\n                    \"Giant panda\",\n                ],\n                \"genus\": [\n                    \"Ursus\",\n                    \"Ursus\",\n                    \"Ursus\",\n                    \"Ursus\",\n                    \"Helarctos\",\n                    \"Melursus\",\n                    \"Tremarctos\",\n                    \"Ailuropoda\",\n                ],\n                \"weight (male, lbs)\": [\n                    \"300-860\",\n                    \"880-1320\",\n                    \"220-440\",\n                    \"125-500\",\n                    \"60-150\",\n                    \"175-310\",\n                    \"220-340\",\n                    \"190-275\",\n                ],\n                \"weight (female, lbs)\": [\n                    \"205-455\",\n                    \"330-550\",\n                    \"110-275\",\n                    \"90-300\",\n                    \"45-90\",", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_readme.py_5-55"}
{"title": "maxhumber_redframes-tests-test_readme.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_readme.py"], "line_no": 40, "start_line_no": 15, "end_line_no": 65, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        import redframes as rf\n\n        df = rf.DataFrame(\n            {\n                \"bear\": [\n                    \"Brown bear\",\n                    \"Polar bear\",\n                    \"Asian black bear\",\n                    \"American black bear\",\n                    \"Sun bear\",\n                    \"Sloth bear\",\n                    \"Spectacled bear\",\n                    \"Giant panda\",\n                ],\n                \"genus\": [\n                    \"Ursus\",\n                    \"Ursus\",\n                    \"Ursus\",\n                    \"Ursus\",\n                    \"Helarctos\",\n                    \"Melursus\",\n                    \"Tremarctos\",\n                    \"Ailuropoda\",\n                ],\n                \"weight (male, lbs)\": [\n                    \"300-860\",\n                    \"880-1320\",\n                    \"220-440\",\n                    \"125-500\",\n                    \"60-150\",\n                    \"175-310\",\n                    \"220-340\",\n                    \"190-275\",\n                ],\n                \"weight (female, lbs)\": [\n                    \"205-455\",\n                    \"330-550\",\n                    \"110-275\",\n                    \"90-300\",\n                    \"45-90\",\n                    \"120-210\",\n                    \"140-180\",\n                    \"155-220\",\n                ],\n            }\n        )\n\n        # | bear                | genus      | weight (male, lbs)   | weight (female, lbs)   |\n        # |:--------------------|:-----------|:---------------------|:-----------------------|\n        # | Brown bear          | Ursus      | 300-860              | 205-455                |", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_readme.py_15-65"}
{"title": "maxhumber_redframes-tests-test_readme.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_readme.py"], "line_no": 50, "start_line_no": 25, "end_line_no": 75, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "                    \"Sloth bear\",\n                    \"Spectacled bear\",\n                    \"Giant panda\",\n                ],\n                \"genus\": [\n                    \"Ursus\",\n                    \"Ursus\",\n                    \"Ursus\",\n                    \"Ursus\",\n                    \"Helarctos\",\n                    \"Melursus\",\n                    \"Tremarctos\",\n                    \"Ailuropoda\",\n                ],\n                \"weight (male, lbs)\": [\n                    \"300-860\",\n                    \"880-1320\",\n                    \"220-440\",\n                    \"125-500\",\n                    \"60-150\",\n                    \"175-310\",\n                    \"220-340\",\n                    \"190-275\",\n                ],\n                \"weight (female, lbs)\": [\n                    \"205-455\",\n                    \"330-550\",\n                    \"110-275\",\n                    \"90-300\",\n                    \"45-90\",\n                    \"120-210\",\n                    \"140-180\",\n                    \"155-220\",\n                ],\n            }\n        )\n\n        # | bear                | genus      | weight (male, lbs)   | weight (female, lbs)   |\n        # |:--------------------|:-----------|:---------------------|:-----------------------|\n        # | Brown bear          | Ursus      | 300-860              | 205-455                |\n        # | Polar bear          | Ursus      | 880-1320             | 330-550                |\n        # | Asian black bear    | Ursus      | 220-440              | 110-275                |\n        # | American black bear | Ursus      | 125-500              | 90-300                 |\n        # | Sun bear            | Helarctos  | 60-150               | 45-90                  |\n        # | Sloth bear          | Melursus   | 175-310              | 120-210                |\n        # | Spectacled bear     | Tremarctos | 220-340              | 140-180                |\n        # | Giant panda         | Ailuropoda | 190-275              | 155-220                |\n\n        (\n            df.rename({\"weight (male, lbs)\": \"male\", \"weight (female, lbs)\": \"female\"})", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_readme.py_25-75"}
{"title": "maxhumber_redframes-tests-test_readme.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_readme.py"], "line_no": 60, "start_line_no": 35, "end_line_no": 85, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "                    \"Melursus\",\n                    \"Tremarctos\",\n                    \"Ailuropoda\",\n                ],\n                \"weight (male, lbs)\": [\n                    \"300-860\",\n                    \"880-1320\",\n                    \"220-440\",\n                    \"125-500\",\n                    \"60-150\",\n                    \"175-310\",\n                    \"220-340\",\n                    \"190-275\",\n                ],\n                \"weight (female, lbs)\": [\n                    \"205-455\",\n                    \"330-550\",\n                    \"110-275\",\n                    \"90-300\",\n                    \"45-90\",\n                    \"120-210\",\n                    \"140-180\",\n                    \"155-220\",\n                ],\n            }\n        )\n\n        # | bear                | genus      | weight (male, lbs)   | weight (female, lbs)   |\n        # |:--------------------|:-----------|:---------------------|:-----------------------|\n        # | Brown bear          | Ursus      | 300-860              | 205-455                |\n        # | Polar bear          | Ursus      | 880-1320             | 330-550                |\n        # | Asian black bear    | Ursus      | 220-440              | 110-275                |\n        # | American black bear | Ursus      | 125-500              | 90-300                 |\n        # | Sun bear            | Helarctos  | 60-150               | 45-90                  |\n        # | Sloth bear          | Melursus   | 175-310              | 120-210                |\n        # | Spectacled bear     | Tremarctos | 220-340              | 140-180                |\n        # | Giant panda         | Ailuropoda | 190-275              | 155-220                |\n\n        (\n            df.rename({\"weight (male, lbs)\": \"male\", \"weight (female, lbs)\": \"female\"})\n            .gather([\"male\", \"female\"], into=(\"sex\", \"weight\"))\n            .split(\"weight\", into=[\"min\", \"max\"], sep=\"-\")\n            .gather([\"min\", \"max\"], into=(\"stat\", \"weight\"))\n            .mutate({\"weight\": lambda row: float(row[\"weight\"])})\n            .group([\"genus\", \"sex\"])\n            .rollup({\"weight\": (\"weight\", rf.stat.mean)})\n            .spread(\"sex\", using=\"weight\")\n            .mutate({\"dimorphism\": lambda row: round(row[\"male\"] / row[\"female\"], 2)})\n            .drop([\"male\", \"female\"])\n            .sort(\"dimorphism\", descending=True)", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_readme.py_35-85"}
{"title": "maxhumber_redframes-tests-test_readme.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_readme.py"], "line_no": 70, "start_line_no": 45, "end_line_no": 95, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "                    \"175-310\",\n                    \"220-340\",\n                    \"190-275\",\n                ],\n                \"weight (female, lbs)\": [\n                    \"205-455\",\n                    \"330-550\",\n                    \"110-275\",\n                    \"90-300\",\n                    \"45-90\",\n                    \"120-210\",\n                    \"140-180\",\n                    \"155-220\",\n                ],\n            }\n        )\n\n        # | bear                | genus      | weight (male, lbs)   | weight (female, lbs)   |\n        # |:--------------------|:-----------|:---------------------|:-----------------------|\n        # | Brown bear          | Ursus      | 300-860              | 205-455                |\n        # | Polar bear          | Ursus      | 880-1320             | 330-550                |\n        # | Asian black bear    | Ursus      | 220-440              | 110-275                |\n        # | American black bear | Ursus      | 125-500              | 90-300                 |\n        # | Sun bear            | Helarctos  | 60-150               | 45-90                  |\n        # | Sloth bear          | Melursus   | 175-310              | 120-210                |\n        # | Spectacled bear     | Tremarctos | 220-340              | 140-180                |\n        # | Giant panda         | Ailuropoda | 190-275              | 155-220                |\n\n        (\n            df.rename({\"weight (male, lbs)\": \"male\", \"weight (female, lbs)\": \"female\"})\n            .gather([\"male\", \"female\"], into=(\"sex\", \"weight\"))\n            .split(\"weight\", into=[\"min\", \"max\"], sep=\"-\")\n            .gather([\"min\", \"max\"], into=(\"stat\", \"weight\"))\n            .mutate({\"weight\": lambda row: float(row[\"weight\"])})\n            .group([\"genus\", \"sex\"])\n            .rollup({\"weight\": (\"weight\", rf.stat.mean)})\n            .spread(\"sex\", using=\"weight\")\n            .mutate({\"dimorphism\": lambda row: round(row[\"male\"] / row[\"female\"], 2)})\n            .drop([\"male\", \"female\"])\n            .sort(\"dimorphism\", descending=True)\n        )\n\n        # | genus      |   dimorphism |\n        # |:-----------|-------------:|\n        # | Ursus      |         2.01 |\n        # | Tremarctos |         1.75 |\n        # | Helarctos  |         1.56 |\n        # | Melursus   |         1.47 |\n        # | Ailuropoda |         1.24 |\n", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_readme.py_45-95"}
{"title": "maxhumber_redframes-tests-test_readme.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_readme.py"], "line_no": 80, "start_line_no": 55, "end_line_no": 105, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "                    \"120-210\",\n                    \"140-180\",\n                    \"155-220\",\n                ],\n            }\n        )\n\n        # | bear                | genus      | weight (male, lbs)   | weight (female, lbs)   |\n        # |:--------------------|:-----------|:---------------------|:-----------------------|\n        # | Brown bear          | Ursus      | 300-860              | 205-455                |\n        # | Polar bear          | Ursus      | 880-1320             | 330-550                |\n        # | Asian black bear    | Ursus      | 220-440              | 110-275                |\n        # | American black bear | Ursus      | 125-500              | 90-300                 |\n        # | Sun bear            | Helarctos  | 60-150               | 45-90                  |\n        # | Sloth bear          | Melursus   | 175-310              | 120-210                |\n        # | Spectacled bear     | Tremarctos | 220-340              | 140-180                |\n        # | Giant panda         | Ailuropoda | 190-275              | 155-220                |\n\n        (\n            df.rename({\"weight (male, lbs)\": \"male\", \"weight (female, lbs)\": \"female\"})\n            .gather([\"male\", \"female\"], into=(\"sex\", \"weight\"))\n            .split(\"weight\", into=[\"min\", \"max\"], sep=\"-\")\n            .gather([\"min\", \"max\"], into=(\"stat\", \"weight\"))\n            .mutate({\"weight\": lambda row: float(row[\"weight\"])})\n            .group([\"genus\", \"sex\"])\n            .rollup({\"weight\": (\"weight\", rf.stat.mean)})\n            .spread(\"sex\", using=\"weight\")\n            .mutate({\"dimorphism\": lambda row: round(row[\"male\"] / row[\"female\"], 2)})\n            .drop([\"male\", \"female\"])\n            .sort(\"dimorphism\", descending=True)\n        )\n\n        # | genus      |   dimorphism |\n        # |:-----------|-------------:|\n        # | Ursus      |         2.01 |\n        # | Tremarctos |         1.75 |\n        # | Helarctos  |         1.56 |\n        # | Melursus   |         1.47 |\n        # | Ailuropoda |         1.24 |\n\n        self.assertTrue(True)\n\n    def test_pandas_comparison(self):\n        import pandas as pd\n\n        df = pd.DataFrame(\n            {\n                \"bear\": [\n                    \"Brown bear\",\n                    \"Polar bear\",", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_readme.py_55-105"}
{"title": "maxhumber_redframes-tests-test_readme.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_readme.py"], "line_no": 90, "start_line_no": 65, "end_line_no": 115, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        # | Polar bear          | Ursus      | 880-1320             | 330-550                |\n        # | Asian black bear    | Ursus      | 220-440              | 110-275                |\n        # | American black bear | Ursus      | 125-500              | 90-300                 |\n        # | Sun bear            | Helarctos  | 60-150               | 45-90                  |\n        # | Sloth bear          | Melursus   | 175-310              | 120-210                |\n        # | Spectacled bear     | Tremarctos | 220-340              | 140-180                |\n        # | Giant panda         | Ailuropoda | 190-275              | 155-220                |\n\n        (\n            df.rename({\"weight (male, lbs)\": \"male\", \"weight (female, lbs)\": \"female\"})\n            .gather([\"male\", \"female\"], into=(\"sex\", \"weight\"))\n            .split(\"weight\", into=[\"min\", \"max\"], sep=\"-\")\n            .gather([\"min\", \"max\"], into=(\"stat\", \"weight\"))\n            .mutate({\"weight\": lambda row: float(row[\"weight\"])})\n            .group([\"genus\", \"sex\"])\n            .rollup({\"weight\": (\"weight\", rf.stat.mean)})\n            .spread(\"sex\", using=\"weight\")\n            .mutate({\"dimorphism\": lambda row: round(row[\"male\"] / row[\"female\"], 2)})\n            .drop([\"male\", \"female\"])\n            .sort(\"dimorphism\", descending=True)\n        )\n\n        # | genus      |   dimorphism |\n        # |:-----------|-------------:|\n        # | Ursus      |         2.01 |\n        # | Tremarctos |         1.75 |\n        # | Helarctos  |         1.56 |\n        # | Melursus   |         1.47 |\n        # | Ailuropoda |         1.24 |\n\n        self.assertTrue(True)\n\n    def test_pandas_comparison(self):\n        import pandas as pd\n\n        df = pd.DataFrame(\n            {\n                \"bear\": [\n                    \"Brown bear\",\n                    \"Polar bear\",\n                    \"Asian black bear\",\n                    \"American black bear\",\n                    \"Sun bear\",\n                    \"Sloth bear\",\n                    \"Spectacled bear\",\n                    \"Giant panda\",\n                ],\n                \"genus\": [\n                    \"Ursus\",\n                    \"Ursus\",", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_readme.py_65-115"}
{"title": "maxhumber_redframes-tests-test_readme.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_readme.py"], "line_no": 100, "start_line_no": 75, "end_line_no": 125, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "            .gather([\"male\", \"female\"], into=(\"sex\", \"weight\"))\n            .split(\"weight\", into=[\"min\", \"max\"], sep=\"-\")\n            .gather([\"min\", \"max\"], into=(\"stat\", \"weight\"))\n            .mutate({\"weight\": lambda row: float(row[\"weight\"])})\n            .group([\"genus\", \"sex\"])\n            .rollup({\"weight\": (\"weight\", rf.stat.mean)})\n            .spread(\"sex\", using=\"weight\")\n            .mutate({\"dimorphism\": lambda row: round(row[\"male\"] / row[\"female\"], 2)})\n            .drop([\"male\", \"female\"])\n            .sort(\"dimorphism\", descending=True)\n        )\n\n        # | genus      |   dimorphism |\n        # |:-----------|-------------:|\n        # | Ursus      |         2.01 |\n        # | Tremarctos |         1.75 |\n        # | Helarctos  |         1.56 |\n        # | Melursus   |         1.47 |\n        # | Ailuropoda |         1.24 |\n\n        self.assertTrue(True)\n\n    def test_pandas_comparison(self):\n        import pandas as pd\n\n        df = pd.DataFrame(\n            {\n                \"bear\": [\n                    \"Brown bear\",\n                    \"Polar bear\",\n                    \"Asian black bear\",\n                    \"American black bear\",\n                    \"Sun bear\",\n                    \"Sloth bear\",\n                    \"Spectacled bear\",\n                    \"Giant panda\",\n                ],\n                \"genus\": [\n                    \"Ursus\",\n                    \"Ursus\",\n                    \"Ursus\",\n                    \"Ursus\",\n                    \"Helarctos\",\n                    \"Melursus\",\n                    \"Tremarctos\",\n                    \"Ailuropoda\",\n                ],\n                \"weight (male, lbs)\": [\n                    \"300-860\",\n                    \"880-1320\",", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_readme.py_75-125"}
{"title": "maxhumber_redframes-tests-test_readme.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_readme.py"], "line_no": 110, "start_line_no": 85, "end_line_no": 135, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        )\n\n        # | genus      |   dimorphism |\n        # |:-----------|-------------:|\n        # | Ursus      |         2.01 |\n        # | Tremarctos |         1.75 |\n        # | Helarctos  |         1.56 |\n        # | Melursus   |         1.47 |\n        # | Ailuropoda |         1.24 |\n\n        self.assertTrue(True)\n\n    def test_pandas_comparison(self):\n        import pandas as pd\n\n        df = pd.DataFrame(\n            {\n                \"bear\": [\n                    \"Brown bear\",\n                    \"Polar bear\",\n                    \"Asian black bear\",\n                    \"American black bear\",\n                    \"Sun bear\",\n                    \"Sloth bear\",\n                    \"Spectacled bear\",\n                    \"Giant panda\",\n                ],\n                \"genus\": [\n                    \"Ursus\",\n                    \"Ursus\",\n                    \"Ursus\",\n                    \"Ursus\",\n                    \"Helarctos\",\n                    \"Melursus\",\n                    \"Tremarctos\",\n                    \"Ailuropoda\",\n                ],\n                \"weight (male, lbs)\": [\n                    \"300-860\",\n                    \"880-1320\",\n                    \"220-440\",\n                    \"125-500\",\n                    \"60-150\",\n                    \"175-310\",\n                    \"220-340\",\n                    \"190-275\",\n                ],\n                \"weight (female, lbs)\": [\n                    \"205-455\",\n                    \"330-550\",", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_readme.py_85-135"}
{"title": "maxhumber_redframes-tests-test_readme.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_readme.py"], "line_no": 120, "start_line_no": 95, "end_line_no": 145, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        self.assertTrue(True)\n\n    def test_pandas_comparison(self):\n        import pandas as pd\n\n        df = pd.DataFrame(\n            {\n                \"bear\": [\n                    \"Brown bear\",\n                    \"Polar bear\",\n                    \"Asian black bear\",\n                    \"American black bear\",\n                    \"Sun bear\",\n                    \"Sloth bear\",\n                    \"Spectacled bear\",\n                    \"Giant panda\",\n                ],\n                \"genus\": [\n                    \"Ursus\",\n                    \"Ursus\",\n                    \"Ursus\",\n                    \"Ursus\",\n                    \"Helarctos\",\n                    \"Melursus\",\n                    \"Tremarctos\",\n                    \"Ailuropoda\",\n                ],\n                \"weight (male, lbs)\": [\n                    \"300-860\",\n                    \"880-1320\",\n                    \"220-440\",\n                    \"125-500\",\n                    \"60-150\",\n                    \"175-310\",\n                    \"220-340\",\n                    \"190-275\",\n                ],\n                \"weight (female, lbs)\": [\n                    \"205-455\",\n                    \"330-550\",\n                    \"110-275\",\n                    \"90-300\",\n                    \"45-90\",\n                    \"120-210\",\n                    \"140-180\",\n                    \"155-220\",\n                ],\n            }\n        )\n", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_readme.py_95-145"}
{"title": "maxhumber_redframes-tests-test_readme.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_readme.py"], "line_no": 130, "start_line_no": 105, "end_line_no": 155, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "                    \"Asian black bear\",\n                    \"American black bear\",\n                    \"Sun bear\",\n                    \"Sloth bear\",\n                    \"Spectacled bear\",\n                    \"Giant panda\",\n                ],\n                \"genus\": [\n                    \"Ursus\",\n                    \"Ursus\",\n                    \"Ursus\",\n                    \"Ursus\",\n                    \"Helarctos\",\n                    \"Melursus\",\n                    \"Tremarctos\",\n                    \"Ailuropoda\",\n                ],\n                \"weight (male, lbs)\": [\n                    \"300-860\",\n                    \"880-1320\",\n                    \"220-440\",\n                    \"125-500\",\n                    \"60-150\",\n                    \"175-310\",\n                    \"220-340\",\n                    \"190-275\",\n                ],\n                \"weight (female, lbs)\": [\n                    \"205-455\",\n                    \"330-550\",\n                    \"110-275\",\n                    \"90-300\",\n                    \"45-90\",\n                    \"120-210\",\n                    \"140-180\",\n                    \"155-220\",\n                ],\n            }\n        )\n\n        df = df.rename(\n            columns={\"weight (male, lbs)\": \"male\", \"weight (female, lbs)\": \"female\"}\n        )\n        df = pd.melt(\n            df,\n            id_vars=[\"bear\", \"genus\"],\n            value_vars=[\"male\", \"female\"],\n            var_name=\"sex\",\n            value_name=\"weight\",\n        )", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_readme.py_105-155"}
{"title": "maxhumber_redframes-tests-test_readme.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_readme.py"], "line_no": 140, "start_line_no": 115, "end_line_no": 165, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "                    \"Ursus\",\n                    \"Ursus\",\n                    \"Helarctos\",\n                    \"Melursus\",\n                    \"Tremarctos\",\n                    \"Ailuropoda\",\n                ],\n                \"weight (male, lbs)\": [\n                    \"300-860\",\n                    \"880-1320\",\n                    \"220-440\",\n                    \"125-500\",\n                    \"60-150\",\n                    \"175-310\",\n                    \"220-340\",\n                    \"190-275\",\n                ],\n                \"weight (female, lbs)\": [\n                    \"205-455\",\n                    \"330-550\",\n                    \"110-275\",\n                    \"90-300\",\n                    \"45-90\",\n                    \"120-210\",\n                    \"140-180\",\n                    \"155-220\",\n                ],\n            }\n        )\n\n        df = df.rename(\n            columns={\"weight (male, lbs)\": \"male\", \"weight (female, lbs)\": \"female\"}\n        )\n        df = pd.melt(\n            df,\n            id_vars=[\"bear\", \"genus\"],\n            value_vars=[\"male\", \"female\"],\n            var_name=\"sex\",\n            value_name=\"weight\",\n        )\n        df[[\"min\", \"max\"]] = df[\"weight\"].str.split(\"-\", expand=True)\n        df = df.drop(\"weight\", axis=1)\n        df = pd.melt(\n            df,\n            id_vars=[\"bear\", \"genus\", \"sex\"],\n            value_vars=[\"min\", \"max\"],\n            var_name=\"stat\",\n            value_name=\"weight\",\n        )\n        df[\"weight\"] = df[\"weight\"].astype(\"float\")", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_readme.py_115-165"}
{"title": "maxhumber_redframes-tests-test_readme.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_readme.py"], "line_no": 150, "start_line_no": 125, "end_line_no": 175, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "                    \"220-440\",\n                    \"125-500\",\n                    \"60-150\",\n                    \"175-310\",\n                    \"220-340\",\n                    \"190-275\",\n                ],\n                \"weight (female, lbs)\": [\n                    \"205-455\",\n                    \"330-550\",\n                    \"110-275\",\n                    \"90-300\",\n                    \"45-90\",\n                    \"120-210\",\n                    \"140-180\",\n                    \"155-220\",\n                ],\n            }\n        )\n\n        df = df.rename(\n            columns={\"weight (male, lbs)\": \"male\", \"weight (female, lbs)\": \"female\"}\n        )\n        df = pd.melt(\n            df,\n            id_vars=[\"bear\", \"genus\"],\n            value_vars=[\"male\", \"female\"],\n            var_name=\"sex\",\n            value_name=\"weight\",\n        )\n        df[[\"min\", \"max\"]] = df[\"weight\"].str.split(\"-\", expand=True)\n        df = df.drop(\"weight\", axis=1)\n        df = pd.melt(\n            df,\n            id_vars=[\"bear\", \"genus\", \"sex\"],\n            value_vars=[\"min\", \"max\"],\n            var_name=\"stat\",\n            value_name=\"weight\",\n        )\n        df[\"weight\"] = df[\"weight\"].astype(\"float\")\n        df = df.groupby([\"genus\", \"sex\"])[\"weight\"].mean()\n        df = df.reset_index()\n        df = pd.pivot_table(df, index=[\"genus\"], columns=[\"sex\"], values=\"weight\")\n        df = df.reset_index()\n        df = df.rename_axis(None, axis=1)\n        df[\"dimorphism\"] = round(df[\"male\"] / df[\"female\"], 2)\n        df = df.drop([\"female\", \"male\"], axis=1)\n        df = df.sort_values(\"dimorphism\", ascending=False)\n        df = df.reset_index(drop=True)\n", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_readme.py_125-175"}
{"title": "maxhumber_redframes-tests-test_readme.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_readme.py"], "line_no": 160, "start_line_no": 135, "end_line_no": 185, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "                    \"110-275\",\n                    \"90-300\",\n                    \"45-90\",\n                    \"120-210\",\n                    \"140-180\",\n                    \"155-220\",\n                ],\n            }\n        )\n\n        df = df.rename(\n            columns={\"weight (male, lbs)\": \"male\", \"weight (female, lbs)\": \"female\"}\n        )\n        df = pd.melt(\n            df,\n            id_vars=[\"bear\", \"genus\"],\n            value_vars=[\"male\", \"female\"],\n            var_name=\"sex\",\n            value_name=\"weight\",\n        )\n        df[[\"min\", \"max\"]] = df[\"weight\"].str.split(\"-\", expand=True)\n        df = df.drop(\"weight\", axis=1)\n        df = pd.melt(\n            df,\n            id_vars=[\"bear\", \"genus\", \"sex\"],\n            value_vars=[\"min\", \"max\"],\n            var_name=\"stat\",\n            value_name=\"weight\",\n        )\n        df[\"weight\"] = df[\"weight\"].astype(\"float\")\n        df = df.groupby([\"genus\", \"sex\"])[\"weight\"].mean()\n        df = df.reset_index()\n        df = pd.pivot_table(df, index=[\"genus\"], columns=[\"sex\"], values=\"weight\")\n        df = df.reset_index()\n        df = df.rename_axis(None, axis=1)\n        df[\"dimorphism\"] = round(df[\"male\"] / df[\"female\"], 2)\n        df = df.drop([\"female\", \"male\"], axis=1)\n        df = df.sort_values(\"dimorphism\", ascending=False)\n        df = df.reset_index(drop=True)\n\n        self.assertTrue(True)\n\n    def test_io(self):\n        import redframes as rf\n\n        df = rf.DataFrame({\"foo\": [1, 2], \"bar\": [\"A\", \"B\"]})\n\n        # save .csv\n        rf.save(df, self.path)\n", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_readme.py_135-185"}
{"title": "maxhumber_redframes-tests-test_readme.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_readme.py"], "line_no": 170, "start_line_no": 145, "end_line_no": 195, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        df = df.rename(\n            columns={\"weight (male, lbs)\": \"male\", \"weight (female, lbs)\": \"female\"}\n        )\n        df = pd.melt(\n            df,\n            id_vars=[\"bear\", \"genus\"],\n            value_vars=[\"male\", \"female\"],\n            var_name=\"sex\",\n            value_name=\"weight\",\n        )\n        df[[\"min\", \"max\"]] = df[\"weight\"].str.split(\"-\", expand=True)\n        df = df.drop(\"weight\", axis=1)\n        df = pd.melt(\n            df,\n            id_vars=[\"bear\", \"genus\", \"sex\"],\n            value_vars=[\"min\", \"max\"],\n            var_name=\"stat\",\n            value_name=\"weight\",\n        )\n        df[\"weight\"] = df[\"weight\"].astype(\"float\")\n        df = df.groupby([\"genus\", \"sex\"])[\"weight\"].mean()\n        df = df.reset_index()\n        df = pd.pivot_table(df, index=[\"genus\"], columns=[\"sex\"], values=\"weight\")\n        df = df.reset_index()\n        df = df.rename_axis(None, axis=1)\n        df[\"dimorphism\"] = round(df[\"male\"] / df[\"female\"], 2)\n        df = df.drop([\"female\", \"male\"], axis=1)\n        df = df.sort_values(\"dimorphism\", ascending=False)\n        df = df.reset_index(drop=True)\n\n        self.assertTrue(True)\n\n    def test_io(self):\n        import redframes as rf\n\n        df = rf.DataFrame({\"foo\": [1, 2], \"bar\": [\"A\", \"B\"]})\n\n        # save .csv\n        rf.save(df, self.path)\n\n        # load .csv\n        df = rf.load(self.path)\n\n        # convert redframes \u2192 pandas\n        pandas_df = rf.unwrap(df)\n\n        # convert pandas \u2192 redframes\n        df = rf.wrap(pandas_df)\n\n        self.assertTrue(True)", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_readme.py_145-195"}
{"title": "maxhumber_redframes-tests-test_readme.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_readme.py"], "line_no": 180, "start_line_no": 155, "end_line_no": 205, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        df[[\"min\", \"max\"]] = df[\"weight\"].str.split(\"-\", expand=True)\n        df = df.drop(\"weight\", axis=1)\n        df = pd.melt(\n            df,\n            id_vars=[\"bear\", \"genus\", \"sex\"],\n            value_vars=[\"min\", \"max\"],\n            var_name=\"stat\",\n            value_name=\"weight\",\n        )\n        df[\"weight\"] = df[\"weight\"].astype(\"float\")\n        df = df.groupby([\"genus\", \"sex\"])[\"weight\"].mean()\n        df = df.reset_index()\n        df = pd.pivot_table(df, index=[\"genus\"], columns=[\"sex\"], values=\"weight\")\n        df = df.reset_index()\n        df = df.rename_axis(None, axis=1)\n        df[\"dimorphism\"] = round(df[\"male\"] / df[\"female\"], 2)\n        df = df.drop([\"female\", \"male\"], axis=1)\n        df = df.sort_values(\"dimorphism\", ascending=False)\n        df = df.reset_index(drop=True)\n\n        self.assertTrue(True)\n\n    def test_io(self):\n        import redframes as rf\n\n        df = rf.DataFrame({\"foo\": [1, 2], \"bar\": [\"A\", \"B\"]})\n\n        # save .csv\n        rf.save(df, self.path)\n\n        # load .csv\n        df = rf.load(self.path)\n\n        # convert redframes \u2192 pandas\n        pandas_df = rf.unwrap(df)\n\n        # convert pandas \u2192 redframes\n        df = rf.wrap(pandas_df)\n\n        self.assertTrue(True)\n\n    def test_properties(self):\n        import redframes as rf\n\n        df = rf.DataFrame({\"genus\": [1]})\n\n        df[\"genus\"]\n        # ['Ursus', 'Ursus', 'Ursus', 'Ursus', 'Helarctos', 'Melursus', 'Tremarctos', 'Ailuropoda']\n\n        df.columns", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_readme.py_155-205"}
{"title": "maxhumber_redframes-tests-test_readme.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_readme.py"], "line_no": 190, "start_line_no": 165, "end_line_no": 215, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        df = df.groupby([\"genus\", \"sex\"])[\"weight\"].mean()\n        df = df.reset_index()\n        df = pd.pivot_table(df, index=[\"genus\"], columns=[\"sex\"], values=\"weight\")\n        df = df.reset_index()\n        df = df.rename_axis(None, axis=1)\n        df[\"dimorphism\"] = round(df[\"male\"] / df[\"female\"], 2)\n        df = df.drop([\"female\", \"male\"], axis=1)\n        df = df.sort_values(\"dimorphism\", ascending=False)\n        df = df.reset_index(drop=True)\n\n        self.assertTrue(True)\n\n    def test_io(self):\n        import redframes as rf\n\n        df = rf.DataFrame({\"foo\": [1, 2], \"bar\": [\"A\", \"B\"]})\n\n        # save .csv\n        rf.save(df, self.path)\n\n        # load .csv\n        df = rf.load(self.path)\n\n        # convert redframes \u2192 pandas\n        pandas_df = rf.unwrap(df)\n\n        # convert pandas \u2192 redframes\n        df = rf.wrap(pandas_df)\n\n        self.assertTrue(True)\n\n    def test_properties(self):\n        import redframes as rf\n\n        df = rf.DataFrame({\"genus\": [1]})\n\n        df[\"genus\"]\n        # ['Ursus', 'Ursus', 'Ursus', 'Ursus', 'Helarctos', 'Melursus', 'Tremarctos', 'Ailuropoda']\n\n        df.columns\n        # ['bear', 'genus', 'weight (male, lbs)', 'weight (female, lbs)']\n\n        df.dimensions\n        # {'rows': 8, 'columns': 4}\n\n        df.empty\n        # False\n\n        df.memory\n        # '2 KB'", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_readme.py_165-215"}
{"title": "maxhumber_redframes-tests-test_readme.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_readme.py"], "line_no": 200, "start_line_no": 175, "end_line_no": 225, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        self.assertTrue(True)\n\n    def test_io(self):\n        import redframes as rf\n\n        df = rf.DataFrame({\"foo\": [1, 2], \"bar\": [\"A\", \"B\"]})\n\n        # save .csv\n        rf.save(df, self.path)\n\n        # load .csv\n        df = rf.load(self.path)\n\n        # convert redframes \u2192 pandas\n        pandas_df = rf.unwrap(df)\n\n        # convert pandas \u2192 redframes\n        df = rf.wrap(pandas_df)\n\n        self.assertTrue(True)\n\n    def test_properties(self):\n        import redframes as rf\n\n        df = rf.DataFrame({\"genus\": [1]})\n\n        df[\"genus\"]\n        # ['Ursus', 'Ursus', 'Ursus', 'Ursus', 'Helarctos', 'Melursus', 'Tremarctos', 'Ailuropoda']\n\n        df.columns\n        # ['bear', 'genus', 'weight (male, lbs)', 'weight (female, lbs)']\n\n        df.dimensions\n        # {'rows': 8, 'columns': 4}\n\n        df.empty\n        # False\n\n        df.memory\n        # '2 KB'\n\n        df.types\n        # {'bear': object, 'genus': object, 'weight (male, lbs)': object, 'weight (female, lbs)': object}\n\n        self.assertTrue(True)\n\n    def test_matplotlib(self):\n        import matplotlib.pyplot as plt\n\n        import redframes as rf", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_readme.py_175-225"}
{"title": "maxhumber_redframes-tests-test_readme.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_readme.py"], "line_no": 210, "start_line_no": 185, "end_line_no": 235, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        # load .csv\n        df = rf.load(self.path)\n\n        # convert redframes \u2192 pandas\n        pandas_df = rf.unwrap(df)\n\n        # convert pandas \u2192 redframes\n        df = rf.wrap(pandas_df)\n\n        self.assertTrue(True)\n\n    def test_properties(self):\n        import redframes as rf\n\n        df = rf.DataFrame({\"genus\": [1]})\n\n        df[\"genus\"]\n        # ['Ursus', 'Ursus', 'Ursus', 'Ursus', 'Helarctos', 'Melursus', 'Tremarctos', 'Ailuropoda']\n\n        df.columns\n        # ['bear', 'genus', 'weight (male, lbs)', 'weight (female, lbs)']\n\n        df.dimensions\n        # {'rows': 8, 'columns': 4}\n\n        df.empty\n        # False\n\n        df.memory\n        # '2 KB'\n\n        df.types\n        # {'bear': object, 'genus': object, 'weight (male, lbs)': object, 'weight (female, lbs)': object}\n\n        self.assertTrue(True)\n\n    def test_matplotlib(self):\n        import matplotlib.pyplot as plt\n\n        import redframes as rf\n\n        football = rf.DataFrame(\n            {\n                \"position\": [\"TE\", \"K\", \"RB\", \"WR\", \"QB\"],\n                \"avp\": [116.98, 131.15, 180, 222.22, 272.91],\n            }\n        )\n\n        df = football.mutate(\n            {\"color\": lambda row: row[\"position\"] in [\"WR\", \"RB\"]}", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_readme.py_185-235"}
{"title": "maxhumber_redframes-tests-test_readme.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_readme.py"], "line_no": 220, "start_line_no": 195, "end_line_no": 245, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "\n    def test_properties(self):\n        import redframes as rf\n\n        df = rf.DataFrame({\"genus\": [1]})\n\n        df[\"genus\"]\n        # ['Ursus', 'Ursus', 'Ursus', 'Ursus', 'Helarctos', 'Melursus', 'Tremarctos', 'Ailuropoda']\n\n        df.columns\n        # ['bear', 'genus', 'weight (male, lbs)', 'weight (female, lbs)']\n\n        df.dimensions\n        # {'rows': 8, 'columns': 4}\n\n        df.empty\n        # False\n\n        df.memory\n        # '2 KB'\n\n        df.types\n        # {'bear': object, 'genus': object, 'weight (male, lbs)': object, 'weight (female, lbs)': object}\n\n        self.assertTrue(True)\n\n    def test_matplotlib(self):\n        import matplotlib.pyplot as plt\n\n        import redframes as rf\n\n        football = rf.DataFrame(\n            {\n                \"position\": [\"TE\", \"K\", \"RB\", \"WR\", \"QB\"],\n                \"avp\": [116.98, 131.15, 180, 222.22, 272.91],\n            }\n        )\n\n        df = football.mutate(\n            {\"color\": lambda row: row[\"position\"] in [\"WR\", \"RB\"]}\n        ).replace({\"color\": {False: \"orange\", True: \"red\"}})\n\n        plt.barh(df[\"position\"], df[\"avp\"], color=df[\"color\"])\n\n        self.assertTrue(True)\n\n    def test_sklearn(self):\n        from sklearn.linear_model import LinearRegression\n        from sklearn.model_selection import train_test_split\n", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_readme.py_195-245"}
{"title": "maxhumber_redframes-tests-test_readme.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_readme.py"], "line_no": 230, "start_line_no": 205, "end_line_no": 255, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        # ['bear', 'genus', 'weight (male, lbs)', 'weight (female, lbs)']\n\n        df.dimensions\n        # {'rows': 8, 'columns': 4}\n\n        df.empty\n        # False\n\n        df.memory\n        # '2 KB'\n\n        df.types\n        # {'bear': object, 'genus': object, 'weight (male, lbs)': object, 'weight (female, lbs)': object}\n\n        self.assertTrue(True)\n\n    def test_matplotlib(self):\n        import matplotlib.pyplot as plt\n\n        import redframes as rf\n\n        football = rf.DataFrame(\n            {\n                \"position\": [\"TE\", \"K\", \"RB\", \"WR\", \"QB\"],\n                \"avp\": [116.98, 131.15, 180, 222.22, 272.91],\n            }\n        )\n\n        df = football.mutate(\n            {\"color\": lambda row: row[\"position\"] in [\"WR\", \"RB\"]}\n        ).replace({\"color\": {False: \"orange\", True: \"red\"}})\n\n        plt.barh(df[\"position\"], df[\"avp\"], color=df[\"color\"])\n\n        self.assertTrue(True)\n\n    def test_sklearn(self):\n        from sklearn.linear_model import LinearRegression\n        from sklearn.model_selection import train_test_split\n\n        import redframes as rf\n\n        df = rf.DataFrame(\n            {\n                \"touchdowns\": [15, 19, 5, 7, 9, 10, 12, 22, 16, 10],\n                \"age\": [21, 22, 21, 24, 26, 28, 30, 35, 28, 21],\n                \"mvp\": [1, 1, 0, 0, 0, 0, 0, 1, 0, 0],\n            }\n        )\n", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_readme.py_205-255"}
{"title": "maxhumber_redframes-tests-test_readme.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_readme.py"], "line_no": 240, "start_line_no": 215, "end_line_no": 265, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "\n        df.types\n        # {'bear': object, 'genus': object, 'weight (male, lbs)': object, 'weight (female, lbs)': object}\n\n        self.assertTrue(True)\n\n    def test_matplotlib(self):\n        import matplotlib.pyplot as plt\n\n        import redframes as rf\n\n        football = rf.DataFrame(\n            {\n                \"position\": [\"TE\", \"K\", \"RB\", \"WR\", \"QB\"],\n                \"avp\": [116.98, 131.15, 180, 222.22, 272.91],\n            }\n        )\n\n        df = football.mutate(\n            {\"color\": lambda row: row[\"position\"] in [\"WR\", \"RB\"]}\n        ).replace({\"color\": {False: \"orange\", True: \"red\"}})\n\n        plt.barh(df[\"position\"], df[\"avp\"], color=df[\"color\"])\n\n        self.assertTrue(True)\n\n    def test_sklearn(self):\n        from sklearn.linear_model import LinearRegression\n        from sklearn.model_selection import train_test_split\n\n        import redframes as rf\n\n        df = rf.DataFrame(\n            {\n                \"touchdowns\": [15, 19, 5, 7, 9, 10, 12, 22, 16, 10],\n                \"age\": [21, 22, 21, 24, 26, 28, 30, 35, 28, 21],\n                \"mvp\": [1, 1, 0, 0, 0, 0, 0, 1, 0, 0],\n            }\n        )\n\n        target = \"touchdowns\"\n        y = df[target]\n        X = df.drop(target)\n        X_train, X_test, y_train, y_test = train_test_split(\n            X, y, test_size=0.3, random_state=1\n        )\n\n        model = LinearRegression()\n        model.fit(X_train, y_train)\n        model.score(X_test, y_test)", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_readme.py_215-265"}
{"title": "maxhumber_redframes-tests-test_readme.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_readme.py"], "line_no": 250, "start_line_no": 225, "end_line_no": 275, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "\n        football = rf.DataFrame(\n            {\n                \"position\": [\"TE\", \"K\", \"RB\", \"WR\", \"QB\"],\n                \"avp\": [116.98, 131.15, 180, 222.22, 272.91],\n            }\n        )\n\n        df = football.mutate(\n            {\"color\": lambda row: row[\"position\"] in [\"WR\", \"RB\"]}\n        ).replace({\"color\": {False: \"orange\", True: \"red\"}})\n\n        plt.barh(df[\"position\"], df[\"avp\"], color=df[\"color\"])\n\n        self.assertTrue(True)\n\n    def test_sklearn(self):\n        from sklearn.linear_model import LinearRegression\n        from sklearn.model_selection import train_test_split\n\n        import redframes as rf\n\n        df = rf.DataFrame(\n            {\n                \"touchdowns\": [15, 19, 5, 7, 9, 10, 12, 22, 16, 10],\n                \"age\": [21, 22, 21, 24, 26, 28, 30, 35, 28, 21],\n                \"mvp\": [1, 1, 0, 0, 0, 0, 0, 1, 0, 0],\n            }\n        )\n\n        target = \"touchdowns\"\n        y = df[target]\n        X = df.drop(target)\n        X_train, X_test, y_train, y_test = train_test_split(\n            X, y, test_size=0.3, random_state=1\n        )\n\n        model = LinearRegression()\n        model.fit(X_train, y_train)\n        model.score(X_test, y_test)\n        # 0.5083194901655527\n\n        # print(X_train.take(1))\n        # rf.DataFrame({'age': [21], 'mvp': [0]})\n\n        X_new = rf.DataFrame({\"age\": [22], \"mvp\": [1]})\n        model.predict(X_new)\n        # array([19.])\n\n        self.assertTrue(True)", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_readme.py_225-275"}
{"title": "maxhumber_redframes-tests-test_readme.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_readme.py"], "line_no": 260, "start_line_no": 235, "end_line_no": 275, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        ).replace({\"color\": {False: \"orange\", True: \"red\"}})\n\n        plt.barh(df[\"position\"], df[\"avp\"], color=df[\"color\"])\n\n        self.assertTrue(True)\n\n    def test_sklearn(self):\n        from sklearn.linear_model import LinearRegression\n        from sklearn.model_selection import train_test_split\n\n        import redframes as rf\n\n        df = rf.DataFrame(\n            {\n                \"touchdowns\": [15, 19, 5, 7, 9, 10, 12, 22, 16, 10],\n                \"age\": [21, 22, 21, 24, 26, 28, 30, 35, 28, 21],\n                \"mvp\": [1, 1, 0, 0, 0, 0, 0, 1, 0, 0],\n            }\n        )\n\n        target = \"touchdowns\"\n        y = df[target]\n        X = df.drop(target)\n        X_train, X_test, y_train, y_test = train_test_split(\n            X, y, test_size=0.3, random_state=1\n        )\n\n        model = LinearRegression()\n        model.fit(X_train, y_train)\n        model.score(X_test, y_test)\n        # 0.5083194901655527\n\n        # print(X_train.take(1))\n        # rf.DataFrame({'age': [21], 'mvp': [0]})\n\n        X_new = rf.DataFrame({\"age\": [22], \"mvp\": [1]})\n        model.predict(X_new)\n        # array([19.])\n\n        self.assertTrue(True)", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_readme.py_235-275"}
{"title": "maxhumber_redframes-tests-test_readme.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_readme.py"], "line_no": 270, "start_line_no": 245, "end_line_no": 275, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        import redframes as rf\n\n        df = rf.DataFrame(\n            {\n                \"touchdowns\": [15, 19, 5, 7, 9, 10, 12, 22, 16, 10],\n                \"age\": [21, 22, 21, 24, 26, 28, 30, 35, 28, 21],\n                \"mvp\": [1, 1, 0, 0, 0, 0, 0, 1, 0, 0],\n            }\n        )\n\n        target = \"touchdowns\"\n        y = df[target]\n        X = df.drop(target)\n        X_train, X_test, y_train, y_test = train_test_split(\n            X, y, test_size=0.3, random_state=1\n        )\n\n        model = LinearRegression()\n        model.fit(X_train, y_train)\n        model.score(X_test, y_test)\n        # 0.5083194901655527\n\n        # print(X_train.take(1))\n        # rf.DataFrame({'age': [21], 'mvp': [0]})\n\n        X_new = rf.DataFrame({\"age\": [22], \"mvp\": [1]})\n        model.predict(X_new)\n        # array([19.])\n\n        self.assertTrue(True)", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_readme.py_245-275"}
{"title": "maxhumber_redframes-tests-test_side_effects.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_side_effects.py"], "line_no": 0, "start_line_no": 0, "end_line_no": 25, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "import unittest\n\nimport redframes as rf\n\n\nclass TestSideEffects(unittest.TestCase):\n    def setUp(self):\n        self.df = rf.DataFrame(\n            {\n                \"foo\": range(10),\n                \"bar\": [1, 3.2, 4.5, 2, -1, 30, None, 1.1, 1.1, 9],\n                \"baz\": [\"A\", \"A\", None, \"B\", \"B\", \"A\", \"B\", \"C\", \"C\", \"A\"],\n                \"jaz\": [\n                    \"1::1\",\n                    \"2::2\",\n                    \"3:3\",\n                    \"4::4\",\n                    \"5::5\",\n                    \"6::7\",\n                    \"7::8\",\n                    \"8::9\",\n                    \"9::0\",\n                    \"0::-1\",\n                ],\n                \"raz\": [1, 2, 3, None, None, None, 9, 9, None, None],", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_side_effects.py_0-25"}
{"title": "maxhumber_redframes-tests-test_side_effects.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_side_effects.py"], "line_no": 10, "start_line_no": 0, "end_line_no": 35, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "import unittest\n\nimport redframes as rf\n\n\nclass TestSideEffects(unittest.TestCase):\n    def setUp(self):\n        self.df = rf.DataFrame(\n            {\n                \"foo\": range(10),\n                \"bar\": [1, 3.2, 4.5, 2, -1, 30, None, 1.1, 1.1, 9],\n                \"baz\": [\"A\", \"A\", None, \"B\", \"B\", \"A\", \"B\", \"C\", \"C\", \"A\"],\n                \"jaz\": [\n                    \"1::1\",\n                    \"2::2\",\n                    \"3:3\",\n                    \"4::4\",\n                    \"5::5\",\n                    \"6::7\",\n                    \"7::8\",\n                    \"8::9\",\n                    \"9::0\",\n                    \"0::-1\",\n                ],\n                \"raz\": [1, 2, 3, None, None, None, 9, 9, None, None],\n            }\n        )\n        self.expected = rf.DataFrame(\n            {\n                \"foo\": range(10),\n                \"bar\": [1, 3.2, 4.5, 2, -1, 30, None, 1.1, 1.1, 9],\n                \"baz\": [\"A\", \"A\", None, \"B\", \"B\", \"A\", \"B\", \"C\", \"C\", \"A\"],\n                \"jaz\": [\n                    \"1::1\",\n                    \"2::2\",", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_side_effects.py_0-35"}
{"title": "maxhumber_redframes-tests-test_side_effects.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_side_effects.py"], "line_no": 20, "start_line_no": 0, "end_line_no": 45, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "import unittest\n\nimport redframes as rf\n\n\nclass TestSideEffects(unittest.TestCase):\n    def setUp(self):\n        self.df = rf.DataFrame(\n            {\n                \"foo\": range(10),\n                \"bar\": [1, 3.2, 4.5, 2, -1, 30, None, 1.1, 1.1, 9],\n                \"baz\": [\"A\", \"A\", None, \"B\", \"B\", \"A\", \"B\", \"C\", \"C\", \"A\"],\n                \"jaz\": [\n                    \"1::1\",\n                    \"2::2\",\n                    \"3:3\",\n                    \"4::4\",\n                    \"5::5\",\n                    \"6::7\",\n                    \"7::8\",\n                    \"8::9\",\n                    \"9::0\",\n                    \"0::-1\",\n                ],\n                \"raz\": [1, 2, 3, None, None, None, 9, 9, None, None],\n            }\n        )\n        self.expected = rf.DataFrame(\n            {\n                \"foo\": range(10),\n                \"bar\": [1, 3.2, 4.5, 2, -1, 30, None, 1.1, 1.1, 9],\n                \"baz\": [\"A\", \"A\", None, \"B\", \"B\", \"A\", \"B\", \"C\", \"C\", \"A\"],\n                \"jaz\": [\n                    \"1::1\",\n                    \"2::2\",\n                    \"3:3\",\n                    \"4::4\",\n                    \"5::5\",\n                    \"6::7\",\n                    \"7::8\",\n                    \"8::9\",\n                    \"9::0\",\n                    \"0::-1\",\n                ],\n                \"raz\": [1, 2, 3, None, None, None, 9, 9, None, None],", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_side_effects.py_0-45"}
{"title": "maxhumber_redframes-tests-test_side_effects.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_side_effects.py"], "line_no": 30, "start_line_no": 5, "end_line_no": 55, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "class TestSideEffects(unittest.TestCase):\n    def setUp(self):\n        self.df = rf.DataFrame(\n            {\n                \"foo\": range(10),\n                \"bar\": [1, 3.2, 4.5, 2, -1, 30, None, 1.1, 1.1, 9],\n                \"baz\": [\"A\", \"A\", None, \"B\", \"B\", \"A\", \"B\", \"C\", \"C\", \"A\"],\n                \"jaz\": [\n                    \"1::1\",\n                    \"2::2\",\n                    \"3:3\",\n                    \"4::4\",\n                    \"5::5\",\n                    \"6::7\",\n                    \"7::8\",\n                    \"8::9\",\n                    \"9::0\",\n                    \"0::-1\",\n                ],\n                \"raz\": [1, 2, 3, None, None, None, 9, 9, None, None],\n            }\n        )\n        self.expected = rf.DataFrame(\n            {\n                \"foo\": range(10),\n                \"bar\": [1, 3.2, 4.5, 2, -1, 30, None, 1.1, 1.1, 9],\n                \"baz\": [\"A\", \"A\", None, \"B\", \"B\", \"A\", \"B\", \"C\", \"C\", \"A\"],\n                \"jaz\": [\n                    \"1::1\",\n                    \"2::2\",\n                    \"3:3\",\n                    \"4::4\",\n                    \"5::5\",\n                    \"6::7\",\n                    \"7::8\",\n                    \"8::9\",\n                    \"9::0\",\n                    \"0::-1\",\n                ],\n                \"raz\": [1, 2, 3, None, None, None, 9, 9, None, None],\n            }\n        )\n\n    def test_accumulate(self):\n        _ = self.df.accumulate(\"foo\", into=\"foo\")\n        self.assertEqual(self.df, self.expected)\n\n    def test_append(self):\n        df_bottom = rf.DataFrame({\"foo\": [10]})\n        df_bottom_expected = rf.DataFrame({\"foo\": [10]})", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_side_effects.py_5-55"}
{"title": "maxhumber_redframes-tests-test_side_effects.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_side_effects.py"], "line_no": 40, "start_line_no": 15, "end_line_no": 65, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "                    \"3:3\",\n                    \"4::4\",\n                    \"5::5\",\n                    \"6::7\",\n                    \"7::8\",\n                    \"8::9\",\n                    \"9::0\",\n                    \"0::-1\",\n                ],\n                \"raz\": [1, 2, 3, None, None, None, 9, 9, None, None],\n            }\n        )\n        self.expected = rf.DataFrame(\n            {\n                \"foo\": range(10),\n                \"bar\": [1, 3.2, 4.5, 2, -1, 30, None, 1.1, 1.1, 9],\n                \"baz\": [\"A\", \"A\", None, \"B\", \"B\", \"A\", \"B\", \"C\", \"C\", \"A\"],\n                \"jaz\": [\n                    \"1::1\",\n                    \"2::2\",\n                    \"3:3\",\n                    \"4::4\",\n                    \"5::5\",\n                    \"6::7\",\n                    \"7::8\",\n                    \"8::9\",\n                    \"9::0\",\n                    \"0::-1\",\n                ],\n                \"raz\": [1, 2, 3, None, None, None, 9, 9, None, None],\n            }\n        )\n\n    def test_accumulate(self):\n        _ = self.df.accumulate(\"foo\", into=\"foo\")\n        self.assertEqual(self.df, self.expected)\n\n    def test_append(self):\n        df_bottom = rf.DataFrame({\"foo\": [10]})\n        df_bottom_expected = rf.DataFrame({\"foo\": [10]})\n        _ = self.df.append(df_bottom)\n        self.assertEqual(self.df, self.expected)\n        self.assertEqual(df_bottom, df_bottom_expected)\n\n    def test_combine(self):\n        _ = self.df.combine([\"foo\", \"bar\"], into=\"foo\", sep=\"-\")\n        self.assertEqual(self.df, self.expected)\n\n    def test_cross(self):\n        _ = self.df.cross(postfix=(\"_a\", \"_b\"))", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_side_effects.py_15-65"}
{"title": "maxhumber_redframes-tests-test_side_effects.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_side_effects.py"], "line_no": 50, "start_line_no": 25, "end_line_no": 75, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "            }\n        )\n        self.expected = rf.DataFrame(\n            {\n                \"foo\": range(10),\n                \"bar\": [1, 3.2, 4.5, 2, -1, 30, None, 1.1, 1.1, 9],\n                \"baz\": [\"A\", \"A\", None, \"B\", \"B\", \"A\", \"B\", \"C\", \"C\", \"A\"],\n                \"jaz\": [\n                    \"1::1\",\n                    \"2::2\",\n                    \"3:3\",\n                    \"4::4\",\n                    \"5::5\",\n                    \"6::7\",\n                    \"7::8\",\n                    \"8::9\",\n                    \"9::0\",\n                    \"0::-1\",\n                ],\n                \"raz\": [1, 2, 3, None, None, None, 9, 9, None, None],\n            }\n        )\n\n    def test_accumulate(self):\n        _ = self.df.accumulate(\"foo\", into=\"foo\")\n        self.assertEqual(self.df, self.expected)\n\n    def test_append(self):\n        df_bottom = rf.DataFrame({\"foo\": [10]})\n        df_bottom_expected = rf.DataFrame({\"foo\": [10]})\n        _ = self.df.append(df_bottom)\n        self.assertEqual(self.df, self.expected)\n        self.assertEqual(df_bottom, df_bottom_expected)\n\n    def test_combine(self):\n        _ = self.df.combine([\"foo\", \"bar\"], into=\"foo\", sep=\"-\")\n        self.assertEqual(self.df, self.expected)\n\n    def test_cross(self):\n        _ = self.df.cross(postfix=(\"_a\", \"_b\"))\n        self.assertEqual(self.df, self.expected)\n\n    def test_dedupe(self):\n        _ = self.df.dedupe(\"baz\")\n        self.assertEqual(self.df, self.expected)\n\n    def test_denix(self):\n        _ = self.df.denix()\n        self.assertEqual(self.df, self.expected)\n", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_side_effects.py_25-75"}
{"title": "maxhumber_redframes-tests-test_side_effects.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_side_effects.py"], "line_no": 60, "start_line_no": 35, "end_line_no": 85, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "                    \"3:3\",\n                    \"4::4\",\n                    \"5::5\",\n                    \"6::7\",\n                    \"7::8\",\n                    \"8::9\",\n                    \"9::0\",\n                    \"0::-1\",\n                ],\n                \"raz\": [1, 2, 3, None, None, None, 9, 9, None, None],\n            }\n        )\n\n    def test_accumulate(self):\n        _ = self.df.accumulate(\"foo\", into=\"foo\")\n        self.assertEqual(self.df, self.expected)\n\n    def test_append(self):\n        df_bottom = rf.DataFrame({\"foo\": [10]})\n        df_bottom_expected = rf.DataFrame({\"foo\": [10]})\n        _ = self.df.append(df_bottom)\n        self.assertEqual(self.df, self.expected)\n        self.assertEqual(df_bottom, df_bottom_expected)\n\n    def test_combine(self):\n        _ = self.df.combine([\"foo\", \"bar\"], into=\"foo\", sep=\"-\")\n        self.assertEqual(self.df, self.expected)\n\n    def test_cross(self):\n        _ = self.df.cross(postfix=(\"_a\", \"_b\"))\n        self.assertEqual(self.df, self.expected)\n\n    def test_dedupe(self):\n        _ = self.df.dedupe(\"baz\")\n        self.assertEqual(self.df, self.expected)\n\n    def test_denix(self):\n        _ = self.df.denix()\n        self.assertEqual(self.df, self.expected)\n\n    def test_drop(self):\n        _ = self.df.drop(\"foo\")\n        self.assertEqual(self.df, self.expected)\n\n    def test_fill(self):\n        _ = self.df.fill(\"baz\", direction=\"down\")\n        self.assertEqual(self.df, self.expected)\n\n    def test_filter(self):\n        _ = self.df.filter(lambda row: row[\"bar\"] > 5)", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_side_effects.py_35-85"}
{"title": "maxhumber_redframes-tests-test_side_effects.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_side_effects.py"], "line_no": 70, "start_line_no": 45, "end_line_no": 95, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "            }\n        )\n\n    def test_accumulate(self):\n        _ = self.df.accumulate(\"foo\", into=\"foo\")\n        self.assertEqual(self.df, self.expected)\n\n    def test_append(self):\n        df_bottom = rf.DataFrame({\"foo\": [10]})\n        df_bottom_expected = rf.DataFrame({\"foo\": [10]})\n        _ = self.df.append(df_bottom)\n        self.assertEqual(self.df, self.expected)\n        self.assertEqual(df_bottom, df_bottom_expected)\n\n    def test_combine(self):\n        _ = self.df.combine([\"foo\", \"bar\"], into=\"foo\", sep=\"-\")\n        self.assertEqual(self.df, self.expected)\n\n    def test_cross(self):\n        _ = self.df.cross(postfix=(\"_a\", \"_b\"))\n        self.assertEqual(self.df, self.expected)\n\n    def test_dedupe(self):\n        _ = self.df.dedupe(\"baz\")\n        self.assertEqual(self.df, self.expected)\n\n    def test_denix(self):\n        _ = self.df.denix()\n        self.assertEqual(self.df, self.expected)\n\n    def test_drop(self):\n        _ = self.df.drop(\"foo\")\n        self.assertEqual(self.df, self.expected)\n\n    def test_fill(self):\n        _ = self.df.fill(\"baz\", direction=\"down\")\n        self.assertEqual(self.df, self.expected)\n\n    def test_filter(self):\n        _ = self.df.filter(lambda row: row[\"bar\"] > 5)\n        self.assertEqual(self.df, self.expected)\n\n    def test_gather(self):\n        _ = self.df.gather()\n        self.assertEqual(self.df, self.expected)\n\n    def test_group(self):\n        _ = self.df.group(\"baz\").rollup({\"foo\": (\"foo\", rf.stat.mean)})\n        self.assertEqual(self.df, self.expected)\n", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_side_effects.py_45-95"}
{"title": "maxhumber_redframes-tests-test_side_effects.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_side_effects.py"], "line_no": 80, "start_line_no": 55, "end_line_no": 105, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        _ = self.df.append(df_bottom)\n        self.assertEqual(self.df, self.expected)\n        self.assertEqual(df_bottom, df_bottom_expected)\n\n    def test_combine(self):\n        _ = self.df.combine([\"foo\", \"bar\"], into=\"foo\", sep=\"-\")\n        self.assertEqual(self.df, self.expected)\n\n    def test_cross(self):\n        _ = self.df.cross(postfix=(\"_a\", \"_b\"))\n        self.assertEqual(self.df, self.expected)\n\n    def test_dedupe(self):\n        _ = self.df.dedupe(\"baz\")\n        self.assertEqual(self.df, self.expected)\n\n    def test_denix(self):\n        _ = self.df.denix()\n        self.assertEqual(self.df, self.expected)\n\n    def test_drop(self):\n        _ = self.df.drop(\"foo\")\n        self.assertEqual(self.df, self.expected)\n\n    def test_fill(self):\n        _ = self.df.fill(\"baz\", direction=\"down\")\n        self.assertEqual(self.df, self.expected)\n\n    def test_filter(self):\n        _ = self.df.filter(lambda row: row[\"bar\"] > 5)\n        self.assertEqual(self.df, self.expected)\n\n    def test_gather(self):\n        _ = self.df.gather()\n        self.assertEqual(self.df, self.expected)\n\n    def test_group(self):\n        _ = self.df.group(\"baz\").rollup({\"foo\": (\"foo\", rf.stat.mean)})\n        self.assertEqual(self.df, self.expected)\n\n    def test_join(self):\n        df_right = rf.DataFrame({\"baz\": [\"A\", \"B\"], \"haz\": [\"Apple\", \"Banana\"]})\n        df_right_expected = rf.DataFrame(\n            {\"baz\": [\"A\", \"B\"], \"haz\": [\"Apple\", \"Banana\"]}\n        )\n        _ = self.df.join(df_right, on=\"baz\")\n        self.assertEqual(self.df, self.expected)\n        self.assertEqual(df_right, df_right_expected)\n\n    def test_mutate(self):", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_side_effects.py_55-105"}
{"title": "maxhumber_redframes-tests-test_side_effects.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_side_effects.py"], "line_no": 90, "start_line_no": 65, "end_line_no": 115, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        self.assertEqual(self.df, self.expected)\n\n    def test_dedupe(self):\n        _ = self.df.dedupe(\"baz\")\n        self.assertEqual(self.df, self.expected)\n\n    def test_denix(self):\n        _ = self.df.denix()\n        self.assertEqual(self.df, self.expected)\n\n    def test_drop(self):\n        _ = self.df.drop(\"foo\")\n        self.assertEqual(self.df, self.expected)\n\n    def test_fill(self):\n        _ = self.df.fill(\"baz\", direction=\"down\")\n        self.assertEqual(self.df, self.expected)\n\n    def test_filter(self):\n        _ = self.df.filter(lambda row: row[\"bar\"] > 5)\n        self.assertEqual(self.df, self.expected)\n\n    def test_gather(self):\n        _ = self.df.gather()\n        self.assertEqual(self.df, self.expected)\n\n    def test_group(self):\n        _ = self.df.group(\"baz\").rollup({\"foo\": (\"foo\", rf.stat.mean)})\n        self.assertEqual(self.df, self.expected)\n\n    def test_join(self):\n        df_right = rf.DataFrame({\"baz\": [\"A\", \"B\"], \"haz\": [\"Apple\", \"Banana\"]})\n        df_right_expected = rf.DataFrame(\n            {\"baz\": [\"A\", \"B\"], \"haz\": [\"Apple\", \"Banana\"]}\n        )\n        _ = self.df.join(df_right, on=\"baz\")\n        self.assertEqual(self.df, self.expected)\n        self.assertEqual(df_right, df_right_expected)\n\n    def test_mutate(self):\n        _ = self.df.mutate({\"foo\": lambda row: row[\"foo\"] * 10})\n        self.assertEqual(self.df, self.expected)\n\n    def test_pack(self):\n        _ = self.df.pack(\"baz\", sep=\"|\")\n        self.assertEqual(self.df, self.expected)\n\n    def test_rank(self):\n        _ = self.df.rank(\"bar\", into=\"bar_rank\", descending=True)\n        self.assertEqual(self.df, self.expected)", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_side_effects.py_65-115"}
{"title": "maxhumber_redframes-tests-test_side_effects.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_side_effects.py"], "line_no": 100, "start_line_no": 75, "end_line_no": 125, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "    def test_drop(self):\n        _ = self.df.drop(\"foo\")\n        self.assertEqual(self.df, self.expected)\n\n    def test_fill(self):\n        _ = self.df.fill(\"baz\", direction=\"down\")\n        self.assertEqual(self.df, self.expected)\n\n    def test_filter(self):\n        _ = self.df.filter(lambda row: row[\"bar\"] > 5)\n        self.assertEqual(self.df, self.expected)\n\n    def test_gather(self):\n        _ = self.df.gather()\n        self.assertEqual(self.df, self.expected)\n\n    def test_group(self):\n        _ = self.df.group(\"baz\").rollup({\"foo\": (\"foo\", rf.stat.mean)})\n        self.assertEqual(self.df, self.expected)\n\n    def test_join(self):\n        df_right = rf.DataFrame({\"baz\": [\"A\", \"B\"], \"haz\": [\"Apple\", \"Banana\"]})\n        df_right_expected = rf.DataFrame(\n            {\"baz\": [\"A\", \"B\"], \"haz\": [\"Apple\", \"Banana\"]}\n        )\n        _ = self.df.join(df_right, on=\"baz\")\n        self.assertEqual(self.df, self.expected)\n        self.assertEqual(df_right, df_right_expected)\n\n    def test_mutate(self):\n        _ = self.df.mutate({\"foo\": lambda row: row[\"foo\"] * 10})\n        self.assertEqual(self.df, self.expected)\n\n    def test_pack(self):\n        _ = self.df.pack(\"baz\", sep=\"|\")\n        self.assertEqual(self.df, self.expected)\n\n    def test_rank(self):\n        _ = self.df.rank(\"bar\", into=\"bar_rank\", descending=True)\n        self.assertEqual(self.df, self.expected)\n\n    def test_rename(self):\n        _ = self.df.rename({\"foo\": \"oof\"})\n        self.assertEqual(self.df, self.expected)\n\n    def test_replace(self):\n        _ = self.df.replace({\"baz\": {\"B\": \"Banana\"}})\n        self.assertEqual(self.df, self.expected)\n\n    def test_rollup(self):", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_side_effects.py_75-125"}
{"title": "maxhumber_redframes-tests-test_side_effects.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_side_effects.py"], "line_no": 110, "start_line_no": 85, "end_line_no": 135, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        self.assertEqual(self.df, self.expected)\n\n    def test_gather(self):\n        _ = self.df.gather()\n        self.assertEqual(self.df, self.expected)\n\n    def test_group(self):\n        _ = self.df.group(\"baz\").rollup({\"foo\": (\"foo\", rf.stat.mean)})\n        self.assertEqual(self.df, self.expected)\n\n    def test_join(self):\n        df_right = rf.DataFrame({\"baz\": [\"A\", \"B\"], \"haz\": [\"Apple\", \"Banana\"]})\n        df_right_expected = rf.DataFrame(\n            {\"baz\": [\"A\", \"B\"], \"haz\": [\"Apple\", \"Banana\"]}\n        )\n        _ = self.df.join(df_right, on=\"baz\")\n        self.assertEqual(self.df, self.expected)\n        self.assertEqual(df_right, df_right_expected)\n\n    def test_mutate(self):\n        _ = self.df.mutate({\"foo\": lambda row: row[\"foo\"] * 10})\n        self.assertEqual(self.df, self.expected)\n\n    def test_pack(self):\n        _ = self.df.pack(\"baz\", sep=\"|\")\n        self.assertEqual(self.df, self.expected)\n\n    def test_rank(self):\n        _ = self.df.rank(\"bar\", into=\"bar_rank\", descending=True)\n        self.assertEqual(self.df, self.expected)\n\n    def test_rename(self):\n        _ = self.df.rename({\"foo\": \"oof\"})\n        self.assertEqual(self.df, self.expected)\n\n    def test_replace(self):\n        _ = self.df.replace({\"baz\": {\"B\": \"Banana\"}})\n        self.assertEqual(self.df, self.expected)\n\n    def test_rollup(self):\n        _ = self.df.rollup({\"bar_mean\": (\"bar\", rf.stat.mean)})\n        self.assertEqual(self.df, self.expected)\n\n    def test_sample(self):\n        _ = self.df.sample(5)\n        self.assertEqual(self.df, self.expected)\n\n    def test_select(self):\n        _ = self.df.select([\"foo\", \"bar\"])\n        self.assertEqual(self.df, self.expected)", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_side_effects.py_85-135"}
{"title": "maxhumber_redframes-tests-test_side_effects.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_side_effects.py"], "line_no": 120, "start_line_no": 95, "end_line_no": 145, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "    def test_join(self):\n        df_right = rf.DataFrame({\"baz\": [\"A\", \"B\"], \"haz\": [\"Apple\", \"Banana\"]})\n        df_right_expected = rf.DataFrame(\n            {\"baz\": [\"A\", \"B\"], \"haz\": [\"Apple\", \"Banana\"]}\n        )\n        _ = self.df.join(df_right, on=\"baz\")\n        self.assertEqual(self.df, self.expected)\n        self.assertEqual(df_right, df_right_expected)\n\n    def test_mutate(self):\n        _ = self.df.mutate({\"foo\": lambda row: row[\"foo\"] * 10})\n        self.assertEqual(self.df, self.expected)\n\n    def test_pack(self):\n        _ = self.df.pack(\"baz\", sep=\"|\")\n        self.assertEqual(self.df, self.expected)\n\n    def test_rank(self):\n        _ = self.df.rank(\"bar\", into=\"bar_rank\", descending=True)\n        self.assertEqual(self.df, self.expected)\n\n    def test_rename(self):\n        _ = self.df.rename({\"foo\": \"oof\"})\n        self.assertEqual(self.df, self.expected)\n\n    def test_replace(self):\n        _ = self.df.replace({\"baz\": {\"B\": \"Banana\"}})\n        self.assertEqual(self.df, self.expected)\n\n    def test_rollup(self):\n        _ = self.df.rollup({\"bar_mean\": (\"bar\", rf.stat.mean)})\n        self.assertEqual(self.df, self.expected)\n\n    def test_sample(self):\n        _ = self.df.sample(5)\n        self.assertEqual(self.df, self.expected)\n\n    def test_select(self):\n        _ = self.df.select([\"foo\", \"bar\"])\n        self.assertEqual(self.df, self.expected)\n\n    def test_shuffle(self):\n        _ = self.df.shuffle()\n        self.assertEqual(self.df, self.expected)\n\n    def test_sort(self):\n        _ = self.df.sort(\"bar\", descending=True)\n        self.assertEqual(self.df, self.expected)\n\n    def test_split(self):", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_side_effects.py_95-145"}
{"title": "maxhumber_redframes-tests-test_side_effects.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_side_effects.py"], "line_no": 130, "start_line_no": 105, "end_line_no": 155, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        _ = self.df.mutate({\"foo\": lambda row: row[\"foo\"] * 10})\n        self.assertEqual(self.df, self.expected)\n\n    def test_pack(self):\n        _ = self.df.pack(\"baz\", sep=\"|\")\n        self.assertEqual(self.df, self.expected)\n\n    def test_rank(self):\n        _ = self.df.rank(\"bar\", into=\"bar_rank\", descending=True)\n        self.assertEqual(self.df, self.expected)\n\n    def test_rename(self):\n        _ = self.df.rename({\"foo\": \"oof\"})\n        self.assertEqual(self.df, self.expected)\n\n    def test_replace(self):\n        _ = self.df.replace({\"baz\": {\"B\": \"Banana\"}})\n        self.assertEqual(self.df, self.expected)\n\n    def test_rollup(self):\n        _ = self.df.rollup({\"bar_mean\": (\"bar\", rf.stat.mean)})\n        self.assertEqual(self.df, self.expected)\n\n    def test_sample(self):\n        _ = self.df.sample(5)\n        self.assertEqual(self.df, self.expected)\n\n    def test_select(self):\n        _ = self.df.select([\"foo\", \"bar\"])\n        self.assertEqual(self.df, self.expected)\n\n    def test_shuffle(self):\n        _ = self.df.shuffle()\n        self.assertEqual(self.df, self.expected)\n\n    def test_sort(self):\n        _ = self.df.sort(\"bar\", descending=True)\n        self.assertEqual(self.df, self.expected)\n\n    def test_split(self):\n        _ = self.df.split(\"jaz\", into=[\"jaz_1\", \"jaz_2\"], sep=\"::\")\n        self.assertEqual(self.df, self.expected)\n\n    def test_spread(self):\n        _ = self.df.denix(\"baz\").select([\"baz\", \"foo\"]).spread(\"baz\", \"foo\")\n        self.assertEqual(self.df, self.expected)\n\n    def test_take(self):\n        _ = self.df.take(-3)\n        self.assertEqual(self.df, self.expected)", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_side_effects.py_105-155"}
{"title": "maxhumber_redframes-tests-test_side_effects.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_side_effects.py"], "line_no": 140, "start_line_no": 115, "end_line_no": 159, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "\n    def test_rename(self):\n        _ = self.df.rename({\"foo\": \"oof\"})\n        self.assertEqual(self.df, self.expected)\n\n    def test_replace(self):\n        _ = self.df.replace({\"baz\": {\"B\": \"Banana\"}})\n        self.assertEqual(self.df, self.expected)\n\n    def test_rollup(self):\n        _ = self.df.rollup({\"bar_mean\": (\"bar\", rf.stat.mean)})\n        self.assertEqual(self.df, self.expected)\n\n    def test_sample(self):\n        _ = self.df.sample(5)\n        self.assertEqual(self.df, self.expected)\n\n    def test_select(self):\n        _ = self.df.select([\"foo\", \"bar\"])\n        self.assertEqual(self.df, self.expected)\n\n    def test_shuffle(self):\n        _ = self.df.shuffle()\n        self.assertEqual(self.df, self.expected)\n\n    def test_sort(self):\n        _ = self.df.sort(\"bar\", descending=True)\n        self.assertEqual(self.df, self.expected)\n\n    def test_split(self):\n        _ = self.df.split(\"jaz\", into=[\"jaz_1\", \"jaz_2\"], sep=\"::\")\n        self.assertEqual(self.df, self.expected)\n\n    def test_spread(self):\n        _ = self.df.denix(\"baz\").select([\"baz\", \"foo\"]).spread(\"baz\", \"foo\")\n        self.assertEqual(self.df, self.expected)\n\n    def test_take(self):\n        _ = self.df.take(-3)\n        self.assertEqual(self.df, self.expected)\n\n    def test_take(self):\n        _ = self.df.unpack(\"jaz\", sep=\"::\")\n        self.assertEqual(self.df, self.expected)", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_side_effects.py_115-159"}
{"title": "maxhumber_redframes-tests-test_side_effects.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_side_effects.py"], "line_no": 150, "start_line_no": 125, "end_line_no": 159, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        _ = self.df.rollup({\"bar_mean\": (\"bar\", rf.stat.mean)})\n        self.assertEqual(self.df, self.expected)\n\n    def test_sample(self):\n        _ = self.df.sample(5)\n        self.assertEqual(self.df, self.expected)\n\n    def test_select(self):\n        _ = self.df.select([\"foo\", \"bar\"])\n        self.assertEqual(self.df, self.expected)\n\n    def test_shuffle(self):\n        _ = self.df.shuffle()\n        self.assertEqual(self.df, self.expected)\n\n    def test_sort(self):\n        _ = self.df.sort(\"bar\", descending=True)\n        self.assertEqual(self.df, self.expected)\n\n    def test_split(self):\n        _ = self.df.split(\"jaz\", into=[\"jaz_1\", \"jaz_2\"], sep=\"::\")\n        self.assertEqual(self.df, self.expected)\n\n    def test_spread(self):\n        _ = self.df.denix(\"baz\").select([\"baz\", \"foo\"]).spread(\"baz\", \"foo\")\n        self.assertEqual(self.df, self.expected)\n\n    def test_take(self):\n        _ = self.df.take(-3)\n        self.assertEqual(self.df, self.expected)\n\n    def test_take(self):\n        _ = self.df.unpack(\"jaz\", sep=\"::\")\n        self.assertEqual(self.df, self.expected)", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_side_effects.py_125-159"}
{"title": "maxhumber_redframes-tests-test_type_hints.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_type_hints.py"], "line_no": 0, "start_line_no": 0, "end_line_no": 25, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "import unittest\n\nimport redframes as rf\n\n\nclass TestTypeHints(unittest.TestCase):\n    def setUp(self):\n        self.df = rf.DataFrame(\n            {\n                \"foo\": range(10),\n                \"bar\": [1, 3.2, 4.5, 2, -1, 30, None, 1.1, 1.1, 9],\n                \"baz\": [\"A\", \"A\", None, \"B\", \"B\", \"A\", \"B\", \"C\", \"C\", \"A\"],\n                \"jaz\": [\n                    \"1::1\",\n                    \"2::2\",\n                    \"3:3\",\n                    \"4::4\",\n                    \"5::5\",\n                    \"6::7\",\n                    \"7::8\",\n                    \"8::9\",\n                    \"9::0\",\n                    \"0::-1\",\n                ],\n                \"raz\": [1, 2, 3, None, None, None, 9, 9, None, None],", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_type_hints.py_0-25"}
{"title": "maxhumber_redframes-tests-test_type_hints.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_type_hints.py"], "line_no": 10, "start_line_no": 0, "end_line_no": 35, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "import unittest\n\nimport redframes as rf\n\n\nclass TestTypeHints(unittest.TestCase):\n    def setUp(self):\n        self.df = rf.DataFrame(\n            {\n                \"foo\": range(10),\n                \"bar\": [1, 3.2, 4.5, 2, -1, 30, None, 1.1, 1.1, 9],\n                \"baz\": [\"A\", \"A\", None, \"B\", \"B\", \"A\", \"B\", \"C\", \"C\", \"A\"],\n                \"jaz\": [\n                    \"1::1\",\n                    \"2::2\",\n                    \"3:3\",\n                    \"4::4\",\n                    \"5::5\",\n                    \"6::7\",\n                    \"7::8\",\n                    \"8::9\",\n                    \"9::0\",\n                    \"0::-1\",\n                ],\n                \"raz\": [1, 2, 3, None, None, None, 9, 9, None, None],\n            }\n        )\n\n    def test_io_load_bad_path(self):\n        with self.assertRaisesRegex(TypeError, \"must be str\"):\n            rf.load(1)\n\n    def test_io_load_bad_file_type(self):\n        with self.assertRaisesRegex(TypeError, \"must end in .csv\"):\n            rf.load(\"example.json\")", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_type_hints.py_0-35"}
{"title": "maxhumber_redframes-tests-test_type_hints.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_type_hints.py"], "line_no": 20, "start_line_no": 0, "end_line_no": 45, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "import unittest\n\nimport redframes as rf\n\n\nclass TestTypeHints(unittest.TestCase):\n    def setUp(self):\n        self.df = rf.DataFrame(\n            {\n                \"foo\": range(10),\n                \"bar\": [1, 3.2, 4.5, 2, -1, 30, None, 1.1, 1.1, 9],\n                \"baz\": [\"A\", \"A\", None, \"B\", \"B\", \"A\", \"B\", \"C\", \"C\", \"A\"],\n                \"jaz\": [\n                    \"1::1\",\n                    \"2::2\",\n                    \"3:3\",\n                    \"4::4\",\n                    \"5::5\",\n                    \"6::7\",\n                    \"7::8\",\n                    \"8::9\",\n                    \"9::0\",\n                    \"0::-1\",\n                ],\n                \"raz\": [1, 2, 3, None, None, None, 9, 9, None, None],\n            }\n        )\n\n    def test_io_load_bad_path(self):\n        with self.assertRaisesRegex(TypeError, \"must be str\"):\n            rf.load(1)\n\n    def test_io_load_bad_file_type(self):\n        with self.assertRaisesRegex(TypeError, \"must end in .csv\"):\n            rf.load(\"example.json\")\n\n    def test_io_save_bad_object(self):\n        with self.assertRaisesRegex(TypeError, \"must be DataFrame\"):\n            rf.save(1, \"example.csv\")\n\n    def test_io_save_bad_path(self):\n        with self.assertRaisesRegex(TypeError, \"must be str\"):\n            rf.save(self.df, 1)\n\n    def test_io_save_bad_format(self):", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_type_hints.py_0-45"}
{"title": "maxhumber_redframes-tests-test_type_hints.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_type_hints.py"], "line_no": 30, "start_line_no": 5, "end_line_no": 55, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "class TestTypeHints(unittest.TestCase):\n    def setUp(self):\n        self.df = rf.DataFrame(\n            {\n                \"foo\": range(10),\n                \"bar\": [1, 3.2, 4.5, 2, -1, 30, None, 1.1, 1.1, 9],\n                \"baz\": [\"A\", \"A\", None, \"B\", \"B\", \"A\", \"B\", \"C\", \"C\", \"A\"],\n                \"jaz\": [\n                    \"1::1\",\n                    \"2::2\",\n                    \"3:3\",\n                    \"4::4\",\n                    \"5::5\",\n                    \"6::7\",\n                    \"7::8\",\n                    \"8::9\",\n                    \"9::0\",\n                    \"0::-1\",\n                ],\n                \"raz\": [1, 2, 3, None, None, None, 9, 9, None, None],\n            }\n        )\n\n    def test_io_load_bad_path(self):\n        with self.assertRaisesRegex(TypeError, \"must be str\"):\n            rf.load(1)\n\n    def test_io_load_bad_file_type(self):\n        with self.assertRaisesRegex(TypeError, \"must end in .csv\"):\n            rf.load(\"example.json\")\n\n    def test_io_save_bad_object(self):\n        with self.assertRaisesRegex(TypeError, \"must be DataFrame\"):\n            rf.save(1, \"example.csv\")\n\n    def test_io_save_bad_path(self):\n        with self.assertRaisesRegex(TypeError, \"must be str\"):\n            rf.save(self.df, 1)\n\n    def test_io_save_bad_format(self):\n        with self.assertRaisesRegex(TypeError, \"must end in .csv\"):\n            rf.save(self.df, \"example.json\")\n\n    def test_io_unwrap_bad_object(self):\n        with self.assertRaisesRegex(TypeError, \"must be DataFrame\"):\n            rf.unwrap(1)\n\n    def test_io_wrap_bad_object(self):\n        with self.assertRaisesRegex(TypeError, \"must be DataFrame\"):\n            rf.unwrap(1)", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_type_hints.py_5-55"}
{"title": "maxhumber_redframes-tests-test_type_hints.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_type_hints.py"], "line_no": 40, "start_line_no": 15, "end_line_no": 65, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "                    \"3:3\",\n                    \"4::4\",\n                    \"5::5\",\n                    \"6::7\",\n                    \"7::8\",\n                    \"8::9\",\n                    \"9::0\",\n                    \"0::-1\",\n                ],\n                \"raz\": [1, 2, 3, None, None, None, 9, 9, None, None],\n            }\n        )\n\n    def test_io_load_bad_path(self):\n        with self.assertRaisesRegex(TypeError, \"must be str\"):\n            rf.load(1)\n\n    def test_io_load_bad_file_type(self):\n        with self.assertRaisesRegex(TypeError, \"must end in .csv\"):\n            rf.load(\"example.json\")\n\n    def test_io_save_bad_object(self):\n        with self.assertRaisesRegex(TypeError, \"must be DataFrame\"):\n            rf.save(1, \"example.csv\")\n\n    def test_io_save_bad_path(self):\n        with self.assertRaisesRegex(TypeError, \"must be str\"):\n            rf.save(self.df, 1)\n\n    def test_io_save_bad_format(self):\n        with self.assertRaisesRegex(TypeError, \"must end in .csv\"):\n            rf.save(self.df, \"example.json\")\n\n    def test_io_unwrap_bad_object(self):\n        with self.assertRaisesRegex(TypeError, \"must be DataFrame\"):\n            rf.unwrap(1)\n\n    def test_io_wrap_bad_object(self):\n        with self.assertRaisesRegex(TypeError, \"must be DataFrame\"):\n            rf.unwrap(1)\n\n    def test_take_bad_rows(self):\n        with self.assertRaisesRegex(TypeError, \"must be int\"):\n            self.df.take(\"A\")\n\n    def test_accumulate_bad_column(self):\n        with self.assertRaisesRegex(TypeError, \"must be str\"):\n            self.df.accumulate(1, \"foo\")\n\n    def test_accumulate_bad_into_column(self):", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_type_hints.py_15-65"}
{"title": "maxhumber_redframes-tests-test_type_hints.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_type_hints.py"], "line_no": 50, "start_line_no": 25, "end_line_no": 75, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "            }\n        )\n\n    def test_io_load_bad_path(self):\n        with self.assertRaisesRegex(TypeError, \"must be str\"):\n            rf.load(1)\n\n    def test_io_load_bad_file_type(self):\n        with self.assertRaisesRegex(TypeError, \"must end in .csv\"):\n            rf.load(\"example.json\")\n\n    def test_io_save_bad_object(self):\n        with self.assertRaisesRegex(TypeError, \"must be DataFrame\"):\n            rf.save(1, \"example.csv\")\n\n    def test_io_save_bad_path(self):\n        with self.assertRaisesRegex(TypeError, \"must be str\"):\n            rf.save(self.df, 1)\n\n    def test_io_save_bad_format(self):\n        with self.assertRaisesRegex(TypeError, \"must end in .csv\"):\n            rf.save(self.df, \"example.json\")\n\n    def test_io_unwrap_bad_object(self):\n        with self.assertRaisesRegex(TypeError, \"must be DataFrame\"):\n            rf.unwrap(1)\n\n    def test_io_wrap_bad_object(self):\n        with self.assertRaisesRegex(TypeError, \"must be DataFrame\"):\n            rf.unwrap(1)\n\n    def test_take_bad_rows(self):\n        with self.assertRaisesRegex(TypeError, \"must be int\"):\n            self.df.take(\"A\")\n\n    def test_accumulate_bad_column(self):\n        with self.assertRaisesRegex(TypeError, \"must be str\"):\n            self.df.accumulate(1, \"foo\")\n\n    def test_accumulate_bad_into_column(self):\n        with self.assertRaisesRegex(TypeError, \"must be str\"):\n            self.df.accumulate(\"foo\", 1)\n\n    def test_rank_bad_column(self):\n        with self.assertRaisesRegex(TypeError, \"must be str\"):\n            self.df.rank(1, \"bar2\")\n\n    def test_rank_bad_into_column(self):\n        with self.assertRaisesRegex(TypeError, \"must be str\"):\n            self.df.rank(\"bar\", 1)", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_type_hints.py_25-75"}
{"title": "maxhumber_redframes-tests-test_type_hints.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_type_hints.py"], "line_no": 60, "start_line_no": 35, "end_line_no": 85, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "\n    def test_io_save_bad_object(self):\n        with self.assertRaisesRegex(TypeError, \"must be DataFrame\"):\n            rf.save(1, \"example.csv\")\n\n    def test_io_save_bad_path(self):\n        with self.assertRaisesRegex(TypeError, \"must be str\"):\n            rf.save(self.df, 1)\n\n    def test_io_save_bad_format(self):\n        with self.assertRaisesRegex(TypeError, \"must end in .csv\"):\n            rf.save(self.df, \"example.json\")\n\n    def test_io_unwrap_bad_object(self):\n        with self.assertRaisesRegex(TypeError, \"must be DataFrame\"):\n            rf.unwrap(1)\n\n    def test_io_wrap_bad_object(self):\n        with self.assertRaisesRegex(TypeError, \"must be DataFrame\"):\n            rf.unwrap(1)\n\n    def test_take_bad_rows(self):\n        with self.assertRaisesRegex(TypeError, \"must be int\"):\n            self.df.take(\"A\")\n\n    def test_accumulate_bad_column(self):\n        with self.assertRaisesRegex(TypeError, \"must be str\"):\n            self.df.accumulate(1, \"foo\")\n\n    def test_accumulate_bad_into_column(self):\n        with self.assertRaisesRegex(TypeError, \"must be str\"):\n            self.df.accumulate(\"foo\", 1)\n\n    def test_rank_bad_column(self):\n        with self.assertRaisesRegex(TypeError, \"must be str\"):\n            self.df.rank(1, \"bar2\")\n\n    def test_rank_bad_into_column(self):\n        with self.assertRaisesRegex(TypeError, \"must be str\"):\n            self.df.rank(\"bar\", 1)\n\n    def test_rank_bad_descending_argument(self):\n        with self.assertRaisesRegex(TypeError, \"must be bool\"):\n            self.df.rank(\"bar\", \"bar\", descending=\"bar\")\n\n    def test_rollup_bad_over(self):\n        with self.assertRaisesRegex(TypeError, \"must be dict\"):\n            self.df.rollup(1)\n\n    def test_rollup_bad_over_values(self):", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_type_hints.py_35-85"}
{"title": "maxhumber_redframes-tests-test_type_hints.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_type_hints.py"], "line_no": 70, "start_line_no": 45, "end_line_no": 95, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        with self.assertRaisesRegex(TypeError, \"must end in .csv\"):\n            rf.save(self.df, \"example.json\")\n\n    def test_io_unwrap_bad_object(self):\n        with self.assertRaisesRegex(TypeError, \"must be DataFrame\"):\n            rf.unwrap(1)\n\n    def test_io_wrap_bad_object(self):\n        with self.assertRaisesRegex(TypeError, \"must be DataFrame\"):\n            rf.unwrap(1)\n\n    def test_take_bad_rows(self):\n        with self.assertRaisesRegex(TypeError, \"must be int\"):\n            self.df.take(\"A\")\n\n    def test_accumulate_bad_column(self):\n        with self.assertRaisesRegex(TypeError, \"must be str\"):\n            self.df.accumulate(1, \"foo\")\n\n    def test_accumulate_bad_into_column(self):\n        with self.assertRaisesRegex(TypeError, \"must be str\"):\n            self.df.accumulate(\"foo\", 1)\n\n    def test_rank_bad_column(self):\n        with self.assertRaisesRegex(TypeError, \"must be str\"):\n            self.df.rank(1, \"bar2\")\n\n    def test_rank_bad_into_column(self):\n        with self.assertRaisesRegex(TypeError, \"must be str\"):\n            self.df.rank(\"bar\", 1)\n\n    def test_rank_bad_descending_argument(self):\n        with self.assertRaisesRegex(TypeError, \"must be bool\"):\n            self.df.rank(\"bar\", \"bar\", descending=\"bar\")\n\n    def test_rollup_bad_over(self):\n        with self.assertRaisesRegex(TypeError, \"must be dict\"):\n            self.df.rollup(1)\n\n    def test_rollup_bad_over_values(self):\n        with self.assertRaises(TypeError):\n            self.df.rollup({\"bar_mean\": 1})\n\n    def test_init_bad_data(self):\n        with self.assertRaisesRegex(TypeError, \"must be dict | None\"):\n            rf.DataFrame(1)\n\n    def test_eq_bad_rhs_object(self):\n        self.assertFalse(self.df == 1)\n", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_type_hints.py_45-95"}
{"title": "maxhumber_redframes-tests-test_type_hints.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_type_hints.py"], "line_no": 80, "start_line_no": 55, "end_line_no": 105, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "\n    def test_take_bad_rows(self):\n        with self.assertRaisesRegex(TypeError, \"must be int\"):\n            self.df.take(\"A\")\n\n    def test_accumulate_bad_column(self):\n        with self.assertRaisesRegex(TypeError, \"must be str\"):\n            self.df.accumulate(1, \"foo\")\n\n    def test_accumulate_bad_into_column(self):\n        with self.assertRaisesRegex(TypeError, \"must be str\"):\n            self.df.accumulate(\"foo\", 1)\n\n    def test_rank_bad_column(self):\n        with self.assertRaisesRegex(TypeError, \"must be str\"):\n            self.df.rank(1, \"bar2\")\n\n    def test_rank_bad_into_column(self):\n        with self.assertRaisesRegex(TypeError, \"must be str\"):\n            self.df.rank(\"bar\", 1)\n\n    def test_rank_bad_descending_argument(self):\n        with self.assertRaisesRegex(TypeError, \"must be bool\"):\n            self.df.rank(\"bar\", \"bar\", descending=\"bar\")\n\n    def test_rollup_bad_over(self):\n        with self.assertRaisesRegex(TypeError, \"must be dict\"):\n            self.df.rollup(1)\n\n    def test_rollup_bad_over_values(self):\n        with self.assertRaises(TypeError):\n            self.df.rollup({\"bar_mean\": 1})\n\n    def test_init_bad_data(self):\n        with self.assertRaisesRegex(TypeError, \"must be dict | None\"):\n            rf.DataFrame(1)\n\n    def test_eq_bad_rhs_object(self):\n        self.assertFalse(self.df == 1)\n\n    def test_getitem_bad_key(self):\n        pass\n\n    def test_append_bad_other(self):\n        with self.assertRaisesRegex(TypeError, \"must be DataFrame\"):\n            self.df.append(1)\n\n    def test_combine_bad_columns(self):\n        with self.assertRaisesRegex(TypeError, \"must be list\"):\n            self.df.combine(1, \"foo\", sep=\"-\")", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_type_hints.py_55-105"}
{"title": "maxhumber_redframes-tests-test_type_hints.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_type_hints.py"], "line_no": 90, "start_line_no": 65, "end_line_no": 115, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        with self.assertRaisesRegex(TypeError, \"must be str\"):\n            self.df.accumulate(\"foo\", 1)\n\n    def test_rank_bad_column(self):\n        with self.assertRaisesRegex(TypeError, \"must be str\"):\n            self.df.rank(1, \"bar2\")\n\n    def test_rank_bad_into_column(self):\n        with self.assertRaisesRegex(TypeError, \"must be str\"):\n            self.df.rank(\"bar\", 1)\n\n    def test_rank_bad_descending_argument(self):\n        with self.assertRaisesRegex(TypeError, \"must be bool\"):\n            self.df.rank(\"bar\", \"bar\", descending=\"bar\")\n\n    def test_rollup_bad_over(self):\n        with self.assertRaisesRegex(TypeError, \"must be dict\"):\n            self.df.rollup(1)\n\n    def test_rollup_bad_over_values(self):\n        with self.assertRaises(TypeError):\n            self.df.rollup({\"bar_mean\": 1})\n\n    def test_init_bad_data(self):\n        with self.assertRaisesRegex(TypeError, \"must be dict | None\"):\n            rf.DataFrame(1)\n\n    def test_eq_bad_rhs_object(self):\n        self.assertFalse(self.df == 1)\n\n    def test_getitem_bad_key(self):\n        pass\n\n    def test_append_bad_other(self):\n        with self.assertRaisesRegex(TypeError, \"must be DataFrame\"):\n            self.df.append(1)\n\n    def test_combine_bad_columns(self):\n        with self.assertRaisesRegex(TypeError, \"must be list\"):\n            self.df.combine(1, \"foo\", sep=\"-\")\n\n    def test_combine_bad_into_column(self):\n        with self.assertRaisesRegex(TypeError, \"must be str\"):\n            self.df.combine([\"foo\", \"bar\"], 1, sep=\"-\")\n\n    def test_combine_bad_sep_argument(self):\n        with self.assertRaisesRegex(TypeError, \"must be str\"):\n            self.df.combine([\"foo\", \"bar\"], \"foo\", sep=1)\n\n    def test_combine_bad_drop_argument(self):", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_type_hints.py_65-115"}
{"title": "maxhumber_redframes-tests-test_type_hints.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_type_hints.py"], "line_no": 100, "start_line_no": 75, "end_line_no": 125, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "\n    def test_rank_bad_descending_argument(self):\n        with self.assertRaisesRegex(TypeError, \"must be bool\"):\n            self.df.rank(\"bar\", \"bar\", descending=\"bar\")\n\n    def test_rollup_bad_over(self):\n        with self.assertRaisesRegex(TypeError, \"must be dict\"):\n            self.df.rollup(1)\n\n    def test_rollup_bad_over_values(self):\n        with self.assertRaises(TypeError):\n            self.df.rollup({\"bar_mean\": 1})\n\n    def test_init_bad_data(self):\n        with self.assertRaisesRegex(TypeError, \"must be dict | None\"):\n            rf.DataFrame(1)\n\n    def test_eq_bad_rhs_object(self):\n        self.assertFalse(self.df == 1)\n\n    def test_getitem_bad_key(self):\n        pass\n\n    def test_append_bad_other(self):\n        with self.assertRaisesRegex(TypeError, \"must be DataFrame\"):\n            self.df.append(1)\n\n    def test_combine_bad_columns(self):\n        with self.assertRaisesRegex(TypeError, \"must be list\"):\n            self.df.combine(1, \"foo\", sep=\"-\")\n\n    def test_combine_bad_into_column(self):\n        with self.assertRaisesRegex(TypeError, \"must be str\"):\n            self.df.combine([\"foo\", \"bar\"], 1, sep=\"-\")\n\n    def test_combine_bad_sep_argument(self):\n        with self.assertRaisesRegex(TypeError, \"must be str\"):\n            self.df.combine([\"foo\", \"bar\"], \"foo\", sep=1)\n\n    def test_combine_bad_drop_argument(self):\n        with self.assertRaisesRegex(TypeError, \"must be bool\"):\n            self.df.combine([\"foo\", \"bar\"], \"foo\", sep=\":::\", drop=\"A\")\n\n    def test_dedupe_bad_columns(self):\n        with self.assertRaisesRegex(TypeError, \"must be list | str | None\"):\n            self.df.dedupe(1)\n\n    def test_denix_bad_columns(self):\n        with self.assertRaisesRegex(TypeError, \"must be list | str | None\"):\n            self.df.denix(1)", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_type_hints.py_75-125"}
{"title": "maxhumber_redframes-tests-test_type_hints.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_type_hints.py"], "line_no": 110, "start_line_no": 85, "end_line_no": 135, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        with self.assertRaises(TypeError):\n            self.df.rollup({\"bar_mean\": 1})\n\n    def test_init_bad_data(self):\n        with self.assertRaisesRegex(TypeError, \"must be dict | None\"):\n            rf.DataFrame(1)\n\n    def test_eq_bad_rhs_object(self):\n        self.assertFalse(self.df == 1)\n\n    def test_getitem_bad_key(self):\n        pass\n\n    def test_append_bad_other(self):\n        with self.assertRaisesRegex(TypeError, \"must be DataFrame\"):\n            self.df.append(1)\n\n    def test_combine_bad_columns(self):\n        with self.assertRaisesRegex(TypeError, \"must be list\"):\n            self.df.combine(1, \"foo\", sep=\"-\")\n\n    def test_combine_bad_into_column(self):\n        with self.assertRaisesRegex(TypeError, \"must be str\"):\n            self.df.combine([\"foo\", \"bar\"], 1, sep=\"-\")\n\n    def test_combine_bad_sep_argument(self):\n        with self.assertRaisesRegex(TypeError, \"must be str\"):\n            self.df.combine([\"foo\", \"bar\"], \"foo\", sep=1)\n\n    def test_combine_bad_drop_argument(self):\n        with self.assertRaisesRegex(TypeError, \"must be bool\"):\n            self.df.combine([\"foo\", \"bar\"], \"foo\", sep=\":::\", drop=\"A\")\n\n    def test_dedupe_bad_columns(self):\n        with self.assertRaisesRegex(TypeError, \"must be list | str | None\"):\n            self.df.dedupe(1)\n\n    def test_denix_bad_columns(self):\n        with self.assertRaisesRegex(TypeError, \"must be list | str | None\"):\n            self.df.denix(1)\n\n    def test_drop_bad_columns(self):\n        with self.assertRaisesRegex(TypeError, \"must be list | str | None\"):\n            self.df.drop(1)\n\n    def test_fill_bad_columns(self):\n        with self.assertRaisesRegex(TypeError, \"must be list | str | None\"):\n            self.df.fill(1)\n\n    def test_fill_bad_direction(self):", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_type_hints.py_85-135"}
{"title": "maxhumber_redframes-tests-test_type_hints.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_type_hints.py"], "line_no": 120, "start_line_no": 95, "end_line_no": 145, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "    def test_getitem_bad_key(self):\n        pass\n\n    def test_append_bad_other(self):\n        with self.assertRaisesRegex(TypeError, \"must be DataFrame\"):\n            self.df.append(1)\n\n    def test_combine_bad_columns(self):\n        with self.assertRaisesRegex(TypeError, \"must be list\"):\n            self.df.combine(1, \"foo\", sep=\"-\")\n\n    def test_combine_bad_into_column(self):\n        with self.assertRaisesRegex(TypeError, \"must be str\"):\n            self.df.combine([\"foo\", \"bar\"], 1, sep=\"-\")\n\n    def test_combine_bad_sep_argument(self):\n        with self.assertRaisesRegex(TypeError, \"must be str\"):\n            self.df.combine([\"foo\", \"bar\"], \"foo\", sep=1)\n\n    def test_combine_bad_drop_argument(self):\n        with self.assertRaisesRegex(TypeError, \"must be bool\"):\n            self.df.combine([\"foo\", \"bar\"], \"foo\", sep=\":::\", drop=\"A\")\n\n    def test_dedupe_bad_columns(self):\n        with self.assertRaisesRegex(TypeError, \"must be list | str | None\"):\n            self.df.dedupe(1)\n\n    def test_denix_bad_columns(self):\n        with self.assertRaisesRegex(TypeError, \"must be list | str | None\"):\n            self.df.denix(1)\n\n    def test_drop_bad_columns(self):\n        with self.assertRaisesRegex(TypeError, \"must be list | str | None\"):\n            self.df.drop(1)\n\n    def test_fill_bad_columns(self):\n        with self.assertRaisesRegex(TypeError, \"must be list | str | None\"):\n            self.df.fill(1)\n\n    def test_fill_bad_direction(self):\n        with self.assertRaisesRegex(ValueError, \"must be one of {'down', 'up'}\"):\n            self.df.fill(\"bar\", direction=\"sideways\")\n\n    def test_fill_bad_constant_and_direction(self):\n        with self.assertRaisesRegex(\n            ValueError, \"either direction OR constant must not be None\"\n        ):\n            self.df.fill(\"bar\")\n\n    def test_fill_bad_no_constant_nor_direction(self):", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_type_hints.py_95-145"}
{"title": "maxhumber_redframes-tests-test_type_hints.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_type_hints.py"], "line_no": 130, "start_line_no": 105, "end_line_no": 155, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "\n    def test_combine_bad_into_column(self):\n        with self.assertRaisesRegex(TypeError, \"must be str\"):\n            self.df.combine([\"foo\", \"bar\"], 1, sep=\"-\")\n\n    def test_combine_bad_sep_argument(self):\n        with self.assertRaisesRegex(TypeError, \"must be str\"):\n            self.df.combine([\"foo\", \"bar\"], \"foo\", sep=1)\n\n    def test_combine_bad_drop_argument(self):\n        with self.assertRaisesRegex(TypeError, \"must be bool\"):\n            self.df.combine([\"foo\", \"bar\"], \"foo\", sep=\":::\", drop=\"A\")\n\n    def test_dedupe_bad_columns(self):\n        with self.assertRaisesRegex(TypeError, \"must be list | str | None\"):\n            self.df.dedupe(1)\n\n    def test_denix_bad_columns(self):\n        with self.assertRaisesRegex(TypeError, \"must be list | str | None\"):\n            self.df.denix(1)\n\n    def test_drop_bad_columns(self):\n        with self.assertRaisesRegex(TypeError, \"must be list | str | None\"):\n            self.df.drop(1)\n\n    def test_fill_bad_columns(self):\n        with self.assertRaisesRegex(TypeError, \"must be list | str | None\"):\n            self.df.fill(1)\n\n    def test_fill_bad_direction(self):\n        with self.assertRaisesRegex(ValueError, \"must be one of {'down', 'up'}\"):\n            self.df.fill(\"bar\", direction=\"sideways\")\n\n    def test_fill_bad_constant_and_direction(self):\n        with self.assertRaisesRegex(\n            ValueError, \"either direction OR constant must not be None\"\n        ):\n            self.df.fill(\"bar\")\n\n    def test_fill_bad_no_constant_nor_direction(self):\n        with self.assertRaisesRegex(\n            ValueError, \"either direction OR constant must be None\"\n        ):\n            self.df.fill(\"bar\", direction=\"down\", constant=\"X\")\n\n    def test_filter_bad_func(self):\n        with self.assertRaisesRegex(TypeError, \"must be Func\"):\n            self.df.filter(1)\n\n    def test_gather_bad_columns(self):", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_type_hints.py_105-155"}
{"title": "maxhumber_redframes-tests-test_type_hints.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_type_hints.py"], "line_no": 140, "start_line_no": 115, "end_line_no": 165, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        with self.assertRaisesRegex(TypeError, \"must be bool\"):\n            self.df.combine([\"foo\", \"bar\"], \"foo\", sep=\":::\", drop=\"A\")\n\n    def test_dedupe_bad_columns(self):\n        with self.assertRaisesRegex(TypeError, \"must be list | str | None\"):\n            self.df.dedupe(1)\n\n    def test_denix_bad_columns(self):\n        with self.assertRaisesRegex(TypeError, \"must be list | str | None\"):\n            self.df.denix(1)\n\n    def test_drop_bad_columns(self):\n        with self.assertRaisesRegex(TypeError, \"must be list | str | None\"):\n            self.df.drop(1)\n\n    def test_fill_bad_columns(self):\n        with self.assertRaisesRegex(TypeError, \"must be list | str | None\"):\n            self.df.fill(1)\n\n    def test_fill_bad_direction(self):\n        with self.assertRaisesRegex(ValueError, \"must be one of {'down', 'up'}\"):\n            self.df.fill(\"bar\", direction=\"sideways\")\n\n    def test_fill_bad_constant_and_direction(self):\n        with self.assertRaisesRegex(\n            ValueError, \"either direction OR constant must not be None\"\n        ):\n            self.df.fill(\"bar\")\n\n    def test_fill_bad_no_constant_nor_direction(self):\n        with self.assertRaisesRegex(\n            ValueError, \"either direction OR constant must be None\"\n        ):\n            self.df.fill(\"bar\", direction=\"down\", constant=\"X\")\n\n    def test_filter_bad_func(self):\n        with self.assertRaisesRegex(TypeError, \"must be Func\"):\n            self.df.filter(1)\n\n    def test_gather_bad_columns(self):\n        with self.assertRaisesRegex(TypeError, \"must be list | None\"):\n            self.df.gather(1)\n\n    def test_gather_bad_beside(self):\n        with self.assertRaisesRegex(TypeError, \"must be str | list | None\"):\n            self.df.gather(beside=1)\n\n    def test_gather_bad_into_column(self):\n        with self.assertRaisesRegex(TypeError, \"must be tuple\"):\n            self.df.gather([\"foo\", \"bar\"], into=1)", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_type_hints.py_115-165"}
{"title": "maxhumber_redframes-tests-test_type_hints.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_type_hints.py"], "line_no": 150, "start_line_no": 125, "end_line_no": 175, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "\n    def test_drop_bad_columns(self):\n        with self.assertRaisesRegex(TypeError, \"must be list | str | None\"):\n            self.df.drop(1)\n\n    def test_fill_bad_columns(self):\n        with self.assertRaisesRegex(TypeError, \"must be list | str | None\"):\n            self.df.fill(1)\n\n    def test_fill_bad_direction(self):\n        with self.assertRaisesRegex(ValueError, \"must be one of {'down', 'up'}\"):\n            self.df.fill(\"bar\", direction=\"sideways\")\n\n    def test_fill_bad_constant_and_direction(self):\n        with self.assertRaisesRegex(\n            ValueError, \"either direction OR constant must not be None\"\n        ):\n            self.df.fill(\"bar\")\n\n    def test_fill_bad_no_constant_nor_direction(self):\n        with self.assertRaisesRegex(\n            ValueError, \"either direction OR constant must be None\"\n        ):\n            self.df.fill(\"bar\", direction=\"down\", constant=\"X\")\n\n    def test_filter_bad_func(self):\n        with self.assertRaisesRegex(TypeError, \"must be Func\"):\n            self.df.filter(1)\n\n    def test_gather_bad_columns(self):\n        with self.assertRaisesRegex(TypeError, \"must be list | None\"):\n            self.df.gather(1)\n\n    def test_gather_bad_beside(self):\n        with self.assertRaisesRegex(TypeError, \"must be str | list | None\"):\n            self.df.gather(beside=1)\n\n    def test_gather_bad_into_column(self):\n        with self.assertRaisesRegex(TypeError, \"must be tuple\"):\n            self.df.gather([\"foo\", \"bar\"], into=1)\n\n    def test_gather_bad_into_tuple(self):\n        with self.assertRaisesRegex(TypeError, \"must be tuple*\"):\n            self.df.gather(into=(\"one\", \"two\", \"three\"))\n\n    def test_gather_bad_both_not_none(self):\n        with self.assertRaisesRegex(ValueError, \"columns OR beside must be None\"):\n            self.df.gather(columns=[\"foo\", \"bar\"], beside=[\"baz\"])\n\n    def test_group_bad_by_columns(self):", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_type_hints.py_125-175"}
{"title": "maxhumber_redframes-tests-test_type_hints.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_type_hints.py"], "line_no": 160, "start_line_no": 135, "end_line_no": 185, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        with self.assertRaisesRegex(ValueError, \"must be one of {'down', 'up'}\"):\n            self.df.fill(\"bar\", direction=\"sideways\")\n\n    def test_fill_bad_constant_and_direction(self):\n        with self.assertRaisesRegex(\n            ValueError, \"either direction OR constant must not be None\"\n        ):\n            self.df.fill(\"bar\")\n\n    def test_fill_bad_no_constant_nor_direction(self):\n        with self.assertRaisesRegex(\n            ValueError, \"either direction OR constant must be None\"\n        ):\n            self.df.fill(\"bar\", direction=\"down\", constant=\"X\")\n\n    def test_filter_bad_func(self):\n        with self.assertRaisesRegex(TypeError, \"must be Func\"):\n            self.df.filter(1)\n\n    def test_gather_bad_columns(self):\n        with self.assertRaisesRegex(TypeError, \"must be list | None\"):\n            self.df.gather(1)\n\n    def test_gather_bad_beside(self):\n        with self.assertRaisesRegex(TypeError, \"must be str | list | None\"):\n            self.df.gather(beside=1)\n\n    def test_gather_bad_into_column(self):\n        with self.assertRaisesRegex(TypeError, \"must be tuple\"):\n            self.df.gather([\"foo\", \"bar\"], into=1)\n\n    def test_gather_bad_into_tuple(self):\n        with self.assertRaisesRegex(TypeError, \"must be tuple*\"):\n            self.df.gather(into=(\"one\", \"two\", \"three\"))\n\n    def test_gather_bad_both_not_none(self):\n        with self.assertRaisesRegex(ValueError, \"columns OR beside must be None\"):\n            self.df.gather(columns=[\"foo\", \"bar\"], beside=[\"baz\"])\n\n    def test_group_bad_by_columns(self):\n        with self.assertRaisesRegex(TypeError, \"must be list | str\"):\n            self.df.group(1)\n\n    def test_join_bad_rhs_object(self):\n        with self.assertRaisesRegex(TypeError, \"must be DataFrame\"):\n            self.df.join(1, on=\"baz\")\n\n    def test_join_bad_on_type(self):\n        rhs = rf.DataFrame()\n        with self.assertRaisesRegex(TypeError, \"must be list | str\"):", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_type_hints.py_135-185"}
{"title": "maxhumber_redframes-tests-test_type_hints.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_type_hints.py"], "line_no": 170, "start_line_no": 145, "end_line_no": 195, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        with self.assertRaisesRegex(\n            ValueError, \"either direction OR constant must be None\"\n        ):\n            self.df.fill(\"bar\", direction=\"down\", constant=\"X\")\n\n    def test_filter_bad_func(self):\n        with self.assertRaisesRegex(TypeError, \"must be Func\"):\n            self.df.filter(1)\n\n    def test_gather_bad_columns(self):\n        with self.assertRaisesRegex(TypeError, \"must be list | None\"):\n            self.df.gather(1)\n\n    def test_gather_bad_beside(self):\n        with self.assertRaisesRegex(TypeError, \"must be str | list | None\"):\n            self.df.gather(beside=1)\n\n    def test_gather_bad_into_column(self):\n        with self.assertRaisesRegex(TypeError, \"must be tuple\"):\n            self.df.gather([\"foo\", \"bar\"], into=1)\n\n    def test_gather_bad_into_tuple(self):\n        with self.assertRaisesRegex(TypeError, \"must be tuple*\"):\n            self.df.gather(into=(\"one\", \"two\", \"three\"))\n\n    def test_gather_bad_both_not_none(self):\n        with self.assertRaisesRegex(ValueError, \"columns OR beside must be None\"):\n            self.df.gather(columns=[\"foo\", \"bar\"], beside=[\"baz\"])\n\n    def test_group_bad_by_columns(self):\n        with self.assertRaisesRegex(TypeError, \"must be list | str\"):\n            self.df.group(1)\n\n    def test_join_bad_rhs_object(self):\n        with self.assertRaisesRegex(TypeError, \"must be DataFrame\"):\n            self.df.join(1, on=\"baz\")\n\n    def test_join_bad_on_type(self):\n        rhs = rf.DataFrame()\n        with self.assertRaisesRegex(TypeError, \"must be list | str\"):\n            self.df.join(rhs, on=1)\n\n    def test_join_bad_how_argument(self):\n        rhs = rf.DataFrame()\n        message = (\n            \"on argument is invalid, must be one of {'left', 'right', 'inner', 'full'}\"\n        )\n        with self.assertRaisesRegex(ValueError, message):\n            self.df.join(rhs, on=\"baz\", how=\"inside\")\n", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_type_hints.py_145-195"}
{"title": "maxhumber_redframes-tests-test_type_hints.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_type_hints.py"], "line_no": 180, "start_line_no": 155, "end_line_no": 205, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        with self.assertRaisesRegex(TypeError, \"must be list | None\"):\n            self.df.gather(1)\n\n    def test_gather_bad_beside(self):\n        with self.assertRaisesRegex(TypeError, \"must be str | list | None\"):\n            self.df.gather(beside=1)\n\n    def test_gather_bad_into_column(self):\n        with self.assertRaisesRegex(TypeError, \"must be tuple\"):\n            self.df.gather([\"foo\", \"bar\"], into=1)\n\n    def test_gather_bad_into_tuple(self):\n        with self.assertRaisesRegex(TypeError, \"must be tuple*\"):\n            self.df.gather(into=(\"one\", \"two\", \"three\"))\n\n    def test_gather_bad_both_not_none(self):\n        with self.assertRaisesRegex(ValueError, \"columns OR beside must be None\"):\n            self.df.gather(columns=[\"foo\", \"bar\"], beside=[\"baz\"])\n\n    def test_group_bad_by_columns(self):\n        with self.assertRaisesRegex(TypeError, \"must be list | str\"):\n            self.df.group(1)\n\n    def test_join_bad_rhs_object(self):\n        with self.assertRaisesRegex(TypeError, \"must be DataFrame\"):\n            self.df.join(1, on=\"baz\")\n\n    def test_join_bad_on_type(self):\n        rhs = rf.DataFrame()\n        with self.assertRaisesRegex(TypeError, \"must be list | str\"):\n            self.df.join(rhs, on=1)\n\n    def test_join_bad_how_argument(self):\n        rhs = rf.DataFrame()\n        message = (\n            \"on argument is invalid, must be one of {'left', 'right', 'inner', 'full'}\"\n        )\n        with self.assertRaisesRegex(ValueError, message):\n            self.df.join(rhs, on=\"baz\", how=\"inside\")\n\n    def test_mutate_bad_over(self):\n        with self.assertRaisesRegex(TypeError, \"must be dict\"):\n            self.df.mutate(1)\n\n    def test_pack_bad_column(self):\n        with self.assertRaisesRegex(TypeError, \"must be str\"):\n            self.df.pack(1, sep=\"|\")\n\n    def test_pack_bad_sep(self):\n        with self.assertRaisesRegex(TypeError, \"must be str\"):", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_type_hints.py_155-205"}
{"title": "maxhumber_redframes-tests-test_type_hints.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_type_hints.py"], "line_no": 190, "start_line_no": 165, "end_line_no": 215, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "\n    def test_gather_bad_into_tuple(self):\n        with self.assertRaisesRegex(TypeError, \"must be tuple*\"):\n            self.df.gather(into=(\"one\", \"two\", \"three\"))\n\n    def test_gather_bad_both_not_none(self):\n        with self.assertRaisesRegex(ValueError, \"columns OR beside must be None\"):\n            self.df.gather(columns=[\"foo\", \"bar\"], beside=[\"baz\"])\n\n    def test_group_bad_by_columns(self):\n        with self.assertRaisesRegex(TypeError, \"must be list | str\"):\n            self.df.group(1)\n\n    def test_join_bad_rhs_object(self):\n        with self.assertRaisesRegex(TypeError, \"must be DataFrame\"):\n            self.df.join(1, on=\"baz\")\n\n    def test_join_bad_on_type(self):\n        rhs = rf.DataFrame()\n        with self.assertRaisesRegex(TypeError, \"must be list | str\"):\n            self.df.join(rhs, on=1)\n\n    def test_join_bad_how_argument(self):\n        rhs = rf.DataFrame()\n        message = (\n            \"on argument is invalid, must be one of {'left', 'right', 'inner', 'full'}\"\n        )\n        with self.assertRaisesRegex(ValueError, message):\n            self.df.join(rhs, on=\"baz\", how=\"inside\")\n\n    def test_mutate_bad_over(self):\n        with self.assertRaisesRegex(TypeError, \"must be dict\"):\n            self.df.mutate(1)\n\n    def test_pack_bad_column(self):\n        with self.assertRaisesRegex(TypeError, \"must be str\"):\n            self.df.pack(1, sep=\"|\")\n\n    def test_pack_bad_sep(self):\n        with self.assertRaisesRegex(TypeError, \"must be str\"):\n            self.df.pack(\"baz\", sep=1)\n\n    def test_rename_bad_columns(self):\n        with self.assertRaisesRegex(TypeError, \"must be dict\"):\n            self.df.rename(1)\n\n    def test_rename_bad_columns_values(self):\n        with self.assertRaisesRegex(TypeError, \"must be str\"):\n            self.df.rename({\"foo\": 1})\n", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_type_hints.py_165-215"}
{"title": "maxhumber_redframes-tests-test_type_hints.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_type_hints.py"], "line_no": 200, "start_line_no": 175, "end_line_no": 225, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        with self.assertRaisesRegex(TypeError, \"must be list | str\"):\n            self.df.group(1)\n\n    def test_join_bad_rhs_object(self):\n        with self.assertRaisesRegex(TypeError, \"must be DataFrame\"):\n            self.df.join(1, on=\"baz\")\n\n    def test_join_bad_on_type(self):\n        rhs = rf.DataFrame()\n        with self.assertRaisesRegex(TypeError, \"must be list | str\"):\n            self.df.join(rhs, on=1)\n\n    def test_join_bad_how_argument(self):\n        rhs = rf.DataFrame()\n        message = (\n            \"on argument is invalid, must be one of {'left', 'right', 'inner', 'full'}\"\n        )\n        with self.assertRaisesRegex(ValueError, message):\n            self.df.join(rhs, on=\"baz\", how=\"inside\")\n\n    def test_mutate_bad_over(self):\n        with self.assertRaisesRegex(TypeError, \"must be dict\"):\n            self.df.mutate(1)\n\n    def test_pack_bad_column(self):\n        with self.assertRaisesRegex(TypeError, \"must be str\"):\n            self.df.pack(1, sep=\"|\")\n\n    def test_pack_bad_sep(self):\n        with self.assertRaisesRegex(TypeError, \"must be str\"):\n            self.df.pack(\"baz\", sep=1)\n\n    def test_rename_bad_columns(self):\n        with self.assertRaisesRegex(TypeError, \"must be dict\"):\n            self.df.rename(1)\n\n    def test_rename_bad_columns_values(self):\n        with self.assertRaisesRegex(TypeError, \"must be str\"):\n            self.df.rename({\"foo\": 1})\n\n    def test_replace_bad_over(self):\n        with self.assertRaisesRegex(TypeError, \"must be dict\"):\n            self.df.replace(1)\n\n    def test_sample_bad_rows(self):\n        with self.assertRaisesRegex(TypeError, \"must be int | float\"):\n            self.df.sample(\"A\")\n\n    def test_select_bad_columns(self):\n        with self.assertRaisesRegex(TypeError, \"must be list | str\"):", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_type_hints.py_175-225"}
{"title": "maxhumber_redframes-tests-test_type_hints.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_type_hints.py"], "line_no": 210, "start_line_no": 185, "end_line_no": 235, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "            self.df.join(rhs, on=1)\n\n    def test_join_bad_how_argument(self):\n        rhs = rf.DataFrame()\n        message = (\n            \"on argument is invalid, must be one of {'left', 'right', 'inner', 'full'}\"\n        )\n        with self.assertRaisesRegex(ValueError, message):\n            self.df.join(rhs, on=\"baz\", how=\"inside\")\n\n    def test_mutate_bad_over(self):\n        with self.assertRaisesRegex(TypeError, \"must be dict\"):\n            self.df.mutate(1)\n\n    def test_pack_bad_column(self):\n        with self.assertRaisesRegex(TypeError, \"must be str\"):\n            self.df.pack(1, sep=\"|\")\n\n    def test_pack_bad_sep(self):\n        with self.assertRaisesRegex(TypeError, \"must be str\"):\n            self.df.pack(\"baz\", sep=1)\n\n    def test_rename_bad_columns(self):\n        with self.assertRaisesRegex(TypeError, \"must be dict\"):\n            self.df.rename(1)\n\n    def test_rename_bad_columns_values(self):\n        with self.assertRaisesRegex(TypeError, \"must be str\"):\n            self.df.rename({\"foo\": 1})\n\n    def test_replace_bad_over(self):\n        with self.assertRaisesRegex(TypeError, \"must be dict\"):\n            self.df.replace(1)\n\n    def test_sample_bad_rows(self):\n        with self.assertRaisesRegex(TypeError, \"must be int | float\"):\n            self.df.sample(\"A\")\n\n    def test_select_bad_columns(self):\n        with self.assertRaisesRegex(TypeError, \"must be list | str\"):\n            self.df.select(1)\n\n    def test_shuffle(self):\n        pass\n\n    def test_sort_bad_columns(self):\n        with self.assertRaisesRegex(TypeError, \"must be list | str\"):\n            self.df.sort(1)\n\n    def test_sort_bad_descending_argument(self):", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_type_hints.py_185-235"}
{"title": "maxhumber_redframes-tests-test_type_hints.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_type_hints.py"], "line_no": 220, "start_line_no": 195, "end_line_no": 245, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "    def test_mutate_bad_over(self):\n        with self.assertRaisesRegex(TypeError, \"must be dict\"):\n            self.df.mutate(1)\n\n    def test_pack_bad_column(self):\n        with self.assertRaisesRegex(TypeError, \"must be str\"):\n            self.df.pack(1, sep=\"|\")\n\n    def test_pack_bad_sep(self):\n        with self.assertRaisesRegex(TypeError, \"must be str\"):\n            self.df.pack(\"baz\", sep=1)\n\n    def test_rename_bad_columns(self):\n        with self.assertRaisesRegex(TypeError, \"must be dict\"):\n            self.df.rename(1)\n\n    def test_rename_bad_columns_values(self):\n        with self.assertRaisesRegex(TypeError, \"must be str\"):\n            self.df.rename({\"foo\": 1})\n\n    def test_replace_bad_over(self):\n        with self.assertRaisesRegex(TypeError, \"must be dict\"):\n            self.df.replace(1)\n\n    def test_sample_bad_rows(self):\n        with self.assertRaisesRegex(TypeError, \"must be int | float\"):\n            self.df.sample(\"A\")\n\n    def test_select_bad_columns(self):\n        with self.assertRaisesRegex(TypeError, \"must be list | str\"):\n            self.df.select(1)\n\n    def test_shuffle(self):\n        pass\n\n    def test_sort_bad_columns(self):\n        with self.assertRaisesRegex(TypeError, \"must be list | str\"):\n            self.df.sort(1)\n\n    def test_sort_bad_descending_argument(self):\n        with self.assertRaisesRegex(TypeError, \"must be bool\"):\n            self.df.sort(\"bar\", descending=\"A\")\n\n    def test_split_bad_column(self):\n        with self.assertRaisesRegex(TypeError, \"must be str\"):\n            self.df.split(1, into=[\"jaz1\", \"jaz2\"], sep=\"::\")\n\n    def test_split_bad_into_column(self):\n        with self.assertRaisesRegex(TypeError, \"must be list\"):\n            self.df.split(\"jaz\", into=1, sep=\"::\")", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_type_hints.py_195-245"}
{"title": "maxhumber_redframes-tests-test_type_hints.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_type_hints.py"], "line_no": 230, "start_line_no": 205, "end_line_no": 255, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "            self.df.pack(\"baz\", sep=1)\n\n    def test_rename_bad_columns(self):\n        with self.assertRaisesRegex(TypeError, \"must be dict\"):\n            self.df.rename(1)\n\n    def test_rename_bad_columns_values(self):\n        with self.assertRaisesRegex(TypeError, \"must be str\"):\n            self.df.rename({\"foo\": 1})\n\n    def test_replace_bad_over(self):\n        with self.assertRaisesRegex(TypeError, \"must be dict\"):\n            self.df.replace(1)\n\n    def test_sample_bad_rows(self):\n        with self.assertRaisesRegex(TypeError, \"must be int | float\"):\n            self.df.sample(\"A\")\n\n    def test_select_bad_columns(self):\n        with self.assertRaisesRegex(TypeError, \"must be list | str\"):\n            self.df.select(1)\n\n    def test_shuffle(self):\n        pass\n\n    def test_sort_bad_columns(self):\n        with self.assertRaisesRegex(TypeError, \"must be list | str\"):\n            self.df.sort(1)\n\n    def test_sort_bad_descending_argument(self):\n        with self.assertRaisesRegex(TypeError, \"must be bool\"):\n            self.df.sort(\"bar\", descending=\"A\")\n\n    def test_split_bad_column(self):\n        with self.assertRaisesRegex(TypeError, \"must be str\"):\n            self.df.split(1, into=[\"jaz1\", \"jaz2\"], sep=\"::\")\n\n    def test_split_bad_into_column(self):\n        with self.assertRaisesRegex(TypeError, \"must be list\"):\n            self.df.split(\"jaz\", into=1, sep=\"::\")\n\n    def test_split_bad_sep_argument(self):\n        with self.assertRaisesRegex(TypeError, \"must be str\"):\n            self.df.split(\"jaz\", into=[\"jaz1\", \"jaz2\"], sep=1)\n\n    def test_split_bad_drop_argument(self):\n        with self.assertRaisesRegex(TypeError, \"must be bool\"):\n            self.df.split(\"jaz\", into=[\"jaz1\", \"jaz2\"], sep=\"::\", drop=\"A\")\n\n    def test_spread_bad_column(self):", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_type_hints.py_205-255"}
{"title": "maxhumber_redframes-tests-test_type_hints.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_type_hints.py"], "line_no": 240, "start_line_no": 215, "end_line_no": 265, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "    def test_replace_bad_over(self):\n        with self.assertRaisesRegex(TypeError, \"must be dict\"):\n            self.df.replace(1)\n\n    def test_sample_bad_rows(self):\n        with self.assertRaisesRegex(TypeError, \"must be int | float\"):\n            self.df.sample(\"A\")\n\n    def test_select_bad_columns(self):\n        with self.assertRaisesRegex(TypeError, \"must be list | str\"):\n            self.df.select(1)\n\n    def test_shuffle(self):\n        pass\n\n    def test_sort_bad_columns(self):\n        with self.assertRaisesRegex(TypeError, \"must be list | str\"):\n            self.df.sort(1)\n\n    def test_sort_bad_descending_argument(self):\n        with self.assertRaisesRegex(TypeError, \"must be bool\"):\n            self.df.sort(\"bar\", descending=\"A\")\n\n    def test_split_bad_column(self):\n        with self.assertRaisesRegex(TypeError, \"must be str\"):\n            self.df.split(1, into=[\"jaz1\", \"jaz2\"], sep=\"::\")\n\n    def test_split_bad_into_column(self):\n        with self.assertRaisesRegex(TypeError, \"must be list\"):\n            self.df.split(\"jaz\", into=1, sep=\"::\")\n\n    def test_split_bad_sep_argument(self):\n        with self.assertRaisesRegex(TypeError, \"must be str\"):\n            self.df.split(\"jaz\", into=[\"jaz1\", \"jaz2\"], sep=1)\n\n    def test_split_bad_drop_argument(self):\n        with self.assertRaisesRegex(TypeError, \"must be bool\"):\n            self.df.split(\"jaz\", into=[\"jaz1\", \"jaz2\"], sep=\"::\", drop=\"A\")\n\n    def test_spread_bad_column(self):\n        with self.assertRaisesRegex(TypeError, \"must be str\"):\n            self.df.spread(1, using=\"bar\")\n\n    def test_spread_bad_using_column(self):\n        with self.assertRaisesRegex(TypeError, \"must be str\"):\n            self.df.spread(\"foo\", using=1)\n\n    def test_unpack_bad_column(self):\n        with self.assertRaisesRegex(TypeError, \"must be str\"):\n            self.df.unpack(1, sep=\"|\")", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_type_hints.py_215-265"}
{"title": "maxhumber_redframes-tests-test_type_hints.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_type_hints.py"], "line_no": 250, "start_line_no": 225, "end_line_no": 269, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "            self.df.select(1)\n\n    def test_shuffle(self):\n        pass\n\n    def test_sort_bad_columns(self):\n        with self.assertRaisesRegex(TypeError, \"must be list | str\"):\n            self.df.sort(1)\n\n    def test_sort_bad_descending_argument(self):\n        with self.assertRaisesRegex(TypeError, \"must be bool\"):\n            self.df.sort(\"bar\", descending=\"A\")\n\n    def test_split_bad_column(self):\n        with self.assertRaisesRegex(TypeError, \"must be str\"):\n            self.df.split(1, into=[\"jaz1\", \"jaz2\"], sep=\"::\")\n\n    def test_split_bad_into_column(self):\n        with self.assertRaisesRegex(TypeError, \"must be list\"):\n            self.df.split(\"jaz\", into=1, sep=\"::\")\n\n    def test_split_bad_sep_argument(self):\n        with self.assertRaisesRegex(TypeError, \"must be str\"):\n            self.df.split(\"jaz\", into=[\"jaz1\", \"jaz2\"], sep=1)\n\n    def test_split_bad_drop_argument(self):\n        with self.assertRaisesRegex(TypeError, \"must be bool\"):\n            self.df.split(\"jaz\", into=[\"jaz1\", \"jaz2\"], sep=\"::\", drop=\"A\")\n\n    def test_spread_bad_column(self):\n        with self.assertRaisesRegex(TypeError, \"must be str\"):\n            self.df.spread(1, using=\"bar\")\n\n    def test_spread_bad_using_column(self):\n        with self.assertRaisesRegex(TypeError, \"must be str\"):\n            self.df.spread(\"foo\", using=1)\n\n    def test_unpack_bad_column(self):\n        with self.assertRaisesRegex(TypeError, \"must be str\"):\n            self.df.unpack(1, sep=\"|\")\n\n    def test_unpack_bad_sep(self):\n        with self.assertRaisesRegex(TypeError, \"must be str\"):\n            self.df.unpack(\"jaz\", sep=1)", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_type_hints.py_225-269"}
{"title": "maxhumber_redframes-tests-test_type_hints.py", "metadata": [{"fpath_tuple": ["maxhumber_redframes", "tests", "test_type_hints.py"], "line_no": 260, "start_line_no": 235, "end_line_no": 269, "window_size": 50, "repo": "maxhumber_redframes", "slice_size": 5}], "contents": "        with self.assertRaisesRegex(TypeError, \"must be bool\"):\n            self.df.sort(\"bar\", descending=\"A\")\n\n    def test_split_bad_column(self):\n        with self.assertRaisesRegex(TypeError, \"must be str\"):\n            self.df.split(1, into=[\"jaz1\", \"jaz2\"], sep=\"::\")\n\n    def test_split_bad_into_column(self):\n        with self.assertRaisesRegex(TypeError, \"must be list\"):\n            self.df.split(\"jaz\", into=1, sep=\"::\")\n\n    def test_split_bad_sep_argument(self):\n        with self.assertRaisesRegex(TypeError, \"must be str\"):\n            self.df.split(\"jaz\", into=[\"jaz1\", \"jaz2\"], sep=1)\n\n    def test_split_bad_drop_argument(self):\n        with self.assertRaisesRegex(TypeError, \"must be bool\"):\n            self.df.split(\"jaz\", into=[\"jaz1\", \"jaz2\"], sep=\"::\", drop=\"A\")\n\n    def test_spread_bad_column(self):\n        with self.assertRaisesRegex(TypeError, \"must be str\"):\n            self.df.spread(1, using=\"bar\")\n\n    def test_spread_bad_using_column(self):\n        with self.assertRaisesRegex(TypeError, \"must be str\"):\n            self.df.spread(\"foo\", using=1)\n\n    def test_unpack_bad_column(self):\n        with self.assertRaisesRegex(TypeError, \"must be str\"):\n            self.df.unpack(1, sep=\"|\")\n\n    def test_unpack_bad_sep(self):\n        with self.assertRaisesRegex(TypeError, \"must be str\"):\n            self.df.unpack(\"jaz\", sep=1)", "id": "maxhumber_redframes_maxhumber_redframes-tests-test_type_hints.py_235-269"}
